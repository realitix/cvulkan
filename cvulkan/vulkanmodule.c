
#include <Python.h>
#include <dlfcn.h>

#define VK_NO_PROTOTYPES

#ifdef __unix__

#define LOAD_SDK() dlopen("libvulkan.so", RTLD_NOW);

#elif defined(_WIN32) || defined(WIN32)

#define LOAD_SDK() LoadLibrary("vulkan-1.dll");
#define dlsym GetProcAddress

#endif

//
// File: vk_platform.h
//
/*
** Copyright (c) 2014-2015 The Khronos Group Inc.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/


#ifndef VK_PLATFORM_H_
#define VK_PLATFORM_H_

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

/*
***************************************************************************************************
*   Platform-specific directives and type declarations
***************************************************************************************************
*/

/* Platform-specific calling convention macros.
 *
 * Platforms should define these so that Vulkan clients call Vulkan commands
 * with the same calling conventions that the Vulkan implementation expects.
 *
 * VKAPI_ATTR - Placed before the return type in function declarations.
 *              Useful for C++11 and GCC/Clang-style function attribute syntax.
 * VKAPI_CALL - Placed after the return type in function declarations.
 *              Useful for MSVC-style calling convention syntax.
 * VKAPI_PTR  - Placed between the '(' and '*' in function pointer types.
 *
 * Function declaration:  VKAPI_ATTR void VKAPI_CALL vkCommand(void);
 * Function pointer type: typedef void (VKAPI_PTR *PFN_vkCommand)(void);
 */
#if defined(_WIN32)
    // On Windows, Vulkan commands use the stdcall convention
    #define VKAPI_ATTR
    #define VKAPI_CALL __stdcall
    #define VKAPI_PTR  VKAPI_CALL
#elif defined(__ANDROID__) && defined(__ARM_ARCH) && __ARM_ARCH < 7
    #error "Vulkan isn't supported for the 'armeabi' NDK ABI"
#elif defined(__ANDROID__) && defined(__ARM_ARCH) && __ARM_ARCH >= 7 && defined(__ARM_32BIT_STATE)
    // On Android 32-bit ARM targets, Vulkan functions use the "hardfloat"
    // calling convention, i.e. float parameters are passed in registers. This
    // is true even if the rest of the application passes floats on the stack,
    // as it does by default when compiling for the armeabi-v7a NDK ABI.
    #define VKAPI_ATTR __attribute__((pcs("aapcs-vfp")))
    #define VKAPI_CALL
    #define VKAPI_PTR  VKAPI_ATTR
#else
    // On other platforms, use the default calling convention
    #define VKAPI_ATTR
    #define VKAPI_CALL
    #define VKAPI_PTR
#endif

#include <stddef.h>

#if !defined(VK_NO_STDINT_H)
    #if defined(_MSC_VER) && (_MSC_VER < 1600)
        typedef signed   __int8  int8_t;
        typedef unsigned __int8  uint8_t;
        typedef signed   __int16 int16_t;
        typedef unsigned __int16 uint16_t;
        typedef signed   __int32 int32_t;
        typedef unsigned __int32 uint32_t;
        typedef signed   __int64 int64_t;
        typedef unsigned __int64 uint64_t;
    #else
        #include <stdint.h>
    #endif
#endif // !defined(VK_NO_STDINT_H)

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

// Platform-specific headers required by platform window system extensions.
// These are enabled prior to #including "vulkan.h". The same enable then
// controls inclusion of the extension interfaces in vulkan.h.

#ifdef VK_USE_PLATFORM_ANDROID_KHR
#include <android/native_window.h>
#endif

#ifdef VK_USE_PLATFORM_MIR_KHR
#include <mir_toolkit/client_types.h>
#endif

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
#include <wayland-client.h>
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
#include <windows.h>
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR
#include <X11/Xlib.h>
#endif

#ifdef VK_USE_PLATFORM_XCB_KHR
#include <xcb/xcb.h>
#endif

#endif

#ifndef VULKAN_H_
#define VULKAN_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

/*
** Copyright (c) 2015-2016 The Khronos Group Inc.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/

/*
** This header is generated from the Khronos Vulkan XML API Registry.
**
*/


#define VK_VERSION_1_0 1

#define VK_MAKE_VERSION(major, minor, patch) \
    (((major) << 22) | ((minor) << 12) | (patch))

// DEPRECATED: This define has been removed. Specific version defines (e.g. VK_API_VERSION_1_0), or the VK_MAKE_VERSION macro, should be used instead.
//#define VK_API_VERSION VK_MAKE_VERSION(1, 0, 0)

// Vulkan 1.0 version number
#define VK_API_VERSION_1_0 VK_MAKE_VERSION(1, 0, 0)

#define VK_VERSION_MAJOR(version) ((uint32_t)(version) >> 22)
#define VK_VERSION_MINOR(version) (((uint32_t)(version) >> 12) & 0x3ff)
#define VK_VERSION_PATCH(version) ((uint32_t)(version) & 0xfff)
// Version of this file
#define VK_HEADER_VERSION 32


#define VK_NULL_HANDLE 0
        


#define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;


#if !defined(VK_DEFINE_NON_DISPATCHABLE_HANDLE)
#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
#else
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
#endif
#endif
        


typedef uint32_t VkFlags;
typedef uint32_t VkBool32;
typedef uint64_t VkDeviceSize;
typedef uint32_t VkSampleMask;

VK_DEFINE_HANDLE(VkInstance)
VK_DEFINE_HANDLE(VkPhysicalDevice)
VK_DEFINE_HANDLE(VkDevice)
VK_DEFINE_HANDLE(VkQueue)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSemaphore)
VK_DEFINE_HANDLE(VkCommandBuffer)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFence)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDeviceMemory)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBuffer)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImage)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkEvent)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkQueryPool)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBufferView)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImageView)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkShaderModule)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineCache)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineLayout)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkRenderPass)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipeline)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSetLayout)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSampler)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorPool)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSet)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFramebuffer)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCommandPool)

#define VK_LOD_CLAMP_NONE                 1000.0f
#define VK_REMAINING_MIP_LEVELS           (~0U)
#define VK_REMAINING_ARRAY_LAYERS         (~0U)
#define VK_WHOLE_SIZE                     (~0ULL)
#define VK_ATTACHMENT_UNUSED              (~0U)
#define VK_TRUE                           1
#define VK_FALSE                          0
#define VK_QUEUE_FAMILY_IGNORED           (~0U)
#define VK_SUBPASS_EXTERNAL               (~0U)
#define VK_MAX_PHYSICAL_DEVICE_NAME_SIZE  256
#define VK_UUID_SIZE                      16
#define VK_MAX_MEMORY_TYPES               32
#define VK_MAX_MEMORY_HEAPS               16
#define VK_MAX_EXTENSION_NAME_SIZE        256
#define VK_MAX_DESCRIPTION_SIZE           256


typedef enum VkPipelineCacheHeaderVersion {
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
    VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
    VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
    VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE = (VK_PIPELINE_CACHE_HEADER_VERSION_ONE - VK_PIPELINE_CACHE_HEADER_VERSION_ONE + 1),
    VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 0x7FFFFFFF
} VkPipelineCacheHeaderVersion;

typedef enum VkResult {
    VK_SUCCESS = 0,
    VK_NOT_READY = 1,
    VK_TIMEOUT = 2,
    VK_EVENT_SET = 3,
    VK_EVENT_RESET = 4,
    VK_INCOMPLETE = 5,
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    VK_ERROR_INITIALIZATION_FAILED = -3,
    VK_ERROR_DEVICE_LOST = -4,
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    VK_ERROR_FRAGMENTED_POOL = -12,
    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    VK_SUBOPTIMAL_KHR = 1000001003,
    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
    VK_ERROR_INVALID_SHADER_NV = -1000012000,
    VK_RESULT_BEGIN_RANGE = VK_ERROR_FRAGMENTED_POOL,
    VK_RESULT_END_RANGE = VK_INCOMPLETE,
    VK_RESULT_RANGE_SIZE = (VK_INCOMPLETE - VK_ERROR_FRAGMENTED_POOL + 1),
    VK_RESULT_MAX_ENUM = 0x7FFFFFFF
} VkResult;

typedef enum VkStructureType {
    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
    VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = 1000007000,
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
    VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
    VK_STRUCTURE_TYPE_BEGIN_RANGE = VK_STRUCTURE_TYPE_APPLICATION_INFO,
    VK_STRUCTURE_TYPE_END_RANGE = VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
    VK_STRUCTURE_TYPE_RANGE_SIZE = (VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO - VK_STRUCTURE_TYPE_APPLICATION_INFO + 1),
    VK_STRUCTURE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkStructureType;

typedef enum VkSystemAllocationScope {
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
    VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
    VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
    VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE = (VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE - VK_SYSTEM_ALLOCATION_SCOPE_COMMAND + 1),
    VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 0x7FFFFFFF
} VkSystemAllocationScope;

typedef enum VkInternalAllocationType {
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
    VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
    VK_INTERNAL_ALLOCATION_TYPE_END_RANGE = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
    VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE = (VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE - VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE + 1),
    VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkInternalAllocationType;

typedef enum VkFormat {
    VK_FORMAT_UNDEFINED = 0,
    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
    VK_FORMAT_R8_UNORM = 9,
    VK_FORMAT_R8_SNORM = 10,
    VK_FORMAT_R8_USCALED = 11,
    VK_FORMAT_R8_SSCALED = 12,
    VK_FORMAT_R8_UINT = 13,
    VK_FORMAT_R8_SINT = 14,
    VK_FORMAT_R8_SRGB = 15,
    VK_FORMAT_R8G8_UNORM = 16,
    VK_FORMAT_R8G8_SNORM = 17,
    VK_FORMAT_R8G8_USCALED = 18,
    VK_FORMAT_R8G8_SSCALED = 19,
    VK_FORMAT_R8G8_UINT = 20,
    VK_FORMAT_R8G8_SINT = 21,
    VK_FORMAT_R8G8_SRGB = 22,
    VK_FORMAT_R8G8B8_UNORM = 23,
    VK_FORMAT_R8G8B8_SNORM = 24,
    VK_FORMAT_R8G8B8_USCALED = 25,
    VK_FORMAT_R8G8B8_SSCALED = 26,
    VK_FORMAT_R8G8B8_UINT = 27,
    VK_FORMAT_R8G8B8_SINT = 28,
    VK_FORMAT_R8G8B8_SRGB = 29,
    VK_FORMAT_B8G8R8_UNORM = 30,
    VK_FORMAT_B8G8R8_SNORM = 31,
    VK_FORMAT_B8G8R8_USCALED = 32,
    VK_FORMAT_B8G8R8_SSCALED = 33,
    VK_FORMAT_B8G8R8_UINT = 34,
    VK_FORMAT_B8G8R8_SINT = 35,
    VK_FORMAT_B8G8R8_SRGB = 36,
    VK_FORMAT_R8G8B8A8_UNORM = 37,
    VK_FORMAT_R8G8B8A8_SNORM = 38,
    VK_FORMAT_R8G8B8A8_USCALED = 39,
    VK_FORMAT_R8G8B8A8_SSCALED = 40,
    VK_FORMAT_R8G8B8A8_UINT = 41,
    VK_FORMAT_R8G8B8A8_SINT = 42,
    VK_FORMAT_R8G8B8A8_SRGB = 43,
    VK_FORMAT_B8G8R8A8_UNORM = 44,
    VK_FORMAT_B8G8R8A8_SNORM = 45,
    VK_FORMAT_B8G8R8A8_USCALED = 46,
    VK_FORMAT_B8G8R8A8_SSCALED = 47,
    VK_FORMAT_B8G8R8A8_UINT = 48,
    VK_FORMAT_B8G8R8A8_SINT = 49,
    VK_FORMAT_B8G8R8A8_SRGB = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
    VK_FORMAT_R16_UNORM = 70,
    VK_FORMAT_R16_SNORM = 71,
    VK_FORMAT_R16_USCALED = 72,
    VK_FORMAT_R16_SSCALED = 73,
    VK_FORMAT_R16_UINT = 74,
    VK_FORMAT_R16_SINT = 75,
    VK_FORMAT_R16_SFLOAT = 76,
    VK_FORMAT_R16G16_UNORM = 77,
    VK_FORMAT_R16G16_SNORM = 78,
    VK_FORMAT_R16G16_USCALED = 79,
    VK_FORMAT_R16G16_SSCALED = 80,
    VK_FORMAT_R16G16_UINT = 81,
    VK_FORMAT_R16G16_SINT = 82,
    VK_FORMAT_R16G16_SFLOAT = 83,
    VK_FORMAT_R16G16B16_UNORM = 84,
    VK_FORMAT_R16G16B16_SNORM = 85,
    VK_FORMAT_R16G16B16_USCALED = 86,
    VK_FORMAT_R16G16B16_SSCALED = 87,
    VK_FORMAT_R16G16B16_UINT = 88,
    VK_FORMAT_R16G16B16_SINT = 89,
    VK_FORMAT_R16G16B16_SFLOAT = 90,
    VK_FORMAT_R16G16B16A16_UNORM = 91,
    VK_FORMAT_R16G16B16A16_SNORM = 92,
    VK_FORMAT_R16G16B16A16_USCALED = 93,
    VK_FORMAT_R16G16B16A16_SSCALED = 94,
    VK_FORMAT_R16G16B16A16_UINT = 95,
    VK_FORMAT_R16G16B16A16_SINT = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
    VK_FORMAT_R32_UINT = 98,
    VK_FORMAT_R32_SINT = 99,
    VK_FORMAT_R32_SFLOAT = 100,
    VK_FORMAT_R32G32_UINT = 101,
    VK_FORMAT_R32G32_SINT = 102,
    VK_FORMAT_R32G32_SFLOAT = 103,
    VK_FORMAT_R32G32B32_UINT = 104,
    VK_FORMAT_R32G32B32_SINT = 105,
    VK_FORMAT_R32G32B32_SFLOAT = 106,
    VK_FORMAT_R32G32B32A32_UINT = 107,
    VK_FORMAT_R32G32B32A32_SINT = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
    VK_FORMAT_R64_UINT = 110,
    VK_FORMAT_R64_SINT = 111,
    VK_FORMAT_R64_SFLOAT = 112,
    VK_FORMAT_R64G64_UINT = 113,
    VK_FORMAT_R64G64_SINT = 114,
    VK_FORMAT_R64G64_SFLOAT = 115,
    VK_FORMAT_R64G64B64_UINT = 116,
    VK_FORMAT_R64G64B64_SINT = 117,
    VK_FORMAT_R64G64B64_SFLOAT = 118,
    VK_FORMAT_R64G64B64A64_UINT = 119,
    VK_FORMAT_R64G64B64A64_SINT = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
    VK_FORMAT_D16_UNORM = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
    VK_FORMAT_D32_SFLOAT = 126,
    VK_FORMAT_S8_UINT = 127,
    VK_FORMAT_D16_UNORM_S8_UINT = 128,
    VK_FORMAT_D24_UNORM_S8_UINT = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
    VK_FORMAT_BC2_UNORM_BLOCK = 135,
    VK_FORMAT_BC2_SRGB_BLOCK = 136,
    VK_FORMAT_BC3_UNORM_BLOCK = 137,
    VK_FORMAT_BC3_SRGB_BLOCK = 138,
    VK_FORMAT_BC4_UNORM_BLOCK = 139,
    VK_FORMAT_BC4_SNORM_BLOCK = 140,
    VK_FORMAT_BC5_UNORM_BLOCK = 141,
    VK_FORMAT_BC5_SNORM_BLOCK = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
    VK_FORMAT_BC7_UNORM_BLOCK = 145,
    VK_FORMAT_BC7_SRGB_BLOCK = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
    VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
    VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
    VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
    VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
    VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
    VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
    VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
    VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
    VK_FORMAT_BEGIN_RANGE = VK_FORMAT_UNDEFINED,
    VK_FORMAT_END_RANGE = VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    VK_FORMAT_RANGE_SIZE = (VK_FORMAT_ASTC_12x12_SRGB_BLOCK - VK_FORMAT_UNDEFINED + 1),
    VK_FORMAT_MAX_ENUM = 0x7FFFFFFF
} VkFormat;

typedef enum VkImageType {
    VK_IMAGE_TYPE_1D = 0,
    VK_IMAGE_TYPE_2D = 1,
    VK_IMAGE_TYPE_3D = 2,
    VK_IMAGE_TYPE_BEGIN_RANGE = VK_IMAGE_TYPE_1D,
    VK_IMAGE_TYPE_END_RANGE = VK_IMAGE_TYPE_3D,
    VK_IMAGE_TYPE_RANGE_SIZE = (VK_IMAGE_TYPE_3D - VK_IMAGE_TYPE_1D + 1),
    VK_IMAGE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkImageType;

typedef enum VkImageTiling {
    VK_IMAGE_TILING_OPTIMAL = 0,
    VK_IMAGE_TILING_LINEAR = 1,
    VK_IMAGE_TILING_BEGIN_RANGE = VK_IMAGE_TILING_OPTIMAL,
    VK_IMAGE_TILING_END_RANGE = VK_IMAGE_TILING_LINEAR,
    VK_IMAGE_TILING_RANGE_SIZE = (VK_IMAGE_TILING_LINEAR - VK_IMAGE_TILING_OPTIMAL + 1),
    VK_IMAGE_TILING_MAX_ENUM = 0x7FFFFFFF
} VkImageTiling;

typedef enum VkPhysicalDeviceType {
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
    VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE = VK_PHYSICAL_DEVICE_TYPE_OTHER,
    VK_PHYSICAL_DEVICE_TYPE_END_RANGE = VK_PHYSICAL_DEVICE_TYPE_CPU,
    VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE = (VK_PHYSICAL_DEVICE_TYPE_CPU - VK_PHYSICAL_DEVICE_TYPE_OTHER + 1),
    VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkPhysicalDeviceType;

typedef enum VkQueryType {
    VK_QUERY_TYPE_OCCLUSION = 0,
    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
    VK_QUERY_TYPE_TIMESTAMP = 2,
    VK_QUERY_TYPE_BEGIN_RANGE = VK_QUERY_TYPE_OCCLUSION,
    VK_QUERY_TYPE_END_RANGE = VK_QUERY_TYPE_TIMESTAMP,
    VK_QUERY_TYPE_RANGE_SIZE = (VK_QUERY_TYPE_TIMESTAMP - VK_QUERY_TYPE_OCCLUSION + 1),
    VK_QUERY_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkQueryType;

typedef enum VkSharingMode {
    VK_SHARING_MODE_EXCLUSIVE = 0,
    VK_SHARING_MODE_CONCURRENT = 1,
    VK_SHARING_MODE_BEGIN_RANGE = VK_SHARING_MODE_EXCLUSIVE,
    VK_SHARING_MODE_END_RANGE = VK_SHARING_MODE_CONCURRENT,
    VK_SHARING_MODE_RANGE_SIZE = (VK_SHARING_MODE_CONCURRENT - VK_SHARING_MODE_EXCLUSIVE + 1),
    VK_SHARING_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSharingMode;

typedef enum VkImageLayout {
    VK_IMAGE_LAYOUT_UNDEFINED = 0,
    VK_IMAGE_LAYOUT_GENERAL = 1,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
    VK_IMAGE_LAYOUT_BEGIN_RANGE = VK_IMAGE_LAYOUT_UNDEFINED,
    VK_IMAGE_LAYOUT_END_RANGE = VK_IMAGE_LAYOUT_PREINITIALIZED,
    VK_IMAGE_LAYOUT_RANGE_SIZE = (VK_IMAGE_LAYOUT_PREINITIALIZED - VK_IMAGE_LAYOUT_UNDEFINED + 1),
    VK_IMAGE_LAYOUT_MAX_ENUM = 0x7FFFFFFF
} VkImageLayout;

typedef enum VkImageViewType {
    VK_IMAGE_VIEW_TYPE_1D = 0,
    VK_IMAGE_VIEW_TYPE_2D = 1,
    VK_IMAGE_VIEW_TYPE_3D = 2,
    VK_IMAGE_VIEW_TYPE_CUBE = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
    VK_IMAGE_VIEW_TYPE_BEGIN_RANGE = VK_IMAGE_VIEW_TYPE_1D,
    VK_IMAGE_VIEW_TYPE_END_RANGE = VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
    VK_IMAGE_VIEW_TYPE_RANGE_SIZE = (VK_IMAGE_VIEW_TYPE_CUBE_ARRAY - VK_IMAGE_VIEW_TYPE_1D + 1),
    VK_IMAGE_VIEW_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkImageViewType;

typedef enum VkComponentSwizzle {
    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
    VK_COMPONENT_SWIZZLE_ZERO = 1,
    VK_COMPONENT_SWIZZLE_ONE = 2,
    VK_COMPONENT_SWIZZLE_R = 3,
    VK_COMPONENT_SWIZZLE_G = 4,
    VK_COMPONENT_SWIZZLE_B = 5,
    VK_COMPONENT_SWIZZLE_A = 6,
    VK_COMPONENT_SWIZZLE_BEGIN_RANGE = VK_COMPONENT_SWIZZLE_IDENTITY,
    VK_COMPONENT_SWIZZLE_END_RANGE = VK_COMPONENT_SWIZZLE_A,
    VK_COMPONENT_SWIZZLE_RANGE_SIZE = (VK_COMPONENT_SWIZZLE_A - VK_COMPONENT_SWIZZLE_IDENTITY + 1),
    VK_COMPONENT_SWIZZLE_MAX_ENUM = 0x7FFFFFFF
} VkComponentSwizzle;

typedef enum VkVertexInputRate {
    VK_VERTEX_INPUT_RATE_VERTEX = 0,
    VK_VERTEX_INPUT_RATE_INSTANCE = 1,
    VK_VERTEX_INPUT_RATE_BEGIN_RANGE = VK_VERTEX_INPUT_RATE_VERTEX,
    VK_VERTEX_INPUT_RATE_END_RANGE = VK_VERTEX_INPUT_RATE_INSTANCE,
    VK_VERTEX_INPUT_RATE_RANGE_SIZE = (VK_VERTEX_INPUT_RATE_INSTANCE - VK_VERTEX_INPUT_RATE_VERTEX + 1),
    VK_VERTEX_INPUT_RATE_MAX_ENUM = 0x7FFFFFFF
} VkVertexInputRate;

typedef enum VkPrimitiveTopology {
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
    VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE = VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    VK_PRIMITIVE_TOPOLOGY_END_RANGE = VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
    VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE = (VK_PRIMITIVE_TOPOLOGY_PATCH_LIST - VK_PRIMITIVE_TOPOLOGY_POINT_LIST + 1),
    VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = 0x7FFFFFFF
} VkPrimitiveTopology;

typedef enum VkPolygonMode {
    VK_POLYGON_MODE_FILL = 0,
    VK_POLYGON_MODE_LINE = 1,
    VK_POLYGON_MODE_POINT = 2,
    VK_POLYGON_MODE_BEGIN_RANGE = VK_POLYGON_MODE_FILL,
    VK_POLYGON_MODE_END_RANGE = VK_POLYGON_MODE_POINT,
    VK_POLYGON_MODE_RANGE_SIZE = (VK_POLYGON_MODE_POINT - VK_POLYGON_MODE_FILL + 1),
    VK_POLYGON_MODE_MAX_ENUM = 0x7FFFFFFF
} VkPolygonMode;

typedef enum VkFrontFace {
    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
    VK_FRONT_FACE_CLOCKWISE = 1,
    VK_FRONT_FACE_BEGIN_RANGE = VK_FRONT_FACE_COUNTER_CLOCKWISE,
    VK_FRONT_FACE_END_RANGE = VK_FRONT_FACE_CLOCKWISE,
    VK_FRONT_FACE_RANGE_SIZE = (VK_FRONT_FACE_CLOCKWISE - VK_FRONT_FACE_COUNTER_CLOCKWISE + 1),
    VK_FRONT_FACE_MAX_ENUM = 0x7FFFFFFF
} VkFrontFace;

typedef enum VkCompareOp {
    VK_COMPARE_OP_NEVER = 0,
    VK_COMPARE_OP_LESS = 1,
    VK_COMPARE_OP_EQUAL = 2,
    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
    VK_COMPARE_OP_GREATER = 4,
    VK_COMPARE_OP_NOT_EQUAL = 5,
    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
    VK_COMPARE_OP_ALWAYS = 7,
    VK_COMPARE_OP_BEGIN_RANGE = VK_COMPARE_OP_NEVER,
    VK_COMPARE_OP_END_RANGE = VK_COMPARE_OP_ALWAYS,
    VK_COMPARE_OP_RANGE_SIZE = (VK_COMPARE_OP_ALWAYS - VK_COMPARE_OP_NEVER + 1),
    VK_COMPARE_OP_MAX_ENUM = 0x7FFFFFFF
} VkCompareOp;

typedef enum VkStencilOp {
    VK_STENCIL_OP_KEEP = 0,
    VK_STENCIL_OP_ZERO = 1,
    VK_STENCIL_OP_REPLACE = 2,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
    VK_STENCIL_OP_INVERT = 5,
    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
    VK_STENCIL_OP_BEGIN_RANGE = VK_STENCIL_OP_KEEP,
    VK_STENCIL_OP_END_RANGE = VK_STENCIL_OP_DECREMENT_AND_WRAP,
    VK_STENCIL_OP_RANGE_SIZE = (VK_STENCIL_OP_DECREMENT_AND_WRAP - VK_STENCIL_OP_KEEP + 1),
    VK_STENCIL_OP_MAX_ENUM = 0x7FFFFFFF
} VkStencilOp;

typedef enum VkLogicOp {
    VK_LOGIC_OP_CLEAR = 0,
    VK_LOGIC_OP_AND = 1,
    VK_LOGIC_OP_AND_REVERSE = 2,
    VK_LOGIC_OP_COPY = 3,
    VK_LOGIC_OP_AND_INVERTED = 4,
    VK_LOGIC_OP_NO_OP = 5,
    VK_LOGIC_OP_XOR = 6,
    VK_LOGIC_OP_OR = 7,
    VK_LOGIC_OP_NOR = 8,
    VK_LOGIC_OP_EQUIVALENT = 9,
    VK_LOGIC_OP_INVERT = 10,
    VK_LOGIC_OP_OR_REVERSE = 11,
    VK_LOGIC_OP_COPY_INVERTED = 12,
    VK_LOGIC_OP_OR_INVERTED = 13,
    VK_LOGIC_OP_NAND = 14,
    VK_LOGIC_OP_SET = 15,
    VK_LOGIC_OP_BEGIN_RANGE = VK_LOGIC_OP_CLEAR,
    VK_LOGIC_OP_END_RANGE = VK_LOGIC_OP_SET,
    VK_LOGIC_OP_RANGE_SIZE = (VK_LOGIC_OP_SET - VK_LOGIC_OP_CLEAR + 1),
    VK_LOGIC_OP_MAX_ENUM = 0x7FFFFFFF
} VkLogicOp;

typedef enum VkBlendFactor {
    VK_BLEND_FACTOR_ZERO = 0,
    VK_BLEND_FACTOR_ONE = 1,
    VK_BLEND_FACTOR_SRC_COLOR = 2,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
    VK_BLEND_FACTOR_DST_COLOR = 4,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
    VK_BLEND_FACTOR_SRC_ALPHA = 6,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
    VK_BLEND_FACTOR_DST_ALPHA = 8,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
    VK_BLEND_FACTOR_SRC1_COLOR = 15,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
    VK_BLEND_FACTOR_BEGIN_RANGE = VK_BLEND_FACTOR_ZERO,
    VK_BLEND_FACTOR_END_RANGE = VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
    VK_BLEND_FACTOR_RANGE_SIZE = (VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA - VK_BLEND_FACTOR_ZERO + 1),
    VK_BLEND_FACTOR_MAX_ENUM = 0x7FFFFFFF
} VkBlendFactor;

typedef enum VkBlendOp {
    VK_BLEND_OP_ADD = 0,
    VK_BLEND_OP_SUBTRACT = 1,
    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
    VK_BLEND_OP_MIN = 3,
    VK_BLEND_OP_MAX = 4,
    VK_BLEND_OP_BEGIN_RANGE = VK_BLEND_OP_ADD,
    VK_BLEND_OP_END_RANGE = VK_BLEND_OP_MAX,
    VK_BLEND_OP_RANGE_SIZE = (VK_BLEND_OP_MAX - VK_BLEND_OP_ADD + 1),
    VK_BLEND_OP_MAX_ENUM = 0x7FFFFFFF
} VkBlendOp;

typedef enum VkDynamicState {
    VK_DYNAMIC_STATE_VIEWPORT = 0,
    VK_DYNAMIC_STATE_SCISSOR = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
    VK_DYNAMIC_STATE_BEGIN_RANGE = VK_DYNAMIC_STATE_VIEWPORT,
    VK_DYNAMIC_STATE_END_RANGE = VK_DYNAMIC_STATE_STENCIL_REFERENCE,
    VK_DYNAMIC_STATE_RANGE_SIZE = (VK_DYNAMIC_STATE_STENCIL_REFERENCE - VK_DYNAMIC_STATE_VIEWPORT + 1),
    VK_DYNAMIC_STATE_MAX_ENUM = 0x7FFFFFFF
} VkDynamicState;

typedef enum VkFilter {
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
    VK_FILTER_CUBIC_IMG = 1000015000,
    VK_FILTER_BEGIN_RANGE = VK_FILTER_NEAREST,
    VK_FILTER_END_RANGE = VK_FILTER_LINEAR,
    VK_FILTER_RANGE_SIZE = (VK_FILTER_LINEAR - VK_FILTER_NEAREST + 1),
    VK_FILTER_MAX_ENUM = 0x7FFFFFFF
} VkFilter;

typedef enum VkSamplerMipmapMode {
    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
    VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE = VK_SAMPLER_MIPMAP_MODE_NEAREST,
    VK_SAMPLER_MIPMAP_MODE_END_RANGE = VK_SAMPLER_MIPMAP_MODE_LINEAR,
    VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE = (VK_SAMPLER_MIPMAP_MODE_LINEAR - VK_SAMPLER_MIPMAP_MODE_NEAREST + 1),
    VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSamplerMipmapMode;

typedef enum VkSamplerAddressMode {
    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
    VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    VK_SAMPLER_ADDRESS_MODE_END_RANGE = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE = (VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER - VK_SAMPLER_ADDRESS_MODE_REPEAT + 1),
    VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSamplerAddressMode;

typedef enum VkBorderColor {
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
    VK_BORDER_COLOR_BEGIN_RANGE = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
    VK_BORDER_COLOR_END_RANGE = VK_BORDER_COLOR_INT_OPAQUE_WHITE,
    VK_BORDER_COLOR_RANGE_SIZE = (VK_BORDER_COLOR_INT_OPAQUE_WHITE - VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK + 1),
    VK_BORDER_COLOR_MAX_ENUM = 0x7FFFFFFF
} VkBorderColor;

typedef enum VkDescriptorType {
    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
    VK_DESCRIPTOR_TYPE_BEGIN_RANGE = VK_DESCRIPTOR_TYPE_SAMPLER,
    VK_DESCRIPTOR_TYPE_END_RANGE = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
    VK_DESCRIPTOR_TYPE_RANGE_SIZE = (VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT - VK_DESCRIPTOR_TYPE_SAMPLER + 1),
    VK_DESCRIPTOR_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorType;

typedef enum VkAttachmentLoadOp {
    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
    VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE = VK_ATTACHMENT_LOAD_OP_LOAD,
    VK_ATTACHMENT_LOAD_OP_END_RANGE = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    VK_ATTACHMENT_LOAD_OP_RANGE_SIZE = (VK_ATTACHMENT_LOAD_OP_DONT_CARE - VK_ATTACHMENT_LOAD_OP_LOAD + 1),
    VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentLoadOp;

typedef enum VkAttachmentStoreOp {
    VK_ATTACHMENT_STORE_OP_STORE = 0,
    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
    VK_ATTACHMENT_STORE_OP_BEGIN_RANGE = VK_ATTACHMENT_STORE_OP_STORE,
    VK_ATTACHMENT_STORE_OP_END_RANGE = VK_ATTACHMENT_STORE_OP_DONT_CARE,
    VK_ATTACHMENT_STORE_OP_RANGE_SIZE = (VK_ATTACHMENT_STORE_OP_DONT_CARE - VK_ATTACHMENT_STORE_OP_STORE + 1),
    VK_ATTACHMENT_STORE_OP_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentStoreOp;

typedef enum VkPipelineBindPoint {
    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
    VK_PIPELINE_BIND_POINT_BEGIN_RANGE = VK_PIPELINE_BIND_POINT_GRAPHICS,
    VK_PIPELINE_BIND_POINT_END_RANGE = VK_PIPELINE_BIND_POINT_COMPUTE,
    VK_PIPELINE_BIND_POINT_RANGE_SIZE = (VK_PIPELINE_BIND_POINT_COMPUTE - VK_PIPELINE_BIND_POINT_GRAPHICS + 1),
    VK_PIPELINE_BIND_POINT_MAX_ENUM = 0x7FFFFFFF
} VkPipelineBindPoint;

typedef enum VkCommandBufferLevel {
    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
    VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
    VK_COMMAND_BUFFER_LEVEL_END_RANGE = VK_COMMAND_BUFFER_LEVEL_SECONDARY,
    VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE = (VK_COMMAND_BUFFER_LEVEL_SECONDARY - VK_COMMAND_BUFFER_LEVEL_PRIMARY + 1),
    VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferLevel;

typedef enum VkIndexType {
    VK_INDEX_TYPE_UINT16 = 0,
    VK_INDEX_TYPE_UINT32 = 1,
    VK_INDEX_TYPE_BEGIN_RANGE = VK_INDEX_TYPE_UINT16,
    VK_INDEX_TYPE_END_RANGE = VK_INDEX_TYPE_UINT32,
    VK_INDEX_TYPE_RANGE_SIZE = (VK_INDEX_TYPE_UINT32 - VK_INDEX_TYPE_UINT16 + 1),
    VK_INDEX_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkIndexType;

typedef enum VkSubpassContents {
    VK_SUBPASS_CONTENTS_INLINE = 0,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
    VK_SUBPASS_CONTENTS_BEGIN_RANGE = VK_SUBPASS_CONTENTS_INLINE,
    VK_SUBPASS_CONTENTS_END_RANGE = VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
    VK_SUBPASS_CONTENTS_RANGE_SIZE = (VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS - VK_SUBPASS_CONTENTS_INLINE + 1),
    VK_SUBPASS_CONTENTS_MAX_ENUM = 0x7FFFFFFF
} VkSubpassContents;

typedef VkFlags VkInstanceCreateFlags;

typedef enum VkFormatFeatureFlagBits {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400,
    VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 0x00002000,
    VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkFormatFeatureFlagBits;
typedef VkFlags VkFormatFeatureFlags;

typedef enum VkImageUsageFlagBits {
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001,
    VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002,
    VK_IMAGE_USAGE_SAMPLED_BIT = 0x00000004,
    VK_IMAGE_USAGE_STORAGE_BIT = 0x00000008,
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010,
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040,
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080,
    VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageUsageFlagBits;
typedef VkFlags VkImageUsageFlags;

typedef enum VkImageCreateFlagBits {
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001,
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008,
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010,
    VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageCreateFlagBits;
typedef VkFlags VkImageCreateFlags;

typedef enum VkSampleCountFlagBits {
    VK_SAMPLE_COUNT_1_BIT = 0x00000001,
    VK_SAMPLE_COUNT_2_BIT = 0x00000002,
    VK_SAMPLE_COUNT_4_BIT = 0x00000004,
    VK_SAMPLE_COUNT_8_BIT = 0x00000008,
    VK_SAMPLE_COUNT_16_BIT = 0x00000010,
    VK_SAMPLE_COUNT_32_BIT = 0x00000020,
    VK_SAMPLE_COUNT_64_BIT = 0x00000040,
    VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSampleCountFlagBits;
typedef VkFlags VkSampleCountFlags;

typedef enum VkQueueFlagBits {
    VK_QUEUE_GRAPHICS_BIT = 0x00000001,
    VK_QUEUE_COMPUTE_BIT = 0x00000002,
    VK_QUEUE_TRANSFER_BIT = 0x00000004,
    VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
    VK_QUEUE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueueFlagBits;
typedef VkFlags VkQueueFlags;

typedef enum VkMemoryPropertyFlagBits {
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
    VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkMemoryPropertyFlagBits;
typedef VkFlags VkMemoryPropertyFlags;

typedef enum VkMemoryHeapFlagBits {
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
    VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkMemoryHeapFlagBits;
typedef VkFlags VkMemoryHeapFlags;
typedef VkFlags VkDeviceCreateFlags;
typedef VkFlags VkDeviceQueueCreateFlags;

typedef enum VkPipelineStageFlagBits {
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004,
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008,
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010,
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020,
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080,
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100,
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800,
    VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000,
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000,
    VK_PIPELINE_STAGE_HOST_BIT = 0x00004000,
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000,
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000,
    VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkPipelineStageFlagBits;
typedef VkFlags VkPipelineStageFlags;
typedef VkFlags VkMemoryMapFlags;

typedef enum VkImageAspectFlagBits {
    VK_IMAGE_ASPECT_COLOR_BIT = 0x00000001,
    VK_IMAGE_ASPECT_DEPTH_BIT = 0x00000002,
    VK_IMAGE_ASPECT_STENCIL_BIT = 0x00000004,
    VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
    VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageAspectFlagBits;
typedef VkFlags VkImageAspectFlags;

typedef enum VkSparseImageFormatFlagBits {
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001,
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002,
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
    VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSparseImageFormatFlagBits;
typedef VkFlags VkSparseImageFormatFlags;

typedef enum VkSparseMemoryBindFlagBits {
    VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
    VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSparseMemoryBindFlagBits;
typedef VkFlags VkSparseMemoryBindFlags;

typedef enum VkFenceCreateFlagBits {
    VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
    VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkFenceCreateFlagBits;
typedef VkFlags VkFenceCreateFlags;
typedef VkFlags VkSemaphoreCreateFlags;
typedef VkFlags VkEventCreateFlags;
typedef VkFlags VkQueryPoolCreateFlags;

typedef enum VkQueryPipelineStatisticFlagBits {
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001,
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002,
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040,
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200,
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400,
    VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryPipelineStatisticFlagBits;
typedef VkFlags VkQueryPipelineStatisticFlags;

typedef enum VkQueryResultFlagBits {
    VK_QUERY_RESULT_64_BIT = 0x00000001,
    VK_QUERY_RESULT_WAIT_BIT = 0x00000002,
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004,
    VK_QUERY_RESULT_PARTIAL_BIT = 0x00000008,
    VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryResultFlagBits;
typedef VkFlags VkQueryResultFlags;

typedef enum VkBufferCreateFlagBits {
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
    VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkBufferCreateFlagBits;
typedef VkFlags VkBufferCreateFlags;

typedef enum VkBufferUsageFlagBits {
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001,
    VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002,
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008,
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010,
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020,
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040,
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100,
    VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkBufferUsageFlagBits;
typedef VkFlags VkBufferUsageFlags;
typedef VkFlags VkBufferViewCreateFlags;
typedef VkFlags VkImageViewCreateFlags;
typedef VkFlags VkShaderModuleCreateFlags;
typedef VkFlags VkPipelineCacheCreateFlags;

typedef enum VkPipelineCreateFlagBits {
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004,
    VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkPipelineCreateFlagBits;
typedef VkFlags VkPipelineCreateFlags;
typedef VkFlags VkPipelineShaderStageCreateFlags;

typedef enum VkShaderStageFlagBits {
    VK_SHADER_STAGE_VERTEX_BIT = 0x00000001,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
    VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008,
    VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010,
    VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020,
    VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F,
    VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
    VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkShaderStageFlagBits;
typedef VkFlags VkPipelineVertexInputStateCreateFlags;
typedef VkFlags VkPipelineInputAssemblyStateCreateFlags;
typedef VkFlags VkPipelineTessellationStateCreateFlags;
typedef VkFlags VkPipelineViewportStateCreateFlags;
typedef VkFlags VkPipelineRasterizationStateCreateFlags;

typedef enum VkCullModeFlagBits {
    VK_CULL_MODE_NONE = 0,
    VK_CULL_MODE_FRONT_BIT = 0x00000001,
    VK_CULL_MODE_BACK_BIT = 0x00000002,
    VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
    VK_CULL_MODE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCullModeFlagBits;
typedef VkFlags VkCullModeFlags;
typedef VkFlags VkPipelineMultisampleStateCreateFlags;
typedef VkFlags VkPipelineDepthStencilStateCreateFlags;
typedef VkFlags VkPipelineColorBlendStateCreateFlags;

typedef enum VkColorComponentFlagBits {
    VK_COLOR_COMPONENT_R_BIT = 0x00000001,
    VK_COLOR_COMPONENT_G_BIT = 0x00000002,
    VK_COLOR_COMPONENT_B_BIT = 0x00000004,
    VK_COLOR_COMPONENT_A_BIT = 0x00000008,
    VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkColorComponentFlagBits;
typedef VkFlags VkColorComponentFlags;
typedef VkFlags VkPipelineDynamicStateCreateFlags;
typedef VkFlags VkPipelineLayoutCreateFlags;
typedef VkFlags VkShaderStageFlags;
typedef VkFlags VkSamplerCreateFlags;
typedef VkFlags VkDescriptorSetLayoutCreateFlags;

typedef enum VkDescriptorPoolCreateFlagBits {
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
    VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorPoolCreateFlagBits;
typedef VkFlags VkDescriptorPoolCreateFlags;
typedef VkFlags VkDescriptorPoolResetFlags;
typedef VkFlags VkFramebufferCreateFlags;
typedef VkFlags VkRenderPassCreateFlags;

typedef enum VkAttachmentDescriptionFlagBits {
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001,
    VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentDescriptionFlagBits;
typedef VkFlags VkAttachmentDescriptionFlags;
typedef VkFlags VkSubpassDescriptionFlags;

typedef enum VkAccessFlagBits {
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001,
    VK_ACCESS_INDEX_READ_BIT = 0x00000002,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004,
    VK_ACCESS_UNIFORM_READ_BIT = 0x00000008,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010,
    VK_ACCESS_SHADER_READ_BIT = 0x00000020,
    VK_ACCESS_SHADER_WRITE_BIT = 0x00000040,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
    VK_ACCESS_TRANSFER_READ_BIT = 0x00000800,
    VK_ACCESS_TRANSFER_WRITE_BIT = 0x00001000,
    VK_ACCESS_HOST_READ_BIT = 0x00002000,
    VK_ACCESS_HOST_WRITE_BIT = 0x00004000,
    VK_ACCESS_MEMORY_READ_BIT = 0x00008000,
    VK_ACCESS_MEMORY_WRITE_BIT = 0x00010000,
    VK_ACCESS_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkAccessFlagBits;
typedef VkFlags VkAccessFlags;

typedef enum VkDependencyFlagBits {
    VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
    VK_DEPENDENCY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDependencyFlagBits;
typedef VkFlags VkDependencyFlags;

typedef enum VkCommandPoolCreateFlagBits {
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001,
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002,
    VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandPoolCreateFlagBits;
typedef VkFlags VkCommandPoolCreateFlags;

typedef enum VkCommandPoolResetFlagBits {
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
    VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandPoolResetFlagBits;
typedef VkFlags VkCommandPoolResetFlags;

typedef enum VkCommandBufferUsageFlagBits {
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001,
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004,
    VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferUsageFlagBits;
typedef VkFlags VkCommandBufferUsageFlags;

typedef enum VkQueryControlFlagBits {
    VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
    VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryControlFlagBits;
typedef VkFlags VkQueryControlFlags;

typedef enum VkCommandBufferResetFlagBits {
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
    VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferResetFlagBits;
typedef VkFlags VkCommandBufferResetFlags;

typedef enum VkStencilFaceFlagBits {
    VK_STENCIL_FACE_FRONT_BIT = 0x00000001,
    VK_STENCIL_FACE_BACK_BIT = 0x00000002,
    VK_STENCIL_FRONT_AND_BACK = 0x00000003,
    VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkStencilFaceFlagBits;
typedef VkFlags VkStencilFaceFlags;

typedef void* (VKAPI_PTR *PFN_vkAllocationFunction)(
    void*                                       pUserData,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);

typedef void* (VKAPI_PTR *PFN_vkReallocationFunction)(
    void*                                       pUserData,
    void*                                       pOriginal,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkFreeFunction)(
    void*                                       pUserData,
    void*                                       pMemory);

typedef void (VKAPI_PTR *PFN_vkInternalAllocationNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkInternalFreeNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkVoidFunction)(void);

typedef struct VkApplicationInfo {
    VkStructureType    sType;
    void*        pNext;
    char*        pApplicationName;
    uint32_t           applicationVersion;
    char*        pEngineName;
    uint32_t           engineVersion;
    uint32_t           apiVersion;
} VkApplicationInfo;

typedef struct VkInstanceCreateInfo {
    VkStructureType             sType;
    void*                 pNext;
    VkInstanceCreateFlags       flags;
    VkApplicationInfo*    pApplicationInfo;
    uint32_t                    enabledLayerCount;
    char* *         ppEnabledLayerNames;
    uint32_t                    enabledExtensionCount;
    char* *         ppEnabledExtensionNames;
} VkInstanceCreateInfo;

typedef struct VkAllocationCallbacks {
    void*                                   pUserData;
    PFN_vkAllocationFunction                pfnAllocation;
    PFN_vkReallocationFunction              pfnReallocation;
    PFN_vkFreeFunction                      pfnFree;
    PFN_vkInternalAllocationNotification    pfnInternalAllocation;
    PFN_vkInternalFreeNotification          pfnInternalFree;
} VkAllocationCallbacks;

typedef struct VkPhysicalDeviceFeatures {
    VkBool32    robustBufferAccess;
    VkBool32    fullDrawIndexUint32;
    VkBool32    imageCubeArray;
    VkBool32    independentBlend;
    VkBool32    geometryShader;
    VkBool32    tessellationShader;
    VkBool32    sampleRateShading;
    VkBool32    dualSrcBlend;
    VkBool32    logicOp;
    VkBool32    multiDrawIndirect;
    VkBool32    drawIndirectFirstInstance;
    VkBool32    depthClamp;
    VkBool32    depthBiasClamp;
    VkBool32    fillModeNonSolid;
    VkBool32    depthBounds;
    VkBool32    wideLines;
    VkBool32    largePoints;
    VkBool32    alphaToOne;
    VkBool32    multiViewport;
    VkBool32    samplerAnisotropy;
    VkBool32    textureCompressionETC2;
    VkBool32    textureCompressionASTC_LDR;
    VkBool32    textureCompressionBC;
    VkBool32    occlusionQueryPrecise;
    VkBool32    pipelineStatisticsQuery;
    VkBool32    vertexPipelineStoresAndAtomics;
    VkBool32    fragmentStoresAndAtomics;
    VkBool32    shaderTessellationAndGeometryPointSize;
    VkBool32    shaderImageGatherExtended;
    VkBool32    shaderStorageImageExtendedFormats;
    VkBool32    shaderStorageImageMultisample;
    VkBool32    shaderStorageImageReadWithoutFormat;
    VkBool32    shaderStorageImageWriteWithoutFormat;
    VkBool32    shaderUniformBufferArrayDynamicIndexing;
    VkBool32    shaderSampledImageArrayDynamicIndexing;
    VkBool32    shaderStorageBufferArrayDynamicIndexing;
    VkBool32    shaderStorageImageArrayDynamicIndexing;
    VkBool32    shaderClipDistance;
    VkBool32    shaderCullDistance;
    VkBool32    shaderFloat64;
    VkBool32    shaderInt64;
    VkBool32    shaderInt16;
    VkBool32    shaderResourceResidency;
    VkBool32    shaderResourceMinLod;
    VkBool32    sparseBinding;
    VkBool32    sparseResidencyBuffer;
    VkBool32    sparseResidencyImage2D;
    VkBool32    sparseResidencyImage3D;
    VkBool32    sparseResidency2Samples;
    VkBool32    sparseResidency4Samples;
    VkBool32    sparseResidency8Samples;
    VkBool32    sparseResidency16Samples;
    VkBool32    sparseResidencyAliased;
    VkBool32    variableMultisampleRate;
    VkBool32    inheritedQueries;
} VkPhysicalDeviceFeatures;

typedef struct VkFormatProperties {
    VkFormatFeatureFlags    linearTilingFeatures;
    VkFormatFeatureFlags    optimalTilingFeatures;
    VkFormatFeatureFlags    bufferFeatures;
} VkFormatProperties;

typedef struct VkExtent3D {
    uint32_t    width;
    uint32_t    height;
    uint32_t    depth;
} VkExtent3D;

typedef struct VkImageFormatProperties {
    VkExtent3D            maxExtent;
    uint32_t              maxMipLevels;
    uint32_t              maxArrayLayers;
    VkSampleCountFlags    sampleCounts;
    VkDeviceSize          maxResourceSize;
} VkImageFormatProperties;

typedef struct VkPhysicalDeviceLimits {
    uint32_t              maxImageDimension1D;
    uint32_t              maxImageDimension2D;
    uint32_t              maxImageDimension3D;
    uint32_t              maxImageDimensionCube;
    uint32_t              maxImageArrayLayers;
    uint32_t              maxTexelBufferElements;
    uint32_t              maxUniformBufferRange;
    uint32_t              maxStorageBufferRange;
    uint32_t              maxPushConstantsSize;
    uint32_t              maxMemoryAllocationCount;
    uint32_t              maxSamplerAllocationCount;
    VkDeviceSize          bufferImageGranularity;
    VkDeviceSize          sparseAddressSpaceSize;
    uint32_t              maxBoundDescriptorSets;
    uint32_t              maxPerStageDescriptorSamplers;
    uint32_t              maxPerStageDescriptorUniformBuffers;
    uint32_t              maxPerStageDescriptorStorageBuffers;
    uint32_t              maxPerStageDescriptorSampledImages;
    uint32_t              maxPerStageDescriptorStorageImages;
    uint32_t              maxPerStageDescriptorInputAttachments;
    uint32_t              maxPerStageResources;
    uint32_t              maxDescriptorSetSamplers;
    uint32_t              maxDescriptorSetUniformBuffers;
    uint32_t              maxDescriptorSetUniformBuffersDynamic;
    uint32_t              maxDescriptorSetStorageBuffers;
    uint32_t              maxDescriptorSetStorageBuffersDynamic;
    uint32_t              maxDescriptorSetSampledImages;
    uint32_t              maxDescriptorSetStorageImages;
    uint32_t              maxDescriptorSetInputAttachments;
    uint32_t              maxVertexInputAttributes;
    uint32_t              maxVertexInputBindings;
    uint32_t              maxVertexInputAttributeOffset;
    uint32_t              maxVertexInputBindingStride;
    uint32_t              maxVertexOutputComponents;
    uint32_t              maxTessellationGenerationLevel;
    uint32_t              maxTessellationPatchSize;
    uint32_t              maxTessellationControlPerVertexInputComponents;
    uint32_t              maxTessellationControlPerVertexOutputComponents;
    uint32_t              maxTessellationControlPerPatchOutputComponents;
    uint32_t              maxTessellationControlTotalOutputComponents;
    uint32_t              maxTessellationEvaluationInputComponents;
    uint32_t              maxTessellationEvaluationOutputComponents;
    uint32_t              maxGeometryShaderInvocations;
    uint32_t              maxGeometryInputComponents;
    uint32_t              maxGeometryOutputComponents;
    uint32_t              maxGeometryOutputVertices;
    uint32_t              maxGeometryTotalOutputComponents;
    uint32_t              maxFragmentInputComponents;
    uint32_t              maxFragmentOutputAttachments;
    uint32_t              maxFragmentDualSrcAttachments;
    uint32_t              maxFragmentCombinedOutputResources;
    uint32_t              maxComputeSharedMemorySize;
    uint32_t              maxComputeWorkGroupCount[3];
    uint32_t              maxComputeWorkGroupInvocations;
    uint32_t              maxComputeWorkGroupSize[3];
    uint32_t              subPixelPrecisionBits;
    uint32_t              subTexelPrecisionBits;
    uint32_t              mipmapPrecisionBits;
    uint32_t              maxDrawIndexedIndexValue;
    uint32_t              maxDrawIndirectCount;
    float                 maxSamplerLodBias;
    float                 maxSamplerAnisotropy;
    uint32_t              maxViewports;
    uint32_t              maxViewportDimensions[2];
    float                 viewportBoundsRange[2];
    uint32_t              viewportSubPixelBits;
    size_t                minMemoryMapAlignment;
    VkDeviceSize          minTexelBufferOffsetAlignment;
    VkDeviceSize          minUniformBufferOffsetAlignment;
    VkDeviceSize          minStorageBufferOffsetAlignment;
    int32_t               minTexelOffset;
    uint32_t              maxTexelOffset;
    int32_t               minTexelGatherOffset;
    uint32_t              maxTexelGatherOffset;
    float                 minInterpolationOffset;
    float                 maxInterpolationOffset;
    uint32_t              subPixelInterpolationOffsetBits;
    uint32_t              maxFramebufferWidth;
    uint32_t              maxFramebufferHeight;
    uint32_t              maxFramebufferLayers;
    VkSampleCountFlags    framebufferColorSampleCounts;
    VkSampleCountFlags    framebufferDepthSampleCounts;
    VkSampleCountFlags    framebufferStencilSampleCounts;
    VkSampleCountFlags    framebufferNoAttachmentsSampleCounts;
    uint32_t              maxColorAttachments;
    VkSampleCountFlags    sampledImageColorSampleCounts;
    VkSampleCountFlags    sampledImageIntegerSampleCounts;
    VkSampleCountFlags    sampledImageDepthSampleCounts;
    VkSampleCountFlags    sampledImageStencilSampleCounts;
    VkSampleCountFlags    storageImageSampleCounts;
    uint32_t              maxSampleMaskWords;
    VkBool32              timestampComputeAndGraphics;
    float                 timestampPeriod;
    uint32_t              maxClipDistances;
    uint32_t              maxCullDistances;
    uint32_t              maxCombinedClipAndCullDistances;
    uint32_t              discreteQueuePriorities;
    float                 pointSizeRange[2];
    float                 lineWidthRange[2];
    float                 pointSizeGranularity;
    float                 lineWidthGranularity;
    VkBool32              strictLines;
    VkBool32              standardSampleLocations;
    VkDeviceSize          optimalBufferCopyOffsetAlignment;
    VkDeviceSize          optimalBufferCopyRowPitchAlignment;
    VkDeviceSize          nonCoherentAtomSize;
} VkPhysicalDeviceLimits;

typedef struct VkPhysicalDeviceSparseProperties {
    VkBool32    residencyStandard2DBlockShape;
    VkBool32    residencyStandard2DMultisampleBlockShape;
    VkBool32    residencyStandard3DBlockShape;
    VkBool32    residencyAlignedMipSize;
    VkBool32    residencyNonResidentStrict;
} VkPhysicalDeviceSparseProperties;

typedef struct VkPhysicalDeviceProperties {
    uint32_t                            apiVersion;
    uint32_t                            driverVersion;
    uint32_t                            vendorID;
    uint32_t                            deviceID;
    VkPhysicalDeviceType                deviceType;
    char                                deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
    uint8_t                             pipelineCacheUUID[VK_UUID_SIZE];
    VkPhysicalDeviceLimits              limits;
    VkPhysicalDeviceSparseProperties    sparseProperties;
} VkPhysicalDeviceProperties;

typedef struct VkQueueFamilyProperties {
    VkQueueFlags    queueFlags;
    uint32_t        queueCount;
    uint32_t        timestampValidBits;
    VkExtent3D      minImageTransferGranularity;
} VkQueueFamilyProperties;

typedef struct VkMemoryType {
    VkMemoryPropertyFlags    propertyFlags;
    uint32_t                 heapIndex;
} VkMemoryType;

typedef struct VkMemoryHeap {
    VkDeviceSize         size;
    VkMemoryHeapFlags    flags;
} VkMemoryHeap;

typedef struct VkPhysicalDeviceMemoryProperties {
    uint32_t        memoryTypeCount;
    VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];
    uint32_t        memoryHeapCount;
    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryProperties;

typedef struct VkDeviceQueueCreateInfo {
    VkStructureType             sType;
    void*                 pNext;
    VkDeviceQueueCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
    uint32_t                    queueCount;
    float*                pQueuePriorities;
} VkDeviceQueueCreateInfo;

typedef struct VkDeviceCreateInfo {
    VkStructureType                    sType;
    void*                        pNext;
    VkDeviceCreateFlags                flags;
    uint32_t                           queueCreateInfoCount;
    VkDeviceQueueCreateInfo*     pQueueCreateInfos;
    uint32_t                           enabledLayerCount;
    char* *                ppEnabledLayerNames;
    uint32_t                           enabledExtensionCount;
    char* *                ppEnabledExtensionNames;
    VkPhysicalDeviceFeatures*    pEnabledFeatures;
} VkDeviceCreateInfo;

typedef struct VkExtensionProperties {
    char        extensionName[VK_MAX_EXTENSION_NAME_SIZE];
    uint32_t    specVersion;
} VkExtensionProperties;

typedef struct VkLayerProperties {
    char        layerName[VK_MAX_EXTENSION_NAME_SIZE];
    uint32_t    specVersion;
    uint32_t    implementationVersion;
    char        description[VK_MAX_DESCRIPTION_SIZE];
} VkLayerProperties;

typedef struct VkSubmitInfo {
    VkStructureType                sType;
    void*                    pNext;
    uint32_t                       waitSemaphoreCount;
    VkSemaphore*             pWaitSemaphores;
    VkPipelineStageFlags*    pWaitDstStageMask;
    uint32_t                       commandBufferCount;
    VkCommandBuffer*         pCommandBuffers;
    uint32_t                       signalSemaphoreCount;
    VkSemaphore*             pSignalSemaphores;
} VkSubmitInfo;

typedef struct VkMemoryAllocateInfo {
    VkStructureType    sType;
    void*        pNext;
    VkDeviceSize       allocationSize;
    uint32_t           memoryTypeIndex;
} VkMemoryAllocateInfo;

typedef struct VkMappedMemoryRange {
    VkStructureType    sType;
    void*        pNext;
    VkDeviceMemory     memory;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} VkMappedMemoryRange;

typedef struct VkMemoryRequirements {
    VkDeviceSize    size;
    VkDeviceSize    alignment;
    uint32_t        memoryTypeBits;
} VkMemoryRequirements;

typedef struct VkSparseImageFormatProperties {
    VkImageAspectFlags          aspectMask;
    VkExtent3D                  imageGranularity;
    VkSparseImageFormatFlags    flags;
} VkSparseImageFormatProperties;

typedef struct VkSparseImageMemoryRequirements {
    VkSparseImageFormatProperties    formatProperties;
    uint32_t                         imageMipTailFirstLod;
    VkDeviceSize                     imageMipTailSize;
    VkDeviceSize                     imageMipTailOffset;
    VkDeviceSize                     imageMipTailStride;
} VkSparseImageMemoryRequirements;

typedef struct VkSparseMemoryBind {
    VkDeviceSize               resourceOffset;
    VkDeviceSize               size;
    VkDeviceMemory             memory;
    VkDeviceSize               memoryOffset;
    VkSparseMemoryBindFlags    flags;
} VkSparseMemoryBind;

typedef struct VkSparseBufferMemoryBindInfo {
    VkBuffer                     buffer;
    uint32_t                     bindCount;
    VkSparseMemoryBind*    pBinds;
} VkSparseBufferMemoryBindInfo;

typedef struct VkSparseImageOpaqueMemoryBindInfo {
    VkImage                      image;
    uint32_t                     bindCount;
    VkSparseMemoryBind*    pBinds;
} VkSparseImageOpaqueMemoryBindInfo;

typedef struct VkImageSubresource {
    VkImageAspectFlags    aspectMask;
    uint32_t              mipLevel;
    uint32_t              arrayLayer;
} VkImageSubresource;

typedef struct VkOffset3D {
    int32_t    x;
    int32_t    y;
    int32_t    z;
} VkOffset3D;

typedef struct VkSparseImageMemoryBind {
    VkImageSubresource         subresource;
    VkOffset3D                 offset;
    VkExtent3D                 extent;
    VkDeviceMemory             memory;
    VkDeviceSize               memoryOffset;
    VkSparseMemoryBindFlags    flags;
} VkSparseImageMemoryBind;

typedef struct VkSparseImageMemoryBindInfo {
    VkImage                           image;
    uint32_t                          bindCount;
    VkSparseImageMemoryBind*    pBinds;
} VkSparseImageMemoryBindInfo;

typedef struct VkBindSparseInfo {
    VkStructureType                             sType;
    void*                                 pNext;
    uint32_t                                    waitSemaphoreCount;
    VkSemaphore*                          pWaitSemaphores;
    uint32_t                                    bufferBindCount;
    VkSparseBufferMemoryBindInfo*         pBufferBinds;
    uint32_t                                    imageOpaqueBindCount;
    VkSparseImageOpaqueMemoryBindInfo*    pImageOpaqueBinds;
    uint32_t                                    imageBindCount;
    VkSparseImageMemoryBindInfo*          pImageBinds;
    uint32_t                                    signalSemaphoreCount;
    VkSemaphore*                          pSignalSemaphores;
} VkBindSparseInfo;

typedef struct VkFenceCreateInfo {
    VkStructureType       sType;
    void*           pNext;
    VkFenceCreateFlags    flags;
} VkFenceCreateInfo;

typedef struct VkSemaphoreCreateInfo {
    VkStructureType           sType;
    void*               pNext;
    VkSemaphoreCreateFlags    flags;
} VkSemaphoreCreateInfo;

typedef struct VkEventCreateInfo {
    VkStructureType       sType;
    void*           pNext;
    VkEventCreateFlags    flags;
} VkEventCreateInfo;

typedef struct VkQueryPoolCreateInfo {
    VkStructureType                  sType;
    void*                      pNext;
    VkQueryPoolCreateFlags           flags;
    VkQueryType                      queryType;
    uint32_t                         queryCount;
    VkQueryPipelineStatisticFlags    pipelineStatistics;
} VkQueryPoolCreateInfo;

typedef struct VkBufferCreateInfo {
    VkStructureType        sType;
    void*            pNext;
    VkBufferCreateFlags    flags;
    VkDeviceSize           size;
    VkBufferUsageFlags     usage;
    VkSharingMode          sharingMode;
    uint32_t               queueFamilyIndexCount;
    uint32_t*        pQueueFamilyIndices;
} VkBufferCreateInfo;

typedef struct VkBufferViewCreateInfo {
    VkStructureType            sType;
    void*                pNext;
    VkBufferViewCreateFlags    flags;
    VkBuffer                   buffer;
    VkFormat                   format;
    VkDeviceSize               offset;
    VkDeviceSize               range;
} VkBufferViewCreateInfo;

typedef struct VkImageCreateInfo {
    VkStructureType          sType;
    void*              pNext;
    VkImageCreateFlags       flags;
    VkImageType              imageType;
    VkFormat                 format;
    VkExtent3D               extent;
    uint32_t                 mipLevels;
    uint32_t                 arrayLayers;
    VkSampleCountFlagBits    samples;
    VkImageTiling            tiling;
    VkImageUsageFlags        usage;
    VkSharingMode            sharingMode;
    uint32_t                 queueFamilyIndexCount;
    uint32_t*          pQueueFamilyIndices;
    VkImageLayout            initialLayout;
} VkImageCreateInfo;

typedef struct VkSubresourceLayout {
    VkDeviceSize    offset;
    VkDeviceSize    size;
    VkDeviceSize    rowPitch;
    VkDeviceSize    arrayPitch;
    VkDeviceSize    depthPitch;
} VkSubresourceLayout;

typedef struct VkComponentMapping {
    VkComponentSwizzle    r;
    VkComponentSwizzle    g;
    VkComponentSwizzle    b;
    VkComponentSwizzle    a;
} VkComponentMapping;

typedef struct VkImageSubresourceRange {
    VkImageAspectFlags    aspectMask;
    uint32_t              baseMipLevel;
    uint32_t              levelCount;
    uint32_t              baseArrayLayer;
    uint32_t              layerCount;
} VkImageSubresourceRange;

typedef struct VkImageViewCreateInfo {
    VkStructureType            sType;
    void*                pNext;
    VkImageViewCreateFlags     flags;
    VkImage                    image;
    VkImageViewType            viewType;
    VkFormat                   format;
    VkComponentMapping         components;
    VkImageSubresourceRange    subresourceRange;
} VkImageViewCreateInfo;

typedef struct VkShaderModuleCreateInfo {
    VkStructureType              sType;
    void*                  pNext;
    VkShaderModuleCreateFlags    flags;
    size_t                       codeSize;
    uint32_t*              pCode;
} VkShaderModuleCreateInfo;

typedef struct VkPipelineCacheCreateInfo {
    VkStructureType               sType;
    void*                   pNext;
    VkPipelineCacheCreateFlags    flags;
    size_t                        initialDataSize;
    void*                   pInitialData;
} VkPipelineCacheCreateInfo;

typedef struct VkSpecializationMapEntry {
    uint32_t    constantID;
    uint32_t    offset;
    size_t      size;
} VkSpecializationMapEntry;

typedef struct VkSpecializationInfo {
    uint32_t                           mapEntryCount;
    VkSpecializationMapEntry*    pMapEntries;
    size_t                             dataSize;
    void*                        pData;
} VkSpecializationInfo;

typedef struct VkPipelineShaderStageCreateInfo {
    VkStructureType                     sType;
    void*                         pNext;
    VkPipelineShaderStageCreateFlags    flags;
    VkShaderStageFlagBits               stage;
    VkShaderModule                      module;
    char*                         pName;
    VkSpecializationInfo*         pSpecializationInfo;
} VkPipelineShaderStageCreateInfo;

typedef struct VkVertexInputBindingDescription {
    uint32_t             binding;
    uint32_t             stride;
    VkVertexInputRate    inputRate;
} VkVertexInputBindingDescription;

typedef struct VkVertexInputAttributeDescription {
    uint32_t    location;
    uint32_t    binding;
    VkFormat    format;
    uint32_t    offset;
} VkVertexInputAttributeDescription;

typedef struct VkPipelineVertexInputStateCreateInfo {
    VkStructureType                             sType;
    void*                                 pNext;
    VkPipelineVertexInputStateCreateFlags       flags;
    uint32_t                                    vertexBindingDescriptionCount;
    VkVertexInputBindingDescription*      pVertexBindingDescriptions;
    uint32_t                                    vertexAttributeDescriptionCount;
    VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;
} VkPipelineVertexInputStateCreateInfo;

typedef struct VkPipelineInputAssemblyStateCreateInfo {
    VkStructureType                            sType;
    void*                                pNext;
    VkPipelineInputAssemblyStateCreateFlags    flags;
    VkPrimitiveTopology                        topology;
    VkBool32                                   primitiveRestartEnable;
} VkPipelineInputAssemblyStateCreateInfo;

typedef struct VkPipelineTessellationStateCreateInfo {
    VkStructureType                           sType;
    void*                               pNext;
    VkPipelineTessellationStateCreateFlags    flags;
    uint32_t                                  patchControlPoints;
} VkPipelineTessellationStateCreateInfo;

typedef struct VkViewport {
    float    x;
    float    y;
    float    width;
    float    height;
    float    minDepth;
    float    maxDepth;
} VkViewport;

typedef struct VkOffset2D {
    int32_t    x;
    int32_t    y;
} VkOffset2D;

typedef struct VkExtent2D {
    uint32_t    width;
    uint32_t    height;
} VkExtent2D;

typedef struct VkRect2D {
    VkOffset2D    offset;
    VkExtent2D    extent;
} VkRect2D;

typedef struct VkPipelineViewportStateCreateInfo {
    VkStructureType                       sType;
    void*                           pNext;
    VkPipelineViewportStateCreateFlags    flags;
    uint32_t                              viewportCount;
    VkViewport*                     pViewports;
    uint32_t                              scissorCount;
    VkRect2D*                       pScissors;
} VkPipelineViewportStateCreateInfo;

typedef struct VkPipelineRasterizationStateCreateInfo {
    VkStructureType                            sType;
    void*                                pNext;
    VkPipelineRasterizationStateCreateFlags    flags;
    VkBool32                                   depthClampEnable;
    VkBool32                                   rasterizerDiscardEnable;
    VkPolygonMode                              polygonMode;
    VkCullModeFlags                            cullMode;
    VkFrontFace                                frontFace;
    VkBool32                                   depthBiasEnable;
    float                                      depthBiasConstantFactor;
    float                                      depthBiasClamp;
    float                                      depthBiasSlopeFactor;
    float                                      lineWidth;
} VkPipelineRasterizationStateCreateInfo;

typedef struct VkPipelineMultisampleStateCreateInfo {
    VkStructureType                          sType;
    void*                              pNext;
    VkPipelineMultisampleStateCreateFlags    flags;
    VkSampleCountFlagBits                    rasterizationSamples;
    VkBool32                                 sampleShadingEnable;
    float                                    minSampleShading;
    VkSampleMask*                      pSampleMask;
    VkBool32                                 alphaToCoverageEnable;
    VkBool32                                 alphaToOneEnable;
} VkPipelineMultisampleStateCreateInfo;

typedef struct VkStencilOpState {
    VkStencilOp    failOp;
    VkStencilOp    passOp;
    VkStencilOp    depthFailOp;
    VkCompareOp    compareOp;
    uint32_t       compareMask;
    uint32_t       writeMask;
    uint32_t       reference;
} VkStencilOpState;

typedef struct VkPipelineDepthStencilStateCreateInfo {
    VkStructureType                           sType;
    void*                               pNext;
    VkPipelineDepthStencilStateCreateFlags    flags;
    VkBool32                                  depthTestEnable;
    VkBool32                                  depthWriteEnable;
    VkCompareOp                               depthCompareOp;
    VkBool32                                  depthBoundsTestEnable;
    VkBool32                                  stencilTestEnable;
    VkStencilOpState                          front;
    VkStencilOpState                          back;
    float                                     minDepthBounds;
    float                                     maxDepthBounds;
} VkPipelineDepthStencilStateCreateInfo;

typedef struct VkPipelineColorBlendAttachmentState {
    VkBool32                 blendEnable;
    VkBlendFactor            srcColorBlendFactor;
    VkBlendFactor            dstColorBlendFactor;
    VkBlendOp                colorBlendOp;
    VkBlendFactor            srcAlphaBlendFactor;
    VkBlendFactor            dstAlphaBlendFactor;
    VkBlendOp                alphaBlendOp;
    VkColorComponentFlags    colorWriteMask;
} VkPipelineColorBlendAttachmentState;

typedef struct VkPipelineColorBlendStateCreateInfo {
    VkStructureType                               sType;
    void*                                   pNext;
    VkPipelineColorBlendStateCreateFlags          flags;
    VkBool32                                      logicOpEnable;
    VkLogicOp                                     logicOp;
    uint32_t                                      attachmentCount;
    VkPipelineColorBlendAttachmentState*    pAttachments;
    float                                         blendConstants[4];
} VkPipelineColorBlendStateCreateInfo;

typedef struct VkPipelineDynamicStateCreateInfo {
    VkStructureType                      sType;
    void*                          pNext;
    VkPipelineDynamicStateCreateFlags    flags;
    uint32_t                             dynamicStateCount;
    VkDynamicState*                pDynamicStates;
} VkPipelineDynamicStateCreateInfo;

typedef struct VkGraphicsPipelineCreateInfo {
    VkStructureType                                  sType;
    void*                                      pNext;
    VkPipelineCreateFlags                            flags;
    uint32_t                                         stageCount;
    VkPipelineShaderStageCreateInfo*           pStages;
    VkPipelineVertexInputStateCreateInfo*      pVertexInputState;
    VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;
    VkPipelineTessellationStateCreateInfo*     pTessellationState;
    VkPipelineViewportStateCreateInfo*         pViewportState;
    VkPipelineRasterizationStateCreateInfo*    pRasterizationState;
    VkPipelineMultisampleStateCreateInfo*      pMultisampleState;
    VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;
    VkPipelineColorBlendStateCreateInfo*       pColorBlendState;
    VkPipelineDynamicStateCreateInfo*          pDynamicState;
    VkPipelineLayout                                 layout;
    VkRenderPass                                     renderPass;
    uint32_t                                         subpass;
    VkPipeline                                       basePipelineHandle;
    int32_t                                          basePipelineIndex;
} VkGraphicsPipelineCreateInfo;

typedef struct VkComputePipelineCreateInfo {
    VkStructureType                    sType;
    void*                        pNext;
    VkPipelineCreateFlags              flags;
    VkPipelineShaderStageCreateInfo    stage;
    VkPipelineLayout                   layout;
    VkPipeline                         basePipelineHandle;
    int32_t                            basePipelineIndex;
} VkComputePipelineCreateInfo;

typedef struct VkPushConstantRange {
    VkShaderStageFlags    stageFlags;
    uint32_t              offset;
    uint32_t              size;
} VkPushConstantRange;

typedef struct VkPipelineLayoutCreateInfo {
    VkStructureType                 sType;
    void*                     pNext;
    VkPipelineLayoutCreateFlags     flags;
    uint32_t                        setLayoutCount;
    VkDescriptorSetLayout*    pSetLayouts;
    uint32_t                        pushConstantRangeCount;
    VkPushConstantRange*      pPushConstantRanges;
} VkPipelineLayoutCreateInfo;

typedef struct VkSamplerCreateInfo {
    VkStructureType         sType;
    void*             pNext;
    VkSamplerCreateFlags    flags;
    VkFilter                magFilter;
    VkFilter                minFilter;
    VkSamplerMipmapMode     mipmapMode;
    VkSamplerAddressMode    addressModeU;
    VkSamplerAddressMode    addressModeV;
    VkSamplerAddressMode    addressModeW;
    float                   mipLodBias;
    VkBool32                anisotropyEnable;
    float                   maxAnisotropy;
    VkBool32                compareEnable;
    VkCompareOp             compareOp;
    float                   minLod;
    float                   maxLod;
    VkBorderColor           borderColor;
    VkBool32                unnormalizedCoordinates;
} VkSamplerCreateInfo;

typedef struct VkDescriptorSetLayoutBinding {
    uint32_t              binding;
    VkDescriptorType      descriptorType;
    uint32_t              descriptorCount;
    VkShaderStageFlags    stageFlags;
    VkSampler*      pImmutableSamplers;
} VkDescriptorSetLayoutBinding;

typedef struct VkDescriptorSetLayoutCreateInfo {
    VkStructureType                        sType;
    void*                            pNext;
    VkDescriptorSetLayoutCreateFlags       flags;
    uint32_t                               bindingCount;
    VkDescriptorSetLayoutBinding*    pBindings;
} VkDescriptorSetLayoutCreateInfo;

typedef struct VkDescriptorPoolSize {
    VkDescriptorType    type;
    uint32_t            descriptorCount;
} VkDescriptorPoolSize;

typedef struct VkDescriptorPoolCreateInfo {
    VkStructureType                sType;
    void*                    pNext;
    VkDescriptorPoolCreateFlags    flags;
    uint32_t                       maxSets;
    uint32_t                       poolSizeCount;
    VkDescriptorPoolSize*    pPoolSizes;
} VkDescriptorPoolCreateInfo;

typedef struct VkDescriptorSetAllocateInfo {
    VkStructureType                 sType;
    void*                     pNext;
    VkDescriptorPool                descriptorPool;
    uint32_t                        descriptorSetCount;
    VkDescriptorSetLayout*    pSetLayouts;
} VkDescriptorSetAllocateInfo;

typedef struct VkDescriptorImageInfo {
    VkSampler        sampler;
    VkImageView      imageView;
    VkImageLayout    imageLayout;
} VkDescriptorImageInfo;

typedef struct VkDescriptorBufferInfo {
    VkBuffer        buffer;
    VkDeviceSize    offset;
    VkDeviceSize    range;
} VkDescriptorBufferInfo;

typedef struct VkWriteDescriptorSet {
    VkStructureType                  sType;
    void*                      pNext;
    VkDescriptorSet                  dstSet;
    uint32_t                         dstBinding;
    uint32_t                         dstArrayElement;
    uint32_t                         descriptorCount;
    VkDescriptorType                 descriptorType;
    VkDescriptorImageInfo*     pImageInfo;
    VkDescriptorBufferInfo*    pBufferInfo;
    VkBufferView*              pTexelBufferView;
} VkWriteDescriptorSet;

typedef struct VkCopyDescriptorSet {
    VkStructureType    sType;
    void*        pNext;
    VkDescriptorSet    srcSet;
    uint32_t           srcBinding;
    uint32_t           srcArrayElement;
    VkDescriptorSet    dstSet;
    uint32_t           dstBinding;
    uint32_t           dstArrayElement;
    uint32_t           descriptorCount;
} VkCopyDescriptorSet;

typedef struct VkFramebufferCreateInfo {
    VkStructureType             sType;
    void*                 pNext;
    VkFramebufferCreateFlags    flags;
    VkRenderPass                renderPass;
    uint32_t                    attachmentCount;
    VkImageView*          pAttachments;
    uint32_t                    width;
    uint32_t                    height;
    uint32_t                    layers;
} VkFramebufferCreateInfo;

typedef struct VkAttachmentDescription {
    VkAttachmentDescriptionFlags    flags;
    VkFormat                        format;
    VkSampleCountFlagBits           samples;
    VkAttachmentLoadOp              loadOp;
    VkAttachmentStoreOp             storeOp;
    VkAttachmentLoadOp              stencilLoadOp;
    VkAttachmentStoreOp             stencilStoreOp;
    VkImageLayout                   initialLayout;
    VkImageLayout                   finalLayout;
} VkAttachmentDescription;

typedef struct VkAttachmentReference {
    uint32_t         attachment;
    VkImageLayout    layout;
} VkAttachmentReference;

typedef struct VkSubpassDescription {
    VkSubpassDescriptionFlags       flags;
    VkPipelineBindPoint             pipelineBindPoint;
    uint32_t                        inputAttachmentCount;
    VkAttachmentReference*    pInputAttachments;
    uint32_t                        colorAttachmentCount;
    VkAttachmentReference*    pColorAttachments;
    VkAttachmentReference*    pResolveAttachments;
    VkAttachmentReference*    pDepthStencilAttachment;
    uint32_t                        preserveAttachmentCount;
    uint32_t*                 pPreserveAttachments;
} VkSubpassDescription;

typedef struct VkSubpassDependency {
    uint32_t                srcSubpass;
    uint32_t                dstSubpass;
    VkPipelineStageFlags    srcStageMask;
    VkPipelineStageFlags    dstStageMask;
    VkAccessFlags           srcAccessMask;
    VkAccessFlags           dstAccessMask;
    VkDependencyFlags       dependencyFlags;
} VkSubpassDependency;

typedef struct VkRenderPassCreateInfo {
    VkStructureType                   sType;
    void*                       pNext;
    VkRenderPassCreateFlags           flags;
    uint32_t                          attachmentCount;
    VkAttachmentDescription*    pAttachments;
    uint32_t                          subpassCount;
    VkSubpassDescription*       pSubpasses;
    uint32_t                          dependencyCount;
    VkSubpassDependency*        pDependencies;
} VkRenderPassCreateInfo;

typedef struct VkCommandPoolCreateInfo {
    VkStructureType             sType;
    void*                 pNext;
    VkCommandPoolCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
} VkCommandPoolCreateInfo;

typedef struct VkCommandBufferAllocateInfo {
    VkStructureType         sType;
    void*             pNext;
    VkCommandPool           commandPool;
    VkCommandBufferLevel    level;
    uint32_t                commandBufferCount;
} VkCommandBufferAllocateInfo;

typedef struct VkCommandBufferInheritanceInfo {
    VkStructureType                  sType;
    void*                      pNext;
    VkRenderPass                     renderPass;
    uint32_t                         subpass;
    VkFramebuffer                    framebuffer;
    VkBool32                         occlusionQueryEnable;
    VkQueryControlFlags              queryFlags;
    VkQueryPipelineStatisticFlags    pipelineStatistics;
} VkCommandBufferInheritanceInfo;

typedef struct VkCommandBufferBeginInfo {
    VkStructureType                          sType;
    void*                              pNext;
    VkCommandBufferUsageFlags                flags;
    VkCommandBufferInheritanceInfo*    pInheritanceInfo;
} VkCommandBufferBeginInfo;

typedef struct VkBufferCopy {
    VkDeviceSize    srcOffset;
    VkDeviceSize    dstOffset;
    VkDeviceSize    size;
} VkBufferCopy;

typedef struct VkImageSubresourceLayers {
    VkImageAspectFlags    aspectMask;
    uint32_t              mipLevel;
    uint32_t              baseArrayLayer;
    uint32_t              layerCount;
} VkImageSubresourceLayers;

typedef struct VkImageCopy {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffset;
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffset;
    VkExtent3D                  extent;
} VkImageCopy;

typedef struct VkImageBlit {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffsets[2];
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffsets[2];
} VkImageBlit;

typedef struct VkBufferImageCopy {
    VkDeviceSize                bufferOffset;
    uint32_t                    bufferRowLength;
    uint32_t                    bufferImageHeight;
    VkImageSubresourceLayers    imageSubresource;
    VkOffset3D                  imageOffset;
    VkExtent3D                  imageExtent;
} VkBufferImageCopy;

typedef union VkClearColorValue {
    float       float32[4];
    int32_t     int32[4];
    uint32_t    uint32[4];
} VkClearColorValue;

typedef struct VkClearDepthStencilValue {
    float       depth;
    uint32_t    stencil;
} VkClearDepthStencilValue;

typedef union VkClearValue {
    VkClearColorValue           color;
    VkClearDepthStencilValue    depthStencil;
} VkClearValue;

typedef struct VkClearAttachment {
    VkImageAspectFlags    aspectMask;
    uint32_t              colorAttachment;
    VkClearValue          clearValue;
} VkClearAttachment;

typedef struct VkClearRect {
    VkRect2D    rect;
    uint32_t    baseArrayLayer;
    uint32_t    layerCount;
} VkClearRect;

typedef struct VkImageResolve {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffset;
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffset;
    VkExtent3D                  extent;
} VkImageResolve;

typedef struct VkMemoryBarrier {
    VkStructureType    sType;
    void*        pNext;
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
} VkMemoryBarrier;

typedef struct VkBufferMemoryBarrier {
    VkStructureType    sType;
    void*        pNext;
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
    uint32_t           srcQueueFamilyIndex;
    uint32_t           dstQueueFamilyIndex;
    VkBuffer           buffer;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} VkBufferMemoryBarrier;

typedef struct VkImageMemoryBarrier {
    VkStructureType            sType;
    void*                pNext;
    VkAccessFlags              srcAccessMask;
    VkAccessFlags              dstAccessMask;
    VkImageLayout              oldLayout;
    VkImageLayout              newLayout;
    uint32_t                   srcQueueFamilyIndex;
    uint32_t                   dstQueueFamilyIndex;
    VkImage                    image;
    VkImageSubresourceRange    subresourceRange;
} VkImageMemoryBarrier;

typedef struct VkRenderPassBeginInfo {
    VkStructureType        sType;
    void*            pNext;
    VkRenderPass           renderPass;
    VkFramebuffer          framebuffer;
    VkRect2D               renderArea;
    uint32_t               clearValueCount;
    VkClearValue*    pClearValues;
} VkRenderPassBeginInfo;

typedef struct VkDispatchIndirectCommand {
    uint32_t    x;
    uint32_t    y;
    uint32_t    z;
} VkDispatchIndirectCommand;

typedef struct VkDrawIndexedIndirectCommand {
    uint32_t    indexCount;
    uint32_t    instanceCount;
    uint32_t    firstIndex;
    int32_t     vertexOffset;
    uint32_t    firstInstance;
} VkDrawIndexedIndirectCommand;

typedef struct VkDrawIndirectCommand {
    uint32_t    vertexCount;
    uint32_t    instanceCount;
    uint32_t    firstVertex;
    uint32_t    firstInstance;
} VkDrawIndirectCommand;


typedef VkResult (VKAPI_PTR *PFN_vkCreateInstance)(const VkInstanceCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkInstance* pInstance);
typedef void (VKAPI_PTR *PFN_vkDestroyInstance)(VkInstance instance, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkEnumeratePhysicalDevices)(VkInstance instance, uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFeatures)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceQueueFamilyProperties)(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceMemoryProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties);
typedef PFN_vkVoidFunction (VKAPI_PTR *PFN_vkGetInstanceProcAddr)(VkInstance instance, char* pName);
typedef PFN_vkVoidFunction (VKAPI_PTR *PFN_vkGetDeviceProcAddr)(VkDevice device, char* pName);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDevice)(VkPhysicalDevice physicalDevice, VkDeviceCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDevice* pDevice);
typedef void (VKAPI_PTR *PFN_vkDestroyDevice)(VkDevice device, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateInstanceExtensionProperties)(const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateDeviceExtensionProperties)(VkPhysicalDevice physicalDevice, char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateInstanceLayerProperties)(uint32_t* pPropertyCount, VkLayerProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateDeviceLayerProperties)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkLayerProperties* pProperties);
typedef void (VKAPI_PTR *PFN_vkGetDeviceQueue)(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue);
typedef VkResult (VKAPI_PTR *PFN_vkQueueSubmit)(VkQueue queue, uint32_t submitCount, VkSubmitInfo* pSubmits, VkFence fence);
typedef VkResult (VKAPI_PTR *PFN_vkQueueWaitIdle)(VkQueue queue);
typedef VkResult (VKAPI_PTR *PFN_vkDeviceWaitIdle)(VkDevice device);
typedef VkResult (VKAPI_PTR *PFN_vkAllocateMemory)(VkDevice device, VkMemoryAllocateInfo* pAllocateInfo, VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory);
typedef void (VKAPI_PTR *PFN_vkFreeMemory)(VkDevice device, VkDeviceMemory memory, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkMapMemory)(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void** ppData);
typedef void (VKAPI_PTR *PFN_vkUnmapMemory)(VkDevice device, VkDeviceMemory memory);
typedef VkResult (VKAPI_PTR *PFN_vkFlushMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, VkMappedMemoryRange* pMemoryRanges);
typedef VkResult (VKAPI_PTR *PFN_vkInvalidateMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, VkMappedMemoryRange* pMemoryRanges);
typedef void (VKAPI_PTR *PFN_vkGetDeviceMemoryCommitment)(VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes);
typedef VkResult (VKAPI_PTR *PFN_vkBindBufferMemory)(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset);
typedef VkResult (VKAPI_PTR *PFN_vkBindImageMemory)(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset);
typedef void (VKAPI_PTR *PFN_vkGetBufferMemoryRequirements)(VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements)(VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetImageSparseMemoryRequirements)(VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceSparseImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkQueueBindSparse)(VkQueue queue, uint32_t bindInfoCount, VkBindSparseInfo* pBindInfo, VkFence fence);
typedef VkResult (VKAPI_PTR *PFN_vkCreateFence)(VkDevice device, VkFenceCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkFence* pFence);
typedef void (VKAPI_PTR *PFN_vkDestroyFence)(VkDevice device, VkFence fence, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkResetFences)(VkDevice device, uint32_t fenceCount, VkFence* pFences);
typedef VkResult (VKAPI_PTR *PFN_vkGetFenceStatus)(VkDevice device, VkFence fence);
typedef VkResult (VKAPI_PTR *PFN_vkWaitForFences)(VkDevice device, uint32_t fenceCount, VkFence* pFences, VkBool32 waitAll, uint64_t timeout);
typedef VkResult (VKAPI_PTR *PFN_vkCreateSemaphore)(VkDevice device, VkSemaphoreCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore);
typedef void (VKAPI_PTR *PFN_vkDestroySemaphore)(VkDevice device, VkSemaphore semaphore, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateEvent)(VkDevice device, VkEventCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkEvent* pEvent);
typedef void (VKAPI_PTR *PFN_vkDestroyEvent)(VkDevice device, VkEvent event, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetEventStatus)(VkDevice device, VkEvent event);
typedef VkResult (VKAPI_PTR *PFN_vkSetEvent)(VkDevice device, VkEvent event);
typedef VkResult (VKAPI_PTR *PFN_vkResetEvent)(VkDevice device, VkEvent event);
typedef VkResult (VKAPI_PTR *PFN_vkCreateQueryPool)(VkDevice device, VkQueryPoolCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool);
typedef void (VKAPI_PTR *PFN_vkDestroyQueryPool)(VkDevice device, VkQueryPool queryPool, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetQueryPoolResults)(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags);
typedef VkResult (VKAPI_PTR *PFN_vkCreateBuffer)(VkDevice device, VkBufferCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer);
typedef void (VKAPI_PTR *PFN_vkDestroyBuffer)(VkDevice device, VkBuffer buffer, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateBufferView)(VkDevice device, VkBufferViewCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkBufferView* pView);
typedef void (VKAPI_PTR *PFN_vkDestroyBufferView)(VkDevice device, VkBufferView bufferView, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateImage)(VkDevice device, VkImageCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkImage* pImage);
typedef void (VKAPI_PTR *PFN_vkDestroyImage)(VkDevice device, VkImage image, VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkGetImageSubresourceLayout)(VkDevice device, VkImage image, VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout);
typedef VkResult (VKAPI_PTR *PFN_vkCreateImageView)(VkDevice device, VkImageViewCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkImageView* pView);
typedef void (VKAPI_PTR *PFN_vkDestroyImageView)(VkDevice device, VkImageView imageView, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateShaderModule)(VkDevice device, VkShaderModuleCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule);
typedef void (VKAPI_PTR *PFN_vkDestroyShaderModule)(VkDevice device, VkShaderModule shaderModule, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreatePipelineCache)(VkDevice device, VkPipelineCacheCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache);
typedef void (VKAPI_PTR *PFN_vkDestroyPipelineCache)(VkDevice device, VkPipelineCache pipelineCache, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetPipelineCacheData)(VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData);
typedef VkResult (VKAPI_PTR *PFN_vkMergePipelineCaches)(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, VkPipelineCache* pSrcCaches);
typedef VkResult (VKAPI_PTR *PFN_vkCreateGraphicsPipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, VkGraphicsPipelineCreateInfo* pCreateInfos, VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
typedef VkResult (VKAPI_PTR *PFN_vkCreateComputePipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, VkComputePipelineCreateInfo* pCreateInfos, VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
typedef void (VKAPI_PTR *PFN_vkDestroyPipeline)(VkDevice device, VkPipeline pipeline, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreatePipelineLayout)(VkDevice device, VkPipelineLayoutCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout);
typedef void (VKAPI_PTR *PFN_vkDestroyPipelineLayout)(VkDevice device, VkPipelineLayout pipelineLayout, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateSampler)(VkDevice device, VkSamplerCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSampler* pSampler);
typedef void (VKAPI_PTR *PFN_vkDestroySampler)(VkDevice device, VkSampler sampler, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorSetLayout)(VkDevice device, VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout);
typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorSetLayout)(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorPool)(VkDevice device, VkDescriptorPoolCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool);
typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkResetDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags);
typedef VkResult (VKAPI_PTR *PFN_vkAllocateDescriptorSets)(VkDevice device, VkDescriptorSetAllocateInfo* pAllocateInfo, VkDescriptorSet* pDescriptorSets);
typedef VkResult (VKAPI_PTR *PFN_vkFreeDescriptorSets)(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, VkDescriptorSet* pDescriptorSets);
typedef void (VKAPI_PTR *PFN_vkUpdateDescriptorSets)(VkDevice device, uint32_t descriptorWriteCount, VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, VkCopyDescriptorSet* pDescriptorCopies);
typedef VkResult (VKAPI_PTR *PFN_vkCreateFramebuffer)(VkDevice device, VkFramebufferCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer);
typedef void (VKAPI_PTR *PFN_vkDestroyFramebuffer)(VkDevice device, VkFramebuffer framebuffer, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateRenderPass)(VkDevice device, VkRenderPassCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass);
typedef void (VKAPI_PTR *PFN_vkDestroyRenderPass)(VkDevice device, VkRenderPass renderPass, VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkGetRenderAreaGranularity)(VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity);
typedef VkResult (VKAPI_PTR *PFN_vkCreateCommandPool)(VkDevice device, VkCommandPoolCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool);
typedef void (VKAPI_PTR *PFN_vkDestroyCommandPool)(VkDevice device, VkCommandPool commandPool, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkResetCommandPool)(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags);
typedef VkResult (VKAPI_PTR *PFN_vkAllocateCommandBuffers)(VkDevice device, VkCommandBufferAllocateInfo* pAllocateInfo, VkCommandBuffer* pCommandBuffers);
typedef void (VKAPI_PTR *PFN_vkFreeCommandBuffers)(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, VkCommandBuffer* pCommandBuffers);
typedef VkResult (VKAPI_PTR *PFN_vkBeginCommandBuffer)(VkCommandBuffer commandBuffer, VkCommandBufferBeginInfo* pBeginInfo);
typedef VkResult (VKAPI_PTR *PFN_vkEndCommandBuffer)(VkCommandBuffer commandBuffer);
typedef VkResult (VKAPI_PTR *PFN_vkResetCommandBuffer)(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags);
typedef void (VKAPI_PTR *PFN_vkCmdBindPipeline)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline);
typedef void (VKAPI_PTR *PFN_vkCmdSetViewport)(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, VkViewport* pViewports);
typedef void (VKAPI_PTR *PFN_vkCmdSetScissor)(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, VkRect2D* pScissors);
typedef void (VKAPI_PTR *PFN_vkCmdSetLineWidth)(VkCommandBuffer commandBuffer, float lineWidth);
typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBias)(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor);
typedef void (VKAPI_PTR *PFN_vkCmdSetBlendConstants)(VkCommandBuffer commandBuffer, float blendConstants[4]);
typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBounds)(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds);
typedef void (VKAPI_PTR *PFN_vkCmdSetStencilCompareMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask);
typedef void (VKAPI_PTR *PFN_vkCmdSetStencilWriteMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask);
typedef void (VKAPI_PTR *PFN_vkCmdSetStencilReference)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference);
typedef void (VKAPI_PTR *PFN_vkCmdBindDescriptorSets)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, uint32_t* pDynamicOffsets);
typedef void (VKAPI_PTR *PFN_vkCmdBindIndexBuffer)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType);
typedef void (VKAPI_PTR *PFN_vkCmdBindVertexBuffers)(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, VkBuffer* pBuffers, VkDeviceSize* pOffsets);
typedef void (VKAPI_PTR *PFN_vkCmdDraw)(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexed)(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexedIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
typedef void (VKAPI_PTR *PFN_vkCmdDispatch)(VkCommandBuffer commandBuffer, uint32_t x, uint32_t y, uint32_t z);
typedef void (VKAPI_PTR *PFN_vkCmdDispatchIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset);
typedef void (VKAPI_PTR *PFN_vkCmdCopyBuffer)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, VkBufferCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdCopyImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdBlitImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageBlit* pRegions, VkFilter filter);
typedef void (VKAPI_PTR *PFN_vkCmdCopyBufferToImage)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkBufferImageCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdCopyImageToBuffer)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, VkBufferImageCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdUpdateBuffer)(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, void* pData);
typedef void (VKAPI_PTR *PFN_vkCmdFillBuffer)(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data);
typedef void (VKAPI_PTR *PFN_vkCmdClearColorImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, VkClearColorValue* pColor, uint32_t rangeCount, VkImageSubresourceRange* pRanges);
typedef void (VKAPI_PTR *PFN_vkCmdClearDepthStencilImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, VkImageSubresourceRange* pRanges);
typedef void (VKAPI_PTR *PFN_vkCmdClearAttachments)(VkCommandBuffer commandBuffer, uint32_t attachmentCount, VkClearAttachment* pAttachments, uint32_t rectCount, VkClearRect* pRects);
typedef void (VKAPI_PTR *PFN_vkCmdResolveImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageResolve* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdSetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
typedef void (VKAPI_PTR *PFN_vkCmdResetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
typedef void (VKAPI_PTR *PFN_vkCmdWaitEvents)(VkCommandBuffer commandBuffer, uint32_t eventCount, VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, VkImageMemoryBarrier* pImageMemoryBarriers);
typedef void (VKAPI_PTR *PFN_vkCmdPipelineBarrier)(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, VkImageMemoryBarrier* pImageMemoryBarriers);
typedef void (VKAPI_PTR *PFN_vkCmdBeginQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags);
typedef void (VKAPI_PTR *PFN_vkCmdEndQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query);
typedef void (VKAPI_PTR *PFN_vkCmdResetQueryPool)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);
typedef void (VKAPI_PTR *PFN_vkCmdWriteTimestamp)(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query);
typedef void (VKAPI_PTR *PFN_vkCmdCopyQueryPoolResults)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags);
typedef void (VKAPI_PTR *PFN_vkCmdPushConstants)(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, void* pValues);
typedef void (VKAPI_PTR *PFN_vkCmdBeginRenderPass)(VkCommandBuffer commandBuffer, VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents);
typedef void (VKAPI_PTR *PFN_vkCmdNextSubpass)(VkCommandBuffer commandBuffer, VkSubpassContents contents);
typedef void (VKAPI_PTR *PFN_vkCmdEndRenderPass)(VkCommandBuffer commandBuffer);
typedef void (VKAPI_PTR *PFN_vkCmdExecuteCommands)(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, VkCommandBuffer* pCommandBuffers);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateInstance(
    VkInstanceCreateInfo*                 pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkInstance*                                 pInstance);

VKAPI_ATTR void VKAPI_CALL vkDestroyInstance(
    VkInstance                                  instance,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkEnumeratePhysicalDevices(
    VkInstance                                  instance,
    uint32_t*                                   pPhysicalDeviceCount,
    VkPhysicalDevice*                           pPhysicalDevices);

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceFeatures(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceFeatures*                   pFeatures);

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkFormatProperties*                         pFormatProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkImageFormatProperties*                    pImageFormatProperties);

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceProperties*                 pProperties);

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pQueueFamilyPropertyCount,
    VkQueueFamilyProperties*                    pQueueFamilyProperties);

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceMemoryProperties*           pMemoryProperties);

VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL vkGetInstanceProcAddr(
    VkInstance                                  instance,
    char*                                 pName);

VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL vkGetDeviceProcAddr(
    VkDevice                                    device,
    char*                                 pName);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateDevice(
    VkPhysicalDevice                            physicalDevice,
    VkDeviceCreateInfo*                   pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkDevice*                                   pDevice);

VKAPI_ATTR void VKAPI_CALL vkDestroyDevice(
    VkDevice                                    device,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkEnumerateInstanceExtensionProperties(
    char*                                 pLayerName,
    uint32_t*                                   pPropertyCount,
    VkExtensionProperties*                      pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkEnumerateDeviceExtensionProperties(
    VkPhysicalDevice                            physicalDevice,
    char*                                 pLayerName,
    uint32_t*                                   pPropertyCount,
    VkExtensionProperties*                      pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkEnumerateInstanceLayerProperties(
    uint32_t*                                   pPropertyCount,
    VkLayerProperties*                          pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkLayerProperties*                          pProperties);

VKAPI_ATTR void VKAPI_CALL vkGetDeviceQueue(
    VkDevice                                    device,
    uint32_t                                    queueFamilyIndex,
    uint32_t                                    queueIndex,
    VkQueue*                                    pQueue);

VKAPI_ATTR VkResult VKAPI_CALL vkQueueSubmit(
    VkQueue                                     queue,
    uint32_t                                    submitCount,
    VkSubmitInfo*                         pSubmits,
    VkFence                                     fence);

VKAPI_ATTR VkResult VKAPI_CALL vkQueueWaitIdle(
    VkQueue                                     queue);

VKAPI_ATTR VkResult VKAPI_CALL vkDeviceWaitIdle(
    VkDevice                                    device);

VKAPI_ATTR VkResult VKAPI_CALL vkAllocateMemory(
    VkDevice                                    device,
    VkMemoryAllocateInfo*                 pAllocateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkDeviceMemory*                             pMemory);

VKAPI_ATTR void VKAPI_CALL vkFreeMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkMapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkMemoryMapFlags                            flags,
    void**                                      ppData);

VKAPI_ATTR void VKAPI_CALL vkUnmapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory);

VKAPI_ATTR VkResult VKAPI_CALL vkFlushMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    VkMappedMemoryRange*                  pMemoryRanges);

VKAPI_ATTR VkResult VKAPI_CALL vkInvalidateMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    VkMappedMemoryRange*                  pMemoryRanges);

VKAPI_ATTR void VKAPI_CALL vkGetDeviceMemoryCommitment(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize*                               pCommittedMemoryInBytes);

VKAPI_ATTR VkResult VKAPI_CALL vkBindBufferMemory(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset);

VKAPI_ATTR VkResult VKAPI_CALL vkBindImageMemory(
    VkDevice                                    device,
    VkImage                                     image,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset);

VKAPI_ATTR void VKAPI_CALL vkGetBufferMemoryRequirements(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkMemoryRequirements*                       pMemoryRequirements);

VKAPI_ATTR void VKAPI_CALL vkGetImageMemoryRequirements(
    VkDevice                                    device,
    VkImage                                     image,
    VkMemoryRequirements*                       pMemoryRequirements);

VKAPI_ATTR void VKAPI_CALL vkGetImageSparseMemoryRequirements(
    VkDevice                                    device,
    VkImage                                     image,
    uint32_t*                                   pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements*            pSparseMemoryRequirements);

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkSampleCountFlagBits                       samples,
    VkImageUsageFlags                           usage,
    VkImageTiling                               tiling,
    uint32_t*                                   pPropertyCount,
    VkSparseImageFormatProperties*              pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkQueueBindSparse(
    VkQueue                                     queue,
    uint32_t                                    bindInfoCount,
    VkBindSparseInfo*                     pBindInfo,
    VkFence                                     fence);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateFence(
    VkDevice                                    device,
    VkFenceCreateInfo*                    pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkFence*                                    pFence);

VKAPI_ATTR void VKAPI_CALL vkDestroyFence(
    VkDevice                                    device,
    VkFence                                     fence,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkResetFences(
    VkDevice                                    device,
    uint32_t                                    fenceCount,
    VkFence*                              pFences);

VKAPI_ATTR VkResult VKAPI_CALL vkGetFenceStatus(
    VkDevice                                    device,
    VkFence                                     fence);

VKAPI_ATTR VkResult VKAPI_CALL vkWaitForFences(
    VkDevice                                    device,
    uint32_t                                    fenceCount,
    VkFence*                              pFences,
    VkBool32                                    waitAll,
    uint64_t                                    timeout);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateSemaphore(
    VkDevice                                    device,
    VkSemaphoreCreateInfo*                pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSemaphore*                                pSemaphore);

VKAPI_ATTR void VKAPI_CALL vkDestroySemaphore(
    VkDevice                                    device,
    VkSemaphore                                 semaphore,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateEvent(
    VkDevice                                    device,
    VkEventCreateInfo*                    pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkEvent*                                    pEvent);

VKAPI_ATTR void VKAPI_CALL vkDestroyEvent(
    VkDevice                                    device,
    VkEvent                                     event,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkGetEventStatus(
    VkDevice                                    device,
    VkEvent                                     event);

VKAPI_ATTR VkResult VKAPI_CALL vkSetEvent(
    VkDevice                                    device,
    VkEvent                                     event);

VKAPI_ATTR VkResult VKAPI_CALL vkResetEvent(
    VkDevice                                    device,
    VkEvent                                     event);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateQueryPool(
    VkDevice                                    device,
    VkQueryPoolCreateInfo*                pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkQueryPool*                                pQueryPool);

VKAPI_ATTR void VKAPI_CALL vkDestroyQueryPool(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkGetQueryPoolResults(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    size_t                                      dataSize,
    void*                                       pData,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateBuffer(
    VkDevice                                    device,
    VkBufferCreateInfo*                   pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkBuffer*                                   pBuffer);

VKAPI_ATTR void VKAPI_CALL vkDestroyBuffer(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateBufferView(
    VkDevice                                    device,
    VkBufferViewCreateInfo*               pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkBufferView*                               pView);

VKAPI_ATTR void VKAPI_CALL vkDestroyBufferView(
    VkDevice                                    device,
    VkBufferView                                bufferView,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateImage(
    VkDevice                                    device,
    VkImageCreateInfo*                    pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkImage*                                    pImage);

VKAPI_ATTR void VKAPI_CALL vkDestroyImage(
    VkDevice                                    device,
    VkImage                                     image,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR void VKAPI_CALL vkGetImageSubresourceLayout(
    VkDevice                                    device,
    VkImage                                     image,
    VkImageSubresource*                   pSubresource,
    VkSubresourceLayout*                        pLayout);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateImageView(
    VkDevice                                    device,
    VkImageViewCreateInfo*                pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkImageView*                                pView);

VKAPI_ATTR void VKAPI_CALL vkDestroyImageView(
    VkDevice                                    device,
    VkImageView                                 imageView,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateShaderModule(
    VkDevice                                    device,
    VkShaderModuleCreateInfo*             pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkShaderModule*                             pShaderModule);

VKAPI_ATTR void VKAPI_CALL vkDestroyShaderModule(
    VkDevice                                    device,
    VkShaderModule                              shaderModule,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreatePipelineCache(
    VkDevice                                    device,
    VkPipelineCacheCreateInfo*            pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkPipelineCache*                            pPipelineCache);

VKAPI_ATTR void VKAPI_CALL vkDestroyPipelineCache(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPipelineCacheData(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    size_t*                                     pDataSize,
    void*                                       pData);

VKAPI_ATTR VkResult VKAPI_CALL vkMergePipelineCaches(
    VkDevice                                    device,
    VkPipelineCache                             dstCache,
    uint32_t                                    srcCacheCount,
    VkPipelineCache*                      pSrcCaches);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateGraphicsPipelines(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    VkGraphicsPipelineCreateInfo*         pCreateInfos,
    VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateComputePipelines(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    VkComputePipelineCreateInfo*          pCreateInfos,
    VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines);

VKAPI_ATTR void VKAPI_CALL vkDestroyPipeline(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreatePipelineLayout(
    VkDevice                                    device,
    VkPipelineLayoutCreateInfo*           pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkPipelineLayout*                           pPipelineLayout);

VKAPI_ATTR void VKAPI_CALL vkDestroyPipelineLayout(
    VkDevice                                    device,
    VkPipelineLayout                            pipelineLayout,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateSampler(
    VkDevice                                    device,
    VkSamplerCreateInfo*                  pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSampler*                                  pSampler);

VKAPI_ATTR void VKAPI_CALL vkDestroySampler(
    VkDevice                                    device,
    VkSampler                                   sampler,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateDescriptorSetLayout(
    VkDevice                                    device,
    VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkDescriptorSetLayout*                      pSetLayout);

VKAPI_ATTR void VKAPI_CALL vkDestroyDescriptorSetLayout(
    VkDevice                                    device,
    VkDescriptorSetLayout                       descriptorSetLayout,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPoolCreateInfo*           pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkDescriptorPool*                           pDescriptorPool);

VKAPI_ATTR void VKAPI_CALL vkDestroyDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkResetDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    VkDescriptorPoolResetFlags                  flags);

VKAPI_ATTR VkResult VKAPI_CALL vkAllocateDescriptorSets(
    VkDevice                                    device,
    VkDescriptorSetAllocateInfo*          pAllocateInfo,
    VkDescriptorSet*                            pDescriptorSets);

VKAPI_ATTR VkResult VKAPI_CALL vkFreeDescriptorSets(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    uint32_t                                    descriptorSetCount,
    VkDescriptorSet*                      pDescriptorSets);

VKAPI_ATTR void VKAPI_CALL vkUpdateDescriptorSets(
    VkDevice                                    device,
    uint32_t                                    descriptorWriteCount,
    VkWriteDescriptorSet*                 pDescriptorWrites,
    uint32_t                                    descriptorCopyCount,
    VkCopyDescriptorSet*                  pDescriptorCopies);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateFramebuffer(
    VkDevice                                    device,
    VkFramebufferCreateInfo*              pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkFramebuffer*                              pFramebuffer);

VKAPI_ATTR void VKAPI_CALL vkDestroyFramebuffer(
    VkDevice                                    device,
    VkFramebuffer                               framebuffer,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateRenderPass(
    VkDevice                                    device,
    VkRenderPassCreateInfo*               pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkRenderPass*                               pRenderPass);

VKAPI_ATTR void VKAPI_CALL vkDestroyRenderPass(
    VkDevice                                    device,
    VkRenderPass                                renderPass,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR void VKAPI_CALL vkGetRenderAreaGranularity(
    VkDevice                                    device,
    VkRenderPass                                renderPass,
    VkExtent2D*                                 pGranularity);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateCommandPool(
    VkDevice                                    device,
    VkCommandPoolCreateInfo*              pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkCommandPool*                              pCommandPool);

VKAPI_ATTR void VKAPI_CALL vkDestroyCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkResetCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    VkCommandPoolResetFlags                     flags);

VKAPI_ATTR VkResult VKAPI_CALL vkAllocateCommandBuffers(
    VkDevice                                    device,
    VkCommandBufferAllocateInfo*          pAllocateInfo,
    VkCommandBuffer*                            pCommandBuffers);

VKAPI_ATTR void VKAPI_CALL vkFreeCommandBuffers(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    uint32_t                                    commandBufferCount,
    VkCommandBuffer*                      pCommandBuffers);

VKAPI_ATTR VkResult VKAPI_CALL vkBeginCommandBuffer(
    VkCommandBuffer                             commandBuffer,
    VkCommandBufferBeginInfo*             pBeginInfo);

VKAPI_ATTR VkResult VKAPI_CALL vkEndCommandBuffer(
    VkCommandBuffer                             commandBuffer);

VKAPI_ATTR VkResult VKAPI_CALL vkResetCommandBuffer(
    VkCommandBuffer                             commandBuffer,
    VkCommandBufferResetFlags                   flags);

VKAPI_ATTR void VKAPI_CALL vkCmdBindPipeline(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipeline                                  pipeline);

VKAPI_ATTR void VKAPI_CALL vkCmdSetViewport(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    VkViewport*                           pViewports);

VKAPI_ATTR void VKAPI_CALL vkCmdSetScissor(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstScissor,
    uint32_t                                    scissorCount,
    VkRect2D*                             pScissors);

VKAPI_ATTR void VKAPI_CALL vkCmdSetLineWidth(
    VkCommandBuffer                             commandBuffer,
    float                                       lineWidth);

VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthBias(
    VkCommandBuffer                             commandBuffer,
    float                                       depthBiasConstantFactor,
    float                                       depthBiasClamp,
    float                                       depthBiasSlopeFactor);

VKAPI_ATTR void VKAPI_CALL vkCmdSetBlendConstants(
    VkCommandBuffer                             commandBuffer,
    float                                 blendConstants[4]);

VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthBounds(
    VkCommandBuffer                             commandBuffer,
    float                                       minDepthBounds,
    float                                       maxDepthBounds);

VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilCompareMask(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    compareMask);

VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilWriteMask(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    writeMask);

VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilReference(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    reference);

VKAPI_ATTR void VKAPI_CALL vkCmdBindDescriptorSets(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    firstSet,
    uint32_t                                    descriptorSetCount,
    VkDescriptorSet*                      pDescriptorSets,
    uint32_t                                    dynamicOffsetCount,
    uint32_t*                             pDynamicOffsets);

VKAPI_ATTR void VKAPI_CALL vkCmdBindIndexBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkIndexType                                 indexType);

VKAPI_ATTR void VKAPI_CALL vkCmdBindVertexBuffers(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    VkBuffer*                             pBuffers,
    VkDeviceSize*                         pOffsets);

VKAPI_ATTR void VKAPI_CALL vkCmdDraw(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance);

VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexed(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance);

VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride);

VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexedIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride);

VKAPI_ATTR void VKAPI_CALL vkCmdDispatch(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    x,
    uint32_t                                    y,
    uint32_t                                    z);

VKAPI_ATTR void VKAPI_CALL vkCmdDispatchIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset);

VKAPI_ATTR void VKAPI_CALL vkCmdCopyBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    srcBuffer,
    VkBuffer                                    dstBuffer,
    uint32_t                                    regionCount,
    VkBufferCopy*                         pRegions);

VKAPI_ATTR void VKAPI_CALL vkCmdCopyImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    VkImageCopy*                          pRegions);

VKAPI_ATTR void VKAPI_CALL vkCmdBlitImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    VkImageBlit*                          pRegions,
    VkFilter                                    filter);

VKAPI_ATTR void VKAPI_CALL vkCmdCopyBufferToImage(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    srcBuffer,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    VkBufferImageCopy*                    pRegions);

VKAPI_ATTR void VKAPI_CALL vkCmdCopyImageToBuffer(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkBuffer                                    dstBuffer,
    uint32_t                                    regionCount,
    VkBufferImageCopy*                    pRegions);

VKAPI_ATTR void VKAPI_CALL vkCmdUpdateBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                dataSize,
    void*                                 pData);

VKAPI_ATTR void VKAPI_CALL vkCmdFillBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                size,
    uint32_t                                    data);

VKAPI_ATTR void VKAPI_CALL vkCmdClearColorImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     image,
    VkImageLayout                               imageLayout,
    VkClearColorValue*                    pColor,
    uint32_t                                    rangeCount,
    VkImageSubresourceRange*              pRanges);

VKAPI_ATTR void VKAPI_CALL vkCmdClearDepthStencilImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     image,
    VkImageLayout                               imageLayout,
    VkClearDepthStencilValue*             pDepthStencil,
    uint32_t                                    rangeCount,
    VkImageSubresourceRange*              pRanges);

VKAPI_ATTR void VKAPI_CALL vkCmdClearAttachments(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    attachmentCount,
    VkClearAttachment*                    pAttachments,
    uint32_t                                    rectCount,
    VkClearRect*                          pRects);

VKAPI_ATTR void VKAPI_CALL vkCmdResolveImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    VkImageResolve*                       pRegions);

VKAPI_ATTR void VKAPI_CALL vkCmdSetEvent(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags                        stageMask);

VKAPI_ATTR void VKAPI_CALL vkCmdResetEvent(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags                        stageMask);

VKAPI_ATTR void VKAPI_CALL vkCmdWaitEvents(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    eventCount,
    VkEvent*                              pEvents,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    uint32_t                                    memoryBarrierCount,
    VkMemoryBarrier*                      pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    VkBufferMemoryBarrier*                pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    VkImageMemoryBarrier*                 pImageMemoryBarriers);

VKAPI_ATTR void VKAPI_CALL vkCmdPipelineBarrier(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    VkDependencyFlags                           dependencyFlags,
    uint32_t                                    memoryBarrierCount,
    VkMemoryBarrier*                      pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    VkBufferMemoryBarrier*                pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    VkImageMemoryBarrier*                 pImageMemoryBarriers);

VKAPI_ATTR void VKAPI_CALL vkCmdBeginQuery(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query,
    VkQueryControlFlags                         flags);

VKAPI_ATTR void VKAPI_CALL vkCmdEndQuery(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query);

VKAPI_ATTR void VKAPI_CALL vkCmdResetQueryPool(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount);

VKAPI_ATTR void VKAPI_CALL vkCmdWriteTimestamp(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    VkQueryPool                                 queryPool,
    uint32_t                                    query);

VKAPI_ATTR void VKAPI_CALL vkCmdCopyQueryPoolResults(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags);

VKAPI_ATTR void VKAPI_CALL vkCmdPushConstants(
    VkCommandBuffer                             commandBuffer,
    VkPipelineLayout                            layout,
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size,
    void*                                 pValues);

VKAPI_ATTR void VKAPI_CALL vkCmdBeginRenderPass(
    VkCommandBuffer                             commandBuffer,
    VkRenderPassBeginInfo*                pRenderPassBegin,
    VkSubpassContents                           contents);

VKAPI_ATTR void VKAPI_CALL vkCmdNextSubpass(
    VkCommandBuffer                             commandBuffer,
    VkSubpassContents                           contents);

VKAPI_ATTR void VKAPI_CALL vkCmdEndRenderPass(
    VkCommandBuffer                             commandBuffer);

VKAPI_ATTR void VKAPI_CALL vkCmdExecuteCommands(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    commandBufferCount,
    VkCommandBuffer*                      pCommandBuffers);
#endif

#define VK_KHR_surface 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSurfaceKHR)

#define VK_KHR_SURFACE_SPEC_VERSION       25
#define VK_KHR_SURFACE_EXTENSION_NAME     "VK_KHR_surface"
#define VK_COLORSPACE_SRGB_NONLINEAR_KHR  VK_COLOR_SPACE_SRGB_NONLINEAR_KHR


typedef enum VkColorSpaceKHR {
    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
    VK_COLOR_SPACE_BEGIN_RANGE_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    VK_COLOR_SPACE_END_RANGE_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    VK_COLOR_SPACE_RANGE_SIZE_KHR = (VK_COLOR_SPACE_SRGB_NONLINEAR_KHR - VK_COLOR_SPACE_SRGB_NONLINEAR_KHR + 1),
    VK_COLOR_SPACE_MAX_ENUM_KHR = 0x7FFFFFFF
} VkColorSpaceKHR;

typedef enum VkPresentModeKHR {
    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
    VK_PRESENT_MODE_MAILBOX_KHR = 1,
    VK_PRESENT_MODE_FIFO_KHR = 2,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
    VK_PRESENT_MODE_BEGIN_RANGE_KHR = VK_PRESENT_MODE_IMMEDIATE_KHR,
    VK_PRESENT_MODE_END_RANGE_KHR = VK_PRESENT_MODE_FIFO_RELAXED_KHR,
    VK_PRESENT_MODE_RANGE_SIZE_KHR = (VK_PRESENT_MODE_FIFO_RELAXED_KHR - VK_PRESENT_MODE_IMMEDIATE_KHR + 1),
    VK_PRESENT_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
} VkPresentModeKHR;


typedef enum VkSurfaceTransformFlagBitsKHR {
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x00000001,
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x00000002,
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x00000004,
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x00000008,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x00000010,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x00000020,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x00000100,
    VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkSurfaceTransformFlagBitsKHR;
typedef VkFlags VkSurfaceTransformFlagsKHR;

typedef enum VkCompositeAlphaFlagBitsKHR {
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0x00000002,
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x00000004,
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0x00000008,
    VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkCompositeAlphaFlagBitsKHR;
typedef VkFlags VkCompositeAlphaFlagsKHR;

typedef struct VkSurfaceCapabilitiesKHR {
    uint32_t                         minImageCount;
    uint32_t                         maxImageCount;
    VkExtent2D                       currentExtent;
    VkExtent2D                       minImageExtent;
    VkExtent2D                       maxImageExtent;
    uint32_t                         maxImageArrayLayers;
    VkSurfaceTransformFlagsKHR       supportedTransforms;
    VkSurfaceTransformFlagBitsKHR    currentTransform;
    VkCompositeAlphaFlagsKHR         supportedCompositeAlpha;
    VkImageUsageFlags                supportedUsageFlags;
} VkSurfaceCapabilitiesKHR;

typedef struct VkSurfaceFormatKHR {
    VkFormat           format;
    VkColorSpaceKHR    colorSpace;
} VkSurfaceFormatKHR;


typedef void (VKAPI_PTR *PFN_vkDestroySurfaceKHR)(VkInstance instance, VkSurfaceKHR surface, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR void VKAPI_CALL vkDestroySurfaceKHR(
    VkInstance                                  instance,
    VkSurfaceKHR                                surface,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    VkSurfaceKHR                                surface,
    VkBool32*                                   pSupported);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    VkSurfaceCapabilitiesKHR*                   pSurfaceCapabilities);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceFormatsKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pSurfaceFormatCount,
    VkSurfaceFormatKHR*                         pSurfaceFormats);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfacePresentModesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pPresentModeCount,
    VkPresentModeKHR*                           pPresentModes);
#endif

#define VK_KHR_swapchain 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSwapchainKHR)

#define VK_KHR_SWAPCHAIN_SPEC_VERSION     68
#define VK_KHR_SWAPCHAIN_EXTENSION_NAME   "VK_KHR_swapchain"

typedef VkFlags VkSwapchainCreateFlagsKHR;

typedef struct VkSwapchainCreateInfoKHR {
    VkStructureType                  sType;
    void*                      pNext;
    VkSwapchainCreateFlagsKHR        flags;
    VkSurfaceKHR                     surface;
    uint32_t                         minImageCount;
    VkFormat                         imageFormat;
    VkColorSpaceKHR                  imageColorSpace;
    VkExtent2D                       imageExtent;
    uint32_t                         imageArrayLayers;
    VkImageUsageFlags                imageUsage;
    VkSharingMode                    imageSharingMode;
    uint32_t                         queueFamilyIndexCount;
    uint32_t*                  pQueueFamilyIndices;
    VkSurfaceTransformFlagBitsKHR    preTransform;
    VkCompositeAlphaFlagBitsKHR      compositeAlpha;
    VkPresentModeKHR                 presentMode;
    VkBool32                         clipped;
    VkSwapchainKHR                   oldSwapchain;
} VkSwapchainCreateInfoKHR;

typedef struct VkPresentInfoKHR {
    VkStructureType          sType;
    void*              pNext;
    uint32_t                 waitSemaphoreCount;
    VkSemaphore*       pWaitSemaphores;
    uint32_t                 swapchainCount;
    VkSwapchainKHR*    pSwapchains;
    uint32_t*          pImageIndices;
    VkResult*                pResults;
} VkPresentInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateSwapchainKHR)(VkDevice device, VkSwapchainCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain);
typedef void (VKAPI_PTR *PFN_vkDestroySwapchainKHR)(VkDevice device, VkSwapchainKHR swapchain, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetSwapchainImagesKHR)(VkDevice device, VkSwapchainKHR swapchain, uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages);
typedef VkResult (VKAPI_PTR *PFN_vkAcquireNextImageKHR)(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex);
typedef VkResult (VKAPI_PTR *PFN_vkQueuePresentKHR)(VkQueue queue, VkPresentInfoKHR* pPresentInfo);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateSwapchainKHR(
    VkDevice                                    device,
    VkSwapchainCreateInfoKHR*             pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSwapchainKHR*                             pSwapchain);

VKAPI_ATTR void VKAPI_CALL vkDestroySwapchainKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkGetSwapchainImagesKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint32_t*                                   pSwapchainImageCount,
    VkImage*                                    pSwapchainImages);

VKAPI_ATTR VkResult VKAPI_CALL vkAcquireNextImageKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint64_t                                    timeout,
    VkSemaphore                                 semaphore,
    VkFence                                     fence,
    uint32_t*                                   pImageIndex);

VKAPI_ATTR VkResult VKAPI_CALL vkQueuePresentKHR(
    VkQueue                                     queue,
    VkPresentInfoKHR*                     pPresentInfo);
#endif

#define VK_KHR_display 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayKHR)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayModeKHR)

#define VK_KHR_DISPLAY_SPEC_VERSION       21
#define VK_KHR_DISPLAY_EXTENSION_NAME     "VK_KHR_display"


typedef enum VkDisplayPlaneAlphaFlagBitsKHR {
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x00000002,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x00000004,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008,
    VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkDisplayPlaneAlphaFlagBitsKHR;
typedef VkFlags VkDisplayPlaneAlphaFlagsKHR;
typedef VkFlags VkDisplayModeCreateFlagsKHR;
typedef VkFlags VkDisplaySurfaceCreateFlagsKHR;

typedef struct VkDisplayPropertiesKHR {
    VkDisplayKHR                  display;
    char*                   displayName;
    VkExtent2D                    physicalDimensions;
    VkExtent2D                    physicalResolution;
    VkSurfaceTransformFlagsKHR    supportedTransforms;
    VkBool32                      planeReorderPossible;
    VkBool32                      persistentContent;
} VkDisplayPropertiesKHR;

typedef struct VkDisplayModeParametersKHR {
    VkExtent2D    visibleRegion;
    uint32_t      refreshRate;
} VkDisplayModeParametersKHR;

typedef struct VkDisplayModePropertiesKHR {
    VkDisplayModeKHR              displayMode;
    VkDisplayModeParametersKHR    parameters;
} VkDisplayModePropertiesKHR;

typedef struct VkDisplayModeCreateInfoKHR {
    VkStructureType                sType;
    void*                    pNext;
    VkDisplayModeCreateFlagsKHR    flags;
    VkDisplayModeParametersKHR     parameters;
} VkDisplayModeCreateInfoKHR;

typedef struct VkDisplayPlaneCapabilitiesKHR {
    VkDisplayPlaneAlphaFlagsKHR    supportedAlpha;
    VkOffset2D                     minSrcPosition;
    VkOffset2D                     maxSrcPosition;
    VkExtent2D                     minSrcExtent;
    VkExtent2D                     maxSrcExtent;
    VkOffset2D                     minDstPosition;
    VkOffset2D                     maxDstPosition;
    VkExtent2D                     minDstExtent;
    VkExtent2D                     maxDstExtent;
} VkDisplayPlaneCapabilitiesKHR;

typedef struct VkDisplayPlanePropertiesKHR {
    VkDisplayKHR    currentDisplay;
    uint32_t        currentStackIndex;
} VkDisplayPlanePropertiesKHR;

typedef struct VkDisplaySurfaceCreateInfoKHR {
    VkStructureType                   sType;
    void*                       pNext;
    VkDisplaySurfaceCreateFlagsKHR    flags;
    VkDisplayModeKHR                  displayMode;
    uint32_t                          planeIndex;
    uint32_t                          planeStackIndex;
    VkSurfaceTransformFlagBitsKHR     transform;
    float                             globalAlpha;
    VkDisplayPlaneAlphaFlagBitsKHR    alphaMode;
    VkExtent2D                        imageExtent;
} VkDisplaySurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPropertiesKHR* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayPlaneSupportedDisplaysKHR)(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t* pDisplayCount, VkDisplayKHR* pDisplays);
typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayModePropertiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModePropertiesKHR* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDisplayModeKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, VkDisplayModeCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode);
typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayPlaneCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDisplayPlaneSurfaceKHR)(VkInstance instance, VkDisplaySurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceDisplayPropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayPropertiesKHR*                     pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayPlanePropertiesKHR*                pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayPlaneSupportedDisplaysKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    planeIndex,
    uint32_t*                                   pDisplayCount,
    VkDisplayKHR*                               pDisplays);

VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayModePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    uint32_t*                                   pPropertyCount,
    VkDisplayModePropertiesKHR*                 pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateDisplayModeKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    VkDisplayModeCreateInfoKHR*           pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkDisplayModeKHR*                           pMode);

VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayPlaneCapabilitiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayModeKHR                            mode,
    uint32_t                                    planeIndex,
    VkDisplayPlaneCapabilitiesKHR*              pCapabilities);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateDisplayPlaneSurfaceKHR(
    VkInstance                                  instance,
    VkDisplaySurfaceCreateInfoKHR*        pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
#endif

#define VK_KHR_display_swapchain 1
#define VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION 9
#define VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME "VK_KHR_display_swapchain"

typedef struct VkDisplayPresentInfoKHR {
    VkStructureType    sType;
    void*        pNext;
    VkRect2D           srcRect;
    VkRect2D           dstRect;
    VkBool32           persistent;
} VkDisplayPresentInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateSharedSwapchainsKHR)(VkDevice device, uint32_t swapchainCount, VkSwapchainCreateInfoKHR* pCreateInfos, VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateSharedSwapchainsKHR(
    VkDevice                                    device,
    uint32_t                                    swapchainCount,
    VkSwapchainCreateInfoKHR*             pCreateInfos,
    VkAllocationCallbacks*                pAllocator,
    VkSwapchainKHR*                             pSwapchains);
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR
#define VK_KHR_xlib_surface 1
#include <X11/Xlib.h>

#define VK_KHR_XLIB_SURFACE_SPEC_VERSION  6
#define VK_KHR_XLIB_SURFACE_EXTENSION_NAME "VK_KHR_xlib_surface"

typedef VkFlags VkXlibSurfaceCreateFlagsKHR;

typedef struct VkXlibSurfaceCreateInfoKHR {
    VkStructureType                sType;
    void*                    pNext;
    VkXlibSurfaceCreateFlagsKHR    flags;
    Display*                       dpy;
    Window                         window;
} VkXlibSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateXlibSurfaceKHR)(VkInstance instance, VkXlibSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display* dpy, VisualID visualID);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateXlibSurfaceKHR(
    VkInstance                                  instance,
    VkXlibSurfaceCreateInfoKHR*           pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceXlibPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    Display*                                    dpy,
    VisualID                                    visualID);
#endif
#endif /* VK_USE_PLATFORM_XLIB_KHR */

#ifdef VK_USE_PLATFORM_XCB_KHR
#define VK_KHR_xcb_surface 1
#include <xcb/xcb.h>

#define VK_KHR_XCB_SURFACE_SPEC_VERSION   6
#define VK_KHR_XCB_SURFACE_EXTENSION_NAME "VK_KHR_xcb_surface"

typedef VkFlags VkXcbSurfaceCreateFlagsKHR;

typedef struct VkXcbSurfaceCreateInfoKHR {
    VkStructureType               sType;
    void*                   pNext;
    VkXcbSurfaceCreateFlagsKHR    flags;
    xcb_connection_t*             connection;
    xcb_window_t                  window;
} VkXcbSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateXcbSurfaceKHR)(VkInstance instance, VkXcbSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateXcbSurfaceKHR(
    VkInstance                                  instance,
    VkXcbSurfaceCreateInfoKHR*            pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceXcbPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    xcb_connection_t*                           connection,
    xcb_visualid_t                              visual_id);
#endif
#endif /* VK_USE_PLATFORM_XCB_KHR */

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
#define VK_KHR_wayland_surface 1
#include <wayland-client.h>

#define VK_KHR_WAYLAND_SURFACE_SPEC_VERSION 5
#define VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME "VK_KHR_wayland_surface"

typedef VkFlags VkWaylandSurfaceCreateFlagsKHR;

typedef struct VkWaylandSurfaceCreateInfoKHR {
    VkStructureType                   sType;
    void*                       pNext;
    VkWaylandSurfaceCreateFlagsKHR    flags;
    struct wl_display*                display;
    struct wl_surface*                surface;
} VkWaylandSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateWaylandSurfaceKHR)(VkInstance instance, VkWaylandSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display* display);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateWaylandSurfaceKHR(
    VkInstance                                  instance,
    VkWaylandSurfaceCreateInfoKHR*        pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceWaylandPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    struct wl_display*                          display);
#endif
#endif /* VK_USE_PLATFORM_WAYLAND_KHR */

#ifdef VK_USE_PLATFORM_MIR_KHR
#define VK_KHR_mir_surface 1
#include <mir_toolkit/client_types.h>

#define VK_KHR_MIR_SURFACE_SPEC_VERSION   4
#define VK_KHR_MIR_SURFACE_EXTENSION_NAME "VK_KHR_mir_surface"

typedef VkFlags VkMirSurfaceCreateFlagsKHR;

typedef struct VkMirSurfaceCreateInfoKHR {
    VkStructureType               sType;
    void*                   pNext;
    VkMirSurfaceCreateFlagsKHR    flags;
    MirConnection*                connection;
    MirSurface*                   mirSurface;
} VkMirSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateMirSurfaceKHR)(VkInstance instance, VkMirSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceMirPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, MirConnection* connection);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateMirSurfaceKHR(
    VkInstance                                  instance,
    VkMirSurfaceCreateInfoKHR*            pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceMirPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    MirConnection*                              connection);
#endif
#endif /* VK_USE_PLATFORM_MIR_KHR */

#ifdef VK_USE_PLATFORM_ANDROID_KHR
#define VK_KHR_android_surface 1
#include <android/native_window.h>

#define VK_KHR_ANDROID_SURFACE_SPEC_VERSION 6
#define VK_KHR_ANDROID_SURFACE_EXTENSION_NAME "VK_KHR_android_surface"

typedef VkFlags VkAndroidSurfaceCreateFlagsKHR;

typedef struct VkAndroidSurfaceCreateInfoKHR {
    VkStructureType                   sType;
    void*                       pNext;
    VkAndroidSurfaceCreateFlagsKHR    flags;
    ANativeWindow*                    window;
} VkAndroidSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateAndroidSurfaceKHR)(VkInstance instance, VkAndroidSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateAndroidSurfaceKHR(
    VkInstance                                  instance,
    VkAndroidSurfaceCreateInfoKHR*        pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
#endif
#endif /* VK_USE_PLATFORM_ANDROID_KHR */

#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_KHR_win32_surface 1
#include <windows.h>

#define VK_KHR_WIN32_SURFACE_SPEC_VERSION 5
#define VK_KHR_WIN32_SURFACE_EXTENSION_NAME "VK_KHR_win32_surface"

typedef VkFlags VkWin32SurfaceCreateFlagsKHR;

typedef struct VkWin32SurfaceCreateInfoKHR {
    VkStructureType                 sType;
    void*                     pNext;
    VkWin32SurfaceCreateFlagsKHR    flags;
    HINSTANCE                       hinstance;
    HWND                            hwnd;
} VkWin32SurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateWin32SurfaceKHR)(VkInstance instance, VkWin32SurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateWin32SurfaceKHR(
    VkInstance                                  instance,
    VkWin32SurfaceCreateInfoKHR*          pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceWin32PresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex);
#endif
#endif /* VK_USE_PLATFORM_WIN32_KHR */

#define VK_KHR_sampler_mirror_clamp_to_edge 1
#define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION 1
#define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME "VK_KHR_sampler_mirror_clamp_to_edge"


#define VK_EXT_debug_report 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDebugReportCallbackEXT)

#define VK_EXT_DEBUG_REPORT_SPEC_VERSION  3
#define VK_EXT_DEBUG_REPORT_EXTENSION_NAME "VK_EXT_debug_report"
#define VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT


typedef enum VkDebugReportObjectTypeEXT {
    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = 28,
    VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT = (VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT - VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT + 1),
    VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugReportObjectTypeEXT;

typedef enum VkDebugReportErrorEXT {
    VK_DEBUG_REPORT_ERROR_NONE_EXT = 0,
    VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT = 1,
    VK_DEBUG_REPORT_ERROR_BEGIN_RANGE_EXT = VK_DEBUG_REPORT_ERROR_NONE_EXT,
    VK_DEBUG_REPORT_ERROR_END_RANGE_EXT = VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT,
    VK_DEBUG_REPORT_ERROR_RANGE_SIZE_EXT = (VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT - VK_DEBUG_REPORT_ERROR_NONE_EXT + 1),
    VK_DEBUG_REPORT_ERROR_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugReportErrorEXT;


typedef enum VkDebugReportFlagBitsEXT {
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0x00000001,
    VK_DEBUG_REPORT_WARNING_BIT_EXT = 0x00000002,
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004,
    VK_DEBUG_REPORT_ERROR_BIT_EXT = 0x00000008,
    VK_DEBUG_REPORT_DEBUG_BIT_EXT = 0x00000010,
    VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugReportFlagBitsEXT;
typedef VkFlags VkDebugReportFlagsEXT;

typedef VkBool32 (VKAPI_PTR *PFN_vkDebugReportCallbackEXT)(
    VkDebugReportFlagsEXT                       flags,
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    char*                                 pLayerPrefix,
    char*                                 pMessage,
    void*                                       pUserData);


typedef struct VkDebugReportCallbackCreateInfoEXT {
    VkStructureType                 sType;
    void*                     pNext;
    VkDebugReportFlagsEXT           flags;
    PFN_vkDebugReportCallbackEXT    pfnCallback;
    void*                           pUserData;
} VkDebugReportCallbackCreateInfoEXT;


typedef VkResult (VKAPI_PTR *PFN_vkCreateDebugReportCallbackEXT)(VkInstance instance, VkDebugReportCallbackCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDebugReportCallbackEXT* pCallback);
typedef void (VKAPI_PTR *PFN_vkDestroyDebugReportCallbackEXT)(VkInstance instance, VkDebugReportCallbackEXT callback, VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkDebugReportMessageEXT)(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, char* pLayerPrefix, char* pMessage);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateDebugReportCallbackEXT(
    VkInstance                                  instance,
    VkDebugReportCallbackCreateInfoEXT*   pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkDebugReportCallbackEXT*                   pCallback);

VKAPI_ATTR void VKAPI_CALL vkDestroyDebugReportCallbackEXT(
    VkInstance                                  instance,
    VkDebugReportCallbackEXT                    callback,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR void VKAPI_CALL vkDebugReportMessageEXT(
    VkInstance                                  instance,
    VkDebugReportFlagsEXT                       flags,
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    char*                                 pLayerPrefix,
    char*                                 pMessage);
#endif

#define VK_NV_glsl_shader 1
#define VK_NV_GLSL_SHADER_SPEC_VERSION    1
#define VK_NV_GLSL_SHADER_EXTENSION_NAME  "VK_NV_glsl_shader"


#define VK_IMG_filter_cubic 1
#define VK_IMG_FILTER_CUBIC_SPEC_VERSION  1
#define VK_IMG_FILTER_CUBIC_EXTENSION_NAME "VK_IMG_filter_cubic"


#define VK_AMD_rasterization_order 1
#define VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION 1
#define VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME "VK_AMD_rasterization_order"


typedef enum VkRasterizationOrderAMD {
    VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
    VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
    VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD = VK_RASTERIZATION_ORDER_STRICT_AMD,
    VK_RASTERIZATION_ORDER_END_RANGE_AMD = VK_RASTERIZATION_ORDER_RELAXED_AMD,
    VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD = (VK_RASTERIZATION_ORDER_RELAXED_AMD - VK_RASTERIZATION_ORDER_STRICT_AMD + 1),
    VK_RASTERIZATION_ORDER_MAX_ENUM_AMD = 0x7FFFFFFF
} VkRasterizationOrderAMD;

typedef struct VkPipelineRasterizationStateRasterizationOrderAMD {
    VkStructureType            sType;
    void*                pNext;
    VkRasterizationOrderAMD    rasterizationOrder;
} VkPipelineRasterizationStateRasterizationOrderAMD;



#define VK_AMD_shader_trinary_minmax 1
#define VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION 1
#define VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME "VK_AMD_shader_trinary_minmax"


#define VK_AMD_shader_explicit_vertex_parameter 1
#define VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION 1
#define VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME "VK_AMD_shader_explicit_vertex_parameter"


#define VK_EXT_debug_marker 1
#define VK_EXT_DEBUG_MARKER_SPEC_VERSION  3
#define VK_EXT_DEBUG_MARKER_EXTENSION_NAME "VK_EXT_debug_marker"

typedef struct VkDebugMarkerObjectNameInfoEXT {
    VkStructureType               sType;
    void*                   pNext;
    VkDebugReportObjectTypeEXT    objectType;
    uint64_t                      object;
    char*                   pObjectName;
} VkDebugMarkerObjectNameInfoEXT;

typedef struct VkDebugMarkerObjectTagInfoEXT {
    VkStructureType               sType;
    void*                   pNext;
    VkDebugReportObjectTypeEXT    objectType;
    uint64_t                      object;
    uint64_t                      tagName;
    size_t                        tagSize;
    void*                   pTag;
} VkDebugMarkerObjectTagInfoEXT;

typedef struct VkDebugMarkerMarkerInfoEXT {
    VkStructureType    sType;
    void*        pNext;
    char*        pMarkerName;
    float              color[4];
} VkDebugMarkerMarkerInfoEXT;


typedef VkResult (VKAPI_PTR *PFN_vkDebugMarkerSetObjectTagEXT)(VkDevice device, VkDebugMarkerObjectTagInfoEXT* pTagInfo);
typedef VkResult (VKAPI_PTR *PFN_vkDebugMarkerSetObjectNameEXT)(VkDevice device, VkDebugMarkerObjectNameInfoEXT* pNameInfo);
typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerBeginEXT)(VkCommandBuffer commandBuffer, VkDebugMarkerMarkerInfoEXT* pMarkerInfo);
typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerEndEXT)(VkCommandBuffer commandBuffer);
typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerInsertEXT)(VkCommandBuffer commandBuffer, VkDebugMarkerMarkerInfoEXT* pMarkerInfo);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkDebugMarkerSetObjectTagEXT(
    VkDevice                                    device,
    VkDebugMarkerObjectTagInfoEXT*              pTagInfo);

VKAPI_ATTR VkResult VKAPI_CALL vkDebugMarkerSetObjectNameEXT(
    VkDevice                                    device,
    VkDebugMarkerObjectNameInfoEXT*             pNameInfo);

VKAPI_ATTR void VKAPI_CALL vkCmdDebugMarkerBeginEXT(
    VkCommandBuffer                             commandBuffer,
    VkDebugMarkerMarkerInfoEXT*                 pMarkerInfo);

VKAPI_ATTR void VKAPI_CALL vkCmdDebugMarkerEndEXT(
    VkCommandBuffer                             commandBuffer);

VKAPI_ATTR void VKAPI_CALL vkCmdDebugMarkerInsertEXT(
    VkCommandBuffer                             commandBuffer,
    VkDebugMarkerMarkerInfoEXT*                 pMarkerInfo);
#endif

#define VK_AMD_gcn_shader 1
#define VK_AMD_GCN_SHADER_SPEC_VERSION    1
#define VK_AMD_GCN_SHADER_EXTENSION_NAME  "VK_AMD_gcn_shader"


#define VK_NV_dedicated_allocation 1
#define VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION 1
#define VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME "VK_NV_dedicated_allocation"

typedef struct VkDedicatedAllocationImageCreateInfoNV {
    VkStructureType    sType;
    void*        pNext;
    VkBool32           dedicatedAllocation;
} VkDedicatedAllocationImageCreateInfoNV;

typedef struct VkDedicatedAllocationBufferCreateInfoNV {
    VkStructureType    sType;
    void*        pNext;
    VkBool32           dedicatedAllocation;
} VkDedicatedAllocationBufferCreateInfoNV;

typedef struct VkDedicatedAllocationMemoryAllocateInfoNV {
    VkStructureType    sType;
    void*        pNext;
    VkImage            image;
    VkBuffer           buffer;
} VkDedicatedAllocationMemoryAllocateInfoNV;



#define VK_AMD_draw_indirect_count 1
#define VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION 1
#define VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME "VK_AMD_draw_indirect_count"

typedef void (VKAPI_PTR *PFN_vkCmdDrawIndirectCountAMD)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexedIndirectCountAMD)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndirectCountAMD(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride);

VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexedIndirectCountAMD(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride);
#endif

#define VK_AMD_negative_viewport_height 1
#define VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION 1
#define VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME "VK_AMD_negative_viewport_height"


#define VK_AMD_gpu_shader_half_float 1
#define VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION 1
#define VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME "VK_AMD_gpu_shader_half_float"


#define VK_AMD_shader_ballot 1
#define VK_AMD_SHADER_BALLOT_SPEC_VERSION 1
#define VK_AMD_SHADER_BALLOT_EXTENSION_NAME "VK_AMD_shader_ballot"


#define VK_IMG_format_pvrtc 1
#define VK_IMG_FORMAT_PVRTC_SPEC_VERSION  1
#define VK_IMG_FORMAT_PVRTC_EXTENSION_NAME "VK_IMG_format_pvrtc"


#define VK_NV_external_memory_capabilities 1
#define VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION 1
#define VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME "VK_NV_external_memory_capabilities"


typedef enum VkExternalMemoryHandleTypeFlagBitsNV {
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 0x00000001,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x00000002,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 0x00000004,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 0x00000008,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
} VkExternalMemoryHandleTypeFlagBitsNV;
typedef VkFlags VkExternalMemoryHandleTypeFlagsNV;

typedef enum VkExternalMemoryFeatureFlagBitsNV {
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 0x00000001,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 0x00000002,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 0x00000004,
    VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
} VkExternalMemoryFeatureFlagBitsNV;
typedef VkFlags VkExternalMemoryFeatureFlagsNV;

typedef struct VkExternalImageFormatPropertiesNV {
    VkImageFormatProperties              imageFormatProperties;
    VkExternalMemoryFeatureFlagsNV       externalMemoryFeatures;
    VkExternalMemoryHandleTypeFlagsNV    exportFromImportedHandleTypes;
    VkExternalMemoryHandleTypeFlagsNV    compatibleHandleTypes;
} VkExternalImageFormatPropertiesNV;


typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkExternalMemoryHandleTypeFlagsNV           externalHandleType,
    VkExternalImageFormatPropertiesNV*          pExternalImageFormatProperties);
#endif

#define VK_NV_external_memory 1
#define VK_NV_EXTERNAL_MEMORY_SPEC_VERSION 1
#define VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME "VK_NV_external_memory"

typedef struct VkExternalMemoryImageCreateInfoNV {
    VkStructureType                      sType;
    void*                          pNext;
    VkExternalMemoryHandleTypeFlagsNV    handleTypes;
} VkExternalMemoryImageCreateInfoNV;

typedef struct VkExportMemoryAllocateInfoNV {
    VkStructureType                      sType;
    void*                          pNext;
    VkExternalMemoryHandleTypeFlagsNV    handleTypes;
} VkExportMemoryAllocateInfoNV;



#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_NV_external_memory_win32 1
#define VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION 1
#define VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME "VK_NV_external_memory_win32"

typedef struct VkImportMemoryWin32HandleInfoNV {
    VkStructureType                      sType;
    void*                          pNext;
    VkExternalMemoryHandleTypeFlagsNV    handleType;
    HANDLE                               handle;
} VkImportMemoryWin32HandleInfoNV;

typedef struct VkExportMemoryWin32HandleInfoNV {
    VkStructureType               sType;
    void*                   pNext;
    SECURITY_ATTRIBUTES*    pAttributes;
    DWORD                         dwAccess;
} VkExportMemoryWin32HandleInfoNV;


typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandleNV)(VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryWin32HandleNV(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkExternalMemoryHandleTypeFlagsNV           handleType,
    HANDLE*                                     pHandle);
#endif
#endif /* VK_USE_PLATFORM_WIN32_KHR */

#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_NV_win32_keyed_mutex 1
#define VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION 1
#define VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME "VK_NV_win32_keyed_mutex"

typedef struct VkWin32KeyedMutexAcquireReleaseInfoNV {
    VkStructureType          sType;
    void*              pNext;
    uint32_t                 acquireCount;
    VkDeviceMemory*    pAcquireSyncs;
    uint64_t*          pAcquireKeys;
    uint32_t*          pAcquireTimeoutMilliseconds;
    uint32_t                 releaseCount;
    VkDeviceMemory*    pReleaseSyncs;
    uint64_t*          pReleaseKeys;
} VkWin32KeyedMutexAcquireReleaseInfoNV;


#endif /* VK_USE_PLATFORM_WIN32_KHR */

#define VK_EXT_validation_flags 1
#define VK_EXT_VALIDATION_FLAGS_SPEC_VERSION 1
#define VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME "VK_EXT_validation_flags"


typedef enum VkValidationCheckEXT {
    VK_VALIDATION_CHECK_ALL_EXT = 0,
    VK_VALIDATION_CHECK_BEGIN_RANGE_EXT = VK_VALIDATION_CHECK_ALL_EXT,
    VK_VALIDATION_CHECK_END_RANGE_EXT = VK_VALIDATION_CHECK_ALL_EXT,
    VK_VALIDATION_CHECK_RANGE_SIZE_EXT = (VK_VALIDATION_CHECK_ALL_EXT - VK_VALIDATION_CHECK_ALL_EXT + 1),
    VK_VALIDATION_CHECK_MAX_ENUM_EXT = 0x7FFFFFFF
} VkValidationCheckEXT;

typedef struct VkValidationFlagsEXT {
    VkStructureType          sType;
    void*              pNext;
    uint32_t                 disabledValidationCheckCount;
    VkValidationCheckEXT*    pDisabledValidationChecks;
} VkValidationFlagsEXT;



#ifdef __cplusplus
}
#endif

#endif


// ---------------
// DECLARE EXCEPTION FUNCTION
// ---------------
static PyObject *VulkanError;

    static PyObject *VkTimeout;

    static PyObject *VkErrorInitializationFailed;

    static PyObject *VkEventSet;

    static PyObject *VkErrorFragmentedPool;

    static PyObject *VkEventReset;

    static PyObject *VkErrorIncompatibleDriver;

    static PyObject *VkErrorOutOfDeviceMemory;

    static PyObject *VkIncomplete;

    static PyObject *VkErrorExtensionNotPresent;

    static PyObject *VkErrorMemoryMapFailed;

    static PyObject *VkErrorDeviceLost;

    static PyObject *VkErrorFormatNotSupported;

    static PyObject *VkNotReady;

    static PyObject *VkErrorLayerNotPresent;

    static PyObject *VkErrorFeatureNotPresent;

    static PyObject *VkErrorTooManyObjects;

    static PyObject *VkErrorOutOfHostMemory;


int raise(int value) {
    switch(value) {
        
            case 2: PyErr_SetString(VkTimeout, "");
                return 1;
        
            case -3: PyErr_SetString(VkErrorInitializationFailed, "");
                return 1;
        
            case 3: PyErr_SetString(VkEventSet, "");
                return 1;
        
            case -12: PyErr_SetString(VkErrorFragmentedPool, "");
                return 1;
        
            case 4: PyErr_SetString(VkEventReset, "");
                return 1;
        
            case -9: PyErr_SetString(VkErrorIncompatibleDriver, "");
                return 1;
        
            case -2: PyErr_SetString(VkErrorOutOfDeviceMemory, "");
                return 1;
        
            case 5: PyErr_SetString(VkIncomplete, "");
                return 1;
        
            case -7: PyErr_SetString(VkErrorExtensionNotPresent, "");
                return 1;
        
            case -5: PyErr_SetString(VkErrorMemoryMapFailed, "");
                return 1;
        
            case -4: PyErr_SetString(VkErrorDeviceLost, "");
                return 1;
        
            case -11: PyErr_SetString(VkErrorFormatNotSupported, "");
                return 1;
        
            case 1: PyErr_SetString(VkNotReady, "");
                return 1;
        
            case -6: PyErr_SetString(VkErrorLayerNotPresent, "");
                return 1;
        
            case -8: PyErr_SetString(VkErrorFeatureNotPresent, "");
                return 1;
        
            case -10: PyErr_SetString(VkErrorTooManyObjects, "");
                return 1;
        
            case -1: PyErr_SetString(VkErrorOutOfHostMemory, "");
                return 1;
        
       }
    return 0;
}


// ---------------
// DECLARE FUNCTIONS PROTOTYPE
// ---------------

    
    
        
        static PFN_vkCreateInstance vkCreateInstance;
    
    


    
    
        
        static PFN_vkDestroyInstance vkDestroyInstance;
    
    


    
    
        
        static PFN_vkEnumeratePhysicalDevices vkEnumeratePhysicalDevices;
    
    


    
    
        
        static PFN_vkGetPhysicalDeviceProperties vkGetPhysicalDeviceProperties;
    
    


    
    
        
        static PFN_vkGetPhysicalDeviceQueueFamilyProperties vkGetPhysicalDeviceQueueFamilyProperties;
    
    


    
    
        
        static PFN_vkGetPhysicalDeviceMemoryProperties vkGetPhysicalDeviceMemoryProperties;
    
    


    
    
        
        static PFN_vkGetPhysicalDeviceFeatures vkGetPhysicalDeviceFeatures;
    
    


    
    
        
        static PFN_vkGetPhysicalDeviceFormatProperties vkGetPhysicalDeviceFormatProperties;
    
    


    
    
        
        static PFN_vkGetPhysicalDeviceImageFormatProperties vkGetPhysicalDeviceImageFormatProperties;
    
    


    
    
        
        static PFN_vkCreateDevice vkCreateDevice;
    
    


    
    
        
        static PFN_vkDestroyDevice vkDestroyDevice;
    
    


    
    
        
        static PFN_vkEnumerateInstanceLayerProperties vkEnumerateInstanceLayerProperties;
    
    


    
    
        
        static PFN_vkEnumerateInstanceExtensionProperties vkEnumerateInstanceExtensionProperties;
    
    


    
    
        
        static PFN_vkEnumerateDeviceLayerProperties vkEnumerateDeviceLayerProperties;
    
    


    
    
        
        static PFN_vkEnumerateDeviceExtensionProperties vkEnumerateDeviceExtensionProperties;
    
    


    
    
        
        static PFN_vkGetDeviceQueue vkGetDeviceQueue;
    
    


    
    
        
        static PFN_vkQueueSubmit vkQueueSubmit;
    
    


    
    
        
        static PFN_vkQueueWaitIdle vkQueueWaitIdle;
    
    


    
    
        
        static PFN_vkDeviceWaitIdle vkDeviceWaitIdle;
    
    


    
    
        
        static PFN_vkAllocateMemory vkAllocateMemory;
    
    


    
    
        
        static PFN_vkFreeMemory vkFreeMemory;
    
    


    
    
        
        static PFN_vkUnmapMemory vkUnmapMemory;
    
    


    
    
        
        static PFN_vkFlushMappedMemoryRanges vkFlushMappedMemoryRanges;
    
    


    
    
        
        static PFN_vkInvalidateMappedMemoryRanges vkInvalidateMappedMemoryRanges;
    
    


    
    
        
        static PFN_vkGetDeviceMemoryCommitment vkGetDeviceMemoryCommitment;
    
    


    
    
        
        static PFN_vkGetBufferMemoryRequirements vkGetBufferMemoryRequirements;
    
    


    
    
        
        static PFN_vkBindBufferMemory vkBindBufferMemory;
    
    


    
    
        
        static PFN_vkGetImageMemoryRequirements vkGetImageMemoryRequirements;
    
    


    
    
        
        static PFN_vkBindImageMemory vkBindImageMemory;
    
    


    
    
        
        static PFN_vkGetImageSparseMemoryRequirements vkGetImageSparseMemoryRequirements;
    
    


    
    
        
        static PFN_vkGetPhysicalDeviceSparseImageFormatProperties vkGetPhysicalDeviceSparseImageFormatProperties;
    
    


    
    
        
        static PFN_vkQueueBindSparse vkQueueBindSparse;
    
    


    
    
        
        static PFN_vkCreateFence vkCreateFence;
    
    


    
    
        
        static PFN_vkDestroyFence vkDestroyFence;
    
    


    
    
        
        static PFN_vkResetFences vkResetFences;
    
    


    
    
        
        static PFN_vkGetFenceStatus vkGetFenceStatus;
    
    


    
    
        
        static PFN_vkWaitForFences vkWaitForFences;
    
    


    
    
        
        static PFN_vkCreateSemaphore vkCreateSemaphore;
    
    


    
    
        
        static PFN_vkDestroySemaphore vkDestroySemaphore;
    
    


    
    
        
        static PFN_vkCreateEvent vkCreateEvent;
    
    


    
    
        
        static PFN_vkDestroyEvent vkDestroyEvent;
    
    


    
    
        
        static PFN_vkGetEventStatus vkGetEventStatus;
    
    


    
    
        
        static PFN_vkSetEvent vkSetEvent;
    
    


    
    
        
        static PFN_vkResetEvent vkResetEvent;
    
    


    
    
        
        static PFN_vkCreateQueryPool vkCreateQueryPool;
    
    


    
    
        
        static PFN_vkDestroyQueryPool vkDestroyQueryPool;
    
    


    
    
        
        static PFN_vkGetQueryPoolResults vkGetQueryPoolResults;
    
    


    
    
        
        static PFN_vkCreateBuffer vkCreateBuffer;
    
    


    
    
        
        static PFN_vkDestroyBuffer vkDestroyBuffer;
    
    


    
    
        
        static PFN_vkCreateBufferView vkCreateBufferView;
    
    


    
    
        
        static PFN_vkDestroyBufferView vkDestroyBufferView;
    
    


    
    
        
        static PFN_vkCreateImage vkCreateImage;
    
    


    
    
        
        static PFN_vkDestroyImage vkDestroyImage;
    
    


    
    
        
        static PFN_vkGetImageSubresourceLayout vkGetImageSubresourceLayout;
    
    


    
    
        
        static PFN_vkCreateImageView vkCreateImageView;
    
    


    
    
        
        static PFN_vkDestroyImageView vkDestroyImageView;
    
    


    
    
        
        static PFN_vkCreateShaderModule vkCreateShaderModule;
    
    


    
    
        
        static PFN_vkDestroyShaderModule vkDestroyShaderModule;
    
    


    
    
        
        static PFN_vkCreatePipelineCache vkCreatePipelineCache;
    
    


    
    
        
        static PFN_vkDestroyPipelineCache vkDestroyPipelineCache;
    
    


    
    
        
        static PFN_vkMergePipelineCaches vkMergePipelineCaches;
    
    


    
    
        
        static PFN_vkCreateGraphicsPipelines vkCreateGraphicsPipelines;
    
    


    
    
        
        static PFN_vkCreateComputePipelines vkCreateComputePipelines;
    
    


    
    
        
        static PFN_vkDestroyPipeline vkDestroyPipeline;
    
    


    
    
        
        static PFN_vkCreatePipelineLayout vkCreatePipelineLayout;
    
    


    
    
        
        static PFN_vkDestroyPipelineLayout vkDestroyPipelineLayout;
    
    


    
    
        
        static PFN_vkCreateSampler vkCreateSampler;
    
    


    
    
        
        static PFN_vkDestroySampler vkDestroySampler;
    
    


    
    
        
        static PFN_vkCreateDescriptorSetLayout vkCreateDescriptorSetLayout;
    
    


    
    
        
        static PFN_vkDestroyDescriptorSetLayout vkDestroyDescriptorSetLayout;
    
    


    
    
        
        static PFN_vkCreateDescriptorPool vkCreateDescriptorPool;
    
    


    
    
        
        static PFN_vkDestroyDescriptorPool vkDestroyDescriptorPool;
    
    


    
    
        
        static PFN_vkResetDescriptorPool vkResetDescriptorPool;
    
    


    
    
        
        static PFN_vkAllocateDescriptorSets vkAllocateDescriptorSets;
    
    


    
    
        
        static PFN_vkFreeDescriptorSets vkFreeDescriptorSets;
    
    


    
    
        
        static PFN_vkUpdateDescriptorSets vkUpdateDescriptorSets;
    
    


    
    
        
        static PFN_vkCreateFramebuffer vkCreateFramebuffer;
    
    


    
    
        
        static PFN_vkDestroyFramebuffer vkDestroyFramebuffer;
    
    


    
    
        
        static PFN_vkCreateRenderPass vkCreateRenderPass;
    
    


    
    
        
        static PFN_vkDestroyRenderPass vkDestroyRenderPass;
    
    


    
    
        
        static PFN_vkGetRenderAreaGranularity vkGetRenderAreaGranularity;
    
    


    
    
        
        static PFN_vkCreateCommandPool vkCreateCommandPool;
    
    


    
    
        
        static PFN_vkDestroyCommandPool vkDestroyCommandPool;
    
    


    
    
        
        static PFN_vkResetCommandPool vkResetCommandPool;
    
    


    
    
        
        static PFN_vkAllocateCommandBuffers vkAllocateCommandBuffers;
    
    


    
    
        
        static PFN_vkFreeCommandBuffers vkFreeCommandBuffers;
    
    


    
    
        
        static PFN_vkBeginCommandBuffer vkBeginCommandBuffer;
    
    


    
    
        
        static PFN_vkEndCommandBuffer vkEndCommandBuffer;
    
    


    
    
        
        static PFN_vkResetCommandBuffer vkResetCommandBuffer;
    
    


    
    
        
        static PFN_vkCmdBindPipeline vkCmdBindPipeline;
    
    


    
    
        
        static PFN_vkCmdSetViewport vkCmdSetViewport;
    
    


    
    
        
        static PFN_vkCmdSetScissor vkCmdSetScissor;
    
    


    
    
        
        static PFN_vkCmdSetLineWidth vkCmdSetLineWidth;
    
    


    
    
        
        static PFN_vkCmdSetDepthBias vkCmdSetDepthBias;
    
    


    
    
        
        static PFN_vkCmdSetBlendConstants vkCmdSetBlendConstants;
    
    


    
    
        
        static PFN_vkCmdSetDepthBounds vkCmdSetDepthBounds;
    
    


    
    
        
        static PFN_vkCmdSetStencilCompareMask vkCmdSetStencilCompareMask;
    
    


    
    
        
        static PFN_vkCmdSetStencilWriteMask vkCmdSetStencilWriteMask;
    
    


    
    
        
        static PFN_vkCmdSetStencilReference vkCmdSetStencilReference;
    
    


    
    
        
        static PFN_vkCmdBindDescriptorSets vkCmdBindDescriptorSets;
    
    


    
    
        
        static PFN_vkCmdBindIndexBuffer vkCmdBindIndexBuffer;
    
    


    
    
        
        static PFN_vkCmdBindVertexBuffers vkCmdBindVertexBuffers;
    
    


    
    
        
        static PFN_vkCmdDraw vkCmdDraw;
    
    


    
    
        
        static PFN_vkCmdDrawIndexed vkCmdDrawIndexed;
    
    


    
    
        
        static PFN_vkCmdDrawIndirect vkCmdDrawIndirect;
    
    


    
    
        
        static PFN_vkCmdDrawIndexedIndirect vkCmdDrawIndexedIndirect;
    
    


    
    
        
        static PFN_vkCmdDispatch vkCmdDispatch;
    
    


    
    
        
        static PFN_vkCmdDispatchIndirect vkCmdDispatchIndirect;
    
    


    
    
        
        static PFN_vkCmdCopyBuffer vkCmdCopyBuffer;
    
    


    
    
        
        static PFN_vkCmdCopyImage vkCmdCopyImage;
    
    


    
    
        
        static PFN_vkCmdBlitImage vkCmdBlitImage;
    
    


    
    
        
        static PFN_vkCmdCopyBufferToImage vkCmdCopyBufferToImage;
    
    


    
    
        
        static PFN_vkCmdCopyImageToBuffer vkCmdCopyImageToBuffer;
    
    


    
    
        
        static PFN_vkCmdUpdateBuffer vkCmdUpdateBuffer;
    
    


    
    
        
        static PFN_vkCmdFillBuffer vkCmdFillBuffer;
    
    


    
    
        
        static PFN_vkCmdClearColorImage vkCmdClearColorImage;
    
    


    
    
        
        static PFN_vkCmdClearDepthStencilImage vkCmdClearDepthStencilImage;
    
    


    
    
        
        static PFN_vkCmdClearAttachments vkCmdClearAttachments;
    
    


    
    
        
        static PFN_vkCmdResolveImage vkCmdResolveImage;
    
    


    
    
        
        static PFN_vkCmdSetEvent vkCmdSetEvent;
    
    


    
    
        
        static PFN_vkCmdResetEvent vkCmdResetEvent;
    
    


    
    
        
        static PFN_vkCmdWaitEvents vkCmdWaitEvents;
    
    


    
    
        
        static PFN_vkCmdPipelineBarrier vkCmdPipelineBarrier;
    
    


    
    
        
        static PFN_vkCmdBeginQuery vkCmdBeginQuery;
    
    


    
    
        
        static PFN_vkCmdEndQuery vkCmdEndQuery;
    
    


    
    
        
        static PFN_vkCmdResetQueryPool vkCmdResetQueryPool;
    
    


    
    
        
        static PFN_vkCmdWriteTimestamp vkCmdWriteTimestamp;
    
    


    
    
        
        static PFN_vkCmdCopyQueryPoolResults vkCmdCopyQueryPoolResults;
    
    


    
    
        
        static PFN_vkCmdPushConstants vkCmdPushConstants;
    
    


    
    
        
        static PFN_vkCmdBeginRenderPass vkCmdBeginRenderPass;
    
    


    
    
        
        static PFN_vkCmdNextSubpass vkCmdNextSubpass;
    
    


    
    
        
        static PFN_vkCmdEndRenderPass vkCmdEndRenderPass;
    
    


    
    
        
        static PFN_vkCmdExecuteCommands vkCmdExecuteCommands;
    
    




    static PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr;

    static PFN_vkGetDeviceProcAddr vkGetDeviceProcAddr;

    static PFN_vkMapMemory vkMapMemory;

    static PFN_vkGetPipelineCacheData vkGetPipelineCacheData;


typedef struct {
    PyObject_HEAD VkDebugReportCallbackCreateInfoEXT *base;
}
PyVkDebugReportCallbackCreateInfoEXT;


// ---------------
// DECLARE PYTHON STRUCTS
// ---------------

    
    
        
        typedef struct {
            PyObject_HEAD
            VkOffset2D *base;
            
        } PyVkOffset2D;
        static PyTypeObject PyVkOffset2DType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkOffset3D *base;
            
        } PyVkOffset3D;
        static PyTypeObject PyVkOffset3DType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkExtent2D *base;
            
        } PyVkExtent2D;
        static PyTypeObject PyVkExtent2DType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkExtent3D *base;
            
        } PyVkExtent3D;
        static PyTypeObject PyVkExtent3DType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkViewport *base;
            
        } PyVkViewport;
        static PyTypeObject PyVkViewportType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkRect2D *base;
            
        } PyVkRect2D;
        static PyTypeObject PyVkRect2DType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
     #ifdef hackdefine 
        
        typedef struct {
            PyObject_HEAD
            VkRect3D *base;
            
        } PyVkRect3D;
        static PyTypeObject PyVkRect3DType;
    
     #endif 

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkClearRect *base;
            
        } PyVkClearRect;
        static PyTypeObject PyVkClearRectType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkComponentMapping *base;
            
        } PyVkComponentMapping;
        static PyTypeObject PyVkComponentMappingType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPhysicalDeviceProperties *base;
            
        } PyVkPhysicalDeviceProperties;
        static PyTypeObject PyVkPhysicalDevicePropertiesType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkExtensionProperties *base;
            
        } PyVkExtensionProperties;
        static PyTypeObject PyVkExtensionPropertiesType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkLayerProperties *base;
            
        } PyVkLayerProperties;
        static PyTypeObject PyVkLayerPropertiesType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkApplicationInfo *base;
            
        } PyVkApplicationInfo;
        static PyTypeObject PyVkApplicationInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkAllocationCallbacks *base;
            
        } PyVkAllocationCallbacks;
        static PyTypeObject PyVkAllocationCallbacksType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDeviceQueueCreateInfo *base;
            
        } PyVkDeviceQueueCreateInfo;
        static PyTypeObject PyVkDeviceQueueCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDeviceCreateInfo *base;
            
        } PyVkDeviceCreateInfo;
        static PyTypeObject PyVkDeviceCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkInstanceCreateInfo *base;
            
        } PyVkInstanceCreateInfo;
        static PyTypeObject PyVkInstanceCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkQueueFamilyProperties *base;
            
        } PyVkQueueFamilyProperties;
        static PyTypeObject PyVkQueueFamilyPropertiesType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPhysicalDeviceMemoryProperties *base;
            
        } PyVkPhysicalDeviceMemoryProperties;
        static PyTypeObject PyVkPhysicalDeviceMemoryPropertiesType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkMemoryAllocateInfo *base;
            
        } PyVkMemoryAllocateInfo;
        static PyTypeObject PyVkMemoryAllocateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkMemoryRequirements *base;
            
        } PyVkMemoryRequirements;
        static PyTypeObject PyVkMemoryRequirementsType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkSparseImageFormatProperties *base;
            
        } PyVkSparseImageFormatProperties;
        static PyTypeObject PyVkSparseImageFormatPropertiesType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkSparseImageMemoryRequirements *base;
            
        } PyVkSparseImageMemoryRequirements;
        static PyTypeObject PyVkSparseImageMemoryRequirementsType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkMemoryType *base;
            
        } PyVkMemoryType;
        static PyTypeObject PyVkMemoryTypeType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkMemoryHeap *base;
            
        } PyVkMemoryHeap;
        static PyTypeObject PyVkMemoryHeapType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkMappedMemoryRange *base;
            
        } PyVkMappedMemoryRange;
        static PyTypeObject PyVkMappedMemoryRangeType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkFormatProperties *base;
            
        } PyVkFormatProperties;
        static PyTypeObject PyVkFormatPropertiesType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkImageFormatProperties *base;
            
        } PyVkImageFormatProperties;
        static PyTypeObject PyVkImageFormatPropertiesType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDescriptorBufferInfo *base;
            
        } PyVkDescriptorBufferInfo;
        static PyTypeObject PyVkDescriptorBufferInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDescriptorImageInfo *base;
            
        } PyVkDescriptorImageInfo;
        static PyTypeObject PyVkDescriptorImageInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkWriteDescriptorSet *base;
            
        } PyVkWriteDescriptorSet;
        static PyTypeObject PyVkWriteDescriptorSetType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkCopyDescriptorSet *base;
            
        } PyVkCopyDescriptorSet;
        static PyTypeObject PyVkCopyDescriptorSetType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkBufferCreateInfo *base;
            
        } PyVkBufferCreateInfo;
        static PyTypeObject PyVkBufferCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkBufferViewCreateInfo *base;
            
        } PyVkBufferViewCreateInfo;
        static PyTypeObject PyVkBufferViewCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkImageSubresource *base;
            
        } PyVkImageSubresource;
        static PyTypeObject PyVkImageSubresourceType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkImageSubresourceLayers *base;
            
        } PyVkImageSubresourceLayers;
        static PyTypeObject PyVkImageSubresourceLayersType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkImageSubresourceRange *base;
            
        } PyVkImageSubresourceRange;
        static PyTypeObject PyVkImageSubresourceRangeType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkMemoryBarrier *base;
            
        } PyVkMemoryBarrier;
        static PyTypeObject PyVkMemoryBarrierType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkBufferMemoryBarrier *base;
            
        } PyVkBufferMemoryBarrier;
        static PyTypeObject PyVkBufferMemoryBarrierType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkImageMemoryBarrier *base;
            
        } PyVkImageMemoryBarrier;
        static PyTypeObject PyVkImageMemoryBarrierType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkImageCreateInfo *base;
            
        } PyVkImageCreateInfo;
        static PyTypeObject PyVkImageCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkSubresourceLayout *base;
            
        } PyVkSubresourceLayout;
        static PyTypeObject PyVkSubresourceLayoutType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkImageViewCreateInfo *base;
            
        } PyVkImageViewCreateInfo;
        static PyTypeObject PyVkImageViewCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkBufferCopy *base;
            
        } PyVkBufferCopy;
        static PyTypeObject PyVkBufferCopyType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkSparseMemoryBind *base;
            
        } PyVkSparseMemoryBind;
        static PyTypeObject PyVkSparseMemoryBindType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkSparseImageMemoryBind *base;
            
        } PyVkSparseImageMemoryBind;
        static PyTypeObject PyVkSparseImageMemoryBindType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkSparseBufferMemoryBindInfo *base;
            
        } PyVkSparseBufferMemoryBindInfo;
        static PyTypeObject PyVkSparseBufferMemoryBindInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkSparseImageOpaqueMemoryBindInfo *base;
            
        } PyVkSparseImageOpaqueMemoryBindInfo;
        static PyTypeObject PyVkSparseImageOpaqueMemoryBindInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkSparseImageMemoryBindInfo *base;
            
        } PyVkSparseImageMemoryBindInfo;
        static PyTypeObject PyVkSparseImageMemoryBindInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkBindSparseInfo *base;
            
        } PyVkBindSparseInfo;
        static PyTypeObject PyVkBindSparseInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkImageCopy *base;
            
        } PyVkImageCopy;
        static PyTypeObject PyVkImageCopyType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkImageBlit *base;
            
        } PyVkImageBlit;
        static PyTypeObject PyVkImageBlitType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkBufferImageCopy *base;
            
        } PyVkBufferImageCopy;
        static PyTypeObject PyVkBufferImageCopyType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkImageResolve *base;
            
        } PyVkImageResolve;
        static PyTypeObject PyVkImageResolveType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkShaderModuleCreateInfo *base;
            
        } PyVkShaderModuleCreateInfo;
        static PyTypeObject PyVkShaderModuleCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDescriptorSetLayoutBinding *base;
            
        } PyVkDescriptorSetLayoutBinding;
        static PyTypeObject PyVkDescriptorSetLayoutBindingType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDescriptorSetLayoutCreateInfo *base;
            
        } PyVkDescriptorSetLayoutCreateInfo;
        static PyTypeObject PyVkDescriptorSetLayoutCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDescriptorPoolSize *base;
            
        } PyVkDescriptorPoolSize;
        static PyTypeObject PyVkDescriptorPoolSizeType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDescriptorPoolCreateInfo *base;
            
        } PyVkDescriptorPoolCreateInfo;
        static PyTypeObject PyVkDescriptorPoolCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDescriptorSetAllocateInfo *base;
            
        } PyVkDescriptorSetAllocateInfo;
        static PyTypeObject PyVkDescriptorSetAllocateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkSpecializationMapEntry *base;
            
        } PyVkSpecializationMapEntry;
        static PyTypeObject PyVkSpecializationMapEntryType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkSpecializationInfo *base;
            
        } PyVkSpecializationInfo;
        static PyTypeObject PyVkSpecializationInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPipelineShaderStageCreateInfo *base;
            
        } PyVkPipelineShaderStageCreateInfo;
        static PyTypeObject PyVkPipelineShaderStageCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkComputePipelineCreateInfo *base;
            
        } PyVkComputePipelineCreateInfo;
        static PyTypeObject PyVkComputePipelineCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkVertexInputBindingDescription *base;
            
        } PyVkVertexInputBindingDescription;
        static PyTypeObject PyVkVertexInputBindingDescriptionType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkVertexInputAttributeDescription *base;
            
        } PyVkVertexInputAttributeDescription;
        static PyTypeObject PyVkVertexInputAttributeDescriptionType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPipelineVertexInputStateCreateInfo *base;
            
        } PyVkPipelineVertexInputStateCreateInfo;
        static PyTypeObject PyVkPipelineVertexInputStateCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPipelineInputAssemblyStateCreateInfo *base;
            
        } PyVkPipelineInputAssemblyStateCreateInfo;
        static PyTypeObject PyVkPipelineInputAssemblyStateCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPipelineTessellationStateCreateInfo *base;
            
        } PyVkPipelineTessellationStateCreateInfo;
        static PyTypeObject PyVkPipelineTessellationStateCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPipelineViewportStateCreateInfo *base;
            
        } PyVkPipelineViewportStateCreateInfo;
        static PyTypeObject PyVkPipelineViewportStateCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPipelineRasterizationStateCreateInfo *base;
            
        } PyVkPipelineRasterizationStateCreateInfo;
        static PyTypeObject PyVkPipelineRasterizationStateCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPipelineMultisampleStateCreateInfo *base;
            
        } PyVkPipelineMultisampleStateCreateInfo;
        static PyTypeObject PyVkPipelineMultisampleStateCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPipelineColorBlendAttachmentState *base;
            
        } PyVkPipelineColorBlendAttachmentState;
        static PyTypeObject PyVkPipelineColorBlendAttachmentStateType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPipelineColorBlendStateCreateInfo *base;
            
        } PyVkPipelineColorBlendStateCreateInfo;
        static PyTypeObject PyVkPipelineColorBlendStateCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPipelineDynamicStateCreateInfo *base;
            
        } PyVkPipelineDynamicStateCreateInfo;
        static PyTypeObject PyVkPipelineDynamicStateCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkStencilOpState *base;
            
        } PyVkStencilOpState;
        static PyTypeObject PyVkStencilOpStateType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPipelineDepthStencilStateCreateInfo *base;
            
        } PyVkPipelineDepthStencilStateCreateInfo;
        static PyTypeObject PyVkPipelineDepthStencilStateCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkGraphicsPipelineCreateInfo *base;
            
        } PyVkGraphicsPipelineCreateInfo;
        static PyTypeObject PyVkGraphicsPipelineCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPipelineCacheCreateInfo *base;
            
        } PyVkPipelineCacheCreateInfo;
        static PyTypeObject PyVkPipelineCacheCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPushConstantRange *base;
            
        } PyVkPushConstantRange;
        static PyTypeObject PyVkPushConstantRangeType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPipelineLayoutCreateInfo *base;
            
        } PyVkPipelineLayoutCreateInfo;
        static PyTypeObject PyVkPipelineLayoutCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkSamplerCreateInfo *base;
            
        } PyVkSamplerCreateInfo;
        static PyTypeObject PyVkSamplerCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkCommandPoolCreateInfo *base;
            
        } PyVkCommandPoolCreateInfo;
        static PyTypeObject PyVkCommandPoolCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkCommandBufferAllocateInfo *base;
            
        } PyVkCommandBufferAllocateInfo;
        static PyTypeObject PyVkCommandBufferAllocateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkCommandBufferInheritanceInfo *base;
            
        } PyVkCommandBufferInheritanceInfo;
        static PyTypeObject PyVkCommandBufferInheritanceInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkCommandBufferBeginInfo *base;
            
        } PyVkCommandBufferBeginInfo;
        static PyTypeObject PyVkCommandBufferBeginInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkRenderPassBeginInfo *base;
            
        } PyVkRenderPassBeginInfo;
        static PyTypeObject PyVkRenderPassBeginInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkClearDepthStencilValue *base;
            
        } PyVkClearDepthStencilValue;
        static PyTypeObject PyVkClearDepthStencilValueType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkClearAttachment *base;
            
        } PyVkClearAttachment;
        static PyTypeObject PyVkClearAttachmentType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkAttachmentDescription *base;
            
        } PyVkAttachmentDescription;
        static PyTypeObject PyVkAttachmentDescriptionType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkAttachmentReference *base;
            
        } PyVkAttachmentReference;
        static PyTypeObject PyVkAttachmentReferenceType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkSubpassDescription *base;
            
        } PyVkSubpassDescription;
        static PyTypeObject PyVkSubpassDescriptionType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkSubpassDependency *base;
            
        } PyVkSubpassDependency;
        static PyTypeObject PyVkSubpassDependencyType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkRenderPassCreateInfo *base;
            
        } PyVkRenderPassCreateInfo;
        static PyTypeObject PyVkRenderPassCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkEventCreateInfo *base;
            
        } PyVkEventCreateInfo;
        static PyTypeObject PyVkEventCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkFenceCreateInfo *base;
            
        } PyVkFenceCreateInfo;
        static PyTypeObject PyVkFenceCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPhysicalDeviceFeatures *base;
            
        } PyVkPhysicalDeviceFeatures;
        static PyTypeObject PyVkPhysicalDeviceFeaturesType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPhysicalDeviceSparseProperties *base;
            
        } PyVkPhysicalDeviceSparseProperties;
        static PyTypeObject PyVkPhysicalDeviceSparsePropertiesType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPhysicalDeviceLimits *base;
            
        } PyVkPhysicalDeviceLimits;
        static PyTypeObject PyVkPhysicalDeviceLimitsType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkSemaphoreCreateInfo *base;
            
        } PyVkSemaphoreCreateInfo;
        static PyTypeObject PyVkSemaphoreCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkQueryPoolCreateInfo *base;
            
        } PyVkQueryPoolCreateInfo;
        static PyTypeObject PyVkQueryPoolCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkFramebufferCreateInfo *base;
            
        } PyVkFramebufferCreateInfo;
        static PyTypeObject PyVkFramebufferCreateInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDrawIndirectCommand *base;
            
        } PyVkDrawIndirectCommand;
        static PyTypeObject PyVkDrawIndirectCommandType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDrawIndexedIndirectCommand *base;
            
        } PyVkDrawIndexedIndirectCommand;
        static PyTypeObject PyVkDrawIndexedIndirectCommandType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDispatchIndirectCommand *base;
            
        } PyVkDispatchIndirectCommand;
        static PyTypeObject PyVkDispatchIndirectCommandType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkSubmitInfo *base;
            
        } PyVkSubmitInfo;
        static PyTypeObject PyVkSubmitInfoType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDisplayPropertiesKHR *base;
            
        } PyVkDisplayPropertiesKHR;
        static PyTypeObject PyVkDisplayPropertiesKHRType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDisplayPlanePropertiesKHR *base;
            
        } PyVkDisplayPlanePropertiesKHR;
        static PyTypeObject PyVkDisplayPlanePropertiesKHRType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDisplayModeParametersKHR *base;
            
        } PyVkDisplayModeParametersKHR;
        static PyTypeObject PyVkDisplayModeParametersKHRType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDisplayModePropertiesKHR *base;
            
        } PyVkDisplayModePropertiesKHR;
        static PyTypeObject PyVkDisplayModePropertiesKHRType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDisplayModeCreateInfoKHR *base;
            
        } PyVkDisplayModeCreateInfoKHR;
        static PyTypeObject PyVkDisplayModeCreateInfoKHRType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDisplayPlaneCapabilitiesKHR *base;
            
        } PyVkDisplayPlaneCapabilitiesKHR;
        static PyTypeObject PyVkDisplayPlaneCapabilitiesKHRType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDisplaySurfaceCreateInfoKHR *base;
            
        } PyVkDisplaySurfaceCreateInfoKHR;
        static PyTypeObject PyVkDisplaySurfaceCreateInfoKHRType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDisplayPresentInfoKHR *base;
            
        } PyVkDisplayPresentInfoKHR;
        static PyTypeObject PyVkDisplayPresentInfoKHRType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkSurfaceCapabilitiesKHR *base;
            
        } PyVkSurfaceCapabilitiesKHR;
        static PyTypeObject PyVkSurfaceCapabilitiesKHRType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
     #ifdef VK_USE_PLATFORM_ANDROID_KHR 
        
        typedef struct {
            PyObject_HEAD
            VkAndroidSurfaceCreateInfoKHR *base;
            
        } PyVkAndroidSurfaceCreateInfoKHR;
        static PyTypeObject PyVkAndroidSurfaceCreateInfoKHRType;
    
     #endif 

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
     #ifdef VK_USE_PLATFORM_MIR_KHR 
        
        typedef struct {
            PyObject_HEAD
            VkMirSurfaceCreateInfoKHR *base;
            
        } PyVkMirSurfaceCreateInfoKHR;
        static PyTypeObject PyVkMirSurfaceCreateInfoKHRType;
    
     #endif 

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
     #ifdef VK_USE_PLATFORM_WAYLAND_KHR 
        
        typedef struct {
            PyObject_HEAD
            VkWaylandSurfaceCreateInfoKHR *base;
            
        } PyVkWaylandSurfaceCreateInfoKHR;
        static PyTypeObject PyVkWaylandSurfaceCreateInfoKHRType;
    
     #endif 

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
        typedef struct {
            PyObject_HEAD
            VkWin32SurfaceCreateInfoKHR *base;
            
        } PyVkWin32SurfaceCreateInfoKHR;
        static PyTypeObject PyVkWin32SurfaceCreateInfoKHRType;
    
     #endif 

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
     #ifdef VK_USE_PLATFORM_XLIB_KHR 
        
        typedef struct {
            PyObject_HEAD
            VkXlibSurfaceCreateInfoKHR *base;
            
        } PyVkXlibSurfaceCreateInfoKHR;
        static PyTypeObject PyVkXlibSurfaceCreateInfoKHRType;
    
     #endif 

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
     #ifdef VK_USE_PLATFORM_XCB_KHR 
        
        typedef struct {
            PyObject_HEAD
            VkXcbSurfaceCreateInfoKHR *base;
            
        } PyVkXcbSurfaceCreateInfoKHR;
        static PyTypeObject PyVkXcbSurfaceCreateInfoKHRType;
    
     #endif 

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkSurfaceFormatKHR *base;
            
        } PyVkSurfaceFormatKHR;
        static PyTypeObject PyVkSurfaceFormatKHRType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkSwapchainCreateInfoKHR *base;
            
        } PyVkSwapchainCreateInfoKHR;
        static PyTypeObject PyVkSwapchainCreateInfoKHRType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPresentInfoKHR *base;
            
        } PyVkPresentInfoKHR;
        static PyTypeObject PyVkPresentInfoKHRType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkValidationFlagsEXT *base;
            
        } PyVkValidationFlagsEXT;
        static PyTypeObject PyVkValidationFlagsEXTType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkPipelineRasterizationStateRasterizationOrderAMD *base;
            
        } PyVkPipelineRasterizationStateRasterizationOrderAMD;
        static PyTypeObject PyVkPipelineRasterizationStateRasterizationOrderAMDType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDebugMarkerObjectNameInfoEXT *base;
            
        } PyVkDebugMarkerObjectNameInfoEXT;
        static PyTypeObject PyVkDebugMarkerObjectNameInfoEXTType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDebugMarkerObjectTagInfoEXT *base;
            
        } PyVkDebugMarkerObjectTagInfoEXT;
        static PyTypeObject PyVkDebugMarkerObjectTagInfoEXTType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDebugMarkerMarkerInfoEXT *base;
            
        } PyVkDebugMarkerMarkerInfoEXT;
        static PyTypeObject PyVkDebugMarkerMarkerInfoEXTType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDedicatedAllocationImageCreateInfoNV *base;
            
        } PyVkDedicatedAllocationImageCreateInfoNV;
        static PyTypeObject PyVkDedicatedAllocationImageCreateInfoNVType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDedicatedAllocationBufferCreateInfoNV *base;
            
        } PyVkDedicatedAllocationBufferCreateInfoNV;
        static PyTypeObject PyVkDedicatedAllocationBufferCreateInfoNVType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkDedicatedAllocationMemoryAllocateInfoNV *base;
            
        } PyVkDedicatedAllocationMemoryAllocateInfoNV;
        static PyTypeObject PyVkDedicatedAllocationMemoryAllocateInfoNVType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkExternalImageFormatPropertiesNV *base;
            
        } PyVkExternalImageFormatPropertiesNV;
        static PyTypeObject PyVkExternalImageFormatPropertiesNVType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkExternalMemoryImageCreateInfoNV *base;
            
        } PyVkExternalMemoryImageCreateInfoNV;
        static PyTypeObject PyVkExternalMemoryImageCreateInfoNVType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkExportMemoryAllocateInfoNV *base;
            
        } PyVkExportMemoryAllocateInfoNV;
        static PyTypeObject PyVkExportMemoryAllocateInfoNVType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
        typedef struct {
            PyObject_HEAD
            VkImportMemoryWin32HandleInfoNV *base;
            
        } PyVkImportMemoryWin32HandleInfoNV;
        static PyTypeObject PyVkImportMemoryWin32HandleInfoNVType;
    
     #endif 

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
        typedef struct {
            PyObject_HEAD
            VkExportMemoryWin32HandleInfoNV *base;
            
        } PyVkExportMemoryWin32HandleInfoNV;
        static PyTypeObject PyVkExportMemoryWin32HandleInfoNVType;
    
     #endif 

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
        typedef struct {
            PyObject_HEAD
            VkWin32KeyedMutexAcquireReleaseInfoNV *base;
            
        } PyVkWin32KeyedMutexAcquireReleaseInfoNV;
        static PyTypeObject PyVkWin32KeyedMutexAcquireReleaseInfoNVType;
    
     #endif 

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkClearColorValue *base;
            
                int selected;
            
        } PyVkClearColorValue;
        static PyTypeObject PyVkClearColorValueType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;

    
    
        
        typedef struct {
            PyObject_HEAD
            VkClearValue *base;
            
                int selected;
            
        } PyVkClearValue;
        static PyTypeObject PyVkClearValueType;
    
    

    static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType;



// ---------------
// DECLARE CONVERTERS
// ---------------



    
    
        
    
    
        
    static int pyc_uint32_t_converter(PyObject* arg, uint32_t* val) {
        if (!PyLong_Check(arg)) {
            PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
            return 0;
        }

        *val = (uint32_t) PyLong_AsLong(arg);

        if (PyErr_Occurred())
            return 0;

        return 1;
    }

    static void pyc_uint32_t_converter_free(uint32_t* val) { }
    
    

    
    


    
    
        
    
    
        
    static int pyc_uint64_t_converter(PyObject* arg, uint64_t* val) {
        if (!PyLong_Check(arg)) {
            PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
            return 0;
        }

        *val = (uint64_t) PyLong_AsLong(arg);

        if (PyErr_Occurred())
            return 0;

        return 1;
    }

    static void pyc_uint64_t_converter_free(uint64_t* val) { }
    
    

    
    


    
    
        
    
    
        
    static int pyc_int32_t_converter(PyObject* arg, int32_t* val) {
        if (!PyLong_Check(arg)) {
            PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
            return 0;
        }

        *val = (int32_t) PyLong_AsLong(arg);

        if (PyErr_Occurred())
            return 0;

        return 1;
    }

    static void pyc_int32_t_converter_free(int32_t* val) { }
    
    

    
    


    
    
        
    
    
        
    static int pyc_size_t_converter(PyObject* arg, size_t* val) {
        if (!PyLong_Check(arg)) {
            PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
            return 0;
        }

        *val = (size_t) PyLong_AsLong(arg);

        if (PyErr_Occurred())
            return 0;

        return 1;
    }

    static void pyc_size_t_converter_free(size_t* val) { }
    
    

    
    


    
     #ifdef VK_USE_PLATFORM_XLIB_KHR 
        
    
    
        
    static int pyc_Window_converter(PyObject* arg, Window* val) {
        if (!PyLong_Check(arg)) {
            PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
            return 0;
        }

        *val = (Window) PyLong_AsLong(arg);

        if (PyErr_Occurred())
            return 0;

        return 1;
    }

    static void pyc_Window_converter_free(Window* val) { }
    
    

    
     #endif 


    
     #ifdef VK_USE_PLATFORM_XLIB_KHR 
        
    
    
        
    static int pyc_Display_x_converter(PyObject* arg, Display ** val) {
        if (!PyLong_Check(arg)) {
            PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
            return 0;
        }

        *val = (Display *) PyLong_AsLong(arg);

        if (PyErr_Occurred())
            return 0;

        return 1;
    }

    static void pyc_Display_x_converter_free(Display ** val) { }
    
    

    
     #endif 


    
     #ifdef VK_USE_PLATFORM_XCB_KHR 
        
    
    
        
    static int pyc_xcb_connection_t_x_converter(PyObject* arg, xcb_connection_t ** val) {
        if (!PyLong_Check(arg)) {
            PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
            return 0;
        }

        *val = (xcb_connection_t *) PyLong_AsLong(arg);

        if (PyErr_Occurred())
            return 0;

        return 1;
    }

    static void pyc_xcb_connection_t_x_converter_free(xcb_connection_t ** val) { }
    
    

    
     #endif 


    
     #ifdef VK_USE_PLATFORM_XCB_KHR 
        
    
    
        
    static int pyc_xcb_visualid_t_converter(PyObject* arg, xcb_visualid_t* val) {
        if (!PyLong_Check(arg)) {
            PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
            return 0;
        }

        *val = (xcb_visualid_t) PyLong_AsLong(arg);

        if (PyErr_Occurred())
            return 0;

        return 1;
    }

    static void pyc_xcb_visualid_t_converter_free(xcb_visualid_t* val) { }
    
    

    
     #endif 


    
     #ifdef VK_USE_PLATFORM_XCB_KHR 
        
    
    
        
    static int pyc_xcb_window_t_converter(PyObject* arg, xcb_window_t* val) {
        if (!PyLong_Check(arg)) {
            PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
            return 0;
        }

        *val = (xcb_window_t) PyLong_AsLong(arg);

        if (PyErr_Occurred())
            return 0;

        return 1;
    }

    static void pyc_xcb_window_t_converter_free(xcb_window_t* val) { }
    
    

    
     #endif 


    
     #ifdef VK_USE_PLATFORM_ANDROID_KHR 
        
    
    
        
    static int pyc_ANativeWindow_x_converter(PyObject* arg, ANativeWindow ** val) {
        if (!PyLong_Check(arg)) {
            PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
            return 0;
        }

        *val = (ANativeWindow *) PyLong_AsLong(arg);

        if (PyErr_Occurred())
            return 0;

        return 1;
    }

    static void pyc_ANativeWindow_x_converter_free(ANativeWindow ** val) { }
    
    

    
     #endif 


    
     #ifdef VK_USE_PLATFORM_MIR_KHR 
        
    
    
        
    static int pyc_MirConnection_x_converter(PyObject* arg, MirConnection ** val) {
        if (!PyLong_Check(arg)) {
            PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
            return 0;
        }

        *val = (MirConnection *) PyLong_AsLong(arg);

        if (PyErr_Occurred())
            return 0;

        return 1;
    }

    static void pyc_MirConnection_x_converter_free(MirConnection ** val) { }
    
    

    
     #endif 


    
     #ifdef VK_USE_PLATFORM_MIR_KHR 
        
    
    
        
    static int pyc_MirSurface_x_converter(PyObject* arg, MirSurface ** val) {
        if (!PyLong_Check(arg)) {
            PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
            return 0;
        }

        *val = (MirSurface *) PyLong_AsLong(arg);

        if (PyErr_Occurred())
            return 0;

        return 1;
    }

    static void pyc_MirSurface_x_converter_free(MirSurface ** val) { }
    
    

    
     #endif 


    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
    
    
        
    static int pyc_HINSTANCE_converter(PyObject* arg, HINSTANCE* val) {
        if (!PyLong_Check(arg)) {
            PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
            return 0;
        }

        *val = (HINSTANCE) PyLong_AsLong(arg);

        if (PyErr_Occurred())
            return 0;

        return 1;
    }

    static void pyc_HINSTANCE_converter_free(HINSTANCE* val) { }
    
    

    
     #endif 


    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
    
    
        
    static int pyc_HWND_converter(PyObject* arg, HWND* val) {
        if (!PyLong_Check(arg)) {
            PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
            return 0;
        }

        *val = (HWND) PyLong_AsLong(arg);

        if (PyErr_Occurred())
            return 0;

        return 1;
    }

    static void pyc_HWND_converter_free(HWND* val) { }
    
    

    
     #endif 


    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
    
    
        
    static int pyc_HANDLE_converter(PyObject* arg, HANDLE* val) {
        if (!PyLong_Check(arg)) {
            PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
            return 0;
        }

        *val = (HANDLE) PyLong_AsLong(arg);

        if (PyErr_Occurred())
            return 0;

        return 1;
    }

    static void pyc_HANDLE_converter_free(HANDLE* val) { }
    
    

    
     #endif 


    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
    
    
        
    static int pyc_SECURITY_ATTRIBUTES_x_converter(PyObject* arg, SECURITY_ATTRIBUTES ** val) {
        if (!PyLong_Check(arg)) {
            PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
            return 0;
        }

        *val = (SECURITY_ATTRIBUTES *) PyLong_AsLong(arg);

        if (PyErr_Occurred())
            return 0;

        return 1;
    }

    static void pyc_SECURITY_ATTRIBUTES_x_converter_free(SECURITY_ATTRIBUTES ** val) { }
    
    

    
     #endif 


    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
    
    
        
    static int pyc_DWORD_converter(PyObject* arg, DWORD* val) {
        if (!PyLong_Check(arg)) {
            PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
            return 0;
        }

        *val = (DWORD) PyLong_AsLong(arg);

        if (PyErr_Occurred())
            return 0;

        return 1;
    }

    static void pyc_DWORD_converter_free(DWORD* val) { }
    
    

    
     #endif 


    
     #ifdef VK_USE_PLATFORM_XCB_KHR 
        
    
    
        
    static int pyc_VisualID_converter(PyObject* arg, VisualID* val) {
        if (!PyLong_Check(arg)) {
            PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
            return 0;
        }

        *val = (VisualID) PyLong_AsLong(arg);

        if (PyErr_Occurred())
            return 0;

        return 1;
    }

    static void pyc_VisualID_converter_free(VisualID* val) { }
    
    

    
     #endif 



static int pyc_float_converter(PyObject* arg, float* val) {
    // We accept int and we convert it to float
    if (!PyFloat_Check(arg) && !PyLong_Check(arg)) {
        PyErr_SetString(PyExc_TypeError, "Argument must be a float");
        return 0;
    }

    *val = (float) PyFloat_AsDouble(arg);

    if (PyErr_Occurred())
        return 0;

    return 1;
}

static void pyc_float_converter_free(float* val) {}

static int pyc_void_x_converter(PyObject* arg, void** val) {
    *val = NULL;
    return 1;
}

static void pyc_void_x_converter_free(void** val) {}

static int pyc_string_converter(PyObject* arg, char** val) {
    if (arg == Py_None) {
        *val = NULL;
        return 1;
    }

    if (!PyUnicode_Check(arg)) {
        PyErr_SetString(PyExc_TypeError, "Argument must be a string");
        return 0;
    }

    PyObject* tmp0 = PyUnicode_AsASCIIString(arg);
    if (tmp0 == NULL) {
        // Exception is raised by PyUnicode_AsASCIIString
        return 0;
    }

    char* tmp1 = PyBytes_AsString(tmp0);
    if (tmp1 == NULL) {
        // Exception is raised by PyUnicode_AsString
        Py_DECREF(tmp0);
        return 0;
    }

    *val = strdup(tmp1);
    if (*val == NULL) {
        Py_DECREF(tmp0);
        PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
        return 0;
    }

    Py_DECREF(tmp0);

    return 1;
}

static void pyc_string_converter_free(char** val) {}

static int pyc_array_string_converter(PyObject* arg, char*** val) {
    if (!PyList_Check(arg)) {
        PyErr_SetString(PyExc_TypeError, "Argument must be a list");
        return 0;
    }

    int size = PyList_Size(arg);

    *val = malloc(sizeof(char*) * size);
    if (*val == NULL) {
        PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
        return 0;
    }

    int i;
    for (i = 0; i < size; i++) {
        // item is a borrowed reference, so no Py_DECREF
        PyObject* item = PyList_GetItem(arg, i);
        if (item == NULL) {
            free(*val);
            // free previous string in array
            int j; for (j = 0; j < i; j++) free((*val)[j]);
            return 0;
        }

        if (!PyUnicode_Check(item)) {
            free(*val);
            // free previous string in array
            int j; for (j = 0; j < i; j++) free((*val)[j]);
            PyErr_SetString(PyExc_TypeError, "Argument must be a list of string");
            return 0;
        }

        PyObject* ascii_str = PyUnicode_AsASCIIString(item);
        if (ascii_str == NULL) {
            free(*val);
            // free previous string in array
            int j; for (j = 0; j < i; j++) free((*val)[j]);
            PyErr_SetString(PyExc_TypeError, "Argument must be a list of strings");
            return 0;
        }

        char* tmp = PyBytes_AsString(ascii_str);
        if (tmp == NULL) {
            // Exception is raised by PyUnicode_AsString
            free(*val);
            // free previous string in array
            int j; for (j = 0; j < i; j++) free((*val)[j]);
            Py_DECREF(ascii_str);
            return 0;
        }

        (*val)[i] = strdup(tmp);
        if ((*val)[i] == NULL) {
            free(*val);
            // free previous string in array
            int j; for (j = 0; j < i; j++) free((*val)[j]);
            Py_DECREF(ascii_str);
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
            return 0;
        }

        Py_DECREF(ascii_str);
    }

    return 1;
}

static void pyc_array_string_converter_free(char*** val) {}




static int pyc_array_float_converter(PyObject* arg, float** val) {
    if (arg == Py_None) {
        *val = VK_NULL_HANDLE;
    }
    else if (PyBytes_CheckExact(arg)) {
        *val = (float*) PyBytes_AsString(arg);
    }
    else {
        int size = PyList_Size(arg);
        *val = malloc(sizeof(float) * size);
        int i;
        for (i = 0; i < size; i++) {
            PyObject* item = PyList_GetItem(arg, i);
            if (item == NULL) {
                return 0;
            }

            float r = (float) PyFloat_AsDouble(item);

            if (PyErr_Occurred())
                return 0;

            memcpy(*val + i, &r, sizeof(float));
        }
    }

    return 1;
}

static void pyc_array_float_converter_free(float** val) {}


static int pyc_array_uint32_t_converter(PyObject* arg, uint32_t** val) {
    if (arg == Py_None) {
        *val = VK_NULL_HANDLE;
    }
    else if (PyBytes_CheckExact(arg)) {
        *val = (uint32_t*) PyBytes_AsString(arg);
    }
    else {
        int size = PyList_Size(arg);
        *val = malloc(sizeof(uint32_t) * size);
        int i;
        for (i = 0; i < size; i++) {
            PyObject* item = PyList_GetItem(arg, i);
            if (item == NULL) {
                return 0;
            }

            uint32_t r = (uint32_t) PyLong_AsLong(item);

            if (PyErr_Occurred())
                return 0;

            memcpy(*val + i, &r, sizeof(uint32_t));
        }
    }

    return 1;
}

static void pyc_array_uint32_t_converter_free(uint32_t** val) {}




static int pyc_wl_display_converter(PyObject* arg, struct wl_display** val) {
    *val = (struct wl_display*) PyLong_AsLong(arg);
    return 1;
}

static void pyc_wl_display_converter_free(struct wl_display** val) {}

static int pyc_wl_surface_converter(PyObject* arg, struct wl_surface** val) {
   *val = (struct wl_surface*) PyLong_AsLong(arg);
   return 1;
}

static void pyc_wl_surface_converter_free(struct wl_surface** val) {}


    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkBool32_converter(PyObject* arg, VkBool32* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkBool32) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkBool32_converter_free(VkBool32* val) {}
        
    


    

    
    



    

    
    
        

    

        
    
        
        // Specific ugly case
        // handle_array_VkDeviceMemory_converter is used only by Windows
        
            #ifdef VK_USE_PLATFORM_WIN32_KHR
        
        static int pyc_handle_array_VkDeviceMemory_converter(PyObject* arg, VkDeviceMemory** val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkDeviceMemory));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                VkDeviceMemory* handle_pointer = PyCapsule_GetPointer(PyList_GetItem(arg, i), "VkDeviceMemory");
                if (handle_pointer == NULL) {
                    free(*val);
                    return 0;
                }

                (*val)[i] = *handle_pointer;
            }

            return 1;
        }
        static void pyc_handle_array_VkDeviceMemory_converter_free(VkDeviceMemory** val) {}
        
            #endif
        
        
    


        
    


        
    
        
        static int pyc_handle_base_VkDeviceMemory_converter(PyObject* arg, VkDeviceMemory* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkDeviceMemory* handle_pointer = PyCapsule_GetPointer(arg, "VkDeviceMemory");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkDeviceMemory_converter_free(VkDeviceMemory* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkApplicationInfo_converter(PyObject* arg, VkApplicationInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkApplicationInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkApplicationInfo");
                return 0;
            }

            *val = ((PyVkApplicationInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkApplicationInfo_converter_free(VkApplicationInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkCommandPoolResetFlags_converter(PyObject* arg, VkCommandPoolResetFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkCommandPoolResetFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkCommandPoolResetFlags_converter_free(VkCommandPoolResetFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkSemaphoreCreateInfo_converter(PyObject* arg, VkSemaphoreCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkSemaphoreCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkSemaphoreCreateInfo");
                return 0;
            }

            *val = ((PyVkSemaphoreCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkSemaphoreCreateInfo_converter_free(VkSemaphoreCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkSamplerCreateFlags_converter(PyObject* arg, VkSamplerCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkSamplerCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkSamplerCreateFlags_converter_free(VkSamplerCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkExternalMemoryHandleTypeFlagsNV_converter(PyObject* arg, VkExternalMemoryHandleTypeFlagsNV* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkExternalMemoryHandleTypeFlagsNV) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkExternalMemoryHandleTypeFlagsNV_converter_free(VkExternalMemoryHandleTypeFlagsNV* val) {}
        
    


    

    
    



    

    
    
        

    

        
    
        
        // Specific ugly case
        // handle_array_VkDeviceMemory_converter is used only by Windows
        
        static int pyc_handle_array_VkBufferView_converter(PyObject* arg, VkBufferView** val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkBufferView));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                VkBufferView* handle_pointer = PyCapsule_GetPointer(PyList_GetItem(arg, i), "VkBufferView");
                if (handle_pointer == NULL) {
                    free(*val);
                    return 0;
                }

                (*val)[i] = *handle_pointer;
            }

            return 1;
        }
        static void pyc_handle_array_VkBufferView_converter_free(VkBufferView** val) {}
        
        
    


        
    


        
    
        
        static int pyc_handle_base_VkBufferView_converter(PyObject* arg, VkBufferView* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkBufferView* handle_pointer = PyCapsule_GetPointer(arg, "VkBufferView");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkBufferView_converter_free(VkBufferView* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_handle_base_VkRenderPass_converter(PyObject* arg, VkRenderPass* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkRenderPass* handle_pointer = PyCapsule_GetPointer(arg, "VkRenderPass");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkRenderPass_converter_free(VkRenderPass* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkQueryPoolCreateFlags_converter(PyObject* arg, VkQueryPoolCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkQueryPoolCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkQueryPoolCreateFlags_converter_free(VkQueryPoolCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkBindSparseInfo_converter(PyObject* arg, VkBindSparseInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkBindSparseInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkBindSparseInfo");
                return 0;
            }

            *val = ((PyVkBindSparseInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkBindSparseInfo_converter_free(VkBindSparseInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkDebugReportFlagsEXT_converter(PyObject* arg, VkDebugReportFlagsEXT* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkDebugReportFlagsEXT) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkDebugReportFlagsEXT_converter_free(VkDebugReportFlagsEXT* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_handle_base_VkFramebuffer_converter(PyObject* arg, VkFramebuffer* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkFramebuffer* handle_pointer = PyCapsule_GetPointer(arg, "VkFramebuffer");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkFramebuffer_converter_free(VkFramebuffer* val) {}
        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkClearValue_converter(PyObject* arg, VkClearValue** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkClearValue));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkClearValueType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkClearValue");
                    return 0;
                }

                (*val)[i] = *(((PyVkClearValue*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkClearValue_converter_free(VkClearValue** val) {}
        
    


        
    


        
    
        
        static int pyc_struct_base_VkClearValue_converter(PyObject* arg, VkClearValue* val) {
            if (!PyObject_TypeCheck(arg, &PyVkClearValueType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkClearValue");
                return 0;
            }

            *val = *(((PyVkClearValue*)arg)->base);
            return 1;
        }
        static void pyc_struct_base_VkClearValue_converter_free(VkClearValue* val) {}
        
    


    

    
    



    

    
     #ifdef VK_USE_PLATFORM_WAYLAND_KHR 
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkWaylandSurfaceCreateInfoKHR_converter(PyObject* arg, VkWaylandSurfaceCreateInfoKHR** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkWaylandSurfaceCreateInfoKHRType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkWaylandSurfaceCreateInfoKHR");
                return 0;
            }

            *val = ((PyVkWaylandSurfaceCreateInfoKHR*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkWaylandSurfaceCreateInfoKHR_converter_free(VkWaylandSurfaceCreateInfoKHR** val) {}
        
    


        
    


    

    
     #endif 



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkRect2D_converter(PyObject* arg, VkRect2D** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkRect2D));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkRect2DType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkRect2D");
                    return 0;
                }

                (*val)[i] = *(((PyVkRect2D*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkRect2D_converter_free(VkRect2D** val) {}
        
    


        
    
        
        static int pyc_struct_pointer_VkRect2D_converter(PyObject* arg, VkRect2D** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkRect2DType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkRect2D");
                return 0;
            }

            *val = ((PyVkRect2D*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkRect2D_converter_free(VkRect2D** val) {}
        
    


        
    
        
        static int pyc_struct_base_VkRect2D_converter(PyObject* arg, VkRect2D* val) {
            if (!PyObject_TypeCheck(arg, &PyVkRect2DType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkRect2D");
                return 0;
            }

            *val = *(((PyVkRect2D*)arg)->base);
            return 1;
        }
        static void pyc_struct_base_VkRect2D_converter_free(VkRect2D* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkQueryControlFlags_converter(PyObject* arg, VkQueryControlFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkQueryControlFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkQueryControlFlags_converter_free(VkQueryControlFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkPipelineColorBlendStateCreateFlags_converter(PyObject* arg, VkPipelineColorBlendStateCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkPipelineColorBlendStateCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkPipelineColorBlendStateCreateFlags_converter_free(VkPipelineColorBlendStateCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkDescriptorPoolSize_converter(PyObject* arg, VkDescriptorPoolSize** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkDescriptorPoolSize));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkDescriptorPoolSizeType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkDescriptorPoolSize");
                    return 0;
                }

                (*val)[i] = *(((PyVkDescriptorPoolSize*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkDescriptorPoolSize_converter_free(VkDescriptorPoolSize** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkRenderPassCreateFlags_converter(PyObject* arg, VkRenderPassCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkRenderPassCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkRenderPassCreateFlags_converter_free(VkRenderPassCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkComponentSwizzle_converter(PyObject* arg, VkComponentSwizzle* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkComponentSwizzle) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkComponentSwizzle_converter_free(VkComponentSwizzle* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkCommandBufferInheritanceInfo_converter(PyObject* arg, VkCommandBufferInheritanceInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkCommandBufferInheritanceInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkCommandBufferInheritanceInfo");
                return 0;
            }

            *val = ((PyVkCommandBufferInheritanceInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkCommandBufferInheritanceInfo_converter_free(VkCommandBufferInheritanceInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    
        
        // Specific ugly case
        // handle_array_VkDeviceMemory_converter is used only by Windows
        
        static int pyc_handle_array_VkSemaphore_converter(PyObject* arg, VkSemaphore** val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkSemaphore));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                VkSemaphore* handle_pointer = PyCapsule_GetPointer(PyList_GetItem(arg, i), "VkSemaphore");
                if (handle_pointer == NULL) {
                    free(*val);
                    return 0;
                }

                (*val)[i] = *handle_pointer;
            }

            return 1;
        }
        static void pyc_handle_array_VkSemaphore_converter_free(VkSemaphore** val) {}
        
        
    


        
    


        
    
        
        static int pyc_handle_base_VkSemaphore_converter(PyObject* arg, VkSemaphore* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkSemaphore* handle_pointer = PyCapsule_GetPointer(arg, "VkSemaphore");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkSemaphore_converter_free(VkSemaphore* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_handle_pointer_VkFence_converter(PyObject* arg, VkFence** val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkFence* handle_pointer = PyCapsule_GetPointer(arg, "VkFence");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = handle_pointer;
            return 1;
        }
        static void pyc_handle_pointer_VkFence_converter_free(VkFence** val) {}
        
    


        
    
        
        static int pyc_handle_base_VkFence_converter(PyObject* arg, VkFence* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkFence* handle_pointer = PyCapsule_GetPointer(arg, "VkFence");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkFence_converter_free(VkFence* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkSurfaceTransformFlagBitsKHR_converter(PyObject* arg, VkSurfaceTransformFlagBitsKHR* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkSurfaceTransformFlagBitsKHR) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkSurfaceTransformFlagBitsKHR_converter_free(VkSurfaceTransformFlagBitsKHR* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_handle_base_VkDescriptorPool_converter(PyObject* arg, VkDescriptorPool* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkDescriptorPool* handle_pointer = PyCapsule_GetPointer(arg, "VkDescriptorPool");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkDescriptorPool_converter_free(VkDescriptorPool* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkRenderPassBeginInfo_converter(PyObject* arg, VkRenderPassBeginInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkRenderPassBeginInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkRenderPassBeginInfo");
                return 0;
            }

            *val = ((PyVkRenderPassBeginInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkRenderPassBeginInfo_converter_free(VkRenderPassBeginInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkImageSubresourceRange_converter(PyObject* arg, VkImageSubresourceRange** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkImageSubresourceRangeType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkImageSubresourceRange");
                return 0;
            }

            *val = ((PyVkImageSubresourceRange*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkImageSubresourceRange_converter_free(VkImageSubresourceRange** val) {}
        
    


        
    
        
        static int pyc_struct_base_VkImageSubresourceRange_converter(PyObject* arg, VkImageSubresourceRange* val) {
            if (!PyObject_TypeCheck(arg, &PyVkImageSubresourceRangeType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkImageSubresourceRange");
                return 0;
            }

            *val = *(((PyVkImageSubresourceRange*)arg)->base);
            return 1;
        }
        static void pyc_struct_base_VkImageSubresourceRange_converter_free(VkImageSubresourceRange* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkInstanceCreateFlags_converter(PyObject* arg, VkInstanceCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkInstanceCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkInstanceCreateFlags_converter_free(VkInstanceCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkDescriptorSetAllocateInfo_converter(PyObject* arg, VkDescriptorSetAllocateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkDescriptorSetAllocateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkDescriptorSetAllocateInfo");
                return 0;
            }

            *val = ((PyVkDescriptorSetAllocateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkDescriptorSetAllocateInfo_converter_free(VkDescriptorSetAllocateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkBufferViewCreateFlags_converter(PyObject* arg, VkBufferViewCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkBufferViewCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkBufferViewCreateFlags_converter_free(VkBufferViewCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkPresentInfoKHR_converter(PyObject* arg, VkPresentInfoKHR** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkPresentInfoKHRType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkPresentInfoKHR");
                return 0;
            }

            *val = ((PyVkPresentInfoKHR*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkPresentInfoKHR_converter_free(VkPresentInfoKHR** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkPipelineShaderStageCreateInfo_converter(PyObject* arg, VkPipelineShaderStageCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkPipelineShaderStageCreateInfo));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkPipelineShaderStageCreateInfoType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkPipelineShaderStageCreateInfo");
                    return 0;
                }

                (*val)[i] = *(((PyVkPipelineShaderStageCreateInfo*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkPipelineShaderStageCreateInfo_converter_free(VkPipelineShaderStageCreateInfo** val) {}
        
    


        
    


        
    
        
        static int pyc_struct_base_VkPipelineShaderStageCreateInfo_converter(PyObject* arg, VkPipelineShaderStageCreateInfo* val) {
            if (!PyObject_TypeCheck(arg, &PyVkPipelineShaderStageCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkPipelineShaderStageCreateInfo");
                return 0;
            }

            *val = *(((PyVkPipelineShaderStageCreateInfo*)arg)->base);
            return 1;
        }
        static void pyc_struct_base_VkPipelineShaderStageCreateInfo_converter_free(VkPipelineShaderStageCreateInfo* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkVertexInputRate_converter(PyObject* arg, VkVertexInputRate* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkVertexInputRate) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkVertexInputRate_converter_free(VkVertexInputRate* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkDeviceQueueCreateFlags_converter(PyObject* arg, VkDeviceQueueCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkDeviceQueueCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkDeviceQueueCreateFlags_converter_free(VkDeviceQueueCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkQueryResultFlags_converter(PyObject* arg, VkQueryResultFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkQueryResultFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkQueryResultFlags_converter_free(VkQueryResultFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    
        
        // Specific ugly case
        // handle_array_VkDeviceMemory_converter is used only by Windows
        
        static int pyc_handle_array_VkDescriptorSetLayout_converter(PyObject* arg, VkDescriptorSetLayout** val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkDescriptorSetLayout));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                VkDescriptorSetLayout* handle_pointer = PyCapsule_GetPointer(PyList_GetItem(arg, i), "VkDescriptorSetLayout");
                if (handle_pointer == NULL) {
                    free(*val);
                    return 0;
                }

                (*val)[i] = *handle_pointer;
            }

            return 1;
        }
        static void pyc_handle_array_VkDescriptorSetLayout_converter_free(VkDescriptorSetLayout** val) {}
        
        
    


        
    


        
    
        
        static int pyc_handle_base_VkDescriptorSetLayout_converter(PyObject* arg, VkDescriptorSetLayout* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkDescriptorSetLayout* handle_pointer = PyCapsule_GetPointer(arg, "VkDescriptorSetLayout");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkDescriptorSetLayout_converter_free(VkDescriptorSetLayout* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkMappedMemoryRange_converter(PyObject* arg, VkMappedMemoryRange** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkMappedMemoryRangeType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkMappedMemoryRange");
                return 0;
            }

            *val = ((PyVkMappedMemoryRange*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkMappedMemoryRange_converter_free(VkMappedMemoryRange** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkDisplayPlaneAlphaFlagBitsKHR_converter(PyObject* arg, VkDisplayPlaneAlphaFlagBitsKHR* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkDisplayPlaneAlphaFlagBitsKHR) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkDisplayPlaneAlphaFlagBitsKHR_converter_free(VkDisplayPlaneAlphaFlagBitsKHR* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkWriteDescriptorSet_converter(PyObject* arg, VkWriteDescriptorSet** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkWriteDescriptorSetType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkWriteDescriptorSet");
                return 0;
            }

            *val = ((PyVkWriteDescriptorSet*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkWriteDescriptorSet_converter_free(VkWriteDescriptorSet** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkSpecializationMapEntry_converter(PyObject* arg, VkSpecializationMapEntry** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkSpecializationMapEntry));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkSpecializationMapEntryType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkSpecializationMapEntry");
                    return 0;
                }

                (*val)[i] = *(((PyVkSpecializationMapEntry*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkSpecializationMapEntry_converter_free(VkSpecializationMapEntry** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkImageAspectFlags_converter(PyObject* arg, VkImageAspectFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkImageAspectFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkImageAspectFlags_converter_free(VkImageAspectFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkImageViewCreateInfo_converter(PyObject* arg, VkImageViewCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkImageViewCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkImageViewCreateInfo");
                return 0;
            }

            *val = ((PyVkImageViewCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkImageViewCreateInfo_converter_free(VkImageViewCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkPipelineTessellationStateCreateFlags_converter(PyObject* arg, VkPipelineTessellationStateCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkPipelineTessellationStateCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkPipelineTessellationStateCreateFlags_converter_free(VkPipelineTessellationStateCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkPipelineInputAssemblyStateCreateInfo_converter(PyObject* arg, VkPipelineInputAssemblyStateCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkPipelineInputAssemblyStateCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkPipelineInputAssemblyStateCreateInfo");
                return 0;
            }

            *val = ((PyVkPipelineInputAssemblyStateCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkPipelineInputAssemblyStateCreateInfo_converter_free(VkPipelineInputAssemblyStateCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_handle_base_VkCommandPool_converter(PyObject* arg, VkCommandPool* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkCommandPool* handle_pointer = PyCapsule_GetPointer(arg, "VkCommandPool");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkCommandPool_converter_free(VkCommandPool* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkShaderModuleCreateInfo_converter(PyObject* arg, VkShaderModuleCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkShaderModuleCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkShaderModuleCreateInfo");
                return 0;
            }

            *val = ((PyVkShaderModuleCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkShaderModuleCreateInfo_converter_free(VkShaderModuleCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkSubmitInfo_converter(PyObject* arg, VkSubmitInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkSubmitInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkSubmitInfo");
                return 0;
            }

            *val = ((PyVkSubmitInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkSubmitInfo_converter_free(VkSubmitInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_flag_array_VkResult_converter(PyObject* arg, VkResult** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkResult));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyLong_Check(item)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                    return 0;
                }

                VkResult tmp = (VkResult) PyLong_AsLong(item);
                if (PyErr_Occurred()) {
                    free(*val);
                    return 0;
                }

                (*val)[i] = tmp;
            }
            return 1;
        }
        static void pyc_flag_array_VkResult_converter_free(VkResult** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkPipelineBindPoint_converter(PyObject* arg, VkPipelineBindPoint* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkPipelineBindPoint) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkPipelineBindPoint_converter_free(VkPipelineBindPoint* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkPipelineViewportStateCreateFlags_converter(PyObject* arg, VkPipelineViewportStateCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkPipelineViewportStateCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkPipelineViewportStateCreateFlags_converter_free(VkPipelineViewportStateCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkPolygonMode_converter(PyObject* arg, VkPolygonMode* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkPolygonMode) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkPolygonMode_converter_free(VkPolygonMode* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkWaylandSurfaceCreateFlagsKHR_converter(PyObject* arg, VkWaylandSurfaceCreateFlagsKHR* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkWaylandSurfaceCreateFlagsKHR) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkWaylandSurfaceCreateFlagsKHR_converter_free(VkWaylandSurfaceCreateFlagsKHR* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkQueryType_converter(PyObject* arg, VkQueryType* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkQueryType) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkQueryType_converter_free(VkQueryType* val) {}
        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkSubpassDescription_converter(PyObject* arg, VkSubpassDescription** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkSubpassDescription));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkSubpassDescriptionType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkSubpassDescription");
                    return 0;
                }

                (*val)[i] = *(((PyVkSubpassDescription*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkSubpassDescription_converter_free(VkSubpassDescription** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkPipelineCacheCreateInfo_converter(PyObject* arg, VkPipelineCacheCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkPipelineCacheCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkPipelineCacheCreateInfo");
                return 0;
            }

            *val = ((PyVkPipelineCacheCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkPipelineCacheCreateInfo_converter_free(VkPipelineCacheCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_struct_base_VkExtent2D_converter(PyObject* arg, VkExtent2D* val) {
            if (!PyObject_TypeCheck(arg, &PyVkExtent2DType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkExtent2D");
                return 0;
            }

            *val = *(((PyVkExtent2D*)arg)->base);
            return 1;
        }
        static void pyc_struct_base_VkExtent2D_converter_free(VkExtent2D* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkDescriptorPoolCreateFlags_converter(PyObject* arg, VkDescriptorPoolCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkDescriptorPoolCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkDescriptorPoolCreateFlags_converter_free(VkDescriptorPoolCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkOffset3D_converter(PyObject* arg, VkOffset3D** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkOffset3D));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkOffset3DType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkOffset3D");
                    return 0;
                }

                (*val)[i] = *(((PyVkOffset3D*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkOffset3D_converter_free(VkOffset3D** val) {}
        
    


        
    


        
    
        
        static int pyc_struct_base_VkOffset3D_converter(PyObject* arg, VkOffset3D* val) {
            if (!PyObject_TypeCheck(arg, &PyVkOffset3DType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkOffset3D");
                return 0;
            }

            *val = *(((PyVkOffset3D*)arg)->base);
            return 1;
        }
        static void pyc_struct_base_VkOffset3D_converter_free(VkOffset3D* val) {}
        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkDeviceQueueCreateInfo_converter(PyObject* arg, VkDeviceQueueCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkDeviceQueueCreateInfo));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkDeviceQueueCreateInfoType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkDeviceQueueCreateInfo");
                    return 0;
                }

                (*val)[i] = *(((PyVkDeviceQueueCreateInfo*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkDeviceQueueCreateInfo_converter_free(VkDeviceQueueCreateInfo** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkFramebufferCreateFlags_converter(PyObject* arg, VkFramebufferCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkFramebufferCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkFramebufferCreateFlags_converter_free(VkFramebufferCreateFlags* val) {}
        
    


    

    
    



    

    
     #ifdef VK_USE_PLATFORM_ANDROID_KHR 
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkAndroidSurfaceCreateFlagsKHR_converter(PyObject* arg, VkAndroidSurfaceCreateFlagsKHR* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkAndroidSurfaceCreateFlagsKHR) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkAndroidSurfaceCreateFlagsKHR_converter_free(VkAndroidSurfaceCreateFlagsKHR* val) {}
        
    


    

    
     #endif 



    

    
    
        

    

        
    


        
    
        
        static int pyc_handle_pointer_VkBuffer_converter(PyObject* arg, VkBuffer** val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkBuffer* handle_pointer = PyCapsule_GetPointer(arg, "VkBuffer");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = handle_pointer;
            return 1;
        }
        static void pyc_handle_pointer_VkBuffer_converter_free(VkBuffer** val) {}
        
    


        
    
        
        static int pyc_handle_base_VkBuffer_converter(PyObject* arg, VkBuffer* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkBuffer* handle_pointer = PyCapsule_GetPointer(arg, "VkBuffer");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkBuffer_converter_free(VkBuffer* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkColorSpaceKHR_converter(PyObject* arg, VkColorSpaceKHR* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkColorSpaceKHR) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkColorSpaceKHR_converter_free(VkColorSpaceKHR* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkFenceCreateInfo_converter(PyObject* arg, VkFenceCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkFenceCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkFenceCreateInfo");
                return 0;
            }

            *val = ((PyVkFenceCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkFenceCreateInfo_converter_free(VkFenceCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_handle_base_VkQueryPool_converter(PyObject* arg, VkQueryPool* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkQueryPool* handle_pointer = PyCapsule_GetPointer(arg, "VkQueryPool");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkQueryPool_converter_free(VkQueryPool* val) {}
        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkAttachmentDescription_converter(PyObject* arg, VkAttachmentDescription** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkAttachmentDescription));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkAttachmentDescriptionType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkAttachmentDescription");
                    return 0;
                }

                (*val)[i] = *(((PyVkAttachmentDescription*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkAttachmentDescription_converter_free(VkAttachmentDescription** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_flag_array_VkPipelineStageFlags_converter(PyObject* arg, VkPipelineStageFlags** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkPipelineStageFlags));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyLong_Check(item)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                    return 0;
                }

                VkPipelineStageFlags tmp = (VkPipelineStageFlags) PyLong_AsLong(item);
                if (PyErr_Occurred()) {
                    free(*val);
                    return 0;
                }

                (*val)[i] = tmp;
            }
            return 1;
        }
        static void pyc_flag_array_VkPipelineStageFlags_converter_free(VkPipelineStageFlags** val) {}
        
    


        
    


        
    
        
        static int pyc_flag_base_VkPipelineStageFlags_converter(PyObject* arg, VkPipelineStageFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkPipelineStageFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkPipelineStageFlags_converter_free(VkPipelineStageFlags* val) {}
        
    


    

    
    



    

    
     #ifdef VK_USE_PLATFORM_XLIB_KHR 
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkXlibSurfaceCreateInfoKHR_converter(PyObject* arg, VkXlibSurfaceCreateInfoKHR** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkXlibSurfaceCreateInfoKHRType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkXlibSurfaceCreateInfoKHR");
                return 0;
            }

            *val = ((PyVkXlibSurfaceCreateInfoKHR*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkXlibSurfaceCreateInfoKHR_converter_free(VkXlibSurfaceCreateInfoKHR** val) {}
        
    


        
    


    

    
     #endif 



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_handle_base_VkPhysicalDevice_converter(PyObject* arg, VkPhysicalDevice* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkPhysicalDevice* handle_pointer = PyCapsule_GetPointer(arg, "VkPhysicalDevice");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkPhysicalDevice_converter_free(VkPhysicalDevice* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkPipelineMultisampleStateCreateFlags_converter(PyObject* arg, VkPipelineMultisampleStateCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkPipelineMultisampleStateCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkPipelineMultisampleStateCreateFlags_converter_free(VkPipelineMultisampleStateCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkVertexInputBindingDescription_converter(PyObject* arg, VkVertexInputBindingDescription** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkVertexInputBindingDescription));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkVertexInputBindingDescriptionType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkVertexInputBindingDescription");
                    return 0;
                }

                (*val)[i] = *(((PyVkVertexInputBindingDescription*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkVertexInputBindingDescription_converter_free(VkVertexInputBindingDescription** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkPhysicalDeviceFeatures_converter(PyObject* arg, VkPhysicalDeviceFeatures** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkPhysicalDeviceFeaturesType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkPhysicalDeviceFeatures");
                return 0;
            }

            *val = ((PyVkPhysicalDeviceFeatures*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkPhysicalDeviceFeatures_converter_free(VkPhysicalDeviceFeatures** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkIndexType_converter(PyObject* arg, VkIndexType* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkIndexType) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkIndexType_converter_free(VkIndexType* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkBufferUsageFlags_converter(PyObject* arg, VkBufferUsageFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkBufferUsageFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkBufferUsageFlags_converter_free(VkBufferUsageFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkDescriptorBufferInfo_converter(PyObject* arg, VkDescriptorBufferInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkDescriptorBufferInfo));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkDescriptorBufferInfoType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkDescriptorBufferInfo");
                    return 0;
                }

                (*val)[i] = *(((PyVkDescriptorBufferInfo*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkDescriptorBufferInfo_converter_free(VkDescriptorBufferInfo** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkPipelineColorBlendAttachmentState_converter(PyObject* arg, VkPipelineColorBlendAttachmentState** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkPipelineColorBlendAttachmentState));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkPipelineColorBlendAttachmentStateType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkPipelineColorBlendAttachmentState");
                    return 0;
                }

                (*val)[i] = *(((PyVkPipelineColorBlendAttachmentState*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkPipelineColorBlendAttachmentState_converter_free(VkPipelineColorBlendAttachmentState** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_handle_base_VkInstance_converter(PyObject* arg, VkInstance* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkInstance* handle_pointer = PyCapsule_GetPointer(arg, "VkInstance");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkInstance_converter_free(VkInstance* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkDescriptorSetLayoutCreateInfo_converter(PyObject* arg, VkDescriptorSetLayoutCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkDescriptorSetLayoutCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkDescriptorSetLayoutCreateInfo");
                return 0;
            }

            *val = ((PyVkDescriptorSetLayoutCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkDescriptorSetLayoutCreateInfo_converter_free(VkDescriptorSetLayoutCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkBufferMemoryBarrier_converter(PyObject* arg, VkBufferMemoryBarrier** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkBufferMemoryBarrierType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkBufferMemoryBarrier");
                return 0;
            }

            *val = ((PyVkBufferMemoryBarrier*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkBufferMemoryBarrier_converter_free(VkBufferMemoryBarrier** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkEventCreateInfo_converter(PyObject* arg, VkEventCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkEventCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkEventCreateInfo");
                return 0;
            }

            *val = ((PyVkEventCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkEventCreateInfo_converter_free(VkEventCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkPipelineInputAssemblyStateCreateFlags_converter(PyObject* arg, VkPipelineInputAssemblyStateCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkPipelineInputAssemblyStateCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkPipelineInputAssemblyStateCreateFlags_converter_free(VkPipelineInputAssemblyStateCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkDeviceCreateInfo_converter(PyObject* arg, VkDeviceCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkDeviceCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkDeviceCreateInfo");
                return 0;
            }

            *val = ((PyVkDeviceCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkDeviceCreateInfo_converter_free(VkDeviceCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkSubpassContents_converter(PyObject* arg, VkSubpassContents* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkSubpassContents) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkSubpassContents_converter_free(VkSubpassContents* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_handle_base_VkDebugReportCallbackEXT_converter(PyObject* arg, VkDebugReportCallbackEXT* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkDebugReportCallbackEXT* handle_pointer = PyCapsule_GetPointer(arg, "VkDebugReportCallbackEXT");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkDebugReportCallbackEXT_converter_free(VkDebugReportCallbackEXT* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkSamplerCreateInfo_converter(PyObject* arg, VkSamplerCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkSamplerCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkSamplerCreateInfo");
                return 0;
            }

            *val = ((PyVkSamplerCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkSamplerCreateInfo_converter_free(VkSamplerCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_handle_base_VkShaderModule_converter(PyObject* arg, VkShaderModule* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkShaderModule* handle_pointer = PyCapsule_GetPointer(arg, "VkShaderModule");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkShaderModule_converter_free(VkShaderModule* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkImageCopy_converter(PyObject* arg, VkImageCopy** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkImageCopyType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkImageCopy");
                return 0;
            }

            *val = ((PyVkImageCopy*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkImageCopy_converter_free(VkImageCopy** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkSampleCountFlagBits_converter(PyObject* arg, VkSampleCountFlagBits* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkSampleCountFlagBits) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkSampleCountFlagBits_converter_free(VkSampleCountFlagBits* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_handle_base_VkPipeline_converter(PyObject* arg, VkPipeline* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkPipeline* handle_pointer = PyCapsule_GetPointer(arg, "VkPipeline");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkPipeline_converter_free(VkPipeline* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkImageType_converter(PyObject* arg, VkImageType* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkImageType) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkImageType_converter_free(VkImageType* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkImageCreateFlags_converter(PyObject* arg, VkImageCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkImageCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkImageCreateFlags_converter_free(VkImageCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkQueryPipelineStatisticFlags_converter(PyObject* arg, VkQueryPipelineStatisticFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkQueryPipelineStatisticFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkQueryPipelineStatisticFlags_converter_free(VkQueryPipelineStatisticFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkFilter_converter(PyObject* arg, VkFilter* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkFilter) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkFilter_converter_free(VkFilter* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkDescriptorSetLayoutBinding_converter(PyObject* arg, VkDescriptorSetLayoutBinding** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkDescriptorSetLayoutBinding));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkDescriptorSetLayoutBindingType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkDescriptorSetLayoutBinding");
                    return 0;
                }

                (*val)[i] = *(((PyVkDescriptorSetLayoutBinding*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkDescriptorSetLayoutBinding_converter_free(VkDescriptorSetLayoutBinding** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_handle_pointer_VkPipelineCache_converter(PyObject* arg, VkPipelineCache** val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkPipelineCache* handle_pointer = PyCapsule_GetPointer(arg, "VkPipelineCache");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = handle_pointer;
            return 1;
        }
        static void pyc_handle_pointer_VkPipelineCache_converter_free(VkPipelineCache** val) {}
        
    


        
    
        
        static int pyc_handle_base_VkPipelineCache_converter(PyObject* arg, VkPipelineCache* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkPipelineCache* handle_pointer = PyCapsule_GetPointer(arg, "VkPipelineCache");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkPipelineCache_converter_free(VkPipelineCache* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkShaderModuleCreateFlags_converter(PyObject* arg, VkShaderModuleCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkShaderModuleCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkShaderModuleCreateFlags_converter_free(VkShaderModuleCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkPipelineMultisampleStateCreateInfo_converter(PyObject* arg, VkPipelineMultisampleStateCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkPipelineMultisampleStateCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkPipelineMultisampleStateCreateInfo");
                return 0;
            }

            *val = ((PyVkPipelineMultisampleStateCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkPipelineMultisampleStateCreateInfo_converter_free(VkPipelineMultisampleStateCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkPipelineDepthStencilStateCreateFlags_converter(PyObject* arg, VkPipelineDepthStencilStateCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkPipelineDepthStencilStateCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkPipelineDepthStencilStateCreateFlags_converter_free(VkPipelineDepthStencilStateCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_handle_base_VkImage_converter(PyObject* arg, VkImage* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkImage* handle_pointer = PyCapsule_GetPointer(arg, "VkImage");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkImage_converter_free(VkImage* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkVertexInputAttributeDescription_converter(PyObject* arg, VkVertexInputAttributeDescription** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkVertexInputAttributeDescription));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkVertexInputAttributeDescriptionType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkVertexInputAttributeDescription");
                    return 0;
                }

                (*val)[i] = *(((PyVkVertexInputAttributeDescription*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkVertexInputAttributeDescription_converter_free(VkVertexInputAttributeDescription** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkPipelineRasterizationStateCreateFlags_converter(PyObject* arg, VkPipelineRasterizationStateCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkPipelineRasterizationStateCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkPipelineRasterizationStateCreateFlags_converter_free(VkPipelineRasterizationStateCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkDescriptorPoolResetFlags_converter(PyObject* arg, VkDescriptorPoolResetFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkDescriptorPoolResetFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkDescriptorPoolResetFlags_converter_free(VkDescriptorPoolResetFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkBorderColor_converter(PyObject* arg, VkBorderColor* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkBorderColor) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkBorderColor_converter_free(VkBorderColor* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkBlendFactor_converter(PyObject* arg, VkBlendFactor* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkBlendFactor) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkBlendFactor_converter_free(VkBlendFactor* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkSwapchainCreateInfoKHR_converter(PyObject* arg, VkSwapchainCreateInfoKHR** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkSwapchainCreateInfoKHRType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkSwapchainCreateInfoKHR");
                return 0;
            }

            *val = ((PyVkSwapchainCreateInfoKHR*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkSwapchainCreateInfoKHR_converter_free(VkSwapchainCreateInfoKHR** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    
        
        // Specific ugly case
        // handle_array_VkDeviceMemory_converter is used only by Windows
        
        static int pyc_handle_array_VkImageView_converter(PyObject* arg, VkImageView** val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkImageView));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                VkImageView* handle_pointer = PyCapsule_GetPointer(PyList_GetItem(arg, i), "VkImageView");
                if (handle_pointer == NULL) {
                    free(*val);
                    return 0;
                }

                (*val)[i] = *handle_pointer;
            }

            return 1;
        }
        static void pyc_handle_array_VkImageView_converter_free(VkImageView** val) {}
        
        
    


        
    


        
    
        
        static int pyc_handle_base_VkImageView_converter(PyObject* arg, VkImageView* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkImageView* handle_pointer = PyCapsule_GetPointer(arg, "VkImageView");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkImageView_converter_free(VkImageView* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkImageViewType_converter(PyObject* arg, VkImageViewType* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkImageViewType) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkImageViewType_converter_free(VkImageViewType* val) {}
        
    


    

    
    



    

    
     #ifdef VK_USE_PLATFORM_ANDROID_KHR 
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkAndroidSurfaceCreateInfoKHR_converter(PyObject* arg, VkAndroidSurfaceCreateInfoKHR** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkAndroidSurfaceCreateInfoKHRType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkAndroidSurfaceCreateInfoKHR");
                return 0;
            }

            *val = ((PyVkAndroidSurfaceCreateInfoKHR*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkAndroidSurfaceCreateInfoKHR_converter_free(VkAndroidSurfaceCreateInfoKHR** val) {}
        
    


        
    


    

    
     #endif 



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkGraphicsPipelineCreateInfo_converter(PyObject* arg, VkGraphicsPipelineCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkGraphicsPipelineCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkGraphicsPipelineCreateInfo");
                return 0;
            }

            *val = ((PyVkGraphicsPipelineCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkGraphicsPipelineCreateInfo_converter_free(VkGraphicsPipelineCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkCompositeAlphaFlagBitsKHR_converter(PyObject* arg, VkCompositeAlphaFlagBitsKHR* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkCompositeAlphaFlagBitsKHR) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkCompositeAlphaFlagBitsKHR_converter_free(VkCompositeAlphaFlagBitsKHR* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_struct_base_VkImageFormatProperties_converter(PyObject* arg, VkImageFormatProperties* val) {
            if (!PyObject_TypeCheck(arg, &PyVkImageFormatPropertiesType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkImageFormatProperties");
                return 0;
            }

            *val = *(((PyVkImageFormatProperties*)arg)->base);
            return 1;
        }
        static void pyc_struct_base_VkImageFormatProperties_converter_free(VkImageFormatProperties* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkMemoryBarrier_converter(PyObject* arg, VkMemoryBarrier** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkMemoryBarrierType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkMemoryBarrier");
                return 0;
            }

            *val = ((PyVkMemoryBarrier*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkMemoryBarrier_converter_free(VkMemoryBarrier** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkSubpassDescriptionFlags_converter(PyObject* arg, VkSubpassDescriptionFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkSubpassDescriptionFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkSubpassDescriptionFlags_converter_free(VkSubpassDescriptionFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkAttachmentDescriptionFlags_converter(PyObject* arg, VkAttachmentDescriptionFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkAttachmentDescriptionFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkAttachmentDescriptionFlags_converter_free(VkAttachmentDescriptionFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkImageUsageFlags_converter(PyObject* arg, VkImageUsageFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkImageUsageFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkImageUsageFlags_converter_free(VkImageUsageFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkShaderStageFlags_converter(PyObject* arg, VkShaderStageFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkShaderStageFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkShaderStageFlags_converter_free(VkShaderStageFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkPipelineLayoutCreateFlags_converter(PyObject* arg, VkPipelineLayoutCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkPipelineLayoutCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkPipelineLayoutCreateFlags_converter_free(VkPipelineLayoutCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_flag_array_VkValidationCheckEXT_converter(PyObject* arg, VkValidationCheckEXT** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkValidationCheckEXT));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyLong_Check(item)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                    return 0;
                }

                VkValidationCheckEXT tmp = (VkValidationCheckEXT) PyLong_AsLong(item);
                if (PyErr_Occurred()) {
                    free(*val);
                    return 0;
                }

                (*val)[i] = tmp;
            }
            return 1;
        }
        static void pyc_flag_array_VkValidationCheckEXT_converter_free(VkValidationCheckEXT** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkXcbSurfaceCreateFlagsKHR_converter(PyObject* arg, VkXcbSurfaceCreateFlagsKHR* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkXcbSurfaceCreateFlagsKHR) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkXcbSurfaceCreateFlagsKHR_converter_free(VkXcbSurfaceCreateFlagsKHR* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkDeviceCreateFlags_converter(PyObject* arg, VkDeviceCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkDeviceCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkDeviceCreateFlags_converter_free(VkDeviceCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkPipelineLayoutCreateInfo_converter(PyObject* arg, VkPipelineLayoutCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkPipelineLayoutCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkPipelineLayoutCreateInfo");
                return 0;
            }

            *val = ((PyVkPipelineLayoutCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkPipelineLayoutCreateInfo_converter_free(VkPipelineLayoutCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_handle_base_VkDisplayModeKHR_converter(PyObject* arg, VkDisplayModeKHR* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkDisplayModeKHR* handle_pointer = PyCapsule_GetPointer(arg, "VkDisplayModeKHR");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkDisplayModeKHR_converter_free(VkDisplayModeKHR* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkPipelineCacheCreateFlags_converter(PyObject* arg, VkPipelineCacheCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkPipelineCacheCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkPipelineCacheCreateFlags_converter_free(VkPipelineCacheCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkPipelineViewportStateCreateInfo_converter(PyObject* arg, VkPipelineViewportStateCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkPipelineViewportStateCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkPipelineViewportStateCreateInfo");
                return 0;
            }

            *val = ((PyVkPipelineViewportStateCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkPipelineViewportStateCreateInfo_converter_free(VkPipelineViewportStateCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkCommandBufferLevel_converter(PyObject* arg, VkCommandBufferLevel* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkCommandBufferLevel) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkCommandBufferLevel_converter_free(VkCommandBufferLevel* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkClearAttachment_converter(PyObject* arg, VkClearAttachment** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkClearAttachmentType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkClearAttachment");
                return 0;
            }

            *val = ((PyVkClearAttachment*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkClearAttachment_converter_free(VkClearAttachment** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkSamplerAddressMode_converter(PyObject* arg, VkSamplerAddressMode* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkSamplerAddressMode) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkSamplerAddressMode_converter_free(VkSamplerAddressMode* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_struct_base_VkExtent3D_converter(PyObject* arg, VkExtent3D* val) {
            if (!PyObject_TypeCheck(arg, &PyVkExtent3DType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkExtent3D");
                return 0;
            }

            *val = *(((PyVkExtent3D*)arg)->base);
            return 1;
        }
        static void pyc_struct_base_VkExtent3D_converter_free(VkExtent3D* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_handle_pointer_VkEvent_converter(PyObject* arg, VkEvent** val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkEvent* handle_pointer = PyCapsule_GetPointer(arg, "VkEvent");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = handle_pointer;
            return 1;
        }
        static void pyc_handle_pointer_VkEvent_converter_free(VkEvent** val) {}
        
    


        
    
        
        static int pyc_handle_base_VkEvent_converter(PyObject* arg, VkEvent* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkEvent* handle_pointer = PyCapsule_GetPointer(arg, "VkEvent");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkEvent_converter_free(VkEvent* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_struct_base_VkOffset2D_converter(PyObject* arg, VkOffset2D* val) {
            if (!PyObject_TypeCheck(arg, &PyVkOffset2DType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkOffset2D");
                return 0;
            }

            *val = *(((PyVkOffset2D*)arg)->base);
            return 1;
        }
        static void pyc_struct_base_VkOffset2D_converter_free(VkOffset2D* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_handle_base_VkPipelineLayout_converter(PyObject* arg, VkPipelineLayout* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkPipelineLayout* handle_pointer = PyCapsule_GetPointer(arg, "VkPipelineLayout");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkPipelineLayout_converter_free(VkPipelineLayout* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_struct_base_VkStencilOpState_converter(PyObject* arg, VkStencilOpState* val) {
            if (!PyObject_TypeCheck(arg, &PyVkStencilOpStateType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkStencilOpState");
                return 0;
            }

            *val = *(((PyVkStencilOpState*)arg)->base);
            return 1;
        }
        static void pyc_struct_base_VkStencilOpState_converter_free(VkStencilOpState* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkCullModeFlags_converter(PyObject* arg, VkCullModeFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkCullModeFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkCullModeFlags_converter_free(VkCullModeFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_handle_base_VkSurfaceKHR_converter(PyObject* arg, VkSurfaceKHR* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkSurfaceKHR* handle_pointer = PyCapsule_GetPointer(arg, "VkSurfaceKHR");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkSurfaceKHR_converter_free(VkSurfaceKHR* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_handle_base_VkQueue_converter(PyObject* arg, VkQueue* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkQueue* handle_pointer = PyCapsule_GetPointer(arg, "VkQueue");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkQueue_converter_free(VkQueue* val) {}
        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkAttachmentReference_converter(PyObject* arg, VkAttachmentReference** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkAttachmentReference));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkAttachmentReferenceType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkAttachmentReference");
                    return 0;
                }

                (*val)[i] = *(((PyVkAttachmentReference*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkAttachmentReference_converter_free(VkAttachmentReference** val) {}
        
    


        
    
        
        static int pyc_struct_pointer_VkAttachmentReference_converter(PyObject* arg, VkAttachmentReference** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkAttachmentReferenceType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkAttachmentReference");
                return 0;
            }

            *val = ((PyVkAttachmentReference*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkAttachmentReference_converter_free(VkAttachmentReference** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkXlibSurfaceCreateFlagsKHR_converter(PyObject* arg, VkXlibSurfaceCreateFlagsKHR* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkXlibSurfaceCreateFlagsKHR) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkXlibSurfaceCreateFlagsKHR_converter_free(VkXlibSurfaceCreateFlagsKHR* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkFenceCreateFlags_converter(PyObject* arg, VkFenceCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkFenceCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkFenceCreateFlags_converter_free(VkFenceCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkCompareOp_converter(PyObject* arg, VkCompareOp* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkCompareOp) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkCompareOp_converter_free(VkCompareOp* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkImageSubresource_converter(PyObject* arg, VkImageSubresource** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkImageSubresourceType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkImageSubresource");
                return 0;
            }

            *val = ((PyVkImageSubresource*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkImageSubresource_converter_free(VkImageSubresource** val) {}
        
    


        
    
        
        static int pyc_struct_base_VkImageSubresource_converter(PyObject* arg, VkImageSubresource* val) {
            if (!PyObject_TypeCheck(arg, &PyVkImageSubresourceType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkImageSubresource");
                return 0;
            }

            *val = *(((PyVkImageSubresource*)arg)->base);
            return 1;
        }
        static void pyc_struct_base_VkImageSubresource_converter_free(VkImageSubresource* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkPresentModeKHR_converter(PyObject* arg, VkPresentModeKHR* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkPresentModeKHR) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkPresentModeKHR_converter_free(VkPresentModeKHR* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkClearColorValue_converter(PyObject* arg, VkClearColorValue** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkClearColorValueType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkClearColorValue");
                return 0;
            }

            *val = ((PyVkClearColorValue*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkClearColorValue_converter_free(VkClearColorValue** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkAttachmentStoreOp_converter(PyObject* arg, VkAttachmentStoreOp* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkAttachmentStoreOp) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkAttachmentStoreOp_converter_free(VkAttachmentStoreOp* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_handle_pointer_VkDescriptorSet_converter(PyObject* arg, VkDescriptorSet** val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkDescriptorSet* handle_pointer = PyCapsule_GetPointer(arg, "VkDescriptorSet");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = handle_pointer;
            return 1;
        }
        static void pyc_handle_pointer_VkDescriptorSet_converter_free(VkDescriptorSet** val) {}
        
    


        
    
        
        static int pyc_handle_base_VkDescriptorSet_converter(PyObject* arg, VkDescriptorSet* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkDescriptorSet* handle_pointer = PyCapsule_GetPointer(arg, "VkDescriptorSet");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkDescriptorSet_converter_free(VkDescriptorSet* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkBufferCreateInfo_converter(PyObject* arg, VkBufferCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkBufferCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkBufferCreateInfo");
                return 0;
            }

            *val = ((PyVkBufferCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkBufferCreateInfo_converter_free(VkBufferCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkImageViewCreateFlags_converter(PyObject* arg, VkImageViewCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkImageViewCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkImageViewCreateFlags_converter_free(VkImageViewCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkFramebufferCreateInfo_converter(PyObject* arg, VkFramebufferCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkFramebufferCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkFramebufferCreateInfo");
                return 0;
            }

            *val = ((PyVkFramebufferCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkFramebufferCreateInfo_converter_free(VkFramebufferCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkBufferImageCopy_converter(PyObject* arg, VkBufferImageCopy** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkBufferImageCopyType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkBufferImageCopy");
                return 0;
            }

            *val = ((PyVkBufferImageCopy*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkBufferImageCopy_converter_free(VkBufferImageCopy** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkCommandBufferResetFlags_converter(PyObject* arg, VkCommandBufferResetFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkCommandBufferResetFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkCommandBufferResetFlags_converter_free(VkCommandBufferResetFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkPushConstantRange_converter(PyObject* arg, VkPushConstantRange** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkPushConstantRange));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkPushConstantRangeType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkPushConstantRange");
                    return 0;
                }

                (*val)[i] = *(((PyVkPushConstantRange*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkPushConstantRange_converter_free(VkPushConstantRange** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkImageResolve_converter(PyObject* arg, VkImageResolve** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkImageResolveType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkImageResolve");
                return 0;
            }

            *val = ((PyVkImageResolve*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkImageResolve_converter_free(VkImageResolve** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkClearDepthStencilValue_converter(PyObject* arg, VkClearDepthStencilValue** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkClearDepthStencilValueType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkClearDepthStencilValue");
                return 0;
            }

            *val = ((PyVkClearDepthStencilValue*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkClearDepthStencilValue_converter_free(VkClearDepthStencilValue** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkSharingMode_converter(PyObject* arg, VkSharingMode* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkSharingMode) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkSharingMode_converter_free(VkSharingMode* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkCommandPoolCreateFlags_converter(PyObject* arg, VkCommandPoolCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkCommandPoolCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkCommandPoolCreateFlags_converter_free(VkCommandPoolCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_handle_base_VkDisplayKHR_converter(PyObject* arg, VkDisplayKHR* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkDisplayKHR* handle_pointer = PyCapsule_GetPointer(arg, "VkDisplayKHR");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkDisplayKHR_converter_free(VkDisplayKHR* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkImageCreateInfo_converter(PyObject* arg, VkImageCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkImageCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkImageCreateInfo");
                return 0;
            }

            *val = ((PyVkImageCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkImageCreateInfo_converter_free(VkImageCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkPipelineStageFlagBits_converter(PyObject* arg, VkPipelineStageFlagBits* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkPipelineStageFlagBits) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkPipelineStageFlagBits_converter_free(VkPipelineStageFlagBits* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkPipelineRasterizationStateCreateInfo_converter(PyObject* arg, VkPipelineRasterizationStateCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkPipelineRasterizationStateCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkPipelineRasterizationStateCreateInfo");
                return 0;
            }

            *val = ((PyVkPipelineRasterizationStateCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkPipelineRasterizationStateCreateInfo_converter_free(VkPipelineRasterizationStateCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkCommandBufferAllocateInfo_converter(PyObject* arg, VkCommandBufferAllocateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkCommandBufferAllocateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkCommandBufferAllocateInfo");
                return 0;
            }

            *val = ((PyVkCommandBufferAllocateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkCommandBufferAllocateInfo_converter_free(VkCommandBufferAllocateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkExternalMemoryFeatureFlagsNV_converter(PyObject* arg, VkExternalMemoryFeatureFlagsNV* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkExternalMemoryFeatureFlagsNV) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkExternalMemoryFeatureFlagsNV_converter_free(VkExternalMemoryFeatureFlagsNV* val) {}
        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkSparseImageMemoryBindInfo_converter(PyObject* arg, VkSparseImageMemoryBindInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkSparseImageMemoryBindInfo));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkSparseImageMemoryBindInfoType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkSparseImageMemoryBindInfo");
                    return 0;
                }

                (*val)[i] = *(((PyVkSparseImageMemoryBindInfo*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkSparseImageMemoryBindInfo_converter_free(VkSparseImageMemoryBindInfo** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkRasterizationOrderAMD_converter(PyObject* arg, VkRasterizationOrderAMD* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkRasterizationOrderAMD) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkRasterizationOrderAMD_converter_free(VkRasterizationOrderAMD* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkDescriptorImageInfo_converter(PyObject* arg, VkDescriptorImageInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkDescriptorImageInfo));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkDescriptorImageInfoType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkDescriptorImageInfo");
                    return 0;
                }

                (*val)[i] = *(((PyVkDescriptorImageInfo*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkDescriptorImageInfo_converter_free(VkDescriptorImageInfo** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkEventCreateFlags_converter(PyObject* arg, VkEventCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkEventCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkEventCreateFlags_converter_free(VkEventCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkInstanceCreateInfo_converter(PyObject* arg, VkInstanceCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkInstanceCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkInstanceCreateInfo");
                return 0;
            }

            *val = ((PyVkInstanceCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkInstanceCreateInfo_converter_free(VkInstanceCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkSpecializationInfo_converter(PyObject* arg, VkSpecializationInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkSpecializationInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkSpecializationInfo");
                return 0;
            }

            *val = ((PyVkSpecializationInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkSpecializationInfo_converter_free(VkSpecializationInfo** val) {}
        
    


        
    


    

    
    



    

    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkWin32SurfaceCreateInfoKHR_converter(PyObject* arg, VkWin32SurfaceCreateInfoKHR** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkWin32SurfaceCreateInfoKHRType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkWin32SurfaceCreateInfoKHR");
                return 0;
            }

            *val = ((PyVkWin32SurfaceCreateInfoKHR*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkWin32SurfaceCreateInfoKHR_converter_free(VkWin32SurfaceCreateInfoKHR** val) {}
        
    


        
    


    

    
     #endif 



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkBufferCreateFlags_converter(PyObject* arg, VkBufferCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkBufferCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkBufferCreateFlags_converter_free(VkBufferCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkDescriptorSetLayoutCreateFlags_converter(PyObject* arg, VkDescriptorSetLayoutCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkDescriptorSetLayoutCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkDescriptorSetLayoutCreateFlags_converter_free(VkDescriptorSetLayoutCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_struct_base_VkComponentMapping_converter(PyObject* arg, VkComponentMapping* val) {
            if (!PyObject_TypeCheck(arg, &PyVkComponentMappingType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkComponentMapping");
                return 0;
            }

            *val = *(((PyVkComponentMapping*)arg)->base);
            return 1;
        }
        static void pyc_struct_base_VkComponentMapping_converter_free(VkComponentMapping* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkSparseMemoryBindFlags_converter(PyObject* arg, VkSparseMemoryBindFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkSparseMemoryBindFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkSparseMemoryBindFlags_converter_free(VkSparseMemoryBindFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkPipelineVertexInputStateCreateFlags_converter(PyObject* arg, VkPipelineVertexInputStateCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkPipelineVertexInputStateCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkPipelineVertexInputStateCreateFlags_converter_free(VkPipelineVertexInputStateCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkStencilOp_converter(PyObject* arg, VkStencilOp* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkStencilOp) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkStencilOp_converter_free(VkStencilOp* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkPipelineVertexInputStateCreateInfo_converter(PyObject* arg, VkPipelineVertexInputStateCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkPipelineVertexInputStateCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkPipelineVertexInputStateCreateInfo");
                return 0;
            }

            *val = ((PyVkPipelineVertexInputStateCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkPipelineVertexInputStateCreateInfo_converter_free(VkPipelineVertexInputStateCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    
        
        // Specific ugly case
        // handle_array_VkDeviceMemory_converter is used only by Windows
        
        static int pyc_handle_array_VkSwapchainKHR_converter(PyObject* arg, VkSwapchainKHR** val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkSwapchainKHR));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                VkSwapchainKHR* handle_pointer = PyCapsule_GetPointer(PyList_GetItem(arg, i), "VkSwapchainKHR");
                if (handle_pointer == NULL) {
                    free(*val);
                    return 0;
                }

                (*val)[i] = *handle_pointer;
            }

            return 1;
        }
        static void pyc_handle_array_VkSwapchainKHR_converter_free(VkSwapchainKHR** val) {}
        
        
    


        
    


        
    
        
        static int pyc_handle_base_VkSwapchainKHR_converter(PyObject* arg, VkSwapchainKHR* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkSwapchainKHR* handle_pointer = PyCapsule_GetPointer(arg, "VkSwapchainKHR");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkSwapchainKHR_converter_free(VkSwapchainKHR* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkPipelineColorBlendStateCreateInfo_converter(PyObject* arg, VkPipelineColorBlendStateCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkPipelineColorBlendStateCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkPipelineColorBlendStateCreateInfo");
                return 0;
            }

            *val = ((PyVkPipelineColorBlendStateCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkPipelineColorBlendStateCreateInfo_converter_free(VkPipelineColorBlendStateCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkAccessFlags_converter(PyObject* arg, VkAccessFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkAccessFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkAccessFlags_converter_free(VkAccessFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkDebugReportObjectTypeEXT_converter(PyObject* arg, VkDebugReportObjectTypeEXT* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkDebugReportObjectTypeEXT) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkDebugReportObjectTypeEXT_converter_free(VkDebugReportObjectTypeEXT* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkClearRect_converter(PyObject* arg, VkClearRect** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkClearRectType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkClearRect");
                return 0;
            }

            *val = ((PyVkClearRect*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkClearRect_converter_free(VkClearRect** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_handle_base_VkDevice_converter(PyObject* arg, VkDevice* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkDevice* handle_pointer = PyCapsule_GetPointer(arg, "VkDevice");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkDevice_converter_free(VkDevice* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkSemaphoreCreateFlags_converter(PyObject* arg, VkSemaphoreCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkSemaphoreCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkSemaphoreCreateFlags_converter_free(VkSemaphoreCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkLogicOp_converter(PyObject* arg, VkLogicOp* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkLogicOp) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkLogicOp_converter_free(VkLogicOp* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkRenderPassCreateInfo_converter(PyObject* arg, VkRenderPassCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkRenderPassCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkRenderPassCreateInfo");
                return 0;
            }

            *val = ((PyVkRenderPassCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkRenderPassCreateInfo_converter_free(VkRenderPassCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    
        
        // Specific ugly case
        // handle_array_VkDeviceMemory_converter is used only by Windows
        
        static int pyc_handle_array_VkSampler_converter(PyObject* arg, VkSampler** val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkSampler));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                VkSampler* handle_pointer = PyCapsule_GetPointer(PyList_GetItem(arg, i), "VkSampler");
                if (handle_pointer == NULL) {
                    free(*val);
                    return 0;
                }

                (*val)[i] = *handle_pointer;
            }

            return 1;
        }
        static void pyc_handle_array_VkSampler_converter_free(VkSampler** val) {}
        
        
    


        
    


        
    
        
        static int pyc_handle_base_VkSampler_converter(PyObject* arg, VkSampler* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkSampler* handle_pointer = PyCapsule_GetPointer(arg, "VkSampler");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkSampler_converter_free(VkSampler* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_flag_pointer_VkDeviceSize_converter(PyObject* arg, VkDeviceSize** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            VkDeviceSize tmp = (VkDeviceSize) PyLong_AsLong(arg);

            if (PyErr_Occurred()) {
                return 0;
            }

            *val = malloc(sizeof(VkDeviceSize));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            memcpy(*val, &tmp, sizeof(VkDeviceSize));
            return 1;
        }
        static void pyc_flag_pointer_VkDeviceSize_converter_free(VkDeviceSize** val) {}
        
    


        
    
        
        static int pyc_flag_base_VkDeviceSize_converter(PyObject* arg, VkDeviceSize* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkDeviceSize) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkDeviceSize_converter_free(VkDeviceSize* val) {}
        
    


    

    
    



    

    
     #ifdef VK_USE_PLATFORM_XCB_KHR 
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkXcbSurfaceCreateInfoKHR_converter(PyObject* arg, VkXcbSurfaceCreateInfoKHR** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkXcbSurfaceCreateInfoKHRType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkXcbSurfaceCreateInfoKHR");
                return 0;
            }

            *val = ((PyVkXcbSurfaceCreateInfoKHR*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkXcbSurfaceCreateInfoKHR_converter_free(VkXcbSurfaceCreateInfoKHR** val) {}
        
    


        
    


    

    
     #endif 



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkBufferViewCreateInfo_converter(PyObject* arg, VkBufferViewCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkBufferViewCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkBufferViewCreateInfo");
                return 0;
            }

            *val = ((PyVkBufferViewCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkBufferViewCreateInfo_converter_free(VkBufferViewCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_struct_base_VkDisplayModeParametersKHR_converter(PyObject* arg, VkDisplayModeParametersKHR* val) {
            if (!PyObject_TypeCheck(arg, &PyVkDisplayModeParametersKHRType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkDisplayModeParametersKHR");
                return 0;
            }

            *val = *(((PyVkDisplayModeParametersKHR*)arg)->base);
            return 1;
        }
        static void pyc_struct_base_VkDisplayModeParametersKHR_converter_free(VkDisplayModeParametersKHR* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkSwapchainCreateFlagsKHR_converter(PyObject* arg, VkSwapchainCreateFlagsKHR* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkSwapchainCreateFlagsKHR) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkSwapchainCreateFlagsKHR_converter_free(VkSwapchainCreateFlagsKHR* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkDisplayModeCreateFlagsKHR_converter(PyObject* arg, VkDisplayModeCreateFlagsKHR* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkDisplayModeCreateFlagsKHR) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkDisplayModeCreateFlagsKHR_converter_free(VkDisplayModeCreateFlagsKHR* val) {}
        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkSubpassDependency_converter(PyObject* arg, VkSubpassDependency** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkSubpassDependency));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkSubpassDependencyType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkSubpassDependency");
                    return 0;
                }

                (*val)[i] = *(((PyVkSubpassDependency*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkSubpassDependency_converter_free(VkSubpassDependency** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    
        
        // Specific ugly case
        // handle_array_VkDeviceMemory_converter is used only by Windows
        
        static int pyc_handle_array_VkCommandBuffer_converter(PyObject* arg, VkCommandBuffer** val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkCommandBuffer));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                VkCommandBuffer* handle_pointer = PyCapsule_GetPointer(PyList_GetItem(arg, i), "VkCommandBuffer");
                if (handle_pointer == NULL) {
                    free(*val);
                    return 0;
                }

                (*val)[i] = *handle_pointer;
            }

            return 1;
        }
        static void pyc_handle_array_VkCommandBuffer_converter_free(VkCommandBuffer** val) {}
        
        
    


        
    
        
        static int pyc_handle_pointer_VkCommandBuffer_converter(PyObject* arg, VkCommandBuffer** val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkCommandBuffer* handle_pointer = PyCapsule_GetPointer(arg, "VkCommandBuffer");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = handle_pointer;
            return 1;
        }
        static void pyc_handle_pointer_VkCommandBuffer_converter_free(VkCommandBuffer** val) {}
        
    


        
    
        
        static int pyc_handle_base_VkCommandBuffer_converter(PyObject* arg, VkCommandBuffer* val) {
            if (arg == Py_None) {
                *val = VK_NULL_HANDLE;
                return 1;
            }

            VkCommandBuffer* handle_pointer = PyCapsule_GetPointer(arg, "VkCommandBuffer");
            if (handle_pointer == NULL) {
                return 0;
            }

            *val = *handle_pointer;
            return 1;
        }
        static void pyc_handle_base_VkCommandBuffer_converter_free(VkCommandBuffer* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkDebugReportCallbackCreateInfoEXT_converter(PyObject* arg, VkDebugReportCallbackCreateInfoEXT** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkDebugReportCallbackCreateInfoEXTType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkDebugReportCallbackCreateInfoEXT");
                return 0;
            }

            *val = ((PyVkDebugReportCallbackCreateInfoEXT*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkDebugReportCallbackCreateInfoEXT_converter_free(VkDebugReportCallbackCreateInfoEXT** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkShaderStageFlagBits_converter(PyObject* arg, VkShaderStageFlagBits* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkShaderStageFlagBits) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkShaderStageFlagBits_converter_free(VkShaderStageFlagBits* val) {}
        
    


    

    
    



    

    
     #ifdef VK_USE_PLATFORM_MIR_KHR 
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkMirSurfaceCreateInfoKHR_converter(PyObject* arg, VkMirSurfaceCreateInfoKHR** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkMirSurfaceCreateInfoKHRType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkMirSurfaceCreateInfoKHR");
                return 0;
            }

            *val = ((PyVkMirSurfaceCreateInfoKHR*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkMirSurfaceCreateInfoKHR_converter_free(VkMirSurfaceCreateInfoKHR** val) {}
        
    


        
    


    

    
     #endif 



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkImageBlit_converter(PyObject* arg, VkImageBlit** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkImageBlitType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkImageBlit");
                return 0;
            }

            *val = ((PyVkImageBlit*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkImageBlit_converter_free(VkImageBlit** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkPrimitiveTopology_converter(PyObject* arg, VkPrimitiveTopology* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkPrimitiveTopology) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkPrimitiveTopology_converter_free(VkPrimitiveTopology* val) {}
        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkViewport_converter(PyObject* arg, VkViewport** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkViewport));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkViewportType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkViewport");
                    return 0;
                }

                (*val)[i] = *(((PyVkViewport*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkViewport_converter_free(VkViewport** val) {}
        
    


        
    
        
        static int pyc_struct_pointer_VkViewport_converter(PyObject* arg, VkViewport** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkViewportType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkViewport");
                return 0;
            }

            *val = ((PyVkViewport*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkViewport_converter_free(VkViewport** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkSparseImageOpaqueMemoryBindInfo_converter(PyObject* arg, VkSparseImageOpaqueMemoryBindInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkSparseImageOpaqueMemoryBindInfo));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkSparseImageOpaqueMemoryBindInfoType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkSparseImageOpaqueMemoryBindInfo");
                    return 0;
                }

                (*val)[i] = *(((PyVkSparseImageOpaqueMemoryBindInfo*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkSparseImageOpaqueMemoryBindInfo_converter_free(VkSparseImageOpaqueMemoryBindInfo** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkDebugMarkerObjectNameInfoEXT_converter(PyObject* arg, VkDebugMarkerObjectNameInfoEXT** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkDebugMarkerObjectNameInfoEXTType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkDebugMarkerObjectNameInfoEXT");
                return 0;
            }

            *val = ((PyVkDebugMarkerObjectNameInfoEXT*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkDebugMarkerObjectNameInfoEXT_converter_free(VkDebugMarkerObjectNameInfoEXT** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkImageTiling_converter(PyObject* arg, VkImageTiling* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkImageTiling) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkImageTiling_converter_free(VkImageTiling* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkPipelineShaderStageCreateFlags_converter(PyObject* arg, VkPipelineShaderStageCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkPipelineShaderStageCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkPipelineShaderStageCreateFlags_converter_free(VkPipelineShaderStageCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkMemoryAllocateInfo_converter(PyObject* arg, VkMemoryAllocateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkMemoryAllocateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkMemoryAllocateInfo");
                return 0;
            }

            *val = ((PyVkMemoryAllocateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkMemoryAllocateInfo_converter_free(VkMemoryAllocateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkImageLayout_converter(PyObject* arg, VkImageLayout* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkImageLayout) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkImageLayout_converter_free(VkImageLayout* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkCopyDescriptorSet_converter(PyObject* arg, VkCopyDescriptorSet** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkCopyDescriptorSetType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkCopyDescriptorSet");
                return 0;
            }

            *val = ((PyVkCopyDescriptorSet*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkCopyDescriptorSet_converter_free(VkCopyDescriptorSet** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkSamplerMipmapMode_converter(PyObject* arg, VkSamplerMipmapMode* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkSamplerMipmapMode) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkSamplerMipmapMode_converter_free(VkSamplerMipmapMode* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkCommandBufferBeginInfo_converter(PyObject* arg, VkCommandBufferBeginInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkCommandBufferBeginInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkCommandBufferBeginInfo");
                return 0;
            }

            *val = ((PyVkCommandBufferBeginInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkCommandBufferBeginInfo_converter_free(VkCommandBufferBeginInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkPipelineDepthStencilStateCreateInfo_converter(PyObject* arg, VkPipelineDepthStencilStateCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkPipelineDepthStencilStateCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkPipelineDepthStencilStateCreateInfo");
                return 0;
            }

            *val = ((PyVkPipelineDepthStencilStateCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkPipelineDepthStencilStateCreateInfo_converter_free(VkPipelineDepthStencilStateCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_struct_base_VkImageSubresourceLayers_converter(PyObject* arg, VkImageSubresourceLayers* val) {
            if (!PyObject_TypeCheck(arg, &PyVkImageSubresourceLayersType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkImageSubresourceLayers");
                return 0;
            }

            *val = *(((PyVkImageSubresourceLayers*)arg)->base);
            return 1;
        }
        static void pyc_struct_base_VkImageSubresourceLayers_converter_free(VkImageSubresourceLayers* val) {}
        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkSparseMemoryBind_converter(PyObject* arg, VkSparseMemoryBind** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkSparseMemoryBind));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkSparseMemoryBindType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkSparseMemoryBind");
                    return 0;
                }

                (*val)[i] = *(((PyVkSparseMemoryBind*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkSparseMemoryBind_converter_free(VkSparseMemoryBind** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_flag_array_VkSampleMask_converter(PyObject* arg, VkSampleMask** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkSampleMask));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyLong_Check(item)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                    return 0;
                }

                VkSampleMask tmp = (VkSampleMask) PyLong_AsLong(item);
                if (PyErr_Occurred()) {
                    free(*val);
                    return 0;
                }

                (*val)[i] = tmp;
            }
            return 1;
        }
        static void pyc_flag_array_VkSampleMask_converter_free(VkSampleMask** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkComputePipelineCreateInfo_converter(PyObject* arg, VkComputePipelineCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkComputePipelineCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkComputePipelineCreateInfo");
                return 0;
            }

            *val = ((PyVkComputePipelineCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkComputePipelineCreateInfo_converter_free(VkComputePipelineCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkDisplaySurfaceCreateFlagsKHR_converter(PyObject* arg, VkDisplaySurfaceCreateFlagsKHR* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkDisplaySurfaceCreateFlagsKHR) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkDisplaySurfaceCreateFlagsKHR_converter_free(VkDisplaySurfaceCreateFlagsKHR* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkAttachmentLoadOp_converter(PyObject* arg, VkAttachmentLoadOp* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkAttachmentLoadOp) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkAttachmentLoadOp_converter_free(VkAttachmentLoadOp* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkDebugMarkerMarkerInfoEXT_converter(PyObject* arg, VkDebugMarkerMarkerInfoEXT** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkDebugMarkerMarkerInfoEXTType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkDebugMarkerMarkerInfoEXT");
                return 0;
            }

            *val = ((PyVkDebugMarkerMarkerInfoEXT*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkDebugMarkerMarkerInfoEXT_converter_free(VkDebugMarkerMarkerInfoEXT** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkFormat_converter(PyObject* arg, VkFormat* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkFormat) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkFormat_converter_free(VkFormat* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkDisplayModeCreateInfoKHR_converter(PyObject* arg, VkDisplayModeCreateInfoKHR** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkDisplayModeCreateInfoKHRType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkDisplayModeCreateInfoKHR");
                return 0;
            }

            *val = ((PyVkDisplayModeCreateInfoKHR*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkDisplayModeCreateInfoKHR_converter_free(VkDisplayModeCreateInfoKHR** val) {}
        
    


        
    


    

    
    



    

    
     #ifdef VK_USE_PLATFORM_MIR_KHR 
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkMirSurfaceCreateFlagsKHR_converter(PyObject* arg, VkMirSurfaceCreateFlagsKHR* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkMirSurfaceCreateFlagsKHR) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkMirSurfaceCreateFlagsKHR_converter_free(VkMirSurfaceCreateFlagsKHR* val) {}
        
    


    

    
     #endif 



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkFrontFace_converter(PyObject* arg, VkFrontFace* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkFrontFace) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkFrontFace_converter_free(VkFrontFace* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkBlendOp_converter(PyObject* arg, VkBlendOp* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkBlendOp) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkBlendOp_converter_free(VkBlendOp* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkDebugMarkerObjectTagInfoEXT_converter(PyObject* arg, VkDebugMarkerObjectTagInfoEXT** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkDebugMarkerObjectTagInfoEXTType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkDebugMarkerObjectTagInfoEXT");
                return 0;
            }

            *val = ((PyVkDebugMarkerObjectTagInfoEXT*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkDebugMarkerObjectTagInfoEXT_converter_free(VkDebugMarkerObjectTagInfoEXT** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkPipelineDynamicStateCreateFlags_converter(PyObject* arg, VkPipelineDynamicStateCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkPipelineDynamicStateCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkPipelineDynamicStateCreateFlags_converter_free(VkPipelineDynamicStateCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkImageMemoryBarrier_converter(PyObject* arg, VkImageMemoryBarrier** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkImageMemoryBarrierType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkImageMemoryBarrier");
                return 0;
            }

            *val = ((PyVkImageMemoryBarrier*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkImageMemoryBarrier_converter_free(VkImageMemoryBarrier** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkDescriptorType_converter(PyObject* arg, VkDescriptorType* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkDescriptorType) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkDescriptorType_converter_free(VkDescriptorType* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkStructureType_converter(PyObject* arg, VkStructureType* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkStructureType) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkStructureType_converter_free(VkStructureType* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkCommandBufferUsageFlags_converter(PyObject* arg, VkCommandBufferUsageFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkCommandBufferUsageFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkCommandBufferUsageFlags_converter_free(VkCommandBufferUsageFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkSparseImageMemoryBind_converter(PyObject* arg, VkSparseImageMemoryBind** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkSparseImageMemoryBind));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkSparseImageMemoryBindType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkSparseImageMemoryBind");
                    return 0;
                }

                (*val)[i] = *(((PyVkSparseImageMemoryBind*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkSparseImageMemoryBind_converter_free(VkSparseImageMemoryBind** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkPipelineCreateFlags_converter(PyObject* arg, VkPipelineCreateFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkPipelineCreateFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkPipelineCreateFlags_converter_free(VkPipelineCreateFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkDisplaySurfaceCreateInfoKHR_converter(PyObject* arg, VkDisplaySurfaceCreateInfoKHR** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkDisplaySurfaceCreateInfoKHRType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkDisplaySurfaceCreateInfoKHR");
                return 0;
            }

            *val = ((PyVkDisplaySurfaceCreateInfoKHR*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkDisplaySurfaceCreateInfoKHR_converter_free(VkDisplaySurfaceCreateInfoKHR** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkDependencyFlags_converter(PyObject* arg, VkDependencyFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkDependencyFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkDependencyFlags_converter_free(VkDependencyFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkStencilFaceFlags_converter(PyObject* arg, VkStencilFaceFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkStencilFaceFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkStencilFaceFlags_converter_free(VkStencilFaceFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkPipelineTessellationStateCreateInfo_converter(PyObject* arg, VkPipelineTessellationStateCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkPipelineTessellationStateCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkPipelineTessellationStateCreateInfo");
                return 0;
            }

            *val = ((PyVkPipelineTessellationStateCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkPipelineTessellationStateCreateInfo_converter_free(VkPipelineTessellationStateCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkPipelineDynamicStateCreateInfo_converter(PyObject* arg, VkPipelineDynamicStateCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkPipelineDynamicStateCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkPipelineDynamicStateCreateInfo");
                return 0;
            }

            *val = ((PyVkPipelineDynamicStateCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkPipelineDynamicStateCreateInfo_converter_free(VkPipelineDynamicStateCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkBufferCopy_converter(PyObject* arg, VkBufferCopy** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkBufferCopyType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkBufferCopy");
                return 0;
            }

            *val = ((PyVkBufferCopy*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkBufferCopy_converter_free(VkBufferCopy** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkCommandPoolCreateInfo_converter(PyObject* arg, VkCommandPoolCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkCommandPoolCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkCommandPoolCreateInfo");
                return 0;
            }

            *val = ((PyVkCommandPoolCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkCommandPoolCreateInfo_converter_free(VkCommandPoolCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkQueryPoolCreateInfo_converter(PyObject* arg, VkQueryPoolCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkQueryPoolCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkQueryPoolCreateInfo");
                return 0;
            }

            *val = ((PyVkQueryPoolCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkQueryPoolCreateInfo_converter_free(VkQueryPoolCreateInfo** val) {}
        
    


        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_flag_array_VkDynamicState_converter(PyObject* arg, VkDynamicState** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkDynamicState));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyLong_Check(item)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                    return 0;
                }

                VkDynamicState tmp = (VkDynamicState) PyLong_AsLong(item);
                if (PyErr_Occurred()) {
                    free(*val);
                    return 0;
                }

                (*val)[i] = tmp;
            }
            return 1;
        }
        static void pyc_flag_array_VkDynamicState_converter_free(VkDynamicState** val) {}
        
    


        
    


        
    


    

    
    



    

    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkWin32SurfaceCreateFlagsKHR_converter(PyObject* arg, VkWin32SurfaceCreateFlagsKHR* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkWin32SurfaceCreateFlagsKHR) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkWin32SurfaceCreateFlagsKHR_converter_free(VkWin32SurfaceCreateFlagsKHR* val) {}
        
    


    

    
     #endif 



    

    
    
        

    

        
    


        
    


        
    
        
        static int pyc_flag_base_VkColorComponentFlags_converter(PyObject* arg, VkColorComponentFlags* val) {
            if (!PyLong_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be an integer");
                return 0;
            }

            *val = (VkColorComponentFlags) PyLong_AsLong(arg);
            if (PyErr_Occurred()) {
                return 0;
            }

            return 1;
        }
        static void pyc_flag_base_VkColorComponentFlags_converter_free(VkColorComponentFlags* val) {}
        
    


    

    
    



    

    
    
        

    

        
    
        
        static int pyc_struct_array_VkSparseBufferMemoryBindInfo_converter(PyObject* arg, VkSparseBufferMemoryBindInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyList_Check(arg)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a list");
                return 0;
            }

            int size = PyList_Size(arg);
            *val = malloc(size * sizeof(VkSparseBufferMemoryBindInfo));
            if (*val == NULL) {
                PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory");
                return 0;
            }

            int i;
            for (i = 0; i < size; i++) {
                PyObject* item = PyList_GetItem(arg, i);
                if (item == NULL) {
                    free(*val);
                    return 0;
                }

                if (!PyObject_TypeCheck(item, &PyVkSparseBufferMemoryBindInfoType)) {
                    free(*val);
                    PyErr_SetString(PyExc_TypeError, "Argument must be a list of VkSparseBufferMemoryBindInfo");
                    return 0;
                }

                (*val)[i] = *(((PyVkSparseBufferMemoryBindInfo*) item)->base);
            }

            return 1;
        }

        static void pyc_struct_array_VkSparseBufferMemoryBindInfo_converter_free(VkSparseBufferMemoryBindInfo** val) {}
        
    


        
    


        
    


    

    
    



    

    
    
        

    

        
    


        
    
        
        static int pyc_struct_pointer_VkDescriptorPoolCreateInfo_converter(PyObject* arg, VkDescriptorPoolCreateInfo** val) {
            if (arg == Py_None) {
                *val = NULL;
                return 1;
            }

            if (!PyObject_TypeCheck(arg, &PyVkDescriptorPoolCreateInfoType)) {
                PyErr_SetString(PyExc_TypeError, "Argument must be a VkDescriptorPoolCreateInfo");
                return 0;
            }

            *val = ((PyVkDescriptorPoolCreateInfo*)arg)->base;
            return 1;
        }
        static void pyc_struct_pointer_VkDescriptorPoolCreateInfo_converter_free(VkDescriptorPoolCreateInfo** val) {}
        
    


        
    


    

    
    





// ---------------
// DECLARE CUSTOM STRUCTS
// ---------------
static void PyVkDebugReportCallbackCreateInfoEXT_del(PyVkDebugReportCallbackCreateInfoEXT* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDebugReportCallbackCreateInfoEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDebugReportCallbackCreateInfoEXT *self;
    self = (PyVkDebugReportCallbackCreateInfoEXT *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDebugReportCallbackCreateInfoEXT));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDebugReportCallbackCreateInfoEXT");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject *python_debug_callback = NULL;
static VKAPI_ATTR VkBool32 VKAPI_CALL debug_callback(
    VkDebugReportFlagsEXT flags,
    VkDebugReportObjectTypeEXT objType,
    uint64_t obj,
    size_t location,
    int32_t code,
    const char* layerPrefix,
    const char* msg,
    void* userData) {
    PyObject_CallFunction(python_debug_callback, "iiKIisss", flags,
                          objType, obj, location, code, layerPrefix, msg, NULL);
    return VK_FALSE;
}

static int
PyVkDebugReportCallbackCreateInfoEXT_init(
    PyVkDebugReportCallbackCreateInfoEXT *self, PyObject *args,
    PyObject *kwds) {
    int sType;
    int flags;
    PyObject* tmp = NULL;
    static char *kwlist[] = {"sType", "flags","pfnCallback",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "iiO", kwlist,
                                    &sType, &flags, &tmp))
        return -1;

    if (!PyCallable_Check(tmp)) {
        PyErr_SetString(PyExc_TypeError,
                        "pfnCallback must be callable");
        return -1;
    }
    // Renew callback
    Py_INCREF(tmp);
    Py_XDECREF(python_debug_callback);
    python_debug_callback = tmp;

    (self->base)->sType = sType;
    (self->base)->pNext = NULL;
    (self->base)->pUserData = NULL;
    (self->base)->flags = flags;
    (self->base)->pfnCallback =
        (PFN_vkDebugReportCallbackEXT)(&debug_callback);

    return 0;
}



// ---------------
// CREATE SDK LOADER FUNCTION
// ---------------
static int init_import_sdk(void) {
    void* vk_sdk = LOAD_SDK();
    if (vk_sdk == NULL) {
        PyErr_SetString(PyExc_ImportError, "Can't find vulkan sdk");
        return 0;
    }

    
        vkCreateInstance = (PFN_vkCreateInstance)dlsym(vk_sdk, "vkCreateInstance");
        if (vkCreateInstance == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreateInstance in sdk");
            return 0;
        }
    
        vkDestroyInstance = (PFN_vkDestroyInstance)dlsym(vk_sdk, "vkDestroyInstance");
        if (vkDestroyInstance == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroyInstance in sdk");
            return 0;
        }
    
        vkEnumeratePhysicalDevices = (PFN_vkEnumeratePhysicalDevices)dlsym(vk_sdk, "vkEnumeratePhysicalDevices");
        if (vkEnumeratePhysicalDevices == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkEnumeratePhysicalDevices in sdk");
            return 0;
        }
    
        vkGetPhysicalDeviceProperties = (PFN_vkGetPhysicalDeviceProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceProperties");
        if (vkGetPhysicalDeviceProperties == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetPhysicalDeviceProperties in sdk");
            return 0;
        }
    
        vkGetPhysicalDeviceQueueFamilyProperties = (PFN_vkGetPhysicalDeviceQueueFamilyProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceQueueFamilyProperties");
        if (vkGetPhysicalDeviceQueueFamilyProperties == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetPhysicalDeviceQueueFamilyProperties in sdk");
            return 0;
        }
    
        vkGetPhysicalDeviceMemoryProperties = (PFN_vkGetPhysicalDeviceMemoryProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceMemoryProperties");
        if (vkGetPhysicalDeviceMemoryProperties == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetPhysicalDeviceMemoryProperties in sdk");
            return 0;
        }
    
        vkGetPhysicalDeviceFeatures = (PFN_vkGetPhysicalDeviceFeatures)dlsym(vk_sdk, "vkGetPhysicalDeviceFeatures");
        if (vkGetPhysicalDeviceFeatures == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetPhysicalDeviceFeatures in sdk");
            return 0;
        }
    
        vkGetPhysicalDeviceFormatProperties = (PFN_vkGetPhysicalDeviceFormatProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceFormatProperties");
        if (vkGetPhysicalDeviceFormatProperties == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetPhysicalDeviceFormatProperties in sdk");
            return 0;
        }
    
        vkGetPhysicalDeviceImageFormatProperties = (PFN_vkGetPhysicalDeviceImageFormatProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceImageFormatProperties");
        if (vkGetPhysicalDeviceImageFormatProperties == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetPhysicalDeviceImageFormatProperties in sdk");
            return 0;
        }
    
        vkCreateDevice = (PFN_vkCreateDevice)dlsym(vk_sdk, "vkCreateDevice");
        if (vkCreateDevice == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreateDevice in sdk");
            return 0;
        }
    
        vkDestroyDevice = (PFN_vkDestroyDevice)dlsym(vk_sdk, "vkDestroyDevice");
        if (vkDestroyDevice == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroyDevice in sdk");
            return 0;
        }
    
        vkEnumerateInstanceLayerProperties = (PFN_vkEnumerateInstanceLayerProperties)dlsym(vk_sdk, "vkEnumerateInstanceLayerProperties");
        if (vkEnumerateInstanceLayerProperties == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkEnumerateInstanceLayerProperties in sdk");
            return 0;
        }
    
        vkEnumerateInstanceExtensionProperties = (PFN_vkEnumerateInstanceExtensionProperties)dlsym(vk_sdk, "vkEnumerateInstanceExtensionProperties");
        if (vkEnumerateInstanceExtensionProperties == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkEnumerateInstanceExtensionProperties in sdk");
            return 0;
        }
    
        vkEnumerateDeviceLayerProperties = (PFN_vkEnumerateDeviceLayerProperties)dlsym(vk_sdk, "vkEnumerateDeviceLayerProperties");
        if (vkEnumerateDeviceLayerProperties == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkEnumerateDeviceLayerProperties in sdk");
            return 0;
        }
    
        vkEnumerateDeviceExtensionProperties = (PFN_vkEnumerateDeviceExtensionProperties)dlsym(vk_sdk, "vkEnumerateDeviceExtensionProperties");
        if (vkEnumerateDeviceExtensionProperties == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkEnumerateDeviceExtensionProperties in sdk");
            return 0;
        }
    
        vkGetDeviceQueue = (PFN_vkGetDeviceQueue)dlsym(vk_sdk, "vkGetDeviceQueue");
        if (vkGetDeviceQueue == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetDeviceQueue in sdk");
            return 0;
        }
    
        vkQueueSubmit = (PFN_vkQueueSubmit)dlsym(vk_sdk, "vkQueueSubmit");
        if (vkQueueSubmit == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkQueueSubmit in sdk");
            return 0;
        }
    
        vkQueueWaitIdle = (PFN_vkQueueWaitIdle)dlsym(vk_sdk, "vkQueueWaitIdle");
        if (vkQueueWaitIdle == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkQueueWaitIdle in sdk");
            return 0;
        }
    
        vkDeviceWaitIdle = (PFN_vkDeviceWaitIdle)dlsym(vk_sdk, "vkDeviceWaitIdle");
        if (vkDeviceWaitIdle == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDeviceWaitIdle in sdk");
            return 0;
        }
    
        vkAllocateMemory = (PFN_vkAllocateMemory)dlsym(vk_sdk, "vkAllocateMemory");
        if (vkAllocateMemory == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkAllocateMemory in sdk");
            return 0;
        }
    
        vkFreeMemory = (PFN_vkFreeMemory)dlsym(vk_sdk, "vkFreeMemory");
        if (vkFreeMemory == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkFreeMemory in sdk");
            return 0;
        }
    
        vkUnmapMemory = (PFN_vkUnmapMemory)dlsym(vk_sdk, "vkUnmapMemory");
        if (vkUnmapMemory == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkUnmapMemory in sdk");
            return 0;
        }
    
        vkFlushMappedMemoryRanges = (PFN_vkFlushMappedMemoryRanges)dlsym(vk_sdk, "vkFlushMappedMemoryRanges");
        if (vkFlushMappedMemoryRanges == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkFlushMappedMemoryRanges in sdk");
            return 0;
        }
    
        vkInvalidateMappedMemoryRanges = (PFN_vkInvalidateMappedMemoryRanges)dlsym(vk_sdk, "vkInvalidateMappedMemoryRanges");
        if (vkInvalidateMappedMemoryRanges == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkInvalidateMappedMemoryRanges in sdk");
            return 0;
        }
    
        vkGetDeviceMemoryCommitment = (PFN_vkGetDeviceMemoryCommitment)dlsym(vk_sdk, "vkGetDeviceMemoryCommitment");
        if (vkGetDeviceMemoryCommitment == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetDeviceMemoryCommitment in sdk");
            return 0;
        }
    
        vkGetBufferMemoryRequirements = (PFN_vkGetBufferMemoryRequirements)dlsym(vk_sdk, "vkGetBufferMemoryRequirements");
        if (vkGetBufferMemoryRequirements == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetBufferMemoryRequirements in sdk");
            return 0;
        }
    
        vkBindBufferMemory = (PFN_vkBindBufferMemory)dlsym(vk_sdk, "vkBindBufferMemory");
        if (vkBindBufferMemory == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkBindBufferMemory in sdk");
            return 0;
        }
    
        vkGetImageMemoryRequirements = (PFN_vkGetImageMemoryRequirements)dlsym(vk_sdk, "vkGetImageMemoryRequirements");
        if (vkGetImageMemoryRequirements == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetImageMemoryRequirements in sdk");
            return 0;
        }
    
        vkBindImageMemory = (PFN_vkBindImageMemory)dlsym(vk_sdk, "vkBindImageMemory");
        if (vkBindImageMemory == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkBindImageMemory in sdk");
            return 0;
        }
    
        vkGetImageSparseMemoryRequirements = (PFN_vkGetImageSparseMemoryRequirements)dlsym(vk_sdk, "vkGetImageSparseMemoryRequirements");
        if (vkGetImageSparseMemoryRequirements == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetImageSparseMemoryRequirements in sdk");
            return 0;
        }
    
        vkGetPhysicalDeviceSparseImageFormatProperties = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceSparseImageFormatProperties");
        if (vkGetPhysicalDeviceSparseImageFormatProperties == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetPhysicalDeviceSparseImageFormatProperties in sdk");
            return 0;
        }
    
        vkQueueBindSparse = (PFN_vkQueueBindSparse)dlsym(vk_sdk, "vkQueueBindSparse");
        if (vkQueueBindSparse == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkQueueBindSparse in sdk");
            return 0;
        }
    
        vkCreateFence = (PFN_vkCreateFence)dlsym(vk_sdk, "vkCreateFence");
        if (vkCreateFence == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreateFence in sdk");
            return 0;
        }
    
        vkDestroyFence = (PFN_vkDestroyFence)dlsym(vk_sdk, "vkDestroyFence");
        if (vkDestroyFence == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroyFence in sdk");
            return 0;
        }
    
        vkResetFences = (PFN_vkResetFences)dlsym(vk_sdk, "vkResetFences");
        if (vkResetFences == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkResetFences in sdk");
            return 0;
        }
    
        vkGetFenceStatus = (PFN_vkGetFenceStatus)dlsym(vk_sdk, "vkGetFenceStatus");
        if (vkGetFenceStatus == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetFenceStatus in sdk");
            return 0;
        }
    
        vkWaitForFences = (PFN_vkWaitForFences)dlsym(vk_sdk, "vkWaitForFences");
        if (vkWaitForFences == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkWaitForFences in sdk");
            return 0;
        }
    
        vkCreateSemaphore = (PFN_vkCreateSemaphore)dlsym(vk_sdk, "vkCreateSemaphore");
        if (vkCreateSemaphore == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreateSemaphore in sdk");
            return 0;
        }
    
        vkDestroySemaphore = (PFN_vkDestroySemaphore)dlsym(vk_sdk, "vkDestroySemaphore");
        if (vkDestroySemaphore == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroySemaphore in sdk");
            return 0;
        }
    
        vkCreateEvent = (PFN_vkCreateEvent)dlsym(vk_sdk, "vkCreateEvent");
        if (vkCreateEvent == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreateEvent in sdk");
            return 0;
        }
    
        vkDestroyEvent = (PFN_vkDestroyEvent)dlsym(vk_sdk, "vkDestroyEvent");
        if (vkDestroyEvent == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroyEvent in sdk");
            return 0;
        }
    
        vkGetEventStatus = (PFN_vkGetEventStatus)dlsym(vk_sdk, "vkGetEventStatus");
        if (vkGetEventStatus == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetEventStatus in sdk");
            return 0;
        }
    
        vkSetEvent = (PFN_vkSetEvent)dlsym(vk_sdk, "vkSetEvent");
        if (vkSetEvent == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkSetEvent in sdk");
            return 0;
        }
    
        vkResetEvent = (PFN_vkResetEvent)dlsym(vk_sdk, "vkResetEvent");
        if (vkResetEvent == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkResetEvent in sdk");
            return 0;
        }
    
        vkCreateQueryPool = (PFN_vkCreateQueryPool)dlsym(vk_sdk, "vkCreateQueryPool");
        if (vkCreateQueryPool == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreateQueryPool in sdk");
            return 0;
        }
    
        vkDestroyQueryPool = (PFN_vkDestroyQueryPool)dlsym(vk_sdk, "vkDestroyQueryPool");
        if (vkDestroyQueryPool == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroyQueryPool in sdk");
            return 0;
        }
    
        vkGetQueryPoolResults = (PFN_vkGetQueryPoolResults)dlsym(vk_sdk, "vkGetQueryPoolResults");
        if (vkGetQueryPoolResults == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetQueryPoolResults in sdk");
            return 0;
        }
    
        vkCreateBuffer = (PFN_vkCreateBuffer)dlsym(vk_sdk, "vkCreateBuffer");
        if (vkCreateBuffer == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreateBuffer in sdk");
            return 0;
        }
    
        vkDestroyBuffer = (PFN_vkDestroyBuffer)dlsym(vk_sdk, "vkDestroyBuffer");
        if (vkDestroyBuffer == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroyBuffer in sdk");
            return 0;
        }
    
        vkCreateBufferView = (PFN_vkCreateBufferView)dlsym(vk_sdk, "vkCreateBufferView");
        if (vkCreateBufferView == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreateBufferView in sdk");
            return 0;
        }
    
        vkDestroyBufferView = (PFN_vkDestroyBufferView)dlsym(vk_sdk, "vkDestroyBufferView");
        if (vkDestroyBufferView == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroyBufferView in sdk");
            return 0;
        }
    
        vkCreateImage = (PFN_vkCreateImage)dlsym(vk_sdk, "vkCreateImage");
        if (vkCreateImage == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreateImage in sdk");
            return 0;
        }
    
        vkDestroyImage = (PFN_vkDestroyImage)dlsym(vk_sdk, "vkDestroyImage");
        if (vkDestroyImage == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroyImage in sdk");
            return 0;
        }
    
        vkGetImageSubresourceLayout = (PFN_vkGetImageSubresourceLayout)dlsym(vk_sdk, "vkGetImageSubresourceLayout");
        if (vkGetImageSubresourceLayout == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetImageSubresourceLayout in sdk");
            return 0;
        }
    
        vkCreateImageView = (PFN_vkCreateImageView)dlsym(vk_sdk, "vkCreateImageView");
        if (vkCreateImageView == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreateImageView in sdk");
            return 0;
        }
    
        vkDestroyImageView = (PFN_vkDestroyImageView)dlsym(vk_sdk, "vkDestroyImageView");
        if (vkDestroyImageView == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroyImageView in sdk");
            return 0;
        }
    
        vkCreateShaderModule = (PFN_vkCreateShaderModule)dlsym(vk_sdk, "vkCreateShaderModule");
        if (vkCreateShaderModule == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreateShaderModule in sdk");
            return 0;
        }
    
        vkDestroyShaderModule = (PFN_vkDestroyShaderModule)dlsym(vk_sdk, "vkDestroyShaderModule");
        if (vkDestroyShaderModule == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroyShaderModule in sdk");
            return 0;
        }
    
        vkCreatePipelineCache = (PFN_vkCreatePipelineCache)dlsym(vk_sdk, "vkCreatePipelineCache");
        if (vkCreatePipelineCache == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreatePipelineCache in sdk");
            return 0;
        }
    
        vkDestroyPipelineCache = (PFN_vkDestroyPipelineCache)dlsym(vk_sdk, "vkDestroyPipelineCache");
        if (vkDestroyPipelineCache == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroyPipelineCache in sdk");
            return 0;
        }
    
        vkMergePipelineCaches = (PFN_vkMergePipelineCaches)dlsym(vk_sdk, "vkMergePipelineCaches");
        if (vkMergePipelineCaches == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkMergePipelineCaches in sdk");
            return 0;
        }
    
        vkCreateGraphicsPipelines = (PFN_vkCreateGraphicsPipelines)dlsym(vk_sdk, "vkCreateGraphicsPipelines");
        if (vkCreateGraphicsPipelines == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreateGraphicsPipelines in sdk");
            return 0;
        }
    
        vkCreateComputePipelines = (PFN_vkCreateComputePipelines)dlsym(vk_sdk, "vkCreateComputePipelines");
        if (vkCreateComputePipelines == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreateComputePipelines in sdk");
            return 0;
        }
    
        vkDestroyPipeline = (PFN_vkDestroyPipeline)dlsym(vk_sdk, "vkDestroyPipeline");
        if (vkDestroyPipeline == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroyPipeline in sdk");
            return 0;
        }
    
        vkCreatePipelineLayout = (PFN_vkCreatePipelineLayout)dlsym(vk_sdk, "vkCreatePipelineLayout");
        if (vkCreatePipelineLayout == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreatePipelineLayout in sdk");
            return 0;
        }
    
        vkDestroyPipelineLayout = (PFN_vkDestroyPipelineLayout)dlsym(vk_sdk, "vkDestroyPipelineLayout");
        if (vkDestroyPipelineLayout == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroyPipelineLayout in sdk");
            return 0;
        }
    
        vkCreateSampler = (PFN_vkCreateSampler)dlsym(vk_sdk, "vkCreateSampler");
        if (vkCreateSampler == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreateSampler in sdk");
            return 0;
        }
    
        vkDestroySampler = (PFN_vkDestroySampler)dlsym(vk_sdk, "vkDestroySampler");
        if (vkDestroySampler == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroySampler in sdk");
            return 0;
        }
    
        vkCreateDescriptorSetLayout = (PFN_vkCreateDescriptorSetLayout)dlsym(vk_sdk, "vkCreateDescriptorSetLayout");
        if (vkCreateDescriptorSetLayout == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreateDescriptorSetLayout in sdk");
            return 0;
        }
    
        vkDestroyDescriptorSetLayout = (PFN_vkDestroyDescriptorSetLayout)dlsym(vk_sdk, "vkDestroyDescriptorSetLayout");
        if (vkDestroyDescriptorSetLayout == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroyDescriptorSetLayout in sdk");
            return 0;
        }
    
        vkCreateDescriptorPool = (PFN_vkCreateDescriptorPool)dlsym(vk_sdk, "vkCreateDescriptorPool");
        if (vkCreateDescriptorPool == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreateDescriptorPool in sdk");
            return 0;
        }
    
        vkDestroyDescriptorPool = (PFN_vkDestroyDescriptorPool)dlsym(vk_sdk, "vkDestroyDescriptorPool");
        if (vkDestroyDescriptorPool == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroyDescriptorPool in sdk");
            return 0;
        }
    
        vkResetDescriptorPool = (PFN_vkResetDescriptorPool)dlsym(vk_sdk, "vkResetDescriptorPool");
        if (vkResetDescriptorPool == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkResetDescriptorPool in sdk");
            return 0;
        }
    
        vkAllocateDescriptorSets = (PFN_vkAllocateDescriptorSets)dlsym(vk_sdk, "vkAllocateDescriptorSets");
        if (vkAllocateDescriptorSets == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkAllocateDescriptorSets in sdk");
            return 0;
        }
    
        vkFreeDescriptorSets = (PFN_vkFreeDescriptorSets)dlsym(vk_sdk, "vkFreeDescriptorSets");
        if (vkFreeDescriptorSets == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkFreeDescriptorSets in sdk");
            return 0;
        }
    
        vkUpdateDescriptorSets = (PFN_vkUpdateDescriptorSets)dlsym(vk_sdk, "vkUpdateDescriptorSets");
        if (vkUpdateDescriptorSets == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkUpdateDescriptorSets in sdk");
            return 0;
        }
    
        vkCreateFramebuffer = (PFN_vkCreateFramebuffer)dlsym(vk_sdk, "vkCreateFramebuffer");
        if (vkCreateFramebuffer == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreateFramebuffer in sdk");
            return 0;
        }
    
        vkDestroyFramebuffer = (PFN_vkDestroyFramebuffer)dlsym(vk_sdk, "vkDestroyFramebuffer");
        if (vkDestroyFramebuffer == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroyFramebuffer in sdk");
            return 0;
        }
    
        vkCreateRenderPass = (PFN_vkCreateRenderPass)dlsym(vk_sdk, "vkCreateRenderPass");
        if (vkCreateRenderPass == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreateRenderPass in sdk");
            return 0;
        }
    
        vkDestroyRenderPass = (PFN_vkDestroyRenderPass)dlsym(vk_sdk, "vkDestroyRenderPass");
        if (vkDestroyRenderPass == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroyRenderPass in sdk");
            return 0;
        }
    
        vkGetRenderAreaGranularity = (PFN_vkGetRenderAreaGranularity)dlsym(vk_sdk, "vkGetRenderAreaGranularity");
        if (vkGetRenderAreaGranularity == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetRenderAreaGranularity in sdk");
            return 0;
        }
    
        vkCreateCommandPool = (PFN_vkCreateCommandPool)dlsym(vk_sdk, "vkCreateCommandPool");
        if (vkCreateCommandPool == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCreateCommandPool in sdk");
            return 0;
        }
    
        vkDestroyCommandPool = (PFN_vkDestroyCommandPool)dlsym(vk_sdk, "vkDestroyCommandPool");
        if (vkDestroyCommandPool == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkDestroyCommandPool in sdk");
            return 0;
        }
    
        vkResetCommandPool = (PFN_vkResetCommandPool)dlsym(vk_sdk, "vkResetCommandPool");
        if (vkResetCommandPool == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkResetCommandPool in sdk");
            return 0;
        }
    
        vkAllocateCommandBuffers = (PFN_vkAllocateCommandBuffers)dlsym(vk_sdk, "vkAllocateCommandBuffers");
        if (vkAllocateCommandBuffers == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkAllocateCommandBuffers in sdk");
            return 0;
        }
    
        vkFreeCommandBuffers = (PFN_vkFreeCommandBuffers)dlsym(vk_sdk, "vkFreeCommandBuffers");
        if (vkFreeCommandBuffers == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkFreeCommandBuffers in sdk");
            return 0;
        }
    
        vkBeginCommandBuffer = (PFN_vkBeginCommandBuffer)dlsym(vk_sdk, "vkBeginCommandBuffer");
        if (vkBeginCommandBuffer == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkBeginCommandBuffer in sdk");
            return 0;
        }
    
        vkEndCommandBuffer = (PFN_vkEndCommandBuffer)dlsym(vk_sdk, "vkEndCommandBuffer");
        if (vkEndCommandBuffer == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkEndCommandBuffer in sdk");
            return 0;
        }
    
        vkResetCommandBuffer = (PFN_vkResetCommandBuffer)dlsym(vk_sdk, "vkResetCommandBuffer");
        if (vkResetCommandBuffer == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkResetCommandBuffer in sdk");
            return 0;
        }
    
        vkCmdBindPipeline = (PFN_vkCmdBindPipeline)dlsym(vk_sdk, "vkCmdBindPipeline");
        if (vkCmdBindPipeline == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdBindPipeline in sdk");
            return 0;
        }
    
        vkCmdSetViewport = (PFN_vkCmdSetViewport)dlsym(vk_sdk, "vkCmdSetViewport");
        if (vkCmdSetViewport == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdSetViewport in sdk");
            return 0;
        }
    
        vkCmdSetScissor = (PFN_vkCmdSetScissor)dlsym(vk_sdk, "vkCmdSetScissor");
        if (vkCmdSetScissor == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdSetScissor in sdk");
            return 0;
        }
    
        vkCmdSetLineWidth = (PFN_vkCmdSetLineWidth)dlsym(vk_sdk, "vkCmdSetLineWidth");
        if (vkCmdSetLineWidth == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdSetLineWidth in sdk");
            return 0;
        }
    
        vkCmdSetDepthBias = (PFN_vkCmdSetDepthBias)dlsym(vk_sdk, "vkCmdSetDepthBias");
        if (vkCmdSetDepthBias == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdSetDepthBias in sdk");
            return 0;
        }
    
        vkCmdSetBlendConstants = (PFN_vkCmdSetBlendConstants)dlsym(vk_sdk, "vkCmdSetBlendConstants");
        if (vkCmdSetBlendConstants == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdSetBlendConstants in sdk");
            return 0;
        }
    
        vkCmdSetDepthBounds = (PFN_vkCmdSetDepthBounds)dlsym(vk_sdk, "vkCmdSetDepthBounds");
        if (vkCmdSetDepthBounds == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdSetDepthBounds in sdk");
            return 0;
        }
    
        vkCmdSetStencilCompareMask = (PFN_vkCmdSetStencilCompareMask)dlsym(vk_sdk, "vkCmdSetStencilCompareMask");
        if (vkCmdSetStencilCompareMask == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdSetStencilCompareMask in sdk");
            return 0;
        }
    
        vkCmdSetStencilWriteMask = (PFN_vkCmdSetStencilWriteMask)dlsym(vk_sdk, "vkCmdSetStencilWriteMask");
        if (vkCmdSetStencilWriteMask == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdSetStencilWriteMask in sdk");
            return 0;
        }
    
        vkCmdSetStencilReference = (PFN_vkCmdSetStencilReference)dlsym(vk_sdk, "vkCmdSetStencilReference");
        if (vkCmdSetStencilReference == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdSetStencilReference in sdk");
            return 0;
        }
    
        vkCmdBindDescriptorSets = (PFN_vkCmdBindDescriptorSets)dlsym(vk_sdk, "vkCmdBindDescriptorSets");
        if (vkCmdBindDescriptorSets == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdBindDescriptorSets in sdk");
            return 0;
        }
    
        vkCmdBindIndexBuffer = (PFN_vkCmdBindIndexBuffer)dlsym(vk_sdk, "vkCmdBindIndexBuffer");
        if (vkCmdBindIndexBuffer == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdBindIndexBuffer in sdk");
            return 0;
        }
    
        vkCmdBindVertexBuffers = (PFN_vkCmdBindVertexBuffers)dlsym(vk_sdk, "vkCmdBindVertexBuffers");
        if (vkCmdBindVertexBuffers == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdBindVertexBuffers in sdk");
            return 0;
        }
    
        vkCmdDraw = (PFN_vkCmdDraw)dlsym(vk_sdk, "vkCmdDraw");
        if (vkCmdDraw == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdDraw in sdk");
            return 0;
        }
    
        vkCmdDrawIndexed = (PFN_vkCmdDrawIndexed)dlsym(vk_sdk, "vkCmdDrawIndexed");
        if (vkCmdDrawIndexed == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdDrawIndexed in sdk");
            return 0;
        }
    
        vkCmdDrawIndirect = (PFN_vkCmdDrawIndirect)dlsym(vk_sdk, "vkCmdDrawIndirect");
        if (vkCmdDrawIndirect == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdDrawIndirect in sdk");
            return 0;
        }
    
        vkCmdDrawIndexedIndirect = (PFN_vkCmdDrawIndexedIndirect)dlsym(vk_sdk, "vkCmdDrawIndexedIndirect");
        if (vkCmdDrawIndexedIndirect == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdDrawIndexedIndirect in sdk");
            return 0;
        }
    
        vkCmdDispatch = (PFN_vkCmdDispatch)dlsym(vk_sdk, "vkCmdDispatch");
        if (vkCmdDispatch == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdDispatch in sdk");
            return 0;
        }
    
        vkCmdDispatchIndirect = (PFN_vkCmdDispatchIndirect)dlsym(vk_sdk, "vkCmdDispatchIndirect");
        if (vkCmdDispatchIndirect == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdDispatchIndirect in sdk");
            return 0;
        }
    
        vkCmdCopyBuffer = (PFN_vkCmdCopyBuffer)dlsym(vk_sdk, "vkCmdCopyBuffer");
        if (vkCmdCopyBuffer == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdCopyBuffer in sdk");
            return 0;
        }
    
        vkCmdCopyImage = (PFN_vkCmdCopyImage)dlsym(vk_sdk, "vkCmdCopyImage");
        if (vkCmdCopyImage == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdCopyImage in sdk");
            return 0;
        }
    
        vkCmdBlitImage = (PFN_vkCmdBlitImage)dlsym(vk_sdk, "vkCmdBlitImage");
        if (vkCmdBlitImage == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdBlitImage in sdk");
            return 0;
        }
    
        vkCmdCopyBufferToImage = (PFN_vkCmdCopyBufferToImage)dlsym(vk_sdk, "vkCmdCopyBufferToImage");
        if (vkCmdCopyBufferToImage == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdCopyBufferToImage in sdk");
            return 0;
        }
    
        vkCmdCopyImageToBuffer = (PFN_vkCmdCopyImageToBuffer)dlsym(vk_sdk, "vkCmdCopyImageToBuffer");
        if (vkCmdCopyImageToBuffer == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdCopyImageToBuffer in sdk");
            return 0;
        }
    
        vkCmdUpdateBuffer = (PFN_vkCmdUpdateBuffer)dlsym(vk_sdk, "vkCmdUpdateBuffer");
        if (vkCmdUpdateBuffer == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdUpdateBuffer in sdk");
            return 0;
        }
    
        vkCmdFillBuffer = (PFN_vkCmdFillBuffer)dlsym(vk_sdk, "vkCmdFillBuffer");
        if (vkCmdFillBuffer == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdFillBuffer in sdk");
            return 0;
        }
    
        vkCmdClearColorImage = (PFN_vkCmdClearColorImage)dlsym(vk_sdk, "vkCmdClearColorImage");
        if (vkCmdClearColorImage == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdClearColorImage in sdk");
            return 0;
        }
    
        vkCmdClearDepthStencilImage = (PFN_vkCmdClearDepthStencilImage)dlsym(vk_sdk, "vkCmdClearDepthStencilImage");
        if (vkCmdClearDepthStencilImage == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdClearDepthStencilImage in sdk");
            return 0;
        }
    
        vkCmdClearAttachments = (PFN_vkCmdClearAttachments)dlsym(vk_sdk, "vkCmdClearAttachments");
        if (vkCmdClearAttachments == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdClearAttachments in sdk");
            return 0;
        }
    
        vkCmdResolveImage = (PFN_vkCmdResolveImage)dlsym(vk_sdk, "vkCmdResolveImage");
        if (vkCmdResolveImage == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdResolveImage in sdk");
            return 0;
        }
    
        vkCmdSetEvent = (PFN_vkCmdSetEvent)dlsym(vk_sdk, "vkCmdSetEvent");
        if (vkCmdSetEvent == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdSetEvent in sdk");
            return 0;
        }
    
        vkCmdResetEvent = (PFN_vkCmdResetEvent)dlsym(vk_sdk, "vkCmdResetEvent");
        if (vkCmdResetEvent == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdResetEvent in sdk");
            return 0;
        }
    
        vkCmdWaitEvents = (PFN_vkCmdWaitEvents)dlsym(vk_sdk, "vkCmdWaitEvents");
        if (vkCmdWaitEvents == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdWaitEvents in sdk");
            return 0;
        }
    
        vkCmdPipelineBarrier = (PFN_vkCmdPipelineBarrier)dlsym(vk_sdk, "vkCmdPipelineBarrier");
        if (vkCmdPipelineBarrier == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdPipelineBarrier in sdk");
            return 0;
        }
    
        vkCmdBeginQuery = (PFN_vkCmdBeginQuery)dlsym(vk_sdk, "vkCmdBeginQuery");
        if (vkCmdBeginQuery == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdBeginQuery in sdk");
            return 0;
        }
    
        vkCmdEndQuery = (PFN_vkCmdEndQuery)dlsym(vk_sdk, "vkCmdEndQuery");
        if (vkCmdEndQuery == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdEndQuery in sdk");
            return 0;
        }
    
        vkCmdResetQueryPool = (PFN_vkCmdResetQueryPool)dlsym(vk_sdk, "vkCmdResetQueryPool");
        if (vkCmdResetQueryPool == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdResetQueryPool in sdk");
            return 0;
        }
    
        vkCmdWriteTimestamp = (PFN_vkCmdWriteTimestamp)dlsym(vk_sdk, "vkCmdWriteTimestamp");
        if (vkCmdWriteTimestamp == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdWriteTimestamp in sdk");
            return 0;
        }
    
        vkCmdCopyQueryPoolResults = (PFN_vkCmdCopyQueryPoolResults)dlsym(vk_sdk, "vkCmdCopyQueryPoolResults");
        if (vkCmdCopyQueryPoolResults == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdCopyQueryPoolResults in sdk");
            return 0;
        }
    
        vkCmdPushConstants = (PFN_vkCmdPushConstants)dlsym(vk_sdk, "vkCmdPushConstants");
        if (vkCmdPushConstants == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdPushConstants in sdk");
            return 0;
        }
    
        vkCmdBeginRenderPass = (PFN_vkCmdBeginRenderPass)dlsym(vk_sdk, "vkCmdBeginRenderPass");
        if (vkCmdBeginRenderPass == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdBeginRenderPass in sdk");
            return 0;
        }
    
        vkCmdNextSubpass = (PFN_vkCmdNextSubpass)dlsym(vk_sdk, "vkCmdNextSubpass");
        if (vkCmdNextSubpass == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdNextSubpass in sdk");
            return 0;
        }
    
        vkCmdEndRenderPass = (PFN_vkCmdEndRenderPass)dlsym(vk_sdk, "vkCmdEndRenderPass");
        if (vkCmdEndRenderPass == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdEndRenderPass in sdk");
            return 0;
        }
    
        vkCmdExecuteCommands = (PFN_vkCmdExecuteCommands)dlsym(vk_sdk, "vkCmdExecuteCommands");
        if (vkCmdExecuteCommands == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkCmdExecuteCommands in sdk");
            return 0;
        }
    

    
        vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)dlsym(vk_sdk, "vkGetInstanceProcAddr");
        if (vkGetInstanceProcAddr == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetInstanceProcAddr in sdk");
            return 0;
        }
    
        vkGetDeviceProcAddr = (PFN_vkGetDeviceProcAddr)dlsym(vk_sdk, "vkGetDeviceProcAddr");
        if (vkGetDeviceProcAddr == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetDeviceProcAddr in sdk");
            return 0;
        }
    
        vkMapMemory = (PFN_vkMapMemory)dlsym(vk_sdk, "vkMapMemory");
        if (vkMapMemory == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkMapMemory in sdk");
            return 0;
        }
    
        vkGetPipelineCacheData = (PFN_vkGetPipelineCacheData)dlsym(vk_sdk, "vkGetPipelineCacheData");
        if (vkGetPipelineCacheData == NULL) {
            PyErr_SetString(PyExc_ImportError, "Can't load vkGetPipelineCacheData in sdk");
            return 0;
        }
    

    return 1;
}


// ---------------
// CREATE PYTHON OBJECTS
// ---------------

    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkOffset2D_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkOffset2D *self = (PyVkOffset2D *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkOffset2D));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkOffset2D");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkOffset2D_del(PyVkOffset2D* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkOffset2D_init(PyVkOffset2D *self, PyObject *args, PyObject *kwds) {
        
            int32_t x;
int32_t y;

            static char *kwlist[] = {"x","y",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_int32_t_converter,&x,pyc_int32_t_converter,&y))
        return -1;
    

            
            
                (self->base)->x = x;
            
            
            
                (self->base)->y = y;
            
            

            pyc_int32_t_converter_free(&x);
pyc_int32_t_converter_free(&y);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkOffset2D_getx(PyVkOffset2D *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->x));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkOffset2D_gety(PyVkOffset2D *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->y));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkOffset2D_getsetters[] = {
        
            {"x", (getter)PyVkOffset2D_getx, NULL, "", NULL},
        
            {"y", (getter)PyVkOffset2D_gety, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkOffset3D_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkOffset3D *self = (PyVkOffset3D *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkOffset3D));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkOffset3D");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkOffset3D_del(PyVkOffset3D* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkOffset3D_init(PyVkOffset3D *self, PyObject *args, PyObject *kwds) {
        
            int32_t x;
int32_t y;
int32_t z;

            static char *kwlist[] = {"x","y","z",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_int32_t_converter,&x,pyc_int32_t_converter,&y,pyc_int32_t_converter,&z))
        return -1;
    

            
            
                (self->base)->x = x;
            
            
            
                (self->base)->y = y;
            
            
            
                (self->base)->z = z;
            
            

            pyc_int32_t_converter_free(&x);
pyc_int32_t_converter_free(&y);
pyc_int32_t_converter_free(&z);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkOffset3D_getx(PyVkOffset3D *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->x));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkOffset3D_gety(PyVkOffset3D *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->y));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkOffset3D_getz(PyVkOffset3D *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->z));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkOffset3D_getsetters[] = {
        
            {"x", (getter)PyVkOffset3D_getx, NULL, "", NULL},
        
            {"y", (getter)PyVkOffset3D_gety, NULL, "", NULL},
        
            {"z", (getter)PyVkOffset3D_getz, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkExtent2D_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkExtent2D *self = (PyVkExtent2D *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkExtent2D));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkExtent2D");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkExtent2D_del(PyVkExtent2D* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkExtent2D_init(PyVkExtent2D *self, PyObject *args, PyObject *kwds) {
        
            uint32_t width;
uint32_t height;

            static char *kwlist[] = {"width","height",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_uint32_t_converter,&width,pyc_uint32_t_converter,&height))
        return -1;
    

            
            
                (self->base)->width = width;
            
            
            
                (self->base)->height = height;
            
            

            pyc_uint32_t_converter_free(&width);
pyc_uint32_t_converter_free(&height);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkExtent2D_getwidth(PyVkExtent2D *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->width));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkExtent2D_getheight(PyVkExtent2D *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->height));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkExtent2D_getsetters[] = {
        
            {"width", (getter)PyVkExtent2D_getwidth, NULL, "", NULL},
        
            {"height", (getter)PyVkExtent2D_getheight, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkExtent3D_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkExtent3D *self = (PyVkExtent3D *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkExtent3D));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkExtent3D");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkExtent3D_del(PyVkExtent3D* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkExtent3D_init(PyVkExtent3D *self, PyObject *args, PyObject *kwds) {
        
            uint32_t width;
uint32_t height;
uint32_t depth;

            static char *kwlist[] = {"width","height","depth",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_uint32_t_converter,&width,pyc_uint32_t_converter,&height,pyc_uint32_t_converter,&depth))
        return -1;
    

            
            
                (self->base)->width = width;
            
            
            
                (self->base)->height = height;
            
            
            
                (self->base)->depth = depth;
            
            

            pyc_uint32_t_converter_free(&width);
pyc_uint32_t_converter_free(&height);
pyc_uint32_t_converter_free(&depth);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkExtent3D_getwidth(PyVkExtent3D *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->width));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkExtent3D_getheight(PyVkExtent3D *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->height));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkExtent3D_getdepth(PyVkExtent3D *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->depth));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkExtent3D_getsetters[] = {
        
            {"width", (getter)PyVkExtent3D_getwidth, NULL, "", NULL},
        
            {"height", (getter)PyVkExtent3D_getheight, NULL, "", NULL},
        
            {"depth", (getter)PyVkExtent3D_getdepth, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkViewport_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkViewport *self = (PyVkViewport *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkViewport));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkViewport");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkViewport_del(PyVkViewport* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkViewport_init(PyVkViewport *self, PyObject *args, PyObject *kwds) {
        
            float x;
float y;
float width;
float height;
float minDepth;
float maxDepth;

            static char *kwlist[] = {"x","y","width","height","minDepth","maxDepth",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_float_converter,&x,pyc_float_converter,&y,pyc_float_converter,&width,pyc_float_converter,&height,pyc_float_converter,&minDepth,pyc_float_converter,&maxDepth))
        return -1;
    

            
            
                (self->base)->x = x;
            
            
            
                (self->base)->y = y;
            
            
            
                (self->base)->width = width;
            
            
            
                (self->base)->height = height;
            
            
            
                (self->base)->minDepth = minDepth;
            
            
            
                (self->base)->maxDepth = maxDepth;
            
            

            pyc_float_converter_free(&x);
pyc_float_converter_free(&y);
pyc_float_converter_free(&width);
pyc_float_converter_free(&height);
pyc_float_converter_free(&minDepth);
pyc_float_converter_free(&maxDepth);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkViewport_getx(PyVkViewport *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->x));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkViewport_gety(PyVkViewport *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->y));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkViewport_getwidth(PyVkViewport *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->width));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkViewport_getheight(PyVkViewport *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->height));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkViewport_getminDepth(PyVkViewport *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->minDepth));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkViewport_getmaxDepth(PyVkViewport *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->maxDepth));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkViewport_getsetters[] = {
        
            {"x", (getter)PyVkViewport_getx, NULL, "", NULL},
        
            {"y", (getter)PyVkViewport_gety, NULL, "", NULL},
        
            {"width", (getter)PyVkViewport_getwidth, NULL, "", NULL},
        
            {"height", (getter)PyVkViewport_getheight, NULL, "", NULL},
        
            {"minDepth", (getter)PyVkViewport_getminDepth, NULL, "", NULL},
        
            {"maxDepth", (getter)PyVkViewport_getmaxDepth, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkRect2D_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkRect2D *self = (PyVkRect2D *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkRect2D));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkRect2D");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkRect2D_del(PyVkRect2D* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkRect2D_init(PyVkRect2D *self, PyObject *args, PyObject *kwds) {
        
            VkOffset2D offset;
VkExtent2D extent;

            static char *kwlist[] = {"offset","extent",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_struct_base_VkOffset2D_converter,&offset,pyc_struct_base_VkExtent2D_converter,&extent))
        return -1;
    

            
            
                (self->base)->offset = offset;
            
            
            
                (self->base)->extent = extent;
            
            

            pyc_struct_base_VkOffset2D_converter_free(&offset);
pyc_struct_base_VkExtent2D_converter_free(&extent);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkRect2D_getoffset(PyVkRect2D *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkOffset2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkOffset2D*) pyvalue)->base = &((self->base)->offset);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkRect2D_getextent(PyVkRect2D *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent2D*) pyvalue)->base = &((self->base)->extent);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkRect2D_getsetters[] = {
        
            {"offset", (getter)PyVkRect2D_getoffset, NULL, "", NULL},
        
            {"extent", (getter)PyVkRect2D_getextent, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
     #ifdef hackdefine 
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkRect3D_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkRect3D *self = (PyVkRect3D *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkRect3D));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkRect3D");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkRect3D_del(PyVkRect3D* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkRect3D_init(PyVkRect3D *self, PyObject *args, PyObject *kwds) {
        
            VkOffset3D offset;
VkExtent3D extent;

            static char *kwlist[] = {"offset","extent",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_struct_base_VkOffset3D_converter,&offset,pyc_struct_base_VkExtent3D_converter,&extent))
        return -1;
    

            
            
                (self->base)->offset = offset;
            
            
            
                (self->base)->extent = extent;
            
            

            pyc_struct_base_VkOffset3D_converter_free(&offset);
pyc_struct_base_VkExtent3D_converter_free(&extent);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkRect3D_getoffset(PyVkRect3D *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkOffset3DType);
            if (!pyvalue)
                return NULL;
            ((PyVkOffset3D*) pyvalue)->base = &((self->base)->offset);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkRect3D_getextent(PyVkRect3D *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent3DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent3D*) pyvalue)->base = &((self->base)->extent);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkRect3D_getsetters[] = {
        
            {"offset", (getter)PyVkRect3D_getoffset, NULL, "", NULL},
        
            {"extent", (getter)PyVkRect3D_getextent, NULL, "", NULL},
        
        {NULL}
    };




    
     #endif 


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkClearRect_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkClearRect *self = (PyVkClearRect *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkClearRect));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkClearRect");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkClearRect_del(PyVkClearRect* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkClearRect_init(PyVkClearRect *self, PyObject *args, PyObject *kwds) {
        
            VkRect2D rect;
uint32_t baseArrayLayer;
uint32_t layerCount;

            static char *kwlist[] = {"rect","baseArrayLayer","layerCount",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_struct_base_VkRect2D_converter,&rect,pyc_uint32_t_converter,&baseArrayLayer,pyc_uint32_t_converter,&layerCount))
        return -1;
    

            
            
                (self->base)->rect = rect;
            
            
            
                (self->base)->baseArrayLayer = baseArrayLayer;
            
            
            
                (self->base)->layerCount = layerCount;
            
            

            pyc_struct_base_VkRect2D_converter_free(&rect);
pyc_uint32_t_converter_free(&baseArrayLayer);
pyc_uint32_t_converter_free(&layerCount);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkClearRect_getrect(PyVkClearRect *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkRect2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkRect2D*) pyvalue)->base = &((self->base)->rect);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkClearRect_getbaseArrayLayer(PyVkClearRect *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->baseArrayLayer));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkClearRect_getlayerCount(PyVkClearRect *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->layerCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkClearRect_getsetters[] = {
        
            {"rect", (getter)PyVkClearRect_getrect, NULL, "", NULL},
        
            {"baseArrayLayer", (getter)PyVkClearRect_getbaseArrayLayer, NULL, "", NULL},
        
            {"layerCount", (getter)PyVkClearRect_getlayerCount, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkComponentMapping_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkComponentMapping *self = (PyVkComponentMapping *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkComponentMapping));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkComponentMapping");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkComponentMapping_del(PyVkComponentMapping* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkComponentMapping_init(PyVkComponentMapping *self, PyObject *args, PyObject *kwds) {
        
            VkComponentSwizzle r;
VkComponentSwizzle g;
VkComponentSwizzle b;
VkComponentSwizzle a;

            static char *kwlist[] = {"r","g","b","a",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_flag_base_VkComponentSwizzle_converter,&r,pyc_flag_base_VkComponentSwizzle_converter,&g,pyc_flag_base_VkComponentSwizzle_converter,&b,pyc_flag_base_VkComponentSwizzle_converter,&a))
        return -1;
    

            
            
                (self->base)->r = r;
            
            
            
                (self->base)->g = g;
            
            
            
                (self->base)->b = b;
            
            
            
                (self->base)->a = a;
            
            

            pyc_flag_base_VkComponentSwizzle_converter_free(&r);
pyc_flag_base_VkComponentSwizzle_converter_free(&g);
pyc_flag_base_VkComponentSwizzle_converter_free(&b);
pyc_flag_base_VkComponentSwizzle_converter_free(&a);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkComponentMapping_getr(PyVkComponentMapping *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->r));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkComponentMapping_getg(PyVkComponentMapping *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->g));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkComponentMapping_getb(PyVkComponentMapping *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->b));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkComponentMapping_geta(PyVkComponentMapping *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->a));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkComponentMapping_getsetters[] = {
        
            {"r", (getter)PyVkComponentMapping_getr, NULL, "", NULL},
        
            {"g", (getter)PyVkComponentMapping_getg, NULL, "", NULL},
        
            {"b", (getter)PyVkComponentMapping_getb, NULL, "", NULL},
        
            {"a", (getter)PyVkComponentMapping_geta, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPhysicalDeviceProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPhysicalDeviceProperties *self = (PyVkPhysicalDeviceProperties *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPhysicalDeviceProperties));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPhysicalDeviceProperties");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPhysicalDeviceProperties_del(PyVkPhysicalDeviceProperties* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPhysicalDeviceProperties_init(PyVkPhysicalDeviceProperties *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPhysicalDeviceProperties_getapiVersion(PyVkPhysicalDeviceProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->apiVersion));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceProperties_getdriverVersion(PyVkPhysicalDeviceProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->driverVersion));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceProperties_getvendorID(PyVkPhysicalDeviceProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->vendorID));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceProperties_getdeviceID(PyVkPhysicalDeviceProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->deviceID));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceProperties_getdeviceType(PyVkPhysicalDeviceProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->deviceType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceProperties_getdeviceName(PyVkPhysicalDeviceProperties *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyUnicode_FromString((const char *) ((self->base)->deviceName));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceProperties_getpipelineCacheUUID(PyVkPhysicalDeviceProperties *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyList_New(0);
        int nb = sizeof(((self->base)->pipelineCacheUUID)) / sizeof(((self->base)->pipelineCacheUUID)[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* tmp = PyLong_FromLong((long) ((self->base)->pipelineCacheUUID)[i]);
            PyList_Append(pyvalue, tmp);
        }
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceProperties_getlimits(PyVkPhysicalDeviceProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkPhysicalDeviceLimitsType);
            if (!pyvalue)
                return NULL;
            ((PyVkPhysicalDeviceLimits*) pyvalue)->base = &((self->base)->limits);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceProperties_getsparseProperties(PyVkPhysicalDeviceProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkPhysicalDeviceSparsePropertiesType);
            if (!pyvalue)
                return NULL;
            ((PyVkPhysicalDeviceSparseProperties*) pyvalue)->base = &((self->base)->sparseProperties);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPhysicalDeviceProperties_getsetters[] = {
        
            {"apiVersion", (getter)PyVkPhysicalDeviceProperties_getapiVersion, NULL, "", NULL},
        
            {"driverVersion", (getter)PyVkPhysicalDeviceProperties_getdriverVersion, NULL, "", NULL},
        
            {"vendorID", (getter)PyVkPhysicalDeviceProperties_getvendorID, NULL, "", NULL},
        
            {"deviceID", (getter)PyVkPhysicalDeviceProperties_getdeviceID, NULL, "", NULL},
        
            {"deviceType", (getter)PyVkPhysicalDeviceProperties_getdeviceType, NULL, "", NULL},
        
            {"deviceName", (getter)PyVkPhysicalDeviceProperties_getdeviceName, NULL, "", NULL},
        
            {"pipelineCacheUUID", (getter)PyVkPhysicalDeviceProperties_getpipelineCacheUUID, NULL, "", NULL},
        
            {"limits", (getter)PyVkPhysicalDeviceProperties_getlimits, NULL, "", NULL},
        
            {"sparseProperties", (getter)PyVkPhysicalDeviceProperties_getsparseProperties, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkExtensionProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkExtensionProperties *self = (PyVkExtensionProperties *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkExtensionProperties));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkExtensionProperties");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkExtensionProperties_del(PyVkExtensionProperties* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkExtensionProperties_init(PyVkExtensionProperties *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkExtensionProperties_getextensionName(PyVkExtensionProperties *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyUnicode_FromString((const char *) ((self->base)->extensionName));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkExtensionProperties_getspecVersion(PyVkExtensionProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->specVersion));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkExtensionProperties_getsetters[] = {
        
            {"extensionName", (getter)PyVkExtensionProperties_getextensionName, NULL, "", NULL},
        
            {"specVersion", (getter)PyVkExtensionProperties_getspecVersion, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkLayerProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkLayerProperties *self = (PyVkLayerProperties *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkLayerProperties));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkLayerProperties");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkLayerProperties_del(PyVkLayerProperties* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkLayerProperties_init(PyVkLayerProperties *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkLayerProperties_getlayerName(PyVkLayerProperties *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyUnicode_FromString((const char *) ((self->base)->layerName));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkLayerProperties_getspecVersion(PyVkLayerProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->specVersion));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkLayerProperties_getimplementationVersion(PyVkLayerProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->implementationVersion));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkLayerProperties_getdescription(PyVkLayerProperties *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyUnicode_FromString((const char *) ((self->base)->description));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkLayerProperties_getsetters[] = {
        
            {"layerName", (getter)PyVkLayerProperties_getlayerName, NULL, "", NULL},
        
            {"specVersion", (getter)PyVkLayerProperties_getspecVersion, NULL, "", NULL},
        
            {"implementationVersion", (getter)PyVkLayerProperties_getimplementationVersion, NULL, "", NULL},
        
            {"description", (getter)PyVkLayerProperties_getdescription, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkApplicationInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkApplicationInfo *self = (PyVkApplicationInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkApplicationInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkApplicationInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkApplicationInfo_del(PyVkApplicationInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkApplicationInfo_init(PyVkApplicationInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
char* pApplicationName;
uint32_t applicationVersion;
char* pEngineName;
uint32_t engineVersion;
uint32_t apiVersion;

            static char *kwlist[] = {"sType","pApplicationName","applicationVersion","pEngineName","engineVersion","apiVersion",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_string_converter,&pApplicationName,pyc_uint32_t_converter,&applicationVersion,pyc_string_converter,&pEngineName,pyc_uint32_t_converter,&engineVersion,pyc_uint32_t_converter,&apiVersion))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->pApplicationName = pApplicationName;
            
            
            
                (self->base)->applicationVersion = applicationVersion;
            
            
            
                (self->base)->pEngineName = pEngineName;
            
            
            
                (self->base)->engineVersion = engineVersion;
            
            
            
                (self->base)->apiVersion = apiVersion;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_string_converter_free(&pApplicationName);
pyc_uint32_t_converter_free(&applicationVersion);
pyc_string_converter_free(&pEngineName);
pyc_uint32_t_converter_free(&engineVersion);
pyc_uint32_t_converter_free(&apiVersion);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkApplicationInfo_getsType(PyVkApplicationInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkApplicationInfo_getpNext(PyVkApplicationInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkApplicationInfo_getpApplicationName(PyVkApplicationInfo *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyUnicode_FromString((const char *) ((self->base)->pApplicationName));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkApplicationInfo_getapplicationVersion(PyVkApplicationInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->applicationVersion));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkApplicationInfo_getpEngineName(PyVkApplicationInfo *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyUnicode_FromString((const char *) ((self->base)->pEngineName));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkApplicationInfo_getengineVersion(PyVkApplicationInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->engineVersion));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkApplicationInfo_getapiVersion(PyVkApplicationInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->apiVersion));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkApplicationInfo_getsetters[] = {
        
            {"sType", (getter)PyVkApplicationInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkApplicationInfo_getpNext, NULL, "", NULL},
        
            {"pApplicationName", (getter)PyVkApplicationInfo_getpApplicationName, NULL, "", NULL},
        
            {"applicationVersion", (getter)PyVkApplicationInfo_getapplicationVersion, NULL, "", NULL},
        
            {"pEngineName", (getter)PyVkApplicationInfo_getpEngineName, NULL, "", NULL},
        
            {"engineVersion", (getter)PyVkApplicationInfo_getengineVersion, NULL, "", NULL},
        
            {"apiVersion", (getter)PyVkApplicationInfo_getapiVersion, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkAllocationCallbacks_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkAllocationCallbacks *self = (PyVkAllocationCallbacks *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkAllocationCallbacks));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkAllocationCallbacks");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkAllocationCallbacks_del(PyVkAllocationCallbacks* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkAllocationCallbacks_init(PyVkAllocationCallbacks *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkAllocationCallbacks_getpUserData(PyVkAllocationCallbacks *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkAllocationCallbacks_getpfnAllocation(PyVkAllocationCallbacks *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkAllocationCallbacks_getpfnReallocation(PyVkAllocationCallbacks *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkAllocationCallbacks_getpfnFree(PyVkAllocationCallbacks *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkAllocationCallbacks_getpfnInternalAllocation(PyVkAllocationCallbacks *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkAllocationCallbacks_getpfnInternalFree(PyVkAllocationCallbacks *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkAllocationCallbacks_getsetters[] = {
        
            {"pUserData", (getter)PyVkAllocationCallbacks_getpUserData, NULL, "", NULL},
        
            {"pfnAllocation", (getter)PyVkAllocationCallbacks_getpfnAllocation, NULL, "", NULL},
        
            {"pfnReallocation", (getter)PyVkAllocationCallbacks_getpfnReallocation, NULL, "", NULL},
        
            {"pfnFree", (getter)PyVkAllocationCallbacks_getpfnFree, NULL, "", NULL},
        
            {"pfnInternalAllocation", (getter)PyVkAllocationCallbacks_getpfnInternalAllocation, NULL, "", NULL},
        
            {"pfnInternalFree", (getter)PyVkAllocationCallbacks_getpfnInternalFree, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDeviceQueueCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDeviceQueueCreateInfo *self = (PyVkDeviceQueueCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDeviceQueueCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDeviceQueueCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDeviceQueueCreateInfo_del(PyVkDeviceQueueCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDeviceQueueCreateInfo_init(PyVkDeviceQueueCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkDeviceQueueCreateFlags flags;
uint32_t queueFamilyIndex;
uint32_t queueCount;
float* pQueuePriorities;

            static char *kwlist[] = {"sType","flags","queueFamilyIndex","queueCount","pQueuePriorities",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkDeviceQueueCreateFlags_converter,&flags,pyc_uint32_t_converter,&queueFamilyIndex,pyc_uint32_t_converter,&queueCount,pyc_array_float_converter,&pQueuePriorities))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->queueFamilyIndex = queueFamilyIndex;
            
            
            
                (self->base)->queueCount = queueCount;
            
            
            
                (self->base)->pQueuePriorities = pQueuePriorities;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkDeviceQueueCreateFlags_converter_free(&flags);
pyc_uint32_t_converter_free(&queueFamilyIndex);
pyc_uint32_t_converter_free(&queueCount);
pyc_array_float_converter_free(&pQueuePriorities);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDeviceQueueCreateInfo_getsType(PyVkDeviceQueueCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDeviceQueueCreateInfo_getpNext(PyVkDeviceQueueCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDeviceQueueCreateInfo_getflags(PyVkDeviceQueueCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDeviceQueueCreateInfo_getqueueFamilyIndex(PyVkDeviceQueueCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->queueFamilyIndex));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDeviceQueueCreateInfo_getqueueCount(PyVkDeviceQueueCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->queueCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDeviceQueueCreateInfo_getpQueuePriorities(PyVkDeviceQueueCreateInfo *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyFloat_FromDouble((double) (*(((self->base)->pQueuePriorities))));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDeviceQueueCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkDeviceQueueCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkDeviceQueueCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkDeviceQueueCreateInfo_getflags, NULL, "", NULL},
        
            {"queueFamilyIndex", (getter)PyVkDeviceQueueCreateInfo_getqueueFamilyIndex, NULL, "", NULL},
        
            {"queueCount", (getter)PyVkDeviceQueueCreateInfo_getqueueCount, NULL, "", NULL},
        
            {"pQueuePriorities", (getter)PyVkDeviceQueueCreateInfo_getpQueuePriorities, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDeviceCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDeviceCreateInfo *self = (PyVkDeviceCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDeviceCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDeviceCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDeviceCreateInfo_del(PyVkDeviceCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDeviceCreateInfo_init(PyVkDeviceCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkDeviceCreateFlags flags;
uint32_t queueCreateInfoCount;
VkDeviceQueueCreateInfo* pQueueCreateInfos;
uint32_t enabledLayerCount;
char** ppEnabledLayerNames;
uint32_t enabledExtensionCount;
char** ppEnabledExtensionNames;
VkPhysicalDeviceFeatures* pEnabledFeatures;

            static char *kwlist[] = {"sType","flags","queueCreateInfoCount","pQueueCreateInfos","enabledLayerCount","ppEnabledLayerNames","enabledExtensionCount","ppEnabledExtensionNames","pEnabledFeatures",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkDeviceCreateFlags_converter,&flags,pyc_uint32_t_converter,&queueCreateInfoCount,pyc_struct_array_VkDeviceQueueCreateInfo_converter,&pQueueCreateInfos,pyc_uint32_t_converter,&enabledLayerCount,pyc_array_string_converter,&ppEnabledLayerNames,pyc_uint32_t_converter,&enabledExtensionCount,pyc_array_string_converter,&ppEnabledExtensionNames,pyc_struct_pointer_VkPhysicalDeviceFeatures_converter,&pEnabledFeatures))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->queueCreateInfoCount = queueCreateInfoCount;
            
            
            
                (self->base)->pQueueCreateInfos = pQueueCreateInfos;
            
            
            
                (self->base)->enabledLayerCount = enabledLayerCount;
            
            
            
                (self->base)->ppEnabledLayerNames = ppEnabledLayerNames;
            
            
            
                (self->base)->enabledExtensionCount = enabledExtensionCount;
            
            
            
                (self->base)->ppEnabledExtensionNames = ppEnabledExtensionNames;
            
            
            
                (self->base)->pEnabledFeatures = pEnabledFeatures;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkDeviceCreateFlags_converter_free(&flags);
pyc_uint32_t_converter_free(&queueCreateInfoCount);
pyc_struct_array_VkDeviceQueueCreateInfo_converter_free(&pQueueCreateInfos);
pyc_uint32_t_converter_free(&enabledLayerCount);
pyc_array_string_converter_free(&ppEnabledLayerNames);
pyc_uint32_t_converter_free(&enabledExtensionCount);
pyc_array_string_converter_free(&ppEnabledExtensionNames);
pyc_struct_pointer_VkPhysicalDeviceFeatures_converter_free(&pEnabledFeatures);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDeviceCreateInfo_getsType(PyVkDeviceCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDeviceCreateInfo_getpNext(PyVkDeviceCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDeviceCreateInfo_getflags(PyVkDeviceCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDeviceCreateInfo_getqueueCreateInfoCount(PyVkDeviceCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->queueCreateInfoCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDeviceCreateInfo_getpQueueCreateInfos(PyVkDeviceCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkDeviceQueueCreateInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkDeviceQueueCreateInfo*) pyvalue)->base = ((self->base)->pQueueCreateInfos);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDeviceCreateInfo_getenabledLayerCount(PyVkDeviceCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->enabledLayerCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDeviceCreateInfo_getppEnabledLayerNames(PyVkDeviceCreateInfo *self, void *closure) {
            
            
                
        if (((self->base)->ppEnabledLayerNames)[0] == NULL)
            return PyList_New(0);
        PyObject* pyvalue = PyList_New(0);
        int i = 0;
        while (((self->base)->ppEnabledLayerNames)[i] != NULL) {
            PyObject* tmp = PyUnicode_FromString((const char *) ((self->base)->ppEnabledLayerNames)[i]);
            PyList_Append(pyvalue, tmp);
            i++;
        }
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDeviceCreateInfo_getenabledExtensionCount(PyVkDeviceCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->enabledExtensionCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDeviceCreateInfo_getppEnabledExtensionNames(PyVkDeviceCreateInfo *self, void *closure) {
            
            
                
        if (((self->base)->ppEnabledExtensionNames)[0] == NULL)
            return PyList_New(0);
        PyObject* pyvalue = PyList_New(0);
        int i = 0;
        while (((self->base)->ppEnabledExtensionNames)[i] != NULL) {
            PyObject* tmp = PyUnicode_FromString((const char *) ((self->base)->ppEnabledExtensionNames)[i]);
            PyList_Append(pyvalue, tmp);
            i++;
        }
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDeviceCreateInfo_getpEnabledFeatures(PyVkDeviceCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkPhysicalDeviceFeaturesType);
            if (!pyvalue)
                return NULL;
            ((PyVkPhysicalDeviceFeatures*) pyvalue)->base = ((self->base)->pEnabledFeatures);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDeviceCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkDeviceCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkDeviceCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkDeviceCreateInfo_getflags, NULL, "", NULL},
        
            {"queueCreateInfoCount", (getter)PyVkDeviceCreateInfo_getqueueCreateInfoCount, NULL, "", NULL},
        
            {"pQueueCreateInfos", (getter)PyVkDeviceCreateInfo_getpQueueCreateInfos, NULL, "", NULL},
        
            {"enabledLayerCount", (getter)PyVkDeviceCreateInfo_getenabledLayerCount, NULL, "", NULL},
        
            {"ppEnabledLayerNames", (getter)PyVkDeviceCreateInfo_getppEnabledLayerNames, NULL, "", NULL},
        
            {"enabledExtensionCount", (getter)PyVkDeviceCreateInfo_getenabledExtensionCount, NULL, "", NULL},
        
            {"ppEnabledExtensionNames", (getter)PyVkDeviceCreateInfo_getppEnabledExtensionNames, NULL, "", NULL},
        
            {"pEnabledFeatures", (getter)PyVkDeviceCreateInfo_getpEnabledFeatures, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkInstanceCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkInstanceCreateInfo *self = (PyVkInstanceCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkInstanceCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkInstanceCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkInstanceCreateInfo_del(PyVkInstanceCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkInstanceCreateInfo_init(PyVkInstanceCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkInstanceCreateFlags flags;
VkApplicationInfo* pApplicationInfo;
uint32_t enabledLayerCount;
char** ppEnabledLayerNames;
uint32_t enabledExtensionCount;
char** ppEnabledExtensionNames;

            static char *kwlist[] = {"sType","flags","pApplicationInfo","enabledLayerCount","ppEnabledLayerNames","enabledExtensionCount","ppEnabledExtensionNames",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkInstanceCreateFlags_converter,&flags,pyc_struct_pointer_VkApplicationInfo_converter,&pApplicationInfo,pyc_uint32_t_converter,&enabledLayerCount,pyc_array_string_converter,&ppEnabledLayerNames,pyc_uint32_t_converter,&enabledExtensionCount,pyc_array_string_converter,&ppEnabledExtensionNames))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->pApplicationInfo = pApplicationInfo;
            
            
            
                (self->base)->enabledLayerCount = enabledLayerCount;
            
            
            
                (self->base)->ppEnabledLayerNames = ppEnabledLayerNames;
            
            
            
                (self->base)->enabledExtensionCount = enabledExtensionCount;
            
            
            
                (self->base)->ppEnabledExtensionNames = ppEnabledExtensionNames;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkInstanceCreateFlags_converter_free(&flags);
pyc_struct_pointer_VkApplicationInfo_converter_free(&pApplicationInfo);
pyc_uint32_t_converter_free(&enabledLayerCount);
pyc_array_string_converter_free(&ppEnabledLayerNames);
pyc_uint32_t_converter_free(&enabledExtensionCount);
pyc_array_string_converter_free(&ppEnabledExtensionNames);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkInstanceCreateInfo_getsType(PyVkInstanceCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkInstanceCreateInfo_getpNext(PyVkInstanceCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkInstanceCreateInfo_getflags(PyVkInstanceCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkInstanceCreateInfo_getpApplicationInfo(PyVkInstanceCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkApplicationInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkApplicationInfo*) pyvalue)->base = ((self->base)->pApplicationInfo);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkInstanceCreateInfo_getenabledLayerCount(PyVkInstanceCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->enabledLayerCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkInstanceCreateInfo_getppEnabledLayerNames(PyVkInstanceCreateInfo *self, void *closure) {
            
            
                
        if (((self->base)->ppEnabledLayerNames)[0] == NULL)
            return PyList_New(0);
        PyObject* pyvalue = PyList_New(0);
        int i = 0;
        while (((self->base)->ppEnabledLayerNames)[i] != NULL) {
            PyObject* tmp = PyUnicode_FromString((const char *) ((self->base)->ppEnabledLayerNames)[i]);
            PyList_Append(pyvalue, tmp);
            i++;
        }
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkInstanceCreateInfo_getenabledExtensionCount(PyVkInstanceCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->enabledExtensionCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkInstanceCreateInfo_getppEnabledExtensionNames(PyVkInstanceCreateInfo *self, void *closure) {
            
            
                
        if (((self->base)->ppEnabledExtensionNames)[0] == NULL)
            return PyList_New(0);
        PyObject* pyvalue = PyList_New(0);
        int i = 0;
        while (((self->base)->ppEnabledExtensionNames)[i] != NULL) {
            PyObject* tmp = PyUnicode_FromString((const char *) ((self->base)->ppEnabledExtensionNames)[i]);
            PyList_Append(pyvalue, tmp);
            i++;
        }
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkInstanceCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkInstanceCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkInstanceCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkInstanceCreateInfo_getflags, NULL, "", NULL},
        
            {"pApplicationInfo", (getter)PyVkInstanceCreateInfo_getpApplicationInfo, NULL, "", NULL},
        
            {"enabledLayerCount", (getter)PyVkInstanceCreateInfo_getenabledLayerCount, NULL, "", NULL},
        
            {"ppEnabledLayerNames", (getter)PyVkInstanceCreateInfo_getppEnabledLayerNames, NULL, "", NULL},
        
            {"enabledExtensionCount", (getter)PyVkInstanceCreateInfo_getenabledExtensionCount, NULL, "", NULL},
        
            {"ppEnabledExtensionNames", (getter)PyVkInstanceCreateInfo_getppEnabledExtensionNames, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkQueueFamilyProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkQueueFamilyProperties *self = (PyVkQueueFamilyProperties *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkQueueFamilyProperties));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkQueueFamilyProperties");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkQueueFamilyProperties_del(PyVkQueueFamilyProperties* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkQueueFamilyProperties_init(PyVkQueueFamilyProperties *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkQueueFamilyProperties_getqueueFlags(PyVkQueueFamilyProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->queueFlags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkQueueFamilyProperties_getqueueCount(PyVkQueueFamilyProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->queueCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkQueueFamilyProperties_gettimestampValidBits(PyVkQueueFamilyProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->timestampValidBits));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkQueueFamilyProperties_getminImageTransferGranularity(PyVkQueueFamilyProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent3DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent3D*) pyvalue)->base = &((self->base)->minImageTransferGranularity);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkQueueFamilyProperties_getsetters[] = {
        
            {"queueFlags", (getter)PyVkQueueFamilyProperties_getqueueFlags, NULL, "", NULL},
        
            {"queueCount", (getter)PyVkQueueFamilyProperties_getqueueCount, NULL, "", NULL},
        
            {"timestampValidBits", (getter)PyVkQueueFamilyProperties_gettimestampValidBits, NULL, "", NULL},
        
            {"minImageTransferGranularity", (getter)PyVkQueueFamilyProperties_getminImageTransferGranularity, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPhysicalDeviceMemoryProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPhysicalDeviceMemoryProperties *self = (PyVkPhysicalDeviceMemoryProperties *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPhysicalDeviceMemoryProperties));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPhysicalDeviceMemoryProperties");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPhysicalDeviceMemoryProperties_del(PyVkPhysicalDeviceMemoryProperties* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPhysicalDeviceMemoryProperties_init(PyVkPhysicalDeviceMemoryProperties *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPhysicalDeviceMemoryProperties_getmemoryTypeCount(PyVkPhysicalDeviceMemoryProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->memoryTypeCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceMemoryProperties_getmemoryTypes(PyVkPhysicalDeviceMemoryProperties *self, void *closure) {
            
            
                
                PyObject* pyvalue = PyList_New(0);
                int nb = sizeof(((self->base)->memoryTypes)) / sizeof(((self->base)->memoryTypes)[0]);
                int i = 0;
                for (i = 0; i < nb; i++) {
                    PyObject* tmp = _PyObject_New(&PyVkMemoryTypeType);
                    if (!tmp)
                        return NULL;
                    ((PyVkMemoryType*) tmp)->base = ((self->base)->memoryTypes);
                    PyList_Append(pyvalue, tmp);
                }
                
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceMemoryProperties_getmemoryHeapCount(PyVkPhysicalDeviceMemoryProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->memoryHeapCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceMemoryProperties_getmemoryHeaps(PyVkPhysicalDeviceMemoryProperties *self, void *closure) {
            
            
                
                PyObject* pyvalue = PyList_New(0);
                int nb = sizeof(((self->base)->memoryHeaps)) / sizeof(((self->base)->memoryHeaps)[0]);
                int i = 0;
                for (i = 0; i < nb; i++) {
                    PyObject* tmp = _PyObject_New(&PyVkMemoryHeapType);
                    if (!tmp)
                        return NULL;
                    ((PyVkMemoryHeap*) tmp)->base = ((self->base)->memoryHeaps);
                    PyList_Append(pyvalue, tmp);
                }
                
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPhysicalDeviceMemoryProperties_getsetters[] = {
        
            {"memoryTypeCount", (getter)PyVkPhysicalDeviceMemoryProperties_getmemoryTypeCount, NULL, "", NULL},
        
            {"memoryTypes", (getter)PyVkPhysicalDeviceMemoryProperties_getmemoryTypes, NULL, "", NULL},
        
            {"memoryHeapCount", (getter)PyVkPhysicalDeviceMemoryProperties_getmemoryHeapCount, NULL, "", NULL},
        
            {"memoryHeaps", (getter)PyVkPhysicalDeviceMemoryProperties_getmemoryHeaps, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkMemoryAllocateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkMemoryAllocateInfo *self = (PyVkMemoryAllocateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkMemoryAllocateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkMemoryAllocateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkMemoryAllocateInfo_del(PyVkMemoryAllocateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkMemoryAllocateInfo_init(PyVkMemoryAllocateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkDeviceSize allocationSize;
uint32_t memoryTypeIndex;

            static char *kwlist[] = {"sType","allocationSize","memoryTypeIndex",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkDeviceSize_converter,&allocationSize,pyc_uint32_t_converter,&memoryTypeIndex))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->allocationSize = allocationSize;
            
            
            
                (self->base)->memoryTypeIndex = memoryTypeIndex;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkDeviceSize_converter_free(&allocationSize);
pyc_uint32_t_converter_free(&memoryTypeIndex);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkMemoryAllocateInfo_getsType(PyVkMemoryAllocateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkMemoryAllocateInfo_getpNext(PyVkMemoryAllocateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkMemoryAllocateInfo_getallocationSize(PyVkMemoryAllocateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->allocationSize));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkMemoryAllocateInfo_getmemoryTypeIndex(PyVkMemoryAllocateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->memoryTypeIndex));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkMemoryAllocateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkMemoryAllocateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkMemoryAllocateInfo_getpNext, NULL, "", NULL},
        
            {"allocationSize", (getter)PyVkMemoryAllocateInfo_getallocationSize, NULL, "", NULL},
        
            {"memoryTypeIndex", (getter)PyVkMemoryAllocateInfo_getmemoryTypeIndex, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkMemoryRequirements_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkMemoryRequirements *self = (PyVkMemoryRequirements *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkMemoryRequirements));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkMemoryRequirements");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkMemoryRequirements_del(PyVkMemoryRequirements* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkMemoryRequirements_init(PyVkMemoryRequirements *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkMemoryRequirements_getsize(PyVkMemoryRequirements *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->size));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkMemoryRequirements_getalignment(PyVkMemoryRequirements *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->alignment));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkMemoryRequirements_getmemoryTypeBits(PyVkMemoryRequirements *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->memoryTypeBits));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkMemoryRequirements_getsetters[] = {
        
            {"size", (getter)PyVkMemoryRequirements_getsize, NULL, "", NULL},
        
            {"alignment", (getter)PyVkMemoryRequirements_getalignment, NULL, "", NULL},
        
            {"memoryTypeBits", (getter)PyVkMemoryRequirements_getmemoryTypeBits, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkSparseImageFormatProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkSparseImageFormatProperties *self = (PyVkSparseImageFormatProperties *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkSparseImageFormatProperties));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkSparseImageFormatProperties");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkSparseImageFormatProperties_del(PyVkSparseImageFormatProperties* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkSparseImageFormatProperties_init(PyVkSparseImageFormatProperties *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkSparseImageFormatProperties_getaspectMask(PyVkSparseImageFormatProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->aspectMask));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSparseImageFormatProperties_getimageGranularity(PyVkSparseImageFormatProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent3DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent3D*) pyvalue)->base = &((self->base)->imageGranularity);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSparseImageFormatProperties_getflags(PyVkSparseImageFormatProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkSparseImageFormatProperties_getsetters[] = {
        
            {"aspectMask", (getter)PyVkSparseImageFormatProperties_getaspectMask, NULL, "", NULL},
        
            {"imageGranularity", (getter)PyVkSparseImageFormatProperties_getimageGranularity, NULL, "", NULL},
        
            {"flags", (getter)PyVkSparseImageFormatProperties_getflags, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkSparseImageMemoryRequirements_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkSparseImageMemoryRequirements *self = (PyVkSparseImageMemoryRequirements *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkSparseImageMemoryRequirements));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkSparseImageMemoryRequirements");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkSparseImageMemoryRequirements_del(PyVkSparseImageMemoryRequirements* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkSparseImageMemoryRequirements_init(PyVkSparseImageMemoryRequirements *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkSparseImageMemoryRequirements_getformatProperties(PyVkSparseImageMemoryRequirements *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkSparseImageFormatPropertiesType);
            if (!pyvalue)
                return NULL;
            ((PyVkSparseImageFormatProperties*) pyvalue)->base = &((self->base)->formatProperties);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSparseImageMemoryRequirements_getimageMipTailFirstLod(PyVkSparseImageMemoryRequirements *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->imageMipTailFirstLod));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSparseImageMemoryRequirements_getimageMipTailSize(PyVkSparseImageMemoryRequirements *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->imageMipTailSize));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSparseImageMemoryRequirements_getimageMipTailOffset(PyVkSparseImageMemoryRequirements *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->imageMipTailOffset));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSparseImageMemoryRequirements_getimageMipTailStride(PyVkSparseImageMemoryRequirements *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->imageMipTailStride));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkSparseImageMemoryRequirements_getsetters[] = {
        
            {"formatProperties", (getter)PyVkSparseImageMemoryRequirements_getformatProperties, NULL, "", NULL},
        
            {"imageMipTailFirstLod", (getter)PyVkSparseImageMemoryRequirements_getimageMipTailFirstLod, NULL, "", NULL},
        
            {"imageMipTailSize", (getter)PyVkSparseImageMemoryRequirements_getimageMipTailSize, NULL, "", NULL},
        
            {"imageMipTailOffset", (getter)PyVkSparseImageMemoryRequirements_getimageMipTailOffset, NULL, "", NULL},
        
            {"imageMipTailStride", (getter)PyVkSparseImageMemoryRequirements_getimageMipTailStride, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkMemoryType_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkMemoryType *self = (PyVkMemoryType *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkMemoryType));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkMemoryType");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkMemoryType_del(PyVkMemoryType* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkMemoryType_init(PyVkMemoryType *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkMemoryType_getpropertyFlags(PyVkMemoryType *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->propertyFlags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkMemoryType_getheapIndex(PyVkMemoryType *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->heapIndex));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkMemoryType_getsetters[] = {
        
            {"propertyFlags", (getter)PyVkMemoryType_getpropertyFlags, NULL, "", NULL},
        
            {"heapIndex", (getter)PyVkMemoryType_getheapIndex, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkMemoryHeap_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkMemoryHeap *self = (PyVkMemoryHeap *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkMemoryHeap));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkMemoryHeap");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkMemoryHeap_del(PyVkMemoryHeap* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkMemoryHeap_init(PyVkMemoryHeap *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkMemoryHeap_getsize(PyVkMemoryHeap *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->size));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkMemoryHeap_getflags(PyVkMemoryHeap *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkMemoryHeap_getsetters[] = {
        
            {"size", (getter)PyVkMemoryHeap_getsize, NULL, "", NULL},
        
            {"flags", (getter)PyVkMemoryHeap_getflags, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkMappedMemoryRange_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkMappedMemoryRange *self = (PyVkMappedMemoryRange *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkMappedMemoryRange));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkMappedMemoryRange");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkMappedMemoryRange_del(PyVkMappedMemoryRange* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkMappedMemoryRange_init(PyVkMappedMemoryRange *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkDeviceMemory memory;
VkDeviceSize offset;
VkDeviceSize size;

            static char *kwlist[] = {"sType","memory","offset","size",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_handle_base_VkDeviceMemory_converter,&memory,pyc_flag_base_VkDeviceSize_converter,&offset,pyc_flag_base_VkDeviceSize_converter,&size))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->memory = memory;
            
            
            
                (self->base)->offset = offset;
            
            
            
                (self->base)->size = size;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_handle_base_VkDeviceMemory_converter_free(&memory);
pyc_flag_base_VkDeviceSize_converter_free(&offset);
pyc_flag_base_VkDeviceSize_converter_free(&size);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkMappedMemoryRange_getsType(PyVkMappedMemoryRange *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkMappedMemoryRange_getpNext(PyVkMappedMemoryRange *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkMappedMemoryRange_getmemory(PyVkMappedMemoryRange *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkMappedMemoryRange_getoffset(PyVkMappedMemoryRange *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->offset));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkMappedMemoryRange_getsize(PyVkMappedMemoryRange *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->size));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkMappedMemoryRange_getsetters[] = {
        
            {"sType", (getter)PyVkMappedMemoryRange_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkMappedMemoryRange_getpNext, NULL, "", NULL},
        
            {"memory", (getter)PyVkMappedMemoryRange_getmemory, NULL, "", NULL},
        
            {"offset", (getter)PyVkMappedMemoryRange_getoffset, NULL, "", NULL},
        
            {"size", (getter)PyVkMappedMemoryRange_getsize, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkFormatProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkFormatProperties *self = (PyVkFormatProperties *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkFormatProperties));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkFormatProperties");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkFormatProperties_del(PyVkFormatProperties* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkFormatProperties_init(PyVkFormatProperties *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkFormatProperties_getlinearTilingFeatures(PyVkFormatProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->linearTilingFeatures));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkFormatProperties_getoptimalTilingFeatures(PyVkFormatProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->optimalTilingFeatures));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkFormatProperties_getbufferFeatures(PyVkFormatProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->bufferFeatures));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkFormatProperties_getsetters[] = {
        
            {"linearTilingFeatures", (getter)PyVkFormatProperties_getlinearTilingFeatures, NULL, "", NULL},
        
            {"optimalTilingFeatures", (getter)PyVkFormatProperties_getoptimalTilingFeatures, NULL, "", NULL},
        
            {"bufferFeatures", (getter)PyVkFormatProperties_getbufferFeatures, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkImageFormatProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkImageFormatProperties *self = (PyVkImageFormatProperties *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkImageFormatProperties));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkImageFormatProperties");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkImageFormatProperties_del(PyVkImageFormatProperties* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkImageFormatProperties_init(PyVkImageFormatProperties *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkImageFormatProperties_getmaxExtent(PyVkImageFormatProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent3DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent3D*) pyvalue)->base = &((self->base)->maxExtent);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageFormatProperties_getmaxMipLevels(PyVkImageFormatProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxMipLevels));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageFormatProperties_getmaxArrayLayers(PyVkImageFormatProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxArrayLayers));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageFormatProperties_getsampleCounts(PyVkImageFormatProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sampleCounts));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageFormatProperties_getmaxResourceSize(PyVkImageFormatProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->maxResourceSize));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkImageFormatProperties_getsetters[] = {
        
            {"maxExtent", (getter)PyVkImageFormatProperties_getmaxExtent, NULL, "", NULL},
        
            {"maxMipLevels", (getter)PyVkImageFormatProperties_getmaxMipLevels, NULL, "", NULL},
        
            {"maxArrayLayers", (getter)PyVkImageFormatProperties_getmaxArrayLayers, NULL, "", NULL},
        
            {"sampleCounts", (getter)PyVkImageFormatProperties_getsampleCounts, NULL, "", NULL},
        
            {"maxResourceSize", (getter)PyVkImageFormatProperties_getmaxResourceSize, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDescriptorBufferInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDescriptorBufferInfo *self = (PyVkDescriptorBufferInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDescriptorBufferInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDescriptorBufferInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDescriptorBufferInfo_del(PyVkDescriptorBufferInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDescriptorBufferInfo_init(PyVkDescriptorBufferInfo *self, PyObject *args, PyObject *kwds) {
        
            VkBuffer buffer;
VkDeviceSize offset;
VkDeviceSize range;

            static char *kwlist[] = {"buffer","offset","range",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkBuffer_converter,&buffer,pyc_flag_base_VkDeviceSize_converter,&offset,pyc_flag_base_VkDeviceSize_converter,&range))
        return -1;
    

            
            
                (self->base)->buffer = buffer;
            
            
            
                (self->base)->offset = offset;
            
            
            
                (self->base)->range = range;
            
            

            pyc_handle_base_VkBuffer_converter_free(&buffer);
pyc_flag_base_VkDeviceSize_converter_free(&offset);
pyc_flag_base_VkDeviceSize_converter_free(&range);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDescriptorBufferInfo_getbuffer(PyVkDescriptorBufferInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkDescriptorBufferInfo_getoffset(PyVkDescriptorBufferInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->offset));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDescriptorBufferInfo_getrange(PyVkDescriptorBufferInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->range));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDescriptorBufferInfo_getsetters[] = {
        
            {"buffer", (getter)PyVkDescriptorBufferInfo_getbuffer, NULL, "", NULL},
        
            {"offset", (getter)PyVkDescriptorBufferInfo_getoffset, NULL, "", NULL},
        
            {"range", (getter)PyVkDescriptorBufferInfo_getrange, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDescriptorImageInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDescriptorImageInfo *self = (PyVkDescriptorImageInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDescriptorImageInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDescriptorImageInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDescriptorImageInfo_del(PyVkDescriptorImageInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDescriptorImageInfo_init(PyVkDescriptorImageInfo *self, PyObject *args, PyObject *kwds) {
        
            VkSampler sampler;
VkImageView imageView;
VkImageLayout imageLayout;

            static char *kwlist[] = {"sampler","imageView","imageLayout",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkSampler_converter,&sampler,pyc_handle_base_VkImageView_converter,&imageView,pyc_flag_base_VkImageLayout_converter,&imageLayout))
        return -1;
    

            
            
                (self->base)->sampler = sampler;
            
            
            
                (self->base)->imageView = imageView;
            
            
            
                (self->base)->imageLayout = imageLayout;
            
            

            pyc_handle_base_VkSampler_converter_free(&sampler);
pyc_handle_base_VkImageView_converter_free(&imageView);
pyc_flag_base_VkImageLayout_converter_free(&imageLayout);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDescriptorImageInfo_getsampler(PyVkDescriptorImageInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkDescriptorImageInfo_getimageView(PyVkDescriptorImageInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkDescriptorImageInfo_getimageLayout(PyVkDescriptorImageInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->imageLayout));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDescriptorImageInfo_getsetters[] = {
        
            {"sampler", (getter)PyVkDescriptorImageInfo_getsampler, NULL, "", NULL},
        
            {"imageView", (getter)PyVkDescriptorImageInfo_getimageView, NULL, "", NULL},
        
            {"imageLayout", (getter)PyVkDescriptorImageInfo_getimageLayout, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkWriteDescriptorSet_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkWriteDescriptorSet *self = (PyVkWriteDescriptorSet *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkWriteDescriptorSet));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkWriteDescriptorSet");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkWriteDescriptorSet_del(PyVkWriteDescriptorSet* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkWriteDescriptorSet_init(PyVkWriteDescriptorSet *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkDescriptorSet dstSet;
uint32_t dstBinding;
uint32_t dstArrayElement;
uint32_t descriptorCount;
VkDescriptorType descriptorType;
VkDescriptorImageInfo* pImageInfo;
VkDescriptorBufferInfo* pBufferInfo;
VkBufferView* pTexelBufferView;

            static char *kwlist[] = {"sType","dstSet","dstBinding","dstArrayElement","descriptorCount","descriptorType","pImageInfo","pBufferInfo","pTexelBufferView",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_handle_base_VkDescriptorSet_converter,&dstSet,pyc_uint32_t_converter,&dstBinding,pyc_uint32_t_converter,&dstArrayElement,pyc_uint32_t_converter,&descriptorCount,pyc_flag_base_VkDescriptorType_converter,&descriptorType,pyc_struct_array_VkDescriptorImageInfo_converter,&pImageInfo,pyc_struct_array_VkDescriptorBufferInfo_converter,&pBufferInfo,pyc_handle_array_VkBufferView_converter,&pTexelBufferView))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->dstSet = dstSet;
            
            
            
                (self->base)->dstBinding = dstBinding;
            
            
            
                (self->base)->dstArrayElement = dstArrayElement;
            
            
            
                (self->base)->descriptorCount = descriptorCount;
            
            
            
                (self->base)->descriptorType = descriptorType;
            
            
            
                (self->base)->pImageInfo = pImageInfo;
            
            
            
                (self->base)->pBufferInfo = pBufferInfo;
            
            
            
                (self->base)->pTexelBufferView = pTexelBufferView;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_handle_base_VkDescriptorSet_converter_free(&dstSet);
pyc_uint32_t_converter_free(&dstBinding);
pyc_uint32_t_converter_free(&dstArrayElement);
pyc_uint32_t_converter_free(&descriptorCount);
pyc_flag_base_VkDescriptorType_converter_free(&descriptorType);
pyc_struct_array_VkDescriptorImageInfo_converter_free(&pImageInfo);
pyc_struct_array_VkDescriptorBufferInfo_converter_free(&pBufferInfo);
pyc_handle_array_VkBufferView_converter_free(&pTexelBufferView);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkWriteDescriptorSet_getsType(PyVkWriteDescriptorSet *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWriteDescriptorSet_getpNext(PyVkWriteDescriptorSet *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWriteDescriptorSet_getdstSet(PyVkWriteDescriptorSet *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkWriteDescriptorSet_getdstBinding(PyVkWriteDescriptorSet *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->dstBinding));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWriteDescriptorSet_getdstArrayElement(PyVkWriteDescriptorSet *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->dstArrayElement));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWriteDescriptorSet_getdescriptorCount(PyVkWriteDescriptorSet *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->descriptorCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWriteDescriptorSet_getdescriptorType(PyVkWriteDescriptorSet *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->descriptorType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWriteDescriptorSet_getpImageInfo(PyVkWriteDescriptorSet *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkDescriptorImageInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkDescriptorImageInfo*) pyvalue)->base = ((self->base)->pImageInfo);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWriteDescriptorSet_getpBufferInfo(PyVkWriteDescriptorSet *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkDescriptorBufferInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkDescriptorBufferInfo*) pyvalue)->base = ((self->base)->pBufferInfo);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWriteDescriptorSet_getpTexelBufferView(PyVkWriteDescriptorSet *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkWriteDescriptorSet_getsetters[] = {
        
            {"sType", (getter)PyVkWriteDescriptorSet_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkWriteDescriptorSet_getpNext, NULL, "", NULL},
        
            {"dstSet", (getter)PyVkWriteDescriptorSet_getdstSet, NULL, "", NULL},
        
            {"dstBinding", (getter)PyVkWriteDescriptorSet_getdstBinding, NULL, "", NULL},
        
            {"dstArrayElement", (getter)PyVkWriteDescriptorSet_getdstArrayElement, NULL, "", NULL},
        
            {"descriptorCount", (getter)PyVkWriteDescriptorSet_getdescriptorCount, NULL, "", NULL},
        
            {"descriptorType", (getter)PyVkWriteDescriptorSet_getdescriptorType, NULL, "", NULL},
        
            {"pImageInfo", (getter)PyVkWriteDescriptorSet_getpImageInfo, NULL, "", NULL},
        
            {"pBufferInfo", (getter)PyVkWriteDescriptorSet_getpBufferInfo, NULL, "", NULL},
        
            {"pTexelBufferView", (getter)PyVkWriteDescriptorSet_getpTexelBufferView, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkCopyDescriptorSet_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkCopyDescriptorSet *self = (PyVkCopyDescriptorSet *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkCopyDescriptorSet));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkCopyDescriptorSet");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkCopyDescriptorSet_del(PyVkCopyDescriptorSet* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkCopyDescriptorSet_init(PyVkCopyDescriptorSet *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkDescriptorSet srcSet;
uint32_t srcBinding;
uint32_t srcArrayElement;
VkDescriptorSet dstSet;
uint32_t dstBinding;
uint32_t dstArrayElement;
uint32_t descriptorCount;

            static char *kwlist[] = {"sType","srcSet","srcBinding","srcArrayElement","dstSet","dstBinding","dstArrayElement","descriptorCount",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_handle_base_VkDescriptorSet_converter,&srcSet,pyc_uint32_t_converter,&srcBinding,pyc_uint32_t_converter,&srcArrayElement,pyc_handle_base_VkDescriptorSet_converter,&dstSet,pyc_uint32_t_converter,&dstBinding,pyc_uint32_t_converter,&dstArrayElement,pyc_uint32_t_converter,&descriptorCount))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->srcSet = srcSet;
            
            
            
                (self->base)->srcBinding = srcBinding;
            
            
            
                (self->base)->srcArrayElement = srcArrayElement;
            
            
            
                (self->base)->dstSet = dstSet;
            
            
            
                (self->base)->dstBinding = dstBinding;
            
            
            
                (self->base)->dstArrayElement = dstArrayElement;
            
            
            
                (self->base)->descriptorCount = descriptorCount;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_handle_base_VkDescriptorSet_converter_free(&srcSet);
pyc_uint32_t_converter_free(&srcBinding);
pyc_uint32_t_converter_free(&srcArrayElement);
pyc_handle_base_VkDescriptorSet_converter_free(&dstSet);
pyc_uint32_t_converter_free(&dstBinding);
pyc_uint32_t_converter_free(&dstArrayElement);
pyc_uint32_t_converter_free(&descriptorCount);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkCopyDescriptorSet_getsType(PyVkCopyDescriptorSet *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCopyDescriptorSet_getpNext(PyVkCopyDescriptorSet *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCopyDescriptorSet_getsrcSet(PyVkCopyDescriptorSet *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkCopyDescriptorSet_getsrcBinding(PyVkCopyDescriptorSet *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->srcBinding));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCopyDescriptorSet_getsrcArrayElement(PyVkCopyDescriptorSet *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->srcArrayElement));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCopyDescriptorSet_getdstSet(PyVkCopyDescriptorSet *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkCopyDescriptorSet_getdstBinding(PyVkCopyDescriptorSet *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->dstBinding));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCopyDescriptorSet_getdstArrayElement(PyVkCopyDescriptorSet *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->dstArrayElement));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCopyDescriptorSet_getdescriptorCount(PyVkCopyDescriptorSet *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->descriptorCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkCopyDescriptorSet_getsetters[] = {
        
            {"sType", (getter)PyVkCopyDescriptorSet_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkCopyDescriptorSet_getpNext, NULL, "", NULL},
        
            {"srcSet", (getter)PyVkCopyDescriptorSet_getsrcSet, NULL, "", NULL},
        
            {"srcBinding", (getter)PyVkCopyDescriptorSet_getsrcBinding, NULL, "", NULL},
        
            {"srcArrayElement", (getter)PyVkCopyDescriptorSet_getsrcArrayElement, NULL, "", NULL},
        
            {"dstSet", (getter)PyVkCopyDescriptorSet_getdstSet, NULL, "", NULL},
        
            {"dstBinding", (getter)PyVkCopyDescriptorSet_getdstBinding, NULL, "", NULL},
        
            {"dstArrayElement", (getter)PyVkCopyDescriptorSet_getdstArrayElement, NULL, "", NULL},
        
            {"descriptorCount", (getter)PyVkCopyDescriptorSet_getdescriptorCount, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkBufferCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkBufferCreateInfo *self = (PyVkBufferCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkBufferCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkBufferCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkBufferCreateInfo_del(PyVkBufferCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkBufferCreateInfo_init(PyVkBufferCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkBufferCreateFlags flags;
VkDeviceSize size;
VkBufferUsageFlags usage;
VkSharingMode sharingMode;
uint32_t queueFamilyIndexCount;
uint32_t* pQueueFamilyIndices;

            static char *kwlist[] = {"sType","flags","size","usage","sharingMode","queueFamilyIndexCount","pQueueFamilyIndices",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkBufferCreateFlags_converter,&flags,pyc_flag_base_VkDeviceSize_converter,&size,pyc_flag_base_VkBufferUsageFlags_converter,&usage,pyc_flag_base_VkSharingMode_converter,&sharingMode,pyc_uint32_t_converter,&queueFamilyIndexCount,pyc_array_uint32_t_converter,&pQueueFamilyIndices))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->size = size;
            
            
            
                (self->base)->usage = usage;
            
            
            
                (self->base)->sharingMode = sharingMode;
            
            
            
                (self->base)->queueFamilyIndexCount = queueFamilyIndexCount;
            
            
            
                (self->base)->pQueueFamilyIndices = pQueueFamilyIndices;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkBufferCreateFlags_converter_free(&flags);
pyc_flag_base_VkDeviceSize_converter_free(&size);
pyc_flag_base_VkBufferUsageFlags_converter_free(&usage);
pyc_flag_base_VkSharingMode_converter_free(&sharingMode);
pyc_uint32_t_converter_free(&queueFamilyIndexCount);
pyc_array_uint32_t_converter_free(&pQueueFamilyIndices);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkBufferCreateInfo_getsType(PyVkBufferCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferCreateInfo_getpNext(PyVkBufferCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferCreateInfo_getflags(PyVkBufferCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferCreateInfo_getsize(PyVkBufferCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->size));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferCreateInfo_getusage(PyVkBufferCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->usage));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferCreateInfo_getsharingMode(PyVkBufferCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sharingMode));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferCreateInfo_getqueueFamilyIndexCount(PyVkBufferCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->queueFamilyIndexCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferCreateInfo_getpQueueFamilyIndices(PyVkBufferCreateInfo *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyLong_FromLong((long) (*(((self->base)->pQueueFamilyIndices))));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkBufferCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkBufferCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkBufferCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkBufferCreateInfo_getflags, NULL, "", NULL},
        
            {"size", (getter)PyVkBufferCreateInfo_getsize, NULL, "", NULL},
        
            {"usage", (getter)PyVkBufferCreateInfo_getusage, NULL, "", NULL},
        
            {"sharingMode", (getter)PyVkBufferCreateInfo_getsharingMode, NULL, "", NULL},
        
            {"queueFamilyIndexCount", (getter)PyVkBufferCreateInfo_getqueueFamilyIndexCount, NULL, "", NULL},
        
            {"pQueueFamilyIndices", (getter)PyVkBufferCreateInfo_getpQueueFamilyIndices, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkBufferViewCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkBufferViewCreateInfo *self = (PyVkBufferViewCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkBufferViewCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkBufferViewCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkBufferViewCreateInfo_del(PyVkBufferViewCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkBufferViewCreateInfo_init(PyVkBufferViewCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkBufferViewCreateFlags flags;
VkBuffer buffer;
VkFormat format;
VkDeviceSize offset;
VkDeviceSize range;

            static char *kwlist[] = {"sType","flags","buffer","format","offset","range",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkBufferViewCreateFlags_converter,&flags,pyc_handle_base_VkBuffer_converter,&buffer,pyc_flag_base_VkFormat_converter,&format,pyc_flag_base_VkDeviceSize_converter,&offset,pyc_flag_base_VkDeviceSize_converter,&range))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->buffer = buffer;
            
            
            
                (self->base)->format = format;
            
            
            
                (self->base)->offset = offset;
            
            
            
                (self->base)->range = range;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkBufferViewCreateFlags_converter_free(&flags);
pyc_handle_base_VkBuffer_converter_free(&buffer);
pyc_flag_base_VkFormat_converter_free(&format);
pyc_flag_base_VkDeviceSize_converter_free(&offset);
pyc_flag_base_VkDeviceSize_converter_free(&range);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkBufferViewCreateInfo_getsType(PyVkBufferViewCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferViewCreateInfo_getpNext(PyVkBufferViewCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferViewCreateInfo_getflags(PyVkBufferViewCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferViewCreateInfo_getbuffer(PyVkBufferViewCreateInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkBufferViewCreateInfo_getformat(PyVkBufferViewCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->format));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferViewCreateInfo_getoffset(PyVkBufferViewCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->offset));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferViewCreateInfo_getrange(PyVkBufferViewCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->range));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkBufferViewCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkBufferViewCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkBufferViewCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkBufferViewCreateInfo_getflags, NULL, "", NULL},
        
            {"buffer", (getter)PyVkBufferViewCreateInfo_getbuffer, NULL, "", NULL},
        
            {"format", (getter)PyVkBufferViewCreateInfo_getformat, NULL, "", NULL},
        
            {"offset", (getter)PyVkBufferViewCreateInfo_getoffset, NULL, "", NULL},
        
            {"range", (getter)PyVkBufferViewCreateInfo_getrange, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkImageSubresource_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkImageSubresource *self = (PyVkImageSubresource *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkImageSubresource));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkImageSubresource");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkImageSubresource_del(PyVkImageSubresource* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkImageSubresource_init(PyVkImageSubresource *self, PyObject *args, PyObject *kwds) {
        
            VkImageAspectFlags aspectMask;
uint32_t mipLevel;
uint32_t arrayLayer;

            static char *kwlist[] = {"aspectMask","mipLevel","arrayLayer",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_flag_base_VkImageAspectFlags_converter,&aspectMask,pyc_uint32_t_converter,&mipLevel,pyc_uint32_t_converter,&arrayLayer))
        return -1;
    

            
            
                (self->base)->aspectMask = aspectMask;
            
            
            
                (self->base)->mipLevel = mipLevel;
            
            
            
                (self->base)->arrayLayer = arrayLayer;
            
            

            pyc_flag_base_VkImageAspectFlags_converter_free(&aspectMask);
pyc_uint32_t_converter_free(&mipLevel);
pyc_uint32_t_converter_free(&arrayLayer);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkImageSubresource_getaspectMask(PyVkImageSubresource *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->aspectMask));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageSubresource_getmipLevel(PyVkImageSubresource *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->mipLevel));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageSubresource_getarrayLayer(PyVkImageSubresource *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->arrayLayer));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkImageSubresource_getsetters[] = {
        
            {"aspectMask", (getter)PyVkImageSubresource_getaspectMask, NULL, "", NULL},
        
            {"mipLevel", (getter)PyVkImageSubresource_getmipLevel, NULL, "", NULL},
        
            {"arrayLayer", (getter)PyVkImageSubresource_getarrayLayer, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkImageSubresourceLayers_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkImageSubresourceLayers *self = (PyVkImageSubresourceLayers *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkImageSubresourceLayers));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkImageSubresourceLayers");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkImageSubresourceLayers_del(PyVkImageSubresourceLayers* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkImageSubresourceLayers_init(PyVkImageSubresourceLayers *self, PyObject *args, PyObject *kwds) {
        
            VkImageAspectFlags aspectMask;
uint32_t mipLevel;
uint32_t baseArrayLayer;
uint32_t layerCount;

            static char *kwlist[] = {"aspectMask","mipLevel","baseArrayLayer","layerCount",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_flag_base_VkImageAspectFlags_converter,&aspectMask,pyc_uint32_t_converter,&mipLevel,pyc_uint32_t_converter,&baseArrayLayer,pyc_uint32_t_converter,&layerCount))
        return -1;
    

            
            
                (self->base)->aspectMask = aspectMask;
            
            
            
                (self->base)->mipLevel = mipLevel;
            
            
            
                (self->base)->baseArrayLayer = baseArrayLayer;
            
            
            
                (self->base)->layerCount = layerCount;
            
            

            pyc_flag_base_VkImageAspectFlags_converter_free(&aspectMask);
pyc_uint32_t_converter_free(&mipLevel);
pyc_uint32_t_converter_free(&baseArrayLayer);
pyc_uint32_t_converter_free(&layerCount);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkImageSubresourceLayers_getaspectMask(PyVkImageSubresourceLayers *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->aspectMask));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageSubresourceLayers_getmipLevel(PyVkImageSubresourceLayers *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->mipLevel));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageSubresourceLayers_getbaseArrayLayer(PyVkImageSubresourceLayers *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->baseArrayLayer));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageSubresourceLayers_getlayerCount(PyVkImageSubresourceLayers *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->layerCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkImageSubresourceLayers_getsetters[] = {
        
            {"aspectMask", (getter)PyVkImageSubresourceLayers_getaspectMask, NULL, "", NULL},
        
            {"mipLevel", (getter)PyVkImageSubresourceLayers_getmipLevel, NULL, "", NULL},
        
            {"baseArrayLayer", (getter)PyVkImageSubresourceLayers_getbaseArrayLayer, NULL, "", NULL},
        
            {"layerCount", (getter)PyVkImageSubresourceLayers_getlayerCount, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkImageSubresourceRange_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkImageSubresourceRange *self = (PyVkImageSubresourceRange *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkImageSubresourceRange));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkImageSubresourceRange");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkImageSubresourceRange_del(PyVkImageSubresourceRange* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkImageSubresourceRange_init(PyVkImageSubresourceRange *self, PyObject *args, PyObject *kwds) {
        
            VkImageAspectFlags aspectMask;
uint32_t baseMipLevel;
uint32_t levelCount;
uint32_t baseArrayLayer;
uint32_t layerCount;

            static char *kwlist[] = {"aspectMask","baseMipLevel","levelCount","baseArrayLayer","layerCount",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_flag_base_VkImageAspectFlags_converter,&aspectMask,pyc_uint32_t_converter,&baseMipLevel,pyc_uint32_t_converter,&levelCount,pyc_uint32_t_converter,&baseArrayLayer,pyc_uint32_t_converter,&layerCount))
        return -1;
    

            
            
                (self->base)->aspectMask = aspectMask;
            
            
            
                (self->base)->baseMipLevel = baseMipLevel;
            
            
            
                (self->base)->levelCount = levelCount;
            
            
            
                (self->base)->baseArrayLayer = baseArrayLayer;
            
            
            
                (self->base)->layerCount = layerCount;
            
            

            pyc_flag_base_VkImageAspectFlags_converter_free(&aspectMask);
pyc_uint32_t_converter_free(&baseMipLevel);
pyc_uint32_t_converter_free(&levelCount);
pyc_uint32_t_converter_free(&baseArrayLayer);
pyc_uint32_t_converter_free(&layerCount);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkImageSubresourceRange_getaspectMask(PyVkImageSubresourceRange *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->aspectMask));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageSubresourceRange_getbaseMipLevel(PyVkImageSubresourceRange *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->baseMipLevel));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageSubresourceRange_getlevelCount(PyVkImageSubresourceRange *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->levelCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageSubresourceRange_getbaseArrayLayer(PyVkImageSubresourceRange *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->baseArrayLayer));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageSubresourceRange_getlayerCount(PyVkImageSubresourceRange *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->layerCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkImageSubresourceRange_getsetters[] = {
        
            {"aspectMask", (getter)PyVkImageSubresourceRange_getaspectMask, NULL, "", NULL},
        
            {"baseMipLevel", (getter)PyVkImageSubresourceRange_getbaseMipLevel, NULL, "", NULL},
        
            {"levelCount", (getter)PyVkImageSubresourceRange_getlevelCount, NULL, "", NULL},
        
            {"baseArrayLayer", (getter)PyVkImageSubresourceRange_getbaseArrayLayer, NULL, "", NULL},
        
            {"layerCount", (getter)PyVkImageSubresourceRange_getlayerCount, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkMemoryBarrier_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkMemoryBarrier *self = (PyVkMemoryBarrier *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkMemoryBarrier));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkMemoryBarrier");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkMemoryBarrier_del(PyVkMemoryBarrier* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkMemoryBarrier_init(PyVkMemoryBarrier *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkAccessFlags srcAccessMask;
VkAccessFlags dstAccessMask;

            static char *kwlist[] = {"sType","srcAccessMask","dstAccessMask",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkAccessFlags_converter,&srcAccessMask,pyc_flag_base_VkAccessFlags_converter,&dstAccessMask))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->srcAccessMask = srcAccessMask;
            
            
            
                (self->base)->dstAccessMask = dstAccessMask;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkAccessFlags_converter_free(&srcAccessMask);
pyc_flag_base_VkAccessFlags_converter_free(&dstAccessMask);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkMemoryBarrier_getsType(PyVkMemoryBarrier *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkMemoryBarrier_getpNext(PyVkMemoryBarrier *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkMemoryBarrier_getsrcAccessMask(PyVkMemoryBarrier *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->srcAccessMask));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkMemoryBarrier_getdstAccessMask(PyVkMemoryBarrier *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->dstAccessMask));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkMemoryBarrier_getsetters[] = {
        
            {"sType", (getter)PyVkMemoryBarrier_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkMemoryBarrier_getpNext, NULL, "", NULL},
        
            {"srcAccessMask", (getter)PyVkMemoryBarrier_getsrcAccessMask, NULL, "", NULL},
        
            {"dstAccessMask", (getter)PyVkMemoryBarrier_getdstAccessMask, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkBufferMemoryBarrier_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkBufferMemoryBarrier *self = (PyVkBufferMemoryBarrier *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkBufferMemoryBarrier));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkBufferMemoryBarrier");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkBufferMemoryBarrier_del(PyVkBufferMemoryBarrier* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkBufferMemoryBarrier_init(PyVkBufferMemoryBarrier *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkAccessFlags srcAccessMask;
VkAccessFlags dstAccessMask;
uint32_t srcQueueFamilyIndex;
uint32_t dstQueueFamilyIndex;
VkBuffer buffer;
VkDeviceSize offset;
VkDeviceSize size;

            static char *kwlist[] = {"sType","srcAccessMask","dstAccessMask","srcQueueFamilyIndex","dstQueueFamilyIndex","buffer","offset","size",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkAccessFlags_converter,&srcAccessMask,pyc_flag_base_VkAccessFlags_converter,&dstAccessMask,pyc_uint32_t_converter,&srcQueueFamilyIndex,pyc_uint32_t_converter,&dstQueueFamilyIndex,pyc_handle_base_VkBuffer_converter,&buffer,pyc_flag_base_VkDeviceSize_converter,&offset,pyc_flag_base_VkDeviceSize_converter,&size))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->srcAccessMask = srcAccessMask;
            
            
            
                (self->base)->dstAccessMask = dstAccessMask;
            
            
            
                (self->base)->srcQueueFamilyIndex = srcQueueFamilyIndex;
            
            
            
                (self->base)->dstQueueFamilyIndex = dstQueueFamilyIndex;
            
            
            
                (self->base)->buffer = buffer;
            
            
            
                (self->base)->offset = offset;
            
            
            
                (self->base)->size = size;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkAccessFlags_converter_free(&srcAccessMask);
pyc_flag_base_VkAccessFlags_converter_free(&dstAccessMask);
pyc_uint32_t_converter_free(&srcQueueFamilyIndex);
pyc_uint32_t_converter_free(&dstQueueFamilyIndex);
pyc_handle_base_VkBuffer_converter_free(&buffer);
pyc_flag_base_VkDeviceSize_converter_free(&offset);
pyc_flag_base_VkDeviceSize_converter_free(&size);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkBufferMemoryBarrier_getsType(PyVkBufferMemoryBarrier *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferMemoryBarrier_getpNext(PyVkBufferMemoryBarrier *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferMemoryBarrier_getsrcAccessMask(PyVkBufferMemoryBarrier *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->srcAccessMask));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferMemoryBarrier_getdstAccessMask(PyVkBufferMemoryBarrier *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->dstAccessMask));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferMemoryBarrier_getsrcQueueFamilyIndex(PyVkBufferMemoryBarrier *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->srcQueueFamilyIndex));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferMemoryBarrier_getdstQueueFamilyIndex(PyVkBufferMemoryBarrier *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->dstQueueFamilyIndex));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferMemoryBarrier_getbuffer(PyVkBufferMemoryBarrier *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkBufferMemoryBarrier_getoffset(PyVkBufferMemoryBarrier *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->offset));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferMemoryBarrier_getsize(PyVkBufferMemoryBarrier *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->size));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkBufferMemoryBarrier_getsetters[] = {
        
            {"sType", (getter)PyVkBufferMemoryBarrier_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkBufferMemoryBarrier_getpNext, NULL, "", NULL},
        
            {"srcAccessMask", (getter)PyVkBufferMemoryBarrier_getsrcAccessMask, NULL, "", NULL},
        
            {"dstAccessMask", (getter)PyVkBufferMemoryBarrier_getdstAccessMask, NULL, "", NULL},
        
            {"srcQueueFamilyIndex", (getter)PyVkBufferMemoryBarrier_getsrcQueueFamilyIndex, NULL, "", NULL},
        
            {"dstQueueFamilyIndex", (getter)PyVkBufferMemoryBarrier_getdstQueueFamilyIndex, NULL, "", NULL},
        
            {"buffer", (getter)PyVkBufferMemoryBarrier_getbuffer, NULL, "", NULL},
        
            {"offset", (getter)PyVkBufferMemoryBarrier_getoffset, NULL, "", NULL},
        
            {"size", (getter)PyVkBufferMemoryBarrier_getsize, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkImageMemoryBarrier_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkImageMemoryBarrier *self = (PyVkImageMemoryBarrier *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkImageMemoryBarrier));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkImageMemoryBarrier");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkImageMemoryBarrier_del(PyVkImageMemoryBarrier* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkImageMemoryBarrier_init(PyVkImageMemoryBarrier *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkAccessFlags srcAccessMask;
VkAccessFlags dstAccessMask;
VkImageLayout oldLayout;
VkImageLayout newLayout;
uint32_t srcQueueFamilyIndex;
uint32_t dstQueueFamilyIndex;
VkImage image;
VkImageSubresourceRange subresourceRange;

            static char *kwlist[] = {"sType","srcAccessMask","dstAccessMask","oldLayout","newLayout","srcQueueFamilyIndex","dstQueueFamilyIndex","image","subresourceRange",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkAccessFlags_converter,&srcAccessMask,pyc_flag_base_VkAccessFlags_converter,&dstAccessMask,pyc_flag_base_VkImageLayout_converter,&oldLayout,pyc_flag_base_VkImageLayout_converter,&newLayout,pyc_uint32_t_converter,&srcQueueFamilyIndex,pyc_uint32_t_converter,&dstQueueFamilyIndex,pyc_handle_base_VkImage_converter,&image,pyc_struct_base_VkImageSubresourceRange_converter,&subresourceRange))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->srcAccessMask = srcAccessMask;
            
            
            
                (self->base)->dstAccessMask = dstAccessMask;
            
            
            
                (self->base)->oldLayout = oldLayout;
            
            
            
                (self->base)->newLayout = newLayout;
            
            
            
                (self->base)->srcQueueFamilyIndex = srcQueueFamilyIndex;
            
            
            
                (self->base)->dstQueueFamilyIndex = dstQueueFamilyIndex;
            
            
            
                (self->base)->image = image;
            
            
            
                (self->base)->subresourceRange = subresourceRange;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkAccessFlags_converter_free(&srcAccessMask);
pyc_flag_base_VkAccessFlags_converter_free(&dstAccessMask);
pyc_flag_base_VkImageLayout_converter_free(&oldLayout);
pyc_flag_base_VkImageLayout_converter_free(&newLayout);
pyc_uint32_t_converter_free(&srcQueueFamilyIndex);
pyc_uint32_t_converter_free(&dstQueueFamilyIndex);
pyc_handle_base_VkImage_converter_free(&image);
pyc_struct_base_VkImageSubresourceRange_converter_free(&subresourceRange);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkImageMemoryBarrier_getsType(PyVkImageMemoryBarrier *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageMemoryBarrier_getpNext(PyVkImageMemoryBarrier *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageMemoryBarrier_getsrcAccessMask(PyVkImageMemoryBarrier *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->srcAccessMask));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageMemoryBarrier_getdstAccessMask(PyVkImageMemoryBarrier *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->dstAccessMask));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageMemoryBarrier_getoldLayout(PyVkImageMemoryBarrier *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->oldLayout));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageMemoryBarrier_getnewLayout(PyVkImageMemoryBarrier *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->newLayout));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageMemoryBarrier_getsrcQueueFamilyIndex(PyVkImageMemoryBarrier *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->srcQueueFamilyIndex));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageMemoryBarrier_getdstQueueFamilyIndex(PyVkImageMemoryBarrier *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->dstQueueFamilyIndex));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageMemoryBarrier_getimage(PyVkImageMemoryBarrier *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkImageMemoryBarrier_getsubresourceRange(PyVkImageMemoryBarrier *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkImageSubresourceRangeType);
            if (!pyvalue)
                return NULL;
            ((PyVkImageSubresourceRange*) pyvalue)->base = &((self->base)->subresourceRange);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkImageMemoryBarrier_getsetters[] = {
        
            {"sType", (getter)PyVkImageMemoryBarrier_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkImageMemoryBarrier_getpNext, NULL, "", NULL},
        
            {"srcAccessMask", (getter)PyVkImageMemoryBarrier_getsrcAccessMask, NULL, "", NULL},
        
            {"dstAccessMask", (getter)PyVkImageMemoryBarrier_getdstAccessMask, NULL, "", NULL},
        
            {"oldLayout", (getter)PyVkImageMemoryBarrier_getoldLayout, NULL, "", NULL},
        
            {"newLayout", (getter)PyVkImageMemoryBarrier_getnewLayout, NULL, "", NULL},
        
            {"srcQueueFamilyIndex", (getter)PyVkImageMemoryBarrier_getsrcQueueFamilyIndex, NULL, "", NULL},
        
            {"dstQueueFamilyIndex", (getter)PyVkImageMemoryBarrier_getdstQueueFamilyIndex, NULL, "", NULL},
        
            {"image", (getter)PyVkImageMemoryBarrier_getimage, NULL, "", NULL},
        
            {"subresourceRange", (getter)PyVkImageMemoryBarrier_getsubresourceRange, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkImageCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkImageCreateInfo *self = (PyVkImageCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkImageCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkImageCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkImageCreateInfo_del(PyVkImageCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkImageCreateInfo_init(PyVkImageCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkImageCreateFlags flags;
VkImageType imageType;
VkFormat format;
VkExtent3D extent;
uint32_t mipLevels;
uint32_t arrayLayers;
VkSampleCountFlagBits samples;
VkImageTiling tiling;
VkImageUsageFlags usage;
VkSharingMode sharingMode;
uint32_t queueFamilyIndexCount;
uint32_t* pQueueFamilyIndices;
VkImageLayout initialLayout;

            static char *kwlist[] = {"sType","flags","imageType","format","extent","mipLevels","arrayLayers","samples","tiling","usage","sharingMode","queueFamilyIndexCount","pQueueFamilyIndices","initialLayout",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkImageCreateFlags_converter,&flags,pyc_flag_base_VkImageType_converter,&imageType,pyc_flag_base_VkFormat_converter,&format,pyc_struct_base_VkExtent3D_converter,&extent,pyc_uint32_t_converter,&mipLevels,pyc_uint32_t_converter,&arrayLayers,pyc_flag_base_VkSampleCountFlagBits_converter,&samples,pyc_flag_base_VkImageTiling_converter,&tiling,pyc_flag_base_VkImageUsageFlags_converter,&usage,pyc_flag_base_VkSharingMode_converter,&sharingMode,pyc_uint32_t_converter,&queueFamilyIndexCount,pyc_array_uint32_t_converter,&pQueueFamilyIndices,pyc_flag_base_VkImageLayout_converter,&initialLayout))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->imageType = imageType;
            
            
            
                (self->base)->format = format;
            
            
            
                (self->base)->extent = extent;
            
            
            
                (self->base)->mipLevels = mipLevels;
            
            
            
                (self->base)->arrayLayers = arrayLayers;
            
            
            
                (self->base)->samples = samples;
            
            
            
                (self->base)->tiling = tiling;
            
            
            
                (self->base)->usage = usage;
            
            
            
                (self->base)->sharingMode = sharingMode;
            
            
            
                (self->base)->queueFamilyIndexCount = queueFamilyIndexCount;
            
            
            
                (self->base)->pQueueFamilyIndices = pQueueFamilyIndices;
            
            
            
                (self->base)->initialLayout = initialLayout;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkImageCreateFlags_converter_free(&flags);
pyc_flag_base_VkImageType_converter_free(&imageType);
pyc_flag_base_VkFormat_converter_free(&format);
pyc_struct_base_VkExtent3D_converter_free(&extent);
pyc_uint32_t_converter_free(&mipLevels);
pyc_uint32_t_converter_free(&arrayLayers);
pyc_flag_base_VkSampleCountFlagBits_converter_free(&samples);
pyc_flag_base_VkImageTiling_converter_free(&tiling);
pyc_flag_base_VkImageUsageFlags_converter_free(&usage);
pyc_flag_base_VkSharingMode_converter_free(&sharingMode);
pyc_uint32_t_converter_free(&queueFamilyIndexCount);
pyc_array_uint32_t_converter_free(&pQueueFamilyIndices);
pyc_flag_base_VkImageLayout_converter_free(&initialLayout);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkImageCreateInfo_getsType(PyVkImageCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageCreateInfo_getpNext(PyVkImageCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageCreateInfo_getflags(PyVkImageCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageCreateInfo_getimageType(PyVkImageCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->imageType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageCreateInfo_getformat(PyVkImageCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->format));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageCreateInfo_getextent(PyVkImageCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent3DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent3D*) pyvalue)->base = &((self->base)->extent);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageCreateInfo_getmipLevels(PyVkImageCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->mipLevels));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageCreateInfo_getarrayLayers(PyVkImageCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->arrayLayers));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageCreateInfo_getsamples(PyVkImageCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->samples));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageCreateInfo_gettiling(PyVkImageCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->tiling));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageCreateInfo_getusage(PyVkImageCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->usage));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageCreateInfo_getsharingMode(PyVkImageCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sharingMode));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageCreateInfo_getqueueFamilyIndexCount(PyVkImageCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->queueFamilyIndexCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageCreateInfo_getpQueueFamilyIndices(PyVkImageCreateInfo *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyLong_FromLong((long) (*(((self->base)->pQueueFamilyIndices))));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageCreateInfo_getinitialLayout(PyVkImageCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->initialLayout));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkImageCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkImageCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkImageCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkImageCreateInfo_getflags, NULL, "", NULL},
        
            {"imageType", (getter)PyVkImageCreateInfo_getimageType, NULL, "", NULL},
        
            {"format", (getter)PyVkImageCreateInfo_getformat, NULL, "", NULL},
        
            {"extent", (getter)PyVkImageCreateInfo_getextent, NULL, "", NULL},
        
            {"mipLevels", (getter)PyVkImageCreateInfo_getmipLevels, NULL, "", NULL},
        
            {"arrayLayers", (getter)PyVkImageCreateInfo_getarrayLayers, NULL, "", NULL},
        
            {"samples", (getter)PyVkImageCreateInfo_getsamples, NULL, "", NULL},
        
            {"tiling", (getter)PyVkImageCreateInfo_gettiling, NULL, "", NULL},
        
            {"usage", (getter)PyVkImageCreateInfo_getusage, NULL, "", NULL},
        
            {"sharingMode", (getter)PyVkImageCreateInfo_getsharingMode, NULL, "", NULL},
        
            {"queueFamilyIndexCount", (getter)PyVkImageCreateInfo_getqueueFamilyIndexCount, NULL, "", NULL},
        
            {"pQueueFamilyIndices", (getter)PyVkImageCreateInfo_getpQueueFamilyIndices, NULL, "", NULL},
        
            {"initialLayout", (getter)PyVkImageCreateInfo_getinitialLayout, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkSubresourceLayout_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkSubresourceLayout *self = (PyVkSubresourceLayout *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkSubresourceLayout));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkSubresourceLayout");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkSubresourceLayout_del(PyVkSubresourceLayout* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkSubresourceLayout_init(PyVkSubresourceLayout *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkSubresourceLayout_getoffset(PyVkSubresourceLayout *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->offset));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubresourceLayout_getsize(PyVkSubresourceLayout *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->size));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubresourceLayout_getrowPitch(PyVkSubresourceLayout *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->rowPitch));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubresourceLayout_getarrayPitch(PyVkSubresourceLayout *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->arrayPitch));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubresourceLayout_getdepthPitch(PyVkSubresourceLayout *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->depthPitch));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkSubresourceLayout_getsetters[] = {
        
            {"offset", (getter)PyVkSubresourceLayout_getoffset, NULL, "", NULL},
        
            {"size", (getter)PyVkSubresourceLayout_getsize, NULL, "", NULL},
        
            {"rowPitch", (getter)PyVkSubresourceLayout_getrowPitch, NULL, "", NULL},
        
            {"arrayPitch", (getter)PyVkSubresourceLayout_getarrayPitch, NULL, "", NULL},
        
            {"depthPitch", (getter)PyVkSubresourceLayout_getdepthPitch, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkImageViewCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkImageViewCreateInfo *self = (PyVkImageViewCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkImageViewCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkImageViewCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkImageViewCreateInfo_del(PyVkImageViewCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkImageViewCreateInfo_init(PyVkImageViewCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkImageViewCreateFlags flags;
VkImage image;
VkImageViewType viewType;
VkFormat format;
VkComponentMapping components;
VkImageSubresourceRange subresourceRange;

            static char *kwlist[] = {"sType","flags","image","viewType","format","components","subresourceRange",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkImageViewCreateFlags_converter,&flags,pyc_handle_base_VkImage_converter,&image,pyc_flag_base_VkImageViewType_converter,&viewType,pyc_flag_base_VkFormat_converter,&format,pyc_struct_base_VkComponentMapping_converter,&components,pyc_struct_base_VkImageSubresourceRange_converter,&subresourceRange))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->image = image;
            
            
            
                (self->base)->viewType = viewType;
            
            
            
                (self->base)->format = format;
            
            
            
                (self->base)->components = components;
            
            
            
                (self->base)->subresourceRange = subresourceRange;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkImageViewCreateFlags_converter_free(&flags);
pyc_handle_base_VkImage_converter_free(&image);
pyc_flag_base_VkImageViewType_converter_free(&viewType);
pyc_flag_base_VkFormat_converter_free(&format);
pyc_struct_base_VkComponentMapping_converter_free(&components);
pyc_struct_base_VkImageSubresourceRange_converter_free(&subresourceRange);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkImageViewCreateInfo_getsType(PyVkImageViewCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageViewCreateInfo_getpNext(PyVkImageViewCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageViewCreateInfo_getflags(PyVkImageViewCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageViewCreateInfo_getimage(PyVkImageViewCreateInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkImageViewCreateInfo_getviewType(PyVkImageViewCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->viewType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageViewCreateInfo_getformat(PyVkImageViewCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->format));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageViewCreateInfo_getcomponents(PyVkImageViewCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkComponentMappingType);
            if (!pyvalue)
                return NULL;
            ((PyVkComponentMapping*) pyvalue)->base = &((self->base)->components);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageViewCreateInfo_getsubresourceRange(PyVkImageViewCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkImageSubresourceRangeType);
            if (!pyvalue)
                return NULL;
            ((PyVkImageSubresourceRange*) pyvalue)->base = &((self->base)->subresourceRange);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkImageViewCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkImageViewCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkImageViewCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkImageViewCreateInfo_getflags, NULL, "", NULL},
        
            {"image", (getter)PyVkImageViewCreateInfo_getimage, NULL, "", NULL},
        
            {"viewType", (getter)PyVkImageViewCreateInfo_getviewType, NULL, "", NULL},
        
            {"format", (getter)PyVkImageViewCreateInfo_getformat, NULL, "", NULL},
        
            {"components", (getter)PyVkImageViewCreateInfo_getcomponents, NULL, "", NULL},
        
            {"subresourceRange", (getter)PyVkImageViewCreateInfo_getsubresourceRange, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkBufferCopy_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkBufferCopy *self = (PyVkBufferCopy *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkBufferCopy));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkBufferCopy");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkBufferCopy_del(PyVkBufferCopy* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkBufferCopy_init(PyVkBufferCopy *self, PyObject *args, PyObject *kwds) {
        
            VkDeviceSize srcOffset;
VkDeviceSize dstOffset;
VkDeviceSize size;

            static char *kwlist[] = {"srcOffset","dstOffset","size",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_flag_base_VkDeviceSize_converter,&srcOffset,pyc_flag_base_VkDeviceSize_converter,&dstOffset,pyc_flag_base_VkDeviceSize_converter,&size))
        return -1;
    

            
            
                (self->base)->srcOffset = srcOffset;
            
            
            
                (self->base)->dstOffset = dstOffset;
            
            
            
                (self->base)->size = size;
            
            

            pyc_flag_base_VkDeviceSize_converter_free(&srcOffset);
pyc_flag_base_VkDeviceSize_converter_free(&dstOffset);
pyc_flag_base_VkDeviceSize_converter_free(&size);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkBufferCopy_getsrcOffset(PyVkBufferCopy *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->srcOffset));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferCopy_getdstOffset(PyVkBufferCopy *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->dstOffset));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferCopy_getsize(PyVkBufferCopy *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->size));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkBufferCopy_getsetters[] = {
        
            {"srcOffset", (getter)PyVkBufferCopy_getsrcOffset, NULL, "", NULL},
        
            {"dstOffset", (getter)PyVkBufferCopy_getdstOffset, NULL, "", NULL},
        
            {"size", (getter)PyVkBufferCopy_getsize, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkSparseMemoryBind_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkSparseMemoryBind *self = (PyVkSparseMemoryBind *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkSparseMemoryBind));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkSparseMemoryBind");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkSparseMemoryBind_del(PyVkSparseMemoryBind* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkSparseMemoryBind_init(PyVkSparseMemoryBind *self, PyObject *args, PyObject *kwds) {
        
            VkDeviceSize resourceOffset;
VkDeviceSize size;
VkDeviceMemory memory;
VkDeviceSize memoryOffset;
VkSparseMemoryBindFlags flags;

            static char *kwlist[] = {"resourceOffset","size","memory","memoryOffset","flags",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_flag_base_VkDeviceSize_converter,&resourceOffset,pyc_flag_base_VkDeviceSize_converter,&size,pyc_handle_base_VkDeviceMemory_converter,&memory,pyc_flag_base_VkDeviceSize_converter,&memoryOffset,pyc_flag_base_VkSparseMemoryBindFlags_converter,&flags))
        return -1;
    

            
            
                (self->base)->resourceOffset = resourceOffset;
            
            
            
                (self->base)->size = size;
            
            
            
                (self->base)->memory = memory;
            
            
            
                (self->base)->memoryOffset = memoryOffset;
            
            
            
                (self->base)->flags = flags;
            
            

            pyc_flag_base_VkDeviceSize_converter_free(&resourceOffset);
pyc_flag_base_VkDeviceSize_converter_free(&size);
pyc_handle_base_VkDeviceMemory_converter_free(&memory);
pyc_flag_base_VkDeviceSize_converter_free(&memoryOffset);
pyc_flag_base_VkSparseMemoryBindFlags_converter_free(&flags);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkSparseMemoryBind_getresourceOffset(PyVkSparseMemoryBind *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->resourceOffset));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSparseMemoryBind_getsize(PyVkSparseMemoryBind *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->size));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSparseMemoryBind_getmemory(PyVkSparseMemoryBind *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkSparseMemoryBind_getmemoryOffset(PyVkSparseMemoryBind *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->memoryOffset));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSparseMemoryBind_getflags(PyVkSparseMemoryBind *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkSparseMemoryBind_getsetters[] = {
        
            {"resourceOffset", (getter)PyVkSparseMemoryBind_getresourceOffset, NULL, "", NULL},
        
            {"size", (getter)PyVkSparseMemoryBind_getsize, NULL, "", NULL},
        
            {"memory", (getter)PyVkSparseMemoryBind_getmemory, NULL, "", NULL},
        
            {"memoryOffset", (getter)PyVkSparseMemoryBind_getmemoryOffset, NULL, "", NULL},
        
            {"flags", (getter)PyVkSparseMemoryBind_getflags, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkSparseImageMemoryBind_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkSparseImageMemoryBind *self = (PyVkSparseImageMemoryBind *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkSparseImageMemoryBind));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkSparseImageMemoryBind");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkSparseImageMemoryBind_del(PyVkSparseImageMemoryBind* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkSparseImageMemoryBind_init(PyVkSparseImageMemoryBind *self, PyObject *args, PyObject *kwds) {
        
            VkImageSubresource subresource;
VkOffset3D offset;
VkExtent3D extent;
VkDeviceMemory memory;
VkDeviceSize memoryOffset;
VkSparseMemoryBindFlags flags;

            static char *kwlist[] = {"subresource","offset","extent","memory","memoryOffset","flags",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_struct_base_VkImageSubresource_converter,&subresource,pyc_struct_base_VkOffset3D_converter,&offset,pyc_struct_base_VkExtent3D_converter,&extent,pyc_handle_base_VkDeviceMemory_converter,&memory,pyc_flag_base_VkDeviceSize_converter,&memoryOffset,pyc_flag_base_VkSparseMemoryBindFlags_converter,&flags))
        return -1;
    

            
            
                (self->base)->subresource = subresource;
            
            
            
                (self->base)->offset = offset;
            
            
            
                (self->base)->extent = extent;
            
            
            
                (self->base)->memory = memory;
            
            
            
                (self->base)->memoryOffset = memoryOffset;
            
            
            
                (self->base)->flags = flags;
            
            

            pyc_struct_base_VkImageSubresource_converter_free(&subresource);
pyc_struct_base_VkOffset3D_converter_free(&offset);
pyc_struct_base_VkExtent3D_converter_free(&extent);
pyc_handle_base_VkDeviceMemory_converter_free(&memory);
pyc_flag_base_VkDeviceSize_converter_free(&memoryOffset);
pyc_flag_base_VkSparseMemoryBindFlags_converter_free(&flags);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkSparseImageMemoryBind_getsubresource(PyVkSparseImageMemoryBind *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkImageSubresourceType);
            if (!pyvalue)
                return NULL;
            ((PyVkImageSubresource*) pyvalue)->base = &((self->base)->subresource);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSparseImageMemoryBind_getoffset(PyVkSparseImageMemoryBind *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkOffset3DType);
            if (!pyvalue)
                return NULL;
            ((PyVkOffset3D*) pyvalue)->base = &((self->base)->offset);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSparseImageMemoryBind_getextent(PyVkSparseImageMemoryBind *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent3DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent3D*) pyvalue)->base = &((self->base)->extent);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSparseImageMemoryBind_getmemory(PyVkSparseImageMemoryBind *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkSparseImageMemoryBind_getmemoryOffset(PyVkSparseImageMemoryBind *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->memoryOffset));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSparseImageMemoryBind_getflags(PyVkSparseImageMemoryBind *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkSparseImageMemoryBind_getsetters[] = {
        
            {"subresource", (getter)PyVkSparseImageMemoryBind_getsubresource, NULL, "", NULL},
        
            {"offset", (getter)PyVkSparseImageMemoryBind_getoffset, NULL, "", NULL},
        
            {"extent", (getter)PyVkSparseImageMemoryBind_getextent, NULL, "", NULL},
        
            {"memory", (getter)PyVkSparseImageMemoryBind_getmemory, NULL, "", NULL},
        
            {"memoryOffset", (getter)PyVkSparseImageMemoryBind_getmemoryOffset, NULL, "", NULL},
        
            {"flags", (getter)PyVkSparseImageMemoryBind_getflags, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkSparseBufferMemoryBindInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkSparseBufferMemoryBindInfo *self = (PyVkSparseBufferMemoryBindInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkSparseBufferMemoryBindInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkSparseBufferMemoryBindInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkSparseBufferMemoryBindInfo_del(PyVkSparseBufferMemoryBindInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkSparseBufferMemoryBindInfo_init(PyVkSparseBufferMemoryBindInfo *self, PyObject *args, PyObject *kwds) {
        
            VkBuffer buffer;
uint32_t bindCount;
VkSparseMemoryBind* pBinds;

            static char *kwlist[] = {"buffer","bindCount","pBinds",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkBuffer_converter,&buffer,pyc_uint32_t_converter,&bindCount,pyc_struct_array_VkSparseMemoryBind_converter,&pBinds))
        return -1;
    

            
            
                (self->base)->buffer = buffer;
            
            
            
                (self->base)->bindCount = bindCount;
            
            
            
                (self->base)->pBinds = pBinds;
            
            

            pyc_handle_base_VkBuffer_converter_free(&buffer);
pyc_uint32_t_converter_free(&bindCount);
pyc_struct_array_VkSparseMemoryBind_converter_free(&pBinds);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkSparseBufferMemoryBindInfo_getbuffer(PyVkSparseBufferMemoryBindInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkSparseBufferMemoryBindInfo_getbindCount(PyVkSparseBufferMemoryBindInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->bindCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSparseBufferMemoryBindInfo_getpBinds(PyVkSparseBufferMemoryBindInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkSparseMemoryBindType);
            if (!pyvalue)
                return NULL;
            ((PyVkSparseMemoryBind*) pyvalue)->base = ((self->base)->pBinds);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkSparseBufferMemoryBindInfo_getsetters[] = {
        
            {"buffer", (getter)PyVkSparseBufferMemoryBindInfo_getbuffer, NULL, "", NULL},
        
            {"bindCount", (getter)PyVkSparseBufferMemoryBindInfo_getbindCount, NULL, "", NULL},
        
            {"pBinds", (getter)PyVkSparseBufferMemoryBindInfo_getpBinds, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkSparseImageOpaqueMemoryBindInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkSparseImageOpaqueMemoryBindInfo *self = (PyVkSparseImageOpaqueMemoryBindInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkSparseImageOpaqueMemoryBindInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkSparseImageOpaqueMemoryBindInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkSparseImageOpaqueMemoryBindInfo_del(PyVkSparseImageOpaqueMemoryBindInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkSparseImageOpaqueMemoryBindInfo_init(PyVkSparseImageOpaqueMemoryBindInfo *self, PyObject *args, PyObject *kwds) {
        
            VkImage image;
uint32_t bindCount;
VkSparseMemoryBind* pBinds;

            static char *kwlist[] = {"image","bindCount","pBinds",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkImage_converter,&image,pyc_uint32_t_converter,&bindCount,pyc_struct_array_VkSparseMemoryBind_converter,&pBinds))
        return -1;
    

            
            
                (self->base)->image = image;
            
            
            
                (self->base)->bindCount = bindCount;
            
            
            
                (self->base)->pBinds = pBinds;
            
            

            pyc_handle_base_VkImage_converter_free(&image);
pyc_uint32_t_converter_free(&bindCount);
pyc_struct_array_VkSparseMemoryBind_converter_free(&pBinds);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkSparseImageOpaqueMemoryBindInfo_getimage(PyVkSparseImageOpaqueMemoryBindInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkSparseImageOpaqueMemoryBindInfo_getbindCount(PyVkSparseImageOpaqueMemoryBindInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->bindCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSparseImageOpaqueMemoryBindInfo_getpBinds(PyVkSparseImageOpaqueMemoryBindInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkSparseMemoryBindType);
            if (!pyvalue)
                return NULL;
            ((PyVkSparseMemoryBind*) pyvalue)->base = ((self->base)->pBinds);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkSparseImageOpaqueMemoryBindInfo_getsetters[] = {
        
            {"image", (getter)PyVkSparseImageOpaqueMemoryBindInfo_getimage, NULL, "", NULL},
        
            {"bindCount", (getter)PyVkSparseImageOpaqueMemoryBindInfo_getbindCount, NULL, "", NULL},
        
            {"pBinds", (getter)PyVkSparseImageOpaqueMemoryBindInfo_getpBinds, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkSparseImageMemoryBindInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkSparseImageMemoryBindInfo *self = (PyVkSparseImageMemoryBindInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkSparseImageMemoryBindInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkSparseImageMemoryBindInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkSparseImageMemoryBindInfo_del(PyVkSparseImageMemoryBindInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkSparseImageMemoryBindInfo_init(PyVkSparseImageMemoryBindInfo *self, PyObject *args, PyObject *kwds) {
        
            VkImage image;
uint32_t bindCount;
VkSparseImageMemoryBind* pBinds;

            static char *kwlist[] = {"image","bindCount","pBinds",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkImage_converter,&image,pyc_uint32_t_converter,&bindCount,pyc_struct_array_VkSparseImageMemoryBind_converter,&pBinds))
        return -1;
    

            
            
                (self->base)->image = image;
            
            
            
                (self->base)->bindCount = bindCount;
            
            
            
                (self->base)->pBinds = pBinds;
            
            

            pyc_handle_base_VkImage_converter_free(&image);
pyc_uint32_t_converter_free(&bindCount);
pyc_struct_array_VkSparseImageMemoryBind_converter_free(&pBinds);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkSparseImageMemoryBindInfo_getimage(PyVkSparseImageMemoryBindInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkSparseImageMemoryBindInfo_getbindCount(PyVkSparseImageMemoryBindInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->bindCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSparseImageMemoryBindInfo_getpBinds(PyVkSparseImageMemoryBindInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkSparseImageMemoryBindType);
            if (!pyvalue)
                return NULL;
            ((PyVkSparseImageMemoryBind*) pyvalue)->base = ((self->base)->pBinds);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkSparseImageMemoryBindInfo_getsetters[] = {
        
            {"image", (getter)PyVkSparseImageMemoryBindInfo_getimage, NULL, "", NULL},
        
            {"bindCount", (getter)PyVkSparseImageMemoryBindInfo_getbindCount, NULL, "", NULL},
        
            {"pBinds", (getter)PyVkSparseImageMemoryBindInfo_getpBinds, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkBindSparseInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkBindSparseInfo *self = (PyVkBindSparseInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkBindSparseInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkBindSparseInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkBindSparseInfo_del(PyVkBindSparseInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkBindSparseInfo_init(PyVkBindSparseInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
uint32_t waitSemaphoreCount;
VkSemaphore* pWaitSemaphores;
uint32_t bufferBindCount;
VkSparseBufferMemoryBindInfo* pBufferBinds;
uint32_t imageOpaqueBindCount;
VkSparseImageOpaqueMemoryBindInfo* pImageOpaqueBinds;
uint32_t imageBindCount;
VkSparseImageMemoryBindInfo* pImageBinds;
uint32_t signalSemaphoreCount;
VkSemaphore* pSignalSemaphores;

            static char *kwlist[] = {"sType","waitSemaphoreCount","pWaitSemaphores","bufferBindCount","pBufferBinds","imageOpaqueBindCount","pImageOpaqueBinds","imageBindCount","pImageBinds","signalSemaphoreCount","pSignalSemaphores",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_uint32_t_converter,&waitSemaphoreCount,pyc_handle_array_VkSemaphore_converter,&pWaitSemaphores,pyc_uint32_t_converter,&bufferBindCount,pyc_struct_array_VkSparseBufferMemoryBindInfo_converter,&pBufferBinds,pyc_uint32_t_converter,&imageOpaqueBindCount,pyc_struct_array_VkSparseImageOpaqueMemoryBindInfo_converter,&pImageOpaqueBinds,pyc_uint32_t_converter,&imageBindCount,pyc_struct_array_VkSparseImageMemoryBindInfo_converter,&pImageBinds,pyc_uint32_t_converter,&signalSemaphoreCount,pyc_handle_array_VkSemaphore_converter,&pSignalSemaphores))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->waitSemaphoreCount = waitSemaphoreCount;
            
            
            
                (self->base)->pWaitSemaphores = pWaitSemaphores;
            
            
            
                (self->base)->bufferBindCount = bufferBindCount;
            
            
            
                (self->base)->pBufferBinds = pBufferBinds;
            
            
            
                (self->base)->imageOpaqueBindCount = imageOpaqueBindCount;
            
            
            
                (self->base)->pImageOpaqueBinds = pImageOpaqueBinds;
            
            
            
                (self->base)->imageBindCount = imageBindCount;
            
            
            
                (self->base)->pImageBinds = pImageBinds;
            
            
            
                (self->base)->signalSemaphoreCount = signalSemaphoreCount;
            
            
            
                (self->base)->pSignalSemaphores = pSignalSemaphores;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_uint32_t_converter_free(&waitSemaphoreCount);
pyc_handle_array_VkSemaphore_converter_free(&pWaitSemaphores);
pyc_uint32_t_converter_free(&bufferBindCount);
pyc_struct_array_VkSparseBufferMemoryBindInfo_converter_free(&pBufferBinds);
pyc_uint32_t_converter_free(&imageOpaqueBindCount);
pyc_struct_array_VkSparseImageOpaqueMemoryBindInfo_converter_free(&pImageOpaqueBinds);
pyc_uint32_t_converter_free(&imageBindCount);
pyc_struct_array_VkSparseImageMemoryBindInfo_converter_free(&pImageBinds);
pyc_uint32_t_converter_free(&signalSemaphoreCount);
pyc_handle_array_VkSemaphore_converter_free(&pSignalSemaphores);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkBindSparseInfo_getsType(PyVkBindSparseInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBindSparseInfo_getpNext(PyVkBindSparseInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBindSparseInfo_getwaitSemaphoreCount(PyVkBindSparseInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->waitSemaphoreCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBindSparseInfo_getpWaitSemaphores(PyVkBindSparseInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkBindSparseInfo_getbufferBindCount(PyVkBindSparseInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->bufferBindCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBindSparseInfo_getpBufferBinds(PyVkBindSparseInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkSparseBufferMemoryBindInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkSparseBufferMemoryBindInfo*) pyvalue)->base = ((self->base)->pBufferBinds);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBindSparseInfo_getimageOpaqueBindCount(PyVkBindSparseInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->imageOpaqueBindCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBindSparseInfo_getpImageOpaqueBinds(PyVkBindSparseInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkSparseImageOpaqueMemoryBindInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkSparseImageOpaqueMemoryBindInfo*) pyvalue)->base = ((self->base)->pImageOpaqueBinds);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBindSparseInfo_getimageBindCount(PyVkBindSparseInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->imageBindCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBindSparseInfo_getpImageBinds(PyVkBindSparseInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkSparseImageMemoryBindInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkSparseImageMemoryBindInfo*) pyvalue)->base = ((self->base)->pImageBinds);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBindSparseInfo_getsignalSemaphoreCount(PyVkBindSparseInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->signalSemaphoreCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBindSparseInfo_getpSignalSemaphores(PyVkBindSparseInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkBindSparseInfo_getsetters[] = {
        
            {"sType", (getter)PyVkBindSparseInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkBindSparseInfo_getpNext, NULL, "", NULL},
        
            {"waitSemaphoreCount", (getter)PyVkBindSparseInfo_getwaitSemaphoreCount, NULL, "", NULL},
        
            {"pWaitSemaphores", (getter)PyVkBindSparseInfo_getpWaitSemaphores, NULL, "", NULL},
        
            {"bufferBindCount", (getter)PyVkBindSparseInfo_getbufferBindCount, NULL, "", NULL},
        
            {"pBufferBinds", (getter)PyVkBindSparseInfo_getpBufferBinds, NULL, "", NULL},
        
            {"imageOpaqueBindCount", (getter)PyVkBindSparseInfo_getimageOpaqueBindCount, NULL, "", NULL},
        
            {"pImageOpaqueBinds", (getter)PyVkBindSparseInfo_getpImageOpaqueBinds, NULL, "", NULL},
        
            {"imageBindCount", (getter)PyVkBindSparseInfo_getimageBindCount, NULL, "", NULL},
        
            {"pImageBinds", (getter)PyVkBindSparseInfo_getpImageBinds, NULL, "", NULL},
        
            {"signalSemaphoreCount", (getter)PyVkBindSparseInfo_getsignalSemaphoreCount, NULL, "", NULL},
        
            {"pSignalSemaphores", (getter)PyVkBindSparseInfo_getpSignalSemaphores, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkImageCopy_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkImageCopy *self = (PyVkImageCopy *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkImageCopy));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkImageCopy");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkImageCopy_del(PyVkImageCopy* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkImageCopy_init(PyVkImageCopy *self, PyObject *args, PyObject *kwds) {
        
            VkImageSubresourceLayers srcSubresource;
VkOffset3D srcOffset;
VkImageSubresourceLayers dstSubresource;
VkOffset3D dstOffset;
VkExtent3D extent;

            static char *kwlist[] = {"srcSubresource","srcOffset","dstSubresource","dstOffset","extent",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_struct_base_VkImageSubresourceLayers_converter,&srcSubresource,pyc_struct_base_VkOffset3D_converter,&srcOffset,pyc_struct_base_VkImageSubresourceLayers_converter,&dstSubresource,pyc_struct_base_VkOffset3D_converter,&dstOffset,pyc_struct_base_VkExtent3D_converter,&extent))
        return -1;
    

            
            
                (self->base)->srcSubresource = srcSubresource;
            
            
            
                (self->base)->srcOffset = srcOffset;
            
            
            
                (self->base)->dstSubresource = dstSubresource;
            
            
            
                (self->base)->dstOffset = dstOffset;
            
            
            
                (self->base)->extent = extent;
            
            

            pyc_struct_base_VkImageSubresourceLayers_converter_free(&srcSubresource);
pyc_struct_base_VkOffset3D_converter_free(&srcOffset);
pyc_struct_base_VkImageSubresourceLayers_converter_free(&dstSubresource);
pyc_struct_base_VkOffset3D_converter_free(&dstOffset);
pyc_struct_base_VkExtent3D_converter_free(&extent);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkImageCopy_getsrcSubresource(PyVkImageCopy *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkImageSubresourceLayersType);
            if (!pyvalue)
                return NULL;
            ((PyVkImageSubresourceLayers*) pyvalue)->base = &((self->base)->srcSubresource);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageCopy_getsrcOffset(PyVkImageCopy *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkOffset3DType);
            if (!pyvalue)
                return NULL;
            ((PyVkOffset3D*) pyvalue)->base = &((self->base)->srcOffset);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageCopy_getdstSubresource(PyVkImageCopy *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkImageSubresourceLayersType);
            if (!pyvalue)
                return NULL;
            ((PyVkImageSubresourceLayers*) pyvalue)->base = &((self->base)->dstSubresource);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageCopy_getdstOffset(PyVkImageCopy *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkOffset3DType);
            if (!pyvalue)
                return NULL;
            ((PyVkOffset3D*) pyvalue)->base = &((self->base)->dstOffset);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageCopy_getextent(PyVkImageCopy *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent3DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent3D*) pyvalue)->base = &((self->base)->extent);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkImageCopy_getsetters[] = {
        
            {"srcSubresource", (getter)PyVkImageCopy_getsrcSubresource, NULL, "", NULL},
        
            {"srcOffset", (getter)PyVkImageCopy_getsrcOffset, NULL, "", NULL},
        
            {"dstSubresource", (getter)PyVkImageCopy_getdstSubresource, NULL, "", NULL},
        
            {"dstOffset", (getter)PyVkImageCopy_getdstOffset, NULL, "", NULL},
        
            {"extent", (getter)PyVkImageCopy_getextent, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkImageBlit_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkImageBlit *self = (PyVkImageBlit *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkImageBlit));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkImageBlit");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkImageBlit_del(PyVkImageBlit* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkImageBlit_init(PyVkImageBlit *self, PyObject *args, PyObject *kwds) {
        
            VkImageSubresourceLayers srcSubresource;
VkOffset3D* srcOffsets;
VkImageSubresourceLayers dstSubresource;
VkOffset3D* dstOffsets;

            static char *kwlist[] = {"srcSubresource","srcOffsets","dstSubresource","dstOffsets",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_struct_base_VkImageSubresourceLayers_converter,&srcSubresource,pyc_struct_array_VkOffset3D_converter,&srcOffsets,pyc_struct_base_VkImageSubresourceLayers_converter,&dstSubresource,pyc_struct_array_VkOffset3D_converter,&dstOffsets))
        return -1;
    

            
            
                (self->base)->srcSubresource = srcSubresource;
            
            
            
                
        memcpy((self->base)->srcOffsets, srcOffsets, 2 * sizeof(VkOffset3D));
        
            
            
            
                (self->base)->dstSubresource = dstSubresource;
            
            
            
                
        memcpy((self->base)->dstOffsets, dstOffsets, 2 * sizeof(VkOffset3D));
        
            
            

            pyc_struct_base_VkImageSubresourceLayers_converter_free(&srcSubresource);
pyc_struct_array_VkOffset3D_converter_free(&srcOffsets);
pyc_struct_base_VkImageSubresourceLayers_converter_free(&dstSubresource);
pyc_struct_array_VkOffset3D_converter_free(&dstOffsets);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkImageBlit_getsrcSubresource(PyVkImageBlit *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkImageSubresourceLayersType);
            if (!pyvalue)
                return NULL;
            ((PyVkImageSubresourceLayers*) pyvalue)->base = &((self->base)->srcSubresource);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageBlit_getsrcOffsets(PyVkImageBlit *self, void *closure) {
            
            
                
                PyObject* pyvalue = PyList_New(0);
                int nb = sizeof(((self->base)->srcOffsets)) / sizeof(((self->base)->srcOffsets)[0]);
                int i = 0;
                for (i = 0; i < nb; i++) {
                    PyObject* tmp = _PyObject_New(&PyVkOffset3DType);
                    if (!tmp)
                        return NULL;
                    ((PyVkOffset3D*) tmp)->base = ((self->base)->srcOffsets);
                    PyList_Append(pyvalue, tmp);
                }
                
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageBlit_getdstSubresource(PyVkImageBlit *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkImageSubresourceLayersType);
            if (!pyvalue)
                return NULL;
            ((PyVkImageSubresourceLayers*) pyvalue)->base = &((self->base)->dstSubresource);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageBlit_getdstOffsets(PyVkImageBlit *self, void *closure) {
            
            
                
                PyObject* pyvalue = PyList_New(0);
                int nb = sizeof(((self->base)->dstOffsets)) / sizeof(((self->base)->dstOffsets)[0]);
                int i = 0;
                for (i = 0; i < nb; i++) {
                    PyObject* tmp = _PyObject_New(&PyVkOffset3DType);
                    if (!tmp)
                        return NULL;
                    ((PyVkOffset3D*) tmp)->base = ((self->base)->dstOffsets);
                    PyList_Append(pyvalue, tmp);
                }
                
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkImageBlit_getsetters[] = {
        
            {"srcSubresource", (getter)PyVkImageBlit_getsrcSubresource, NULL, "", NULL},
        
            {"srcOffsets", (getter)PyVkImageBlit_getsrcOffsets, NULL, "", NULL},
        
            {"dstSubresource", (getter)PyVkImageBlit_getdstSubresource, NULL, "", NULL},
        
            {"dstOffsets", (getter)PyVkImageBlit_getdstOffsets, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkBufferImageCopy_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkBufferImageCopy *self = (PyVkBufferImageCopy *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkBufferImageCopy));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkBufferImageCopy");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkBufferImageCopy_del(PyVkBufferImageCopy* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkBufferImageCopy_init(PyVkBufferImageCopy *self, PyObject *args, PyObject *kwds) {
        
            VkDeviceSize bufferOffset;
uint32_t bufferRowLength;
uint32_t bufferImageHeight;
VkImageSubresourceLayers imageSubresource;
VkOffset3D imageOffset;
VkExtent3D imageExtent;

            static char *kwlist[] = {"bufferOffset","bufferRowLength","bufferImageHeight","imageSubresource","imageOffset","imageExtent",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_flag_base_VkDeviceSize_converter,&bufferOffset,pyc_uint32_t_converter,&bufferRowLength,pyc_uint32_t_converter,&bufferImageHeight,pyc_struct_base_VkImageSubresourceLayers_converter,&imageSubresource,pyc_struct_base_VkOffset3D_converter,&imageOffset,pyc_struct_base_VkExtent3D_converter,&imageExtent))
        return -1;
    

            
            
                (self->base)->bufferOffset = bufferOffset;
            
            
            
                (self->base)->bufferRowLength = bufferRowLength;
            
            
            
                (self->base)->bufferImageHeight = bufferImageHeight;
            
            
            
                (self->base)->imageSubresource = imageSubresource;
            
            
            
                (self->base)->imageOffset = imageOffset;
            
            
            
                (self->base)->imageExtent = imageExtent;
            
            

            pyc_flag_base_VkDeviceSize_converter_free(&bufferOffset);
pyc_uint32_t_converter_free(&bufferRowLength);
pyc_uint32_t_converter_free(&bufferImageHeight);
pyc_struct_base_VkImageSubresourceLayers_converter_free(&imageSubresource);
pyc_struct_base_VkOffset3D_converter_free(&imageOffset);
pyc_struct_base_VkExtent3D_converter_free(&imageExtent);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkBufferImageCopy_getbufferOffset(PyVkBufferImageCopy *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->bufferOffset));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferImageCopy_getbufferRowLength(PyVkBufferImageCopy *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->bufferRowLength));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferImageCopy_getbufferImageHeight(PyVkBufferImageCopy *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->bufferImageHeight));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferImageCopy_getimageSubresource(PyVkBufferImageCopy *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkImageSubresourceLayersType);
            if (!pyvalue)
                return NULL;
            ((PyVkImageSubresourceLayers*) pyvalue)->base = &((self->base)->imageSubresource);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferImageCopy_getimageOffset(PyVkBufferImageCopy *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkOffset3DType);
            if (!pyvalue)
                return NULL;
            ((PyVkOffset3D*) pyvalue)->base = &((self->base)->imageOffset);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkBufferImageCopy_getimageExtent(PyVkBufferImageCopy *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent3DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent3D*) pyvalue)->base = &((self->base)->imageExtent);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkBufferImageCopy_getsetters[] = {
        
            {"bufferOffset", (getter)PyVkBufferImageCopy_getbufferOffset, NULL, "", NULL},
        
            {"bufferRowLength", (getter)PyVkBufferImageCopy_getbufferRowLength, NULL, "", NULL},
        
            {"bufferImageHeight", (getter)PyVkBufferImageCopy_getbufferImageHeight, NULL, "", NULL},
        
            {"imageSubresource", (getter)PyVkBufferImageCopy_getimageSubresource, NULL, "", NULL},
        
            {"imageOffset", (getter)PyVkBufferImageCopy_getimageOffset, NULL, "", NULL},
        
            {"imageExtent", (getter)PyVkBufferImageCopy_getimageExtent, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkImageResolve_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkImageResolve *self = (PyVkImageResolve *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkImageResolve));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkImageResolve");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkImageResolve_del(PyVkImageResolve* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkImageResolve_init(PyVkImageResolve *self, PyObject *args, PyObject *kwds) {
        
            VkImageSubresourceLayers srcSubresource;
VkOffset3D srcOffset;
VkImageSubresourceLayers dstSubresource;
VkOffset3D dstOffset;
VkExtent3D extent;

            static char *kwlist[] = {"srcSubresource","srcOffset","dstSubresource","dstOffset","extent",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_struct_base_VkImageSubresourceLayers_converter,&srcSubresource,pyc_struct_base_VkOffset3D_converter,&srcOffset,pyc_struct_base_VkImageSubresourceLayers_converter,&dstSubresource,pyc_struct_base_VkOffset3D_converter,&dstOffset,pyc_struct_base_VkExtent3D_converter,&extent))
        return -1;
    

            
            
                (self->base)->srcSubresource = srcSubresource;
            
            
            
                (self->base)->srcOffset = srcOffset;
            
            
            
                (self->base)->dstSubresource = dstSubresource;
            
            
            
                (self->base)->dstOffset = dstOffset;
            
            
            
                (self->base)->extent = extent;
            
            

            pyc_struct_base_VkImageSubresourceLayers_converter_free(&srcSubresource);
pyc_struct_base_VkOffset3D_converter_free(&srcOffset);
pyc_struct_base_VkImageSubresourceLayers_converter_free(&dstSubresource);
pyc_struct_base_VkOffset3D_converter_free(&dstOffset);
pyc_struct_base_VkExtent3D_converter_free(&extent);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkImageResolve_getsrcSubresource(PyVkImageResolve *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkImageSubresourceLayersType);
            if (!pyvalue)
                return NULL;
            ((PyVkImageSubresourceLayers*) pyvalue)->base = &((self->base)->srcSubresource);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageResolve_getsrcOffset(PyVkImageResolve *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkOffset3DType);
            if (!pyvalue)
                return NULL;
            ((PyVkOffset3D*) pyvalue)->base = &((self->base)->srcOffset);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageResolve_getdstSubresource(PyVkImageResolve *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkImageSubresourceLayersType);
            if (!pyvalue)
                return NULL;
            ((PyVkImageSubresourceLayers*) pyvalue)->base = &((self->base)->dstSubresource);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageResolve_getdstOffset(PyVkImageResolve *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkOffset3DType);
            if (!pyvalue)
                return NULL;
            ((PyVkOffset3D*) pyvalue)->base = &((self->base)->dstOffset);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImageResolve_getextent(PyVkImageResolve *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent3DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent3D*) pyvalue)->base = &((self->base)->extent);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkImageResolve_getsetters[] = {
        
            {"srcSubresource", (getter)PyVkImageResolve_getsrcSubresource, NULL, "", NULL},
        
            {"srcOffset", (getter)PyVkImageResolve_getsrcOffset, NULL, "", NULL},
        
            {"dstSubresource", (getter)PyVkImageResolve_getdstSubresource, NULL, "", NULL},
        
            {"dstOffset", (getter)PyVkImageResolve_getdstOffset, NULL, "", NULL},
        
            {"extent", (getter)PyVkImageResolve_getextent, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkShaderModuleCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkShaderModuleCreateInfo *self = (PyVkShaderModuleCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkShaderModuleCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkShaderModuleCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkShaderModuleCreateInfo_del(PyVkShaderModuleCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkShaderModuleCreateInfo_init(PyVkShaderModuleCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkShaderModuleCreateFlags flags;
size_t codeSize;
uint32_t* pCode;

            static char *kwlist[] = {"sType","flags","codeSize","pCode",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkShaderModuleCreateFlags_converter,&flags,pyc_size_t_converter,&codeSize,pyc_array_uint32_t_converter,&pCode))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->codeSize = codeSize;
            
            
            
                (self->base)->pCode = pCode;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkShaderModuleCreateFlags_converter_free(&flags);
pyc_size_t_converter_free(&codeSize);
pyc_array_uint32_t_converter_free(&pCode);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkShaderModuleCreateInfo_getsType(PyVkShaderModuleCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkShaderModuleCreateInfo_getpNext(PyVkShaderModuleCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkShaderModuleCreateInfo_getflags(PyVkShaderModuleCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkShaderModuleCreateInfo_getcodeSize(PyVkShaderModuleCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->codeSize));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkShaderModuleCreateInfo_getpCode(PyVkShaderModuleCreateInfo *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyLong_FromLong((long) (*(((self->base)->pCode))));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkShaderModuleCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkShaderModuleCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkShaderModuleCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkShaderModuleCreateInfo_getflags, NULL, "", NULL},
        
            {"codeSize", (getter)PyVkShaderModuleCreateInfo_getcodeSize, NULL, "", NULL},
        
            {"pCode", (getter)PyVkShaderModuleCreateInfo_getpCode, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDescriptorSetLayoutBinding_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDescriptorSetLayoutBinding *self = (PyVkDescriptorSetLayoutBinding *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDescriptorSetLayoutBinding));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDescriptorSetLayoutBinding");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDescriptorSetLayoutBinding_del(PyVkDescriptorSetLayoutBinding* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDescriptorSetLayoutBinding_init(PyVkDescriptorSetLayoutBinding *self, PyObject *args, PyObject *kwds) {
        
            uint32_t binding;
VkDescriptorType descriptorType;
uint32_t descriptorCount;
VkShaderStageFlags stageFlags;
VkSampler* pImmutableSamplers;

            static char *kwlist[] = {"binding","descriptorType","descriptorCount","stageFlags","pImmutableSamplers",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_uint32_t_converter,&binding,pyc_flag_base_VkDescriptorType_converter,&descriptorType,pyc_uint32_t_converter,&descriptorCount,pyc_flag_base_VkShaderStageFlags_converter,&stageFlags,pyc_handle_array_VkSampler_converter,&pImmutableSamplers))
        return -1;
    

            
            
                (self->base)->binding = binding;
            
            
            
                (self->base)->descriptorType = descriptorType;
            
            
            
                (self->base)->descriptorCount = descriptorCount;
            
            
            
                (self->base)->stageFlags = stageFlags;
            
            
            
                (self->base)->pImmutableSamplers = pImmutableSamplers;
            
            

            pyc_uint32_t_converter_free(&binding);
pyc_flag_base_VkDescriptorType_converter_free(&descriptorType);
pyc_uint32_t_converter_free(&descriptorCount);
pyc_flag_base_VkShaderStageFlags_converter_free(&stageFlags);
pyc_handle_array_VkSampler_converter_free(&pImmutableSamplers);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDescriptorSetLayoutBinding_getbinding(PyVkDescriptorSetLayoutBinding *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->binding));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDescriptorSetLayoutBinding_getdescriptorType(PyVkDescriptorSetLayoutBinding *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->descriptorType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDescriptorSetLayoutBinding_getdescriptorCount(PyVkDescriptorSetLayoutBinding *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->descriptorCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDescriptorSetLayoutBinding_getstageFlags(PyVkDescriptorSetLayoutBinding *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->stageFlags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDescriptorSetLayoutBinding_getpImmutableSamplers(PyVkDescriptorSetLayoutBinding *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDescriptorSetLayoutBinding_getsetters[] = {
        
            {"binding", (getter)PyVkDescriptorSetLayoutBinding_getbinding, NULL, "", NULL},
        
            {"descriptorType", (getter)PyVkDescriptorSetLayoutBinding_getdescriptorType, NULL, "", NULL},
        
            {"descriptorCount", (getter)PyVkDescriptorSetLayoutBinding_getdescriptorCount, NULL, "", NULL},
        
            {"stageFlags", (getter)PyVkDescriptorSetLayoutBinding_getstageFlags, NULL, "", NULL},
        
            {"pImmutableSamplers", (getter)PyVkDescriptorSetLayoutBinding_getpImmutableSamplers, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDescriptorSetLayoutCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDescriptorSetLayoutCreateInfo *self = (PyVkDescriptorSetLayoutCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDescriptorSetLayoutCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDescriptorSetLayoutCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDescriptorSetLayoutCreateInfo_del(PyVkDescriptorSetLayoutCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDescriptorSetLayoutCreateInfo_init(PyVkDescriptorSetLayoutCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkDescriptorSetLayoutCreateFlags flags;
uint32_t bindingCount;
VkDescriptorSetLayoutBinding* pBindings;

            static char *kwlist[] = {"sType","flags","bindingCount","pBindings",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkDescriptorSetLayoutCreateFlags_converter,&flags,pyc_uint32_t_converter,&bindingCount,pyc_struct_array_VkDescriptorSetLayoutBinding_converter,&pBindings))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->bindingCount = bindingCount;
            
            
            
                (self->base)->pBindings = pBindings;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkDescriptorSetLayoutCreateFlags_converter_free(&flags);
pyc_uint32_t_converter_free(&bindingCount);
pyc_struct_array_VkDescriptorSetLayoutBinding_converter_free(&pBindings);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDescriptorSetLayoutCreateInfo_getsType(PyVkDescriptorSetLayoutCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDescriptorSetLayoutCreateInfo_getpNext(PyVkDescriptorSetLayoutCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDescriptorSetLayoutCreateInfo_getflags(PyVkDescriptorSetLayoutCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDescriptorSetLayoutCreateInfo_getbindingCount(PyVkDescriptorSetLayoutCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->bindingCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDescriptorSetLayoutCreateInfo_getpBindings(PyVkDescriptorSetLayoutCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkDescriptorSetLayoutBindingType);
            if (!pyvalue)
                return NULL;
            ((PyVkDescriptorSetLayoutBinding*) pyvalue)->base = ((self->base)->pBindings);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDescriptorSetLayoutCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkDescriptorSetLayoutCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkDescriptorSetLayoutCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkDescriptorSetLayoutCreateInfo_getflags, NULL, "", NULL},
        
            {"bindingCount", (getter)PyVkDescriptorSetLayoutCreateInfo_getbindingCount, NULL, "", NULL},
        
            {"pBindings", (getter)PyVkDescriptorSetLayoutCreateInfo_getpBindings, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDescriptorPoolSize_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDescriptorPoolSize *self = (PyVkDescriptorPoolSize *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDescriptorPoolSize));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDescriptorPoolSize");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDescriptorPoolSize_del(PyVkDescriptorPoolSize* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDescriptorPoolSize_init(PyVkDescriptorPoolSize *self, PyObject *args, PyObject *kwds) {
        
            VkDescriptorType type;
uint32_t descriptorCount;

            static char *kwlist[] = {"type","descriptorCount",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_flag_base_VkDescriptorType_converter,&type,pyc_uint32_t_converter,&descriptorCount))
        return -1;
    

            
            
                (self->base)->type = type;
            
            
            
                (self->base)->descriptorCount = descriptorCount;
            
            

            pyc_flag_base_VkDescriptorType_converter_free(&type);
pyc_uint32_t_converter_free(&descriptorCount);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDescriptorPoolSize_gettype(PyVkDescriptorPoolSize *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->type));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDescriptorPoolSize_getdescriptorCount(PyVkDescriptorPoolSize *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->descriptorCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDescriptorPoolSize_getsetters[] = {
        
            {"type", (getter)PyVkDescriptorPoolSize_gettype, NULL, "", NULL},
        
            {"descriptorCount", (getter)PyVkDescriptorPoolSize_getdescriptorCount, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDescriptorPoolCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDescriptorPoolCreateInfo *self = (PyVkDescriptorPoolCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDescriptorPoolCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDescriptorPoolCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDescriptorPoolCreateInfo_del(PyVkDescriptorPoolCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDescriptorPoolCreateInfo_init(PyVkDescriptorPoolCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkDescriptorPoolCreateFlags flags;
uint32_t maxSets;
uint32_t poolSizeCount;
VkDescriptorPoolSize* pPoolSizes;

            static char *kwlist[] = {"sType","flags","maxSets","poolSizeCount","pPoolSizes",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkDescriptorPoolCreateFlags_converter,&flags,pyc_uint32_t_converter,&maxSets,pyc_uint32_t_converter,&poolSizeCount,pyc_struct_array_VkDescriptorPoolSize_converter,&pPoolSizes))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->maxSets = maxSets;
            
            
            
                (self->base)->poolSizeCount = poolSizeCount;
            
            
            
                (self->base)->pPoolSizes = pPoolSizes;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkDescriptorPoolCreateFlags_converter_free(&flags);
pyc_uint32_t_converter_free(&maxSets);
pyc_uint32_t_converter_free(&poolSizeCount);
pyc_struct_array_VkDescriptorPoolSize_converter_free(&pPoolSizes);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDescriptorPoolCreateInfo_getsType(PyVkDescriptorPoolCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDescriptorPoolCreateInfo_getpNext(PyVkDescriptorPoolCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDescriptorPoolCreateInfo_getflags(PyVkDescriptorPoolCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDescriptorPoolCreateInfo_getmaxSets(PyVkDescriptorPoolCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxSets));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDescriptorPoolCreateInfo_getpoolSizeCount(PyVkDescriptorPoolCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->poolSizeCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDescriptorPoolCreateInfo_getpPoolSizes(PyVkDescriptorPoolCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkDescriptorPoolSizeType);
            if (!pyvalue)
                return NULL;
            ((PyVkDescriptorPoolSize*) pyvalue)->base = ((self->base)->pPoolSizes);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDescriptorPoolCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkDescriptorPoolCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkDescriptorPoolCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkDescriptorPoolCreateInfo_getflags, NULL, "", NULL},
        
            {"maxSets", (getter)PyVkDescriptorPoolCreateInfo_getmaxSets, NULL, "", NULL},
        
            {"poolSizeCount", (getter)PyVkDescriptorPoolCreateInfo_getpoolSizeCount, NULL, "", NULL},
        
            {"pPoolSizes", (getter)PyVkDescriptorPoolCreateInfo_getpPoolSizes, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDescriptorSetAllocateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDescriptorSetAllocateInfo *self = (PyVkDescriptorSetAllocateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDescriptorSetAllocateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDescriptorSetAllocateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDescriptorSetAllocateInfo_del(PyVkDescriptorSetAllocateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDescriptorSetAllocateInfo_init(PyVkDescriptorSetAllocateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkDescriptorPool descriptorPool;
uint32_t descriptorSetCount;
VkDescriptorSetLayout* pSetLayouts;

            static char *kwlist[] = {"sType","descriptorPool","descriptorSetCount","pSetLayouts",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_handle_base_VkDescriptorPool_converter,&descriptorPool,pyc_uint32_t_converter,&descriptorSetCount,pyc_handle_array_VkDescriptorSetLayout_converter,&pSetLayouts))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->descriptorPool = descriptorPool;
            
            
            
                (self->base)->descriptorSetCount = descriptorSetCount;
            
            
            
                (self->base)->pSetLayouts = pSetLayouts;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_handle_base_VkDescriptorPool_converter_free(&descriptorPool);
pyc_uint32_t_converter_free(&descriptorSetCount);
pyc_handle_array_VkDescriptorSetLayout_converter_free(&pSetLayouts);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDescriptorSetAllocateInfo_getsType(PyVkDescriptorSetAllocateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDescriptorSetAllocateInfo_getpNext(PyVkDescriptorSetAllocateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDescriptorSetAllocateInfo_getdescriptorPool(PyVkDescriptorSetAllocateInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkDescriptorSetAllocateInfo_getdescriptorSetCount(PyVkDescriptorSetAllocateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->descriptorSetCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDescriptorSetAllocateInfo_getpSetLayouts(PyVkDescriptorSetAllocateInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDescriptorSetAllocateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkDescriptorSetAllocateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkDescriptorSetAllocateInfo_getpNext, NULL, "", NULL},
        
            {"descriptorPool", (getter)PyVkDescriptorSetAllocateInfo_getdescriptorPool, NULL, "", NULL},
        
            {"descriptorSetCount", (getter)PyVkDescriptorSetAllocateInfo_getdescriptorSetCount, NULL, "", NULL},
        
            {"pSetLayouts", (getter)PyVkDescriptorSetAllocateInfo_getpSetLayouts, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkSpecializationMapEntry_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkSpecializationMapEntry *self = (PyVkSpecializationMapEntry *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkSpecializationMapEntry));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkSpecializationMapEntry");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkSpecializationMapEntry_del(PyVkSpecializationMapEntry* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkSpecializationMapEntry_init(PyVkSpecializationMapEntry *self, PyObject *args, PyObject *kwds) {
        
            uint32_t constantID;
uint32_t offset;
size_t size;

            static char *kwlist[] = {"constantID","offset","size",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_uint32_t_converter,&constantID,pyc_uint32_t_converter,&offset,pyc_size_t_converter,&size))
        return -1;
    

            
            
                (self->base)->constantID = constantID;
            
            
            
                (self->base)->offset = offset;
            
            
            
                (self->base)->size = size;
            
            

            pyc_uint32_t_converter_free(&constantID);
pyc_uint32_t_converter_free(&offset);
pyc_size_t_converter_free(&size);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkSpecializationMapEntry_getconstantID(PyVkSpecializationMapEntry *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->constantID));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSpecializationMapEntry_getoffset(PyVkSpecializationMapEntry *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->offset));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSpecializationMapEntry_getsize(PyVkSpecializationMapEntry *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->size));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkSpecializationMapEntry_getsetters[] = {
        
            {"constantID", (getter)PyVkSpecializationMapEntry_getconstantID, NULL, "", NULL},
        
            {"offset", (getter)PyVkSpecializationMapEntry_getoffset, NULL, "", NULL},
        
            {"size", (getter)PyVkSpecializationMapEntry_getsize, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkSpecializationInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkSpecializationInfo *self = (PyVkSpecializationInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkSpecializationInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkSpecializationInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkSpecializationInfo_del(PyVkSpecializationInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkSpecializationInfo_init(PyVkSpecializationInfo *self, PyObject *args, PyObject *kwds) {
        
            uint32_t mapEntryCount;
VkSpecializationMapEntry* pMapEntries;
size_t dataSize;
void * pData;

            static char *kwlist[] = {"mapEntryCount","pMapEntries","dataSize","pData",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_uint32_t_converter,&mapEntryCount,pyc_struct_array_VkSpecializationMapEntry_converter,&pMapEntries,pyc_size_t_converter,&dataSize,pyc_void_x_converter,&pData))
        return -1;
    

            
            
                (self->base)->mapEntryCount = mapEntryCount;
            
            
            
                (self->base)->pMapEntries = pMapEntries;
            
            
            
                (self->base)->dataSize = dataSize;
            
            
            
                (self->base)->pData = pData;
            
            

            pyc_uint32_t_converter_free(&mapEntryCount);
pyc_struct_array_VkSpecializationMapEntry_converter_free(&pMapEntries);
pyc_size_t_converter_free(&dataSize);
pyc_void_x_converter_free(&pData);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkSpecializationInfo_getmapEntryCount(PyVkSpecializationInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->mapEntryCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSpecializationInfo_getpMapEntries(PyVkSpecializationInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkSpecializationMapEntryType);
            if (!pyvalue)
                return NULL;
            ((PyVkSpecializationMapEntry*) pyvalue)->base = ((self->base)->pMapEntries);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSpecializationInfo_getdataSize(PyVkSpecializationInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->dataSize));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSpecializationInfo_getpData(PyVkSpecializationInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkSpecializationInfo_getsetters[] = {
        
            {"mapEntryCount", (getter)PyVkSpecializationInfo_getmapEntryCount, NULL, "", NULL},
        
            {"pMapEntries", (getter)PyVkSpecializationInfo_getpMapEntries, NULL, "", NULL},
        
            {"dataSize", (getter)PyVkSpecializationInfo_getdataSize, NULL, "", NULL},
        
            {"pData", (getter)PyVkSpecializationInfo_getpData, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPipelineShaderStageCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPipelineShaderStageCreateInfo *self = (PyVkPipelineShaderStageCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPipelineShaderStageCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPipelineShaderStageCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPipelineShaderStageCreateInfo_del(PyVkPipelineShaderStageCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPipelineShaderStageCreateInfo_init(PyVkPipelineShaderStageCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkPipelineShaderStageCreateFlags flags;
VkShaderStageFlagBits stage;
VkShaderModule module;
char* pName;
VkSpecializationInfo* pSpecializationInfo;

            static char *kwlist[] = {"sType","flags","stage","module","pName","pSpecializationInfo",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkPipelineShaderStageCreateFlags_converter,&flags,pyc_flag_base_VkShaderStageFlagBits_converter,&stage,pyc_handle_base_VkShaderModule_converter,&module,pyc_string_converter,&pName,pyc_struct_pointer_VkSpecializationInfo_converter,&pSpecializationInfo))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->stage = stage;
            
            
            
                (self->base)->module = module;
            
            
            
                (self->base)->pName = pName;
            
            
            
                (self->base)->pSpecializationInfo = pSpecializationInfo;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkPipelineShaderStageCreateFlags_converter_free(&flags);
pyc_flag_base_VkShaderStageFlagBits_converter_free(&stage);
pyc_handle_base_VkShaderModule_converter_free(&module);
pyc_string_converter_free(&pName);
pyc_struct_pointer_VkSpecializationInfo_converter_free(&pSpecializationInfo);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPipelineShaderStageCreateInfo_getsType(PyVkPipelineShaderStageCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineShaderStageCreateInfo_getpNext(PyVkPipelineShaderStageCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineShaderStageCreateInfo_getflags(PyVkPipelineShaderStageCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineShaderStageCreateInfo_getstage(PyVkPipelineShaderStageCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->stage));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineShaderStageCreateInfo_getmodule(PyVkPipelineShaderStageCreateInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkPipelineShaderStageCreateInfo_getpName(PyVkPipelineShaderStageCreateInfo *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyUnicode_FromString((const char *) ((self->base)->pName));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineShaderStageCreateInfo_getpSpecializationInfo(PyVkPipelineShaderStageCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkSpecializationInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkSpecializationInfo*) pyvalue)->base = ((self->base)->pSpecializationInfo);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPipelineShaderStageCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkPipelineShaderStageCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkPipelineShaderStageCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkPipelineShaderStageCreateInfo_getflags, NULL, "", NULL},
        
            {"stage", (getter)PyVkPipelineShaderStageCreateInfo_getstage, NULL, "", NULL},
        
            {"module", (getter)PyVkPipelineShaderStageCreateInfo_getmodule, NULL, "", NULL},
        
            {"pName", (getter)PyVkPipelineShaderStageCreateInfo_getpName, NULL, "", NULL},
        
            {"pSpecializationInfo", (getter)PyVkPipelineShaderStageCreateInfo_getpSpecializationInfo, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkComputePipelineCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkComputePipelineCreateInfo *self = (PyVkComputePipelineCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkComputePipelineCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkComputePipelineCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkComputePipelineCreateInfo_del(PyVkComputePipelineCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkComputePipelineCreateInfo_init(PyVkComputePipelineCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkPipelineCreateFlags flags;
VkPipelineShaderStageCreateInfo stage;
VkPipelineLayout layout;
VkPipeline basePipelineHandle;
int32_t basePipelineIndex;

            static char *kwlist[] = {"sType","flags","stage","layout","basePipelineHandle","basePipelineIndex",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkPipelineCreateFlags_converter,&flags,pyc_struct_base_VkPipelineShaderStageCreateInfo_converter,&stage,pyc_handle_base_VkPipelineLayout_converter,&layout,pyc_handle_base_VkPipeline_converter,&basePipelineHandle,pyc_int32_t_converter,&basePipelineIndex))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->stage = stage;
            
            
            
                (self->base)->layout = layout;
            
            
            
                (self->base)->basePipelineHandle = basePipelineHandle;
            
            
            
                (self->base)->basePipelineIndex = basePipelineIndex;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkPipelineCreateFlags_converter_free(&flags);
pyc_struct_base_VkPipelineShaderStageCreateInfo_converter_free(&stage);
pyc_handle_base_VkPipelineLayout_converter_free(&layout);
pyc_handle_base_VkPipeline_converter_free(&basePipelineHandle);
pyc_int32_t_converter_free(&basePipelineIndex);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkComputePipelineCreateInfo_getsType(PyVkComputePipelineCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkComputePipelineCreateInfo_getpNext(PyVkComputePipelineCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkComputePipelineCreateInfo_getflags(PyVkComputePipelineCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkComputePipelineCreateInfo_getstage(PyVkComputePipelineCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkPipelineShaderStageCreateInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkPipelineShaderStageCreateInfo*) pyvalue)->base = &((self->base)->stage);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkComputePipelineCreateInfo_getlayout(PyVkComputePipelineCreateInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkComputePipelineCreateInfo_getbasePipelineHandle(PyVkComputePipelineCreateInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkComputePipelineCreateInfo_getbasePipelineIndex(PyVkComputePipelineCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->basePipelineIndex));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkComputePipelineCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkComputePipelineCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkComputePipelineCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkComputePipelineCreateInfo_getflags, NULL, "", NULL},
        
            {"stage", (getter)PyVkComputePipelineCreateInfo_getstage, NULL, "", NULL},
        
            {"layout", (getter)PyVkComputePipelineCreateInfo_getlayout, NULL, "", NULL},
        
            {"basePipelineHandle", (getter)PyVkComputePipelineCreateInfo_getbasePipelineHandle, NULL, "", NULL},
        
            {"basePipelineIndex", (getter)PyVkComputePipelineCreateInfo_getbasePipelineIndex, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkVertexInputBindingDescription_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkVertexInputBindingDescription *self = (PyVkVertexInputBindingDescription *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkVertexInputBindingDescription));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkVertexInputBindingDescription");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkVertexInputBindingDescription_del(PyVkVertexInputBindingDescription* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkVertexInputBindingDescription_init(PyVkVertexInputBindingDescription *self, PyObject *args, PyObject *kwds) {
        
            uint32_t binding;
uint32_t stride;
VkVertexInputRate inputRate;

            static char *kwlist[] = {"binding","stride","inputRate",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_uint32_t_converter,&binding,pyc_uint32_t_converter,&stride,pyc_flag_base_VkVertexInputRate_converter,&inputRate))
        return -1;
    

            
            
                (self->base)->binding = binding;
            
            
            
                (self->base)->stride = stride;
            
            
            
                (self->base)->inputRate = inputRate;
            
            

            pyc_uint32_t_converter_free(&binding);
pyc_uint32_t_converter_free(&stride);
pyc_flag_base_VkVertexInputRate_converter_free(&inputRate);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkVertexInputBindingDescription_getbinding(PyVkVertexInputBindingDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->binding));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkVertexInputBindingDescription_getstride(PyVkVertexInputBindingDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->stride));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkVertexInputBindingDescription_getinputRate(PyVkVertexInputBindingDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->inputRate));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkVertexInputBindingDescription_getsetters[] = {
        
            {"binding", (getter)PyVkVertexInputBindingDescription_getbinding, NULL, "", NULL},
        
            {"stride", (getter)PyVkVertexInputBindingDescription_getstride, NULL, "", NULL},
        
            {"inputRate", (getter)PyVkVertexInputBindingDescription_getinputRate, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkVertexInputAttributeDescription_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkVertexInputAttributeDescription *self = (PyVkVertexInputAttributeDescription *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkVertexInputAttributeDescription));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkVertexInputAttributeDescription");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkVertexInputAttributeDescription_del(PyVkVertexInputAttributeDescription* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkVertexInputAttributeDescription_init(PyVkVertexInputAttributeDescription *self, PyObject *args, PyObject *kwds) {
        
            uint32_t location;
uint32_t binding;
VkFormat format;
uint32_t offset;

            static char *kwlist[] = {"location","binding","format","offset",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_uint32_t_converter,&location,pyc_uint32_t_converter,&binding,pyc_flag_base_VkFormat_converter,&format,pyc_uint32_t_converter,&offset))
        return -1;
    

            
            
                (self->base)->location = location;
            
            
            
                (self->base)->binding = binding;
            
            
            
                (self->base)->format = format;
            
            
            
                (self->base)->offset = offset;
            
            

            pyc_uint32_t_converter_free(&location);
pyc_uint32_t_converter_free(&binding);
pyc_flag_base_VkFormat_converter_free(&format);
pyc_uint32_t_converter_free(&offset);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkVertexInputAttributeDescription_getlocation(PyVkVertexInputAttributeDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->location));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkVertexInputAttributeDescription_getbinding(PyVkVertexInputAttributeDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->binding));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkVertexInputAttributeDescription_getformat(PyVkVertexInputAttributeDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->format));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkVertexInputAttributeDescription_getoffset(PyVkVertexInputAttributeDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->offset));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkVertexInputAttributeDescription_getsetters[] = {
        
            {"location", (getter)PyVkVertexInputAttributeDescription_getlocation, NULL, "", NULL},
        
            {"binding", (getter)PyVkVertexInputAttributeDescription_getbinding, NULL, "", NULL},
        
            {"format", (getter)PyVkVertexInputAttributeDescription_getformat, NULL, "", NULL},
        
            {"offset", (getter)PyVkVertexInputAttributeDescription_getoffset, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPipelineVertexInputStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPipelineVertexInputStateCreateInfo *self = (PyVkPipelineVertexInputStateCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPipelineVertexInputStateCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPipelineVertexInputStateCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPipelineVertexInputStateCreateInfo_del(PyVkPipelineVertexInputStateCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPipelineVertexInputStateCreateInfo_init(PyVkPipelineVertexInputStateCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkPipelineVertexInputStateCreateFlags flags;
uint32_t vertexBindingDescriptionCount;
VkVertexInputBindingDescription* pVertexBindingDescriptions;
uint32_t vertexAttributeDescriptionCount;
VkVertexInputAttributeDescription* pVertexAttributeDescriptions;

            static char *kwlist[] = {"sType","flags","vertexBindingDescriptionCount","pVertexBindingDescriptions","vertexAttributeDescriptionCount","pVertexAttributeDescriptions",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkPipelineVertexInputStateCreateFlags_converter,&flags,pyc_uint32_t_converter,&vertexBindingDescriptionCount,pyc_struct_array_VkVertexInputBindingDescription_converter,&pVertexBindingDescriptions,pyc_uint32_t_converter,&vertexAttributeDescriptionCount,pyc_struct_array_VkVertexInputAttributeDescription_converter,&pVertexAttributeDescriptions))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->vertexBindingDescriptionCount = vertexBindingDescriptionCount;
            
            
            
                (self->base)->pVertexBindingDescriptions = pVertexBindingDescriptions;
            
            
            
                (self->base)->vertexAttributeDescriptionCount = vertexAttributeDescriptionCount;
            
            
            
                (self->base)->pVertexAttributeDescriptions = pVertexAttributeDescriptions;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkPipelineVertexInputStateCreateFlags_converter_free(&flags);
pyc_uint32_t_converter_free(&vertexBindingDescriptionCount);
pyc_struct_array_VkVertexInputBindingDescription_converter_free(&pVertexBindingDescriptions);
pyc_uint32_t_converter_free(&vertexAttributeDescriptionCount);
pyc_struct_array_VkVertexInputAttributeDescription_converter_free(&pVertexAttributeDescriptions);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPipelineVertexInputStateCreateInfo_getsType(PyVkPipelineVertexInputStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineVertexInputStateCreateInfo_getpNext(PyVkPipelineVertexInputStateCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineVertexInputStateCreateInfo_getflags(PyVkPipelineVertexInputStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineVertexInputStateCreateInfo_getvertexBindingDescriptionCount(PyVkPipelineVertexInputStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->vertexBindingDescriptionCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineVertexInputStateCreateInfo_getpVertexBindingDescriptions(PyVkPipelineVertexInputStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkVertexInputBindingDescriptionType);
            if (!pyvalue)
                return NULL;
            ((PyVkVertexInputBindingDescription*) pyvalue)->base = ((self->base)->pVertexBindingDescriptions);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineVertexInputStateCreateInfo_getvertexAttributeDescriptionCount(PyVkPipelineVertexInputStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->vertexAttributeDescriptionCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineVertexInputStateCreateInfo_getpVertexAttributeDescriptions(PyVkPipelineVertexInputStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkVertexInputAttributeDescriptionType);
            if (!pyvalue)
                return NULL;
            ((PyVkVertexInputAttributeDescription*) pyvalue)->base = ((self->base)->pVertexAttributeDescriptions);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPipelineVertexInputStateCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkPipelineVertexInputStateCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkPipelineVertexInputStateCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkPipelineVertexInputStateCreateInfo_getflags, NULL, "", NULL},
        
            {"vertexBindingDescriptionCount", (getter)PyVkPipelineVertexInputStateCreateInfo_getvertexBindingDescriptionCount, NULL, "", NULL},
        
            {"pVertexBindingDescriptions", (getter)PyVkPipelineVertexInputStateCreateInfo_getpVertexBindingDescriptions, NULL, "", NULL},
        
            {"vertexAttributeDescriptionCount", (getter)PyVkPipelineVertexInputStateCreateInfo_getvertexAttributeDescriptionCount, NULL, "", NULL},
        
            {"pVertexAttributeDescriptions", (getter)PyVkPipelineVertexInputStateCreateInfo_getpVertexAttributeDescriptions, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPipelineInputAssemblyStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPipelineInputAssemblyStateCreateInfo *self = (PyVkPipelineInputAssemblyStateCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPipelineInputAssemblyStateCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPipelineInputAssemblyStateCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPipelineInputAssemblyStateCreateInfo_del(PyVkPipelineInputAssemblyStateCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPipelineInputAssemblyStateCreateInfo_init(PyVkPipelineInputAssemblyStateCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkPipelineInputAssemblyStateCreateFlags flags;
VkPrimitiveTopology topology;
VkBool32 primitiveRestartEnable;

            static char *kwlist[] = {"sType","flags","topology","primitiveRestartEnable",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkPipelineInputAssemblyStateCreateFlags_converter,&flags,pyc_flag_base_VkPrimitiveTopology_converter,&topology,pyc_flag_base_VkBool32_converter,&primitiveRestartEnable))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->topology = topology;
            
            
            
                (self->base)->primitiveRestartEnable = primitiveRestartEnable;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkPipelineInputAssemblyStateCreateFlags_converter_free(&flags);
pyc_flag_base_VkPrimitiveTopology_converter_free(&topology);
pyc_flag_base_VkBool32_converter_free(&primitiveRestartEnable);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPipelineInputAssemblyStateCreateInfo_getsType(PyVkPipelineInputAssemblyStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineInputAssemblyStateCreateInfo_getpNext(PyVkPipelineInputAssemblyStateCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineInputAssemblyStateCreateInfo_getflags(PyVkPipelineInputAssemblyStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineInputAssemblyStateCreateInfo_gettopology(PyVkPipelineInputAssemblyStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->topology));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineInputAssemblyStateCreateInfo_getprimitiveRestartEnable(PyVkPipelineInputAssemblyStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->primitiveRestartEnable));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPipelineInputAssemblyStateCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkPipelineInputAssemblyStateCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkPipelineInputAssemblyStateCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkPipelineInputAssemblyStateCreateInfo_getflags, NULL, "", NULL},
        
            {"topology", (getter)PyVkPipelineInputAssemblyStateCreateInfo_gettopology, NULL, "", NULL},
        
            {"primitiveRestartEnable", (getter)PyVkPipelineInputAssemblyStateCreateInfo_getprimitiveRestartEnable, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPipelineTessellationStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPipelineTessellationStateCreateInfo *self = (PyVkPipelineTessellationStateCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPipelineTessellationStateCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPipelineTessellationStateCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPipelineTessellationStateCreateInfo_del(PyVkPipelineTessellationStateCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPipelineTessellationStateCreateInfo_init(PyVkPipelineTessellationStateCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkPipelineTessellationStateCreateFlags flags;
uint32_t patchControlPoints;

            static char *kwlist[] = {"sType","flags","patchControlPoints",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkPipelineTessellationStateCreateFlags_converter,&flags,pyc_uint32_t_converter,&patchControlPoints))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->patchControlPoints = patchControlPoints;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkPipelineTessellationStateCreateFlags_converter_free(&flags);
pyc_uint32_t_converter_free(&patchControlPoints);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPipelineTessellationStateCreateInfo_getsType(PyVkPipelineTessellationStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineTessellationStateCreateInfo_getpNext(PyVkPipelineTessellationStateCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineTessellationStateCreateInfo_getflags(PyVkPipelineTessellationStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineTessellationStateCreateInfo_getpatchControlPoints(PyVkPipelineTessellationStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->patchControlPoints));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPipelineTessellationStateCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkPipelineTessellationStateCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkPipelineTessellationStateCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkPipelineTessellationStateCreateInfo_getflags, NULL, "", NULL},
        
            {"patchControlPoints", (getter)PyVkPipelineTessellationStateCreateInfo_getpatchControlPoints, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPipelineViewportStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPipelineViewportStateCreateInfo *self = (PyVkPipelineViewportStateCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPipelineViewportStateCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPipelineViewportStateCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPipelineViewportStateCreateInfo_del(PyVkPipelineViewportStateCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPipelineViewportStateCreateInfo_init(PyVkPipelineViewportStateCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkPipelineViewportStateCreateFlags flags;
uint32_t viewportCount;
VkViewport* pViewports;
uint32_t scissorCount;
VkRect2D* pScissors;

            static char *kwlist[] = {"sType","flags","viewportCount","pViewports","scissorCount","pScissors",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkPipelineViewportStateCreateFlags_converter,&flags,pyc_uint32_t_converter,&viewportCount,pyc_struct_array_VkViewport_converter,&pViewports,pyc_uint32_t_converter,&scissorCount,pyc_struct_array_VkRect2D_converter,&pScissors))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->viewportCount = viewportCount;
            
            
            
                (self->base)->pViewports = pViewports;
            
            
            
                (self->base)->scissorCount = scissorCount;
            
            
            
                (self->base)->pScissors = pScissors;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkPipelineViewportStateCreateFlags_converter_free(&flags);
pyc_uint32_t_converter_free(&viewportCount);
pyc_struct_array_VkViewport_converter_free(&pViewports);
pyc_uint32_t_converter_free(&scissorCount);
pyc_struct_array_VkRect2D_converter_free(&pScissors);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPipelineViewportStateCreateInfo_getsType(PyVkPipelineViewportStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineViewportStateCreateInfo_getpNext(PyVkPipelineViewportStateCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineViewportStateCreateInfo_getflags(PyVkPipelineViewportStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineViewportStateCreateInfo_getviewportCount(PyVkPipelineViewportStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->viewportCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineViewportStateCreateInfo_getpViewports(PyVkPipelineViewportStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkViewportType);
            if (!pyvalue)
                return NULL;
            ((PyVkViewport*) pyvalue)->base = ((self->base)->pViewports);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineViewportStateCreateInfo_getscissorCount(PyVkPipelineViewportStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->scissorCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineViewportStateCreateInfo_getpScissors(PyVkPipelineViewportStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkRect2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkRect2D*) pyvalue)->base = ((self->base)->pScissors);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPipelineViewportStateCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkPipelineViewportStateCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkPipelineViewportStateCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkPipelineViewportStateCreateInfo_getflags, NULL, "", NULL},
        
            {"viewportCount", (getter)PyVkPipelineViewportStateCreateInfo_getviewportCount, NULL, "", NULL},
        
            {"pViewports", (getter)PyVkPipelineViewportStateCreateInfo_getpViewports, NULL, "", NULL},
        
            {"scissorCount", (getter)PyVkPipelineViewportStateCreateInfo_getscissorCount, NULL, "", NULL},
        
            {"pScissors", (getter)PyVkPipelineViewportStateCreateInfo_getpScissors, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPipelineRasterizationStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPipelineRasterizationStateCreateInfo *self = (PyVkPipelineRasterizationStateCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPipelineRasterizationStateCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPipelineRasterizationStateCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPipelineRasterizationStateCreateInfo_del(PyVkPipelineRasterizationStateCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPipelineRasterizationStateCreateInfo_init(PyVkPipelineRasterizationStateCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkPipelineRasterizationStateCreateFlags flags;
VkBool32 depthClampEnable;
VkBool32 rasterizerDiscardEnable;
VkPolygonMode polygonMode;
VkCullModeFlags cullMode;
VkFrontFace frontFace;
VkBool32 depthBiasEnable;
float depthBiasConstantFactor;
float depthBiasClamp;
float depthBiasSlopeFactor;
float lineWidth;

            static char *kwlist[] = {"sType","flags","depthClampEnable","rasterizerDiscardEnable","polygonMode","cullMode","frontFace","depthBiasEnable","depthBiasConstantFactor","depthBiasClamp","depthBiasSlopeFactor","lineWidth",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkPipelineRasterizationStateCreateFlags_converter,&flags,pyc_flag_base_VkBool32_converter,&depthClampEnable,pyc_flag_base_VkBool32_converter,&rasterizerDiscardEnable,pyc_flag_base_VkPolygonMode_converter,&polygonMode,pyc_flag_base_VkCullModeFlags_converter,&cullMode,pyc_flag_base_VkFrontFace_converter,&frontFace,pyc_flag_base_VkBool32_converter,&depthBiasEnable,pyc_float_converter,&depthBiasConstantFactor,pyc_float_converter,&depthBiasClamp,pyc_float_converter,&depthBiasSlopeFactor,pyc_float_converter,&lineWidth))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->depthClampEnable = depthClampEnable;
            
            
            
                (self->base)->rasterizerDiscardEnable = rasterizerDiscardEnable;
            
            
            
                (self->base)->polygonMode = polygonMode;
            
            
            
                (self->base)->cullMode = cullMode;
            
            
            
                (self->base)->frontFace = frontFace;
            
            
            
                (self->base)->depthBiasEnable = depthBiasEnable;
            
            
            
                (self->base)->depthBiasConstantFactor = depthBiasConstantFactor;
            
            
            
                (self->base)->depthBiasClamp = depthBiasClamp;
            
            
            
                (self->base)->depthBiasSlopeFactor = depthBiasSlopeFactor;
            
            
            
                (self->base)->lineWidth = lineWidth;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkPipelineRasterizationStateCreateFlags_converter_free(&flags);
pyc_flag_base_VkBool32_converter_free(&depthClampEnable);
pyc_flag_base_VkBool32_converter_free(&rasterizerDiscardEnable);
pyc_flag_base_VkPolygonMode_converter_free(&polygonMode);
pyc_flag_base_VkCullModeFlags_converter_free(&cullMode);
pyc_flag_base_VkFrontFace_converter_free(&frontFace);
pyc_flag_base_VkBool32_converter_free(&depthBiasEnable);
pyc_float_converter_free(&depthBiasConstantFactor);
pyc_float_converter_free(&depthBiasClamp);
pyc_float_converter_free(&depthBiasSlopeFactor);
pyc_float_converter_free(&lineWidth);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPipelineRasterizationStateCreateInfo_getsType(PyVkPipelineRasterizationStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineRasterizationStateCreateInfo_getpNext(PyVkPipelineRasterizationStateCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineRasterizationStateCreateInfo_getflags(PyVkPipelineRasterizationStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineRasterizationStateCreateInfo_getdepthClampEnable(PyVkPipelineRasterizationStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->depthClampEnable));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineRasterizationStateCreateInfo_getrasterizerDiscardEnable(PyVkPipelineRasterizationStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->rasterizerDiscardEnable));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineRasterizationStateCreateInfo_getpolygonMode(PyVkPipelineRasterizationStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->polygonMode));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineRasterizationStateCreateInfo_getcullMode(PyVkPipelineRasterizationStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->cullMode));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineRasterizationStateCreateInfo_getfrontFace(PyVkPipelineRasterizationStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->frontFace));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineRasterizationStateCreateInfo_getdepthBiasEnable(PyVkPipelineRasterizationStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->depthBiasEnable));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineRasterizationStateCreateInfo_getdepthBiasConstantFactor(PyVkPipelineRasterizationStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->depthBiasConstantFactor));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineRasterizationStateCreateInfo_getdepthBiasClamp(PyVkPipelineRasterizationStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->depthBiasClamp));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineRasterizationStateCreateInfo_getdepthBiasSlopeFactor(PyVkPipelineRasterizationStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->depthBiasSlopeFactor));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineRasterizationStateCreateInfo_getlineWidth(PyVkPipelineRasterizationStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->lineWidth));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPipelineRasterizationStateCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkPipelineRasterizationStateCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkPipelineRasterizationStateCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkPipelineRasterizationStateCreateInfo_getflags, NULL, "", NULL},
        
            {"depthClampEnable", (getter)PyVkPipelineRasterizationStateCreateInfo_getdepthClampEnable, NULL, "", NULL},
        
            {"rasterizerDiscardEnable", (getter)PyVkPipelineRasterizationStateCreateInfo_getrasterizerDiscardEnable, NULL, "", NULL},
        
            {"polygonMode", (getter)PyVkPipelineRasterizationStateCreateInfo_getpolygonMode, NULL, "", NULL},
        
            {"cullMode", (getter)PyVkPipelineRasterizationStateCreateInfo_getcullMode, NULL, "", NULL},
        
            {"frontFace", (getter)PyVkPipelineRasterizationStateCreateInfo_getfrontFace, NULL, "", NULL},
        
            {"depthBiasEnable", (getter)PyVkPipelineRasterizationStateCreateInfo_getdepthBiasEnable, NULL, "", NULL},
        
            {"depthBiasConstantFactor", (getter)PyVkPipelineRasterizationStateCreateInfo_getdepthBiasConstantFactor, NULL, "", NULL},
        
            {"depthBiasClamp", (getter)PyVkPipelineRasterizationStateCreateInfo_getdepthBiasClamp, NULL, "", NULL},
        
            {"depthBiasSlopeFactor", (getter)PyVkPipelineRasterizationStateCreateInfo_getdepthBiasSlopeFactor, NULL, "", NULL},
        
            {"lineWidth", (getter)PyVkPipelineRasterizationStateCreateInfo_getlineWidth, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPipelineMultisampleStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPipelineMultisampleStateCreateInfo *self = (PyVkPipelineMultisampleStateCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPipelineMultisampleStateCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPipelineMultisampleStateCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPipelineMultisampleStateCreateInfo_del(PyVkPipelineMultisampleStateCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPipelineMultisampleStateCreateInfo_init(PyVkPipelineMultisampleStateCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkPipelineMultisampleStateCreateFlags flags;
VkSampleCountFlagBits rasterizationSamples;
VkBool32 sampleShadingEnable;
float minSampleShading;
VkSampleMask* pSampleMask;
VkBool32 alphaToCoverageEnable;
VkBool32 alphaToOneEnable;

            static char *kwlist[] = {"sType","flags","rasterizationSamples","sampleShadingEnable","minSampleShading","pSampleMask","alphaToCoverageEnable","alphaToOneEnable",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkPipelineMultisampleStateCreateFlags_converter,&flags,pyc_flag_base_VkSampleCountFlagBits_converter,&rasterizationSamples,pyc_flag_base_VkBool32_converter,&sampleShadingEnable,pyc_float_converter,&minSampleShading,pyc_flag_array_VkSampleMask_converter,&pSampleMask,pyc_flag_base_VkBool32_converter,&alphaToCoverageEnable,pyc_flag_base_VkBool32_converter,&alphaToOneEnable))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->rasterizationSamples = rasterizationSamples;
            
            
            
                (self->base)->sampleShadingEnable = sampleShadingEnable;
            
            
            
                (self->base)->minSampleShading = minSampleShading;
            
            
            
                (self->base)->pSampleMask = pSampleMask;
            
            
            
                (self->base)->alphaToCoverageEnable = alphaToCoverageEnable;
            
            
            
                (self->base)->alphaToOneEnable = alphaToOneEnable;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkPipelineMultisampleStateCreateFlags_converter_free(&flags);
pyc_flag_base_VkSampleCountFlagBits_converter_free(&rasterizationSamples);
pyc_flag_base_VkBool32_converter_free(&sampleShadingEnable);
pyc_float_converter_free(&minSampleShading);
pyc_flag_array_VkSampleMask_converter_free(&pSampleMask);
pyc_flag_base_VkBool32_converter_free(&alphaToCoverageEnable);
pyc_flag_base_VkBool32_converter_free(&alphaToOneEnable);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPipelineMultisampleStateCreateInfo_getsType(PyVkPipelineMultisampleStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineMultisampleStateCreateInfo_getpNext(PyVkPipelineMultisampleStateCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineMultisampleStateCreateInfo_getflags(PyVkPipelineMultisampleStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineMultisampleStateCreateInfo_getrasterizationSamples(PyVkPipelineMultisampleStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->rasterizationSamples));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineMultisampleStateCreateInfo_getsampleShadingEnable(PyVkPipelineMultisampleStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sampleShadingEnable));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineMultisampleStateCreateInfo_getminSampleShading(PyVkPipelineMultisampleStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->minSampleShading));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineMultisampleStateCreateInfo_getpSampleMask(PyVkPipelineMultisampleStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(*((self->base)->pSampleMask));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineMultisampleStateCreateInfo_getalphaToCoverageEnable(PyVkPipelineMultisampleStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->alphaToCoverageEnable));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineMultisampleStateCreateInfo_getalphaToOneEnable(PyVkPipelineMultisampleStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->alphaToOneEnable));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPipelineMultisampleStateCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkPipelineMultisampleStateCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkPipelineMultisampleStateCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkPipelineMultisampleStateCreateInfo_getflags, NULL, "", NULL},
        
            {"rasterizationSamples", (getter)PyVkPipelineMultisampleStateCreateInfo_getrasterizationSamples, NULL, "", NULL},
        
            {"sampleShadingEnable", (getter)PyVkPipelineMultisampleStateCreateInfo_getsampleShadingEnable, NULL, "", NULL},
        
            {"minSampleShading", (getter)PyVkPipelineMultisampleStateCreateInfo_getminSampleShading, NULL, "", NULL},
        
            {"pSampleMask", (getter)PyVkPipelineMultisampleStateCreateInfo_getpSampleMask, NULL, "", NULL},
        
            {"alphaToCoverageEnable", (getter)PyVkPipelineMultisampleStateCreateInfo_getalphaToCoverageEnable, NULL, "", NULL},
        
            {"alphaToOneEnable", (getter)PyVkPipelineMultisampleStateCreateInfo_getalphaToOneEnable, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPipelineColorBlendAttachmentState_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPipelineColorBlendAttachmentState *self = (PyVkPipelineColorBlendAttachmentState *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPipelineColorBlendAttachmentState));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPipelineColorBlendAttachmentState");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPipelineColorBlendAttachmentState_del(PyVkPipelineColorBlendAttachmentState* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPipelineColorBlendAttachmentState_init(PyVkPipelineColorBlendAttachmentState *self, PyObject *args, PyObject *kwds) {
        
            VkBool32 blendEnable;
VkBlendFactor srcColorBlendFactor;
VkBlendFactor dstColorBlendFactor;
VkBlendOp colorBlendOp;
VkBlendFactor srcAlphaBlendFactor;
VkBlendFactor dstAlphaBlendFactor;
VkBlendOp alphaBlendOp;
VkColorComponentFlags colorWriteMask;

            static char *kwlist[] = {"blendEnable","srcColorBlendFactor","dstColorBlendFactor","colorBlendOp","srcAlphaBlendFactor","dstAlphaBlendFactor","alphaBlendOp","colorWriteMask",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkBool32_converter,&blendEnable,pyc_flag_base_VkBlendFactor_converter,&srcColorBlendFactor,pyc_flag_base_VkBlendFactor_converter,&dstColorBlendFactor,pyc_flag_base_VkBlendOp_converter,&colorBlendOp,pyc_flag_base_VkBlendFactor_converter,&srcAlphaBlendFactor,pyc_flag_base_VkBlendFactor_converter,&dstAlphaBlendFactor,pyc_flag_base_VkBlendOp_converter,&alphaBlendOp,pyc_flag_base_VkColorComponentFlags_converter,&colorWriteMask))
        return -1;
    

            
            
                (self->base)->blendEnable = blendEnable;
            
            
            
                (self->base)->srcColorBlendFactor = srcColorBlendFactor;
            
            
            
                (self->base)->dstColorBlendFactor = dstColorBlendFactor;
            
            
            
                (self->base)->colorBlendOp = colorBlendOp;
            
            
            
                (self->base)->srcAlphaBlendFactor = srcAlphaBlendFactor;
            
            
            
                (self->base)->dstAlphaBlendFactor = dstAlphaBlendFactor;
            
            
            
                (self->base)->alphaBlendOp = alphaBlendOp;
            
            
            
                (self->base)->colorWriteMask = colorWriteMask;
            
            

            pyc_flag_base_VkBool32_converter_free(&blendEnable);
pyc_flag_base_VkBlendFactor_converter_free(&srcColorBlendFactor);
pyc_flag_base_VkBlendFactor_converter_free(&dstColorBlendFactor);
pyc_flag_base_VkBlendOp_converter_free(&colorBlendOp);
pyc_flag_base_VkBlendFactor_converter_free(&srcAlphaBlendFactor);
pyc_flag_base_VkBlendFactor_converter_free(&dstAlphaBlendFactor);
pyc_flag_base_VkBlendOp_converter_free(&alphaBlendOp);
pyc_flag_base_VkColorComponentFlags_converter_free(&colorWriteMask);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPipelineColorBlendAttachmentState_getblendEnable(PyVkPipelineColorBlendAttachmentState *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->blendEnable));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineColorBlendAttachmentState_getsrcColorBlendFactor(PyVkPipelineColorBlendAttachmentState *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->srcColorBlendFactor));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineColorBlendAttachmentState_getdstColorBlendFactor(PyVkPipelineColorBlendAttachmentState *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->dstColorBlendFactor));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineColorBlendAttachmentState_getcolorBlendOp(PyVkPipelineColorBlendAttachmentState *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->colorBlendOp));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineColorBlendAttachmentState_getsrcAlphaBlendFactor(PyVkPipelineColorBlendAttachmentState *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->srcAlphaBlendFactor));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineColorBlendAttachmentState_getdstAlphaBlendFactor(PyVkPipelineColorBlendAttachmentState *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->dstAlphaBlendFactor));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineColorBlendAttachmentState_getalphaBlendOp(PyVkPipelineColorBlendAttachmentState *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->alphaBlendOp));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineColorBlendAttachmentState_getcolorWriteMask(PyVkPipelineColorBlendAttachmentState *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->colorWriteMask));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPipelineColorBlendAttachmentState_getsetters[] = {
        
            {"blendEnable", (getter)PyVkPipelineColorBlendAttachmentState_getblendEnable, NULL, "", NULL},
        
            {"srcColorBlendFactor", (getter)PyVkPipelineColorBlendAttachmentState_getsrcColorBlendFactor, NULL, "", NULL},
        
            {"dstColorBlendFactor", (getter)PyVkPipelineColorBlendAttachmentState_getdstColorBlendFactor, NULL, "", NULL},
        
            {"colorBlendOp", (getter)PyVkPipelineColorBlendAttachmentState_getcolorBlendOp, NULL, "", NULL},
        
            {"srcAlphaBlendFactor", (getter)PyVkPipelineColorBlendAttachmentState_getsrcAlphaBlendFactor, NULL, "", NULL},
        
            {"dstAlphaBlendFactor", (getter)PyVkPipelineColorBlendAttachmentState_getdstAlphaBlendFactor, NULL, "", NULL},
        
            {"alphaBlendOp", (getter)PyVkPipelineColorBlendAttachmentState_getalphaBlendOp, NULL, "", NULL},
        
            {"colorWriteMask", (getter)PyVkPipelineColorBlendAttachmentState_getcolorWriteMask, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPipelineColorBlendStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPipelineColorBlendStateCreateInfo *self = (PyVkPipelineColorBlendStateCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPipelineColorBlendStateCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPipelineColorBlendStateCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPipelineColorBlendStateCreateInfo_del(PyVkPipelineColorBlendStateCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPipelineColorBlendStateCreateInfo_init(PyVkPipelineColorBlendStateCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkPipelineColorBlendStateCreateFlags flags;
VkBool32 logicOpEnable;
VkLogicOp logicOp;
uint32_t attachmentCount;
VkPipelineColorBlendAttachmentState* pAttachments;
float* blendConstants;

            static char *kwlist[] = {"sType","flags","logicOpEnable","logicOp","attachmentCount","pAttachments","blendConstants",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkPipelineColorBlendStateCreateFlags_converter,&flags,pyc_flag_base_VkBool32_converter,&logicOpEnable,pyc_flag_base_VkLogicOp_converter,&logicOp,pyc_uint32_t_converter,&attachmentCount,pyc_struct_array_VkPipelineColorBlendAttachmentState_converter,&pAttachments,pyc_array_float_converter,&blendConstants))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->logicOpEnable = logicOpEnable;
            
            
            
                (self->base)->logicOp = logicOp;
            
            
            
                (self->base)->attachmentCount = attachmentCount;
            
            
            
                (self->base)->pAttachments = pAttachments;
            
            
            
                
        memcpy((self->base)->blendConstants, blendConstants, 4 * sizeof(float));
        
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkPipelineColorBlendStateCreateFlags_converter_free(&flags);
pyc_flag_base_VkBool32_converter_free(&logicOpEnable);
pyc_flag_base_VkLogicOp_converter_free(&logicOp);
pyc_uint32_t_converter_free(&attachmentCount);
pyc_struct_array_VkPipelineColorBlendAttachmentState_converter_free(&pAttachments);
pyc_array_float_converter_free(&blendConstants);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPipelineColorBlendStateCreateInfo_getsType(PyVkPipelineColorBlendStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineColorBlendStateCreateInfo_getpNext(PyVkPipelineColorBlendStateCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineColorBlendStateCreateInfo_getflags(PyVkPipelineColorBlendStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineColorBlendStateCreateInfo_getlogicOpEnable(PyVkPipelineColorBlendStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->logicOpEnable));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineColorBlendStateCreateInfo_getlogicOp(PyVkPipelineColorBlendStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->logicOp));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineColorBlendStateCreateInfo_getattachmentCount(PyVkPipelineColorBlendStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->attachmentCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineColorBlendStateCreateInfo_getpAttachments(PyVkPipelineColorBlendStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkPipelineColorBlendAttachmentStateType);
            if (!pyvalue)
                return NULL;
            ((PyVkPipelineColorBlendAttachmentState*) pyvalue)->base = ((self->base)->pAttachments);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineColorBlendStateCreateInfo_getblendConstants(PyVkPipelineColorBlendStateCreateInfo *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyList_New(0);
        int nb = sizeof(((self->base)->blendConstants)) / sizeof(((self->base)->blendConstants)[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* tmp = PyFloat_FromDouble((double) ((self->base)->blendConstants)[i]);
            PyList_Append(pyvalue, tmp);
        }
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPipelineColorBlendStateCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkPipelineColorBlendStateCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkPipelineColorBlendStateCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkPipelineColorBlendStateCreateInfo_getflags, NULL, "", NULL},
        
            {"logicOpEnable", (getter)PyVkPipelineColorBlendStateCreateInfo_getlogicOpEnable, NULL, "", NULL},
        
            {"logicOp", (getter)PyVkPipelineColorBlendStateCreateInfo_getlogicOp, NULL, "", NULL},
        
            {"attachmentCount", (getter)PyVkPipelineColorBlendStateCreateInfo_getattachmentCount, NULL, "", NULL},
        
            {"pAttachments", (getter)PyVkPipelineColorBlendStateCreateInfo_getpAttachments, NULL, "", NULL},
        
            {"blendConstants", (getter)PyVkPipelineColorBlendStateCreateInfo_getblendConstants, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPipelineDynamicStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPipelineDynamicStateCreateInfo *self = (PyVkPipelineDynamicStateCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPipelineDynamicStateCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPipelineDynamicStateCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPipelineDynamicStateCreateInfo_del(PyVkPipelineDynamicStateCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPipelineDynamicStateCreateInfo_init(PyVkPipelineDynamicStateCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkPipelineDynamicStateCreateFlags flags;
uint32_t dynamicStateCount;
VkDynamicState* pDynamicStates;

            static char *kwlist[] = {"sType","flags","dynamicStateCount","pDynamicStates",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkPipelineDynamicStateCreateFlags_converter,&flags,pyc_uint32_t_converter,&dynamicStateCount,pyc_flag_array_VkDynamicState_converter,&pDynamicStates))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->dynamicStateCount = dynamicStateCount;
            
            
            
                (self->base)->pDynamicStates = pDynamicStates;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkPipelineDynamicStateCreateFlags_converter_free(&flags);
pyc_uint32_t_converter_free(&dynamicStateCount);
pyc_flag_array_VkDynamicState_converter_free(&pDynamicStates);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPipelineDynamicStateCreateInfo_getsType(PyVkPipelineDynamicStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineDynamicStateCreateInfo_getpNext(PyVkPipelineDynamicStateCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineDynamicStateCreateInfo_getflags(PyVkPipelineDynamicStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineDynamicStateCreateInfo_getdynamicStateCount(PyVkPipelineDynamicStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->dynamicStateCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineDynamicStateCreateInfo_getpDynamicStates(PyVkPipelineDynamicStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(*((self->base)->pDynamicStates));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPipelineDynamicStateCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkPipelineDynamicStateCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkPipelineDynamicStateCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkPipelineDynamicStateCreateInfo_getflags, NULL, "", NULL},
        
            {"dynamicStateCount", (getter)PyVkPipelineDynamicStateCreateInfo_getdynamicStateCount, NULL, "", NULL},
        
            {"pDynamicStates", (getter)PyVkPipelineDynamicStateCreateInfo_getpDynamicStates, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkStencilOpState_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkStencilOpState *self = (PyVkStencilOpState *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkStencilOpState));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkStencilOpState");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkStencilOpState_del(PyVkStencilOpState* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkStencilOpState_init(PyVkStencilOpState *self, PyObject *args, PyObject *kwds) {
        
            VkStencilOp failOp;
VkStencilOp passOp;
VkStencilOp depthFailOp;
VkCompareOp compareOp;
uint32_t compareMask;
uint32_t writeMask;
uint32_t reference;

            static char *kwlist[] = {"failOp","passOp","depthFailOp","compareOp","compareMask","writeMask","reference",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStencilOp_converter,&failOp,pyc_flag_base_VkStencilOp_converter,&passOp,pyc_flag_base_VkStencilOp_converter,&depthFailOp,pyc_flag_base_VkCompareOp_converter,&compareOp,pyc_uint32_t_converter,&compareMask,pyc_uint32_t_converter,&writeMask,pyc_uint32_t_converter,&reference))
        return -1;
    

            
            
                (self->base)->failOp = failOp;
            
            
            
                (self->base)->passOp = passOp;
            
            
            
                (self->base)->depthFailOp = depthFailOp;
            
            
            
                (self->base)->compareOp = compareOp;
            
            
            
                (self->base)->compareMask = compareMask;
            
            
            
                (self->base)->writeMask = writeMask;
            
            
            
                (self->base)->reference = reference;
            
            

            pyc_flag_base_VkStencilOp_converter_free(&failOp);
pyc_flag_base_VkStencilOp_converter_free(&passOp);
pyc_flag_base_VkStencilOp_converter_free(&depthFailOp);
pyc_flag_base_VkCompareOp_converter_free(&compareOp);
pyc_uint32_t_converter_free(&compareMask);
pyc_uint32_t_converter_free(&writeMask);
pyc_uint32_t_converter_free(&reference);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkStencilOpState_getfailOp(PyVkStencilOpState *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->failOp));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkStencilOpState_getpassOp(PyVkStencilOpState *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->passOp));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkStencilOpState_getdepthFailOp(PyVkStencilOpState *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->depthFailOp));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkStencilOpState_getcompareOp(PyVkStencilOpState *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->compareOp));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkStencilOpState_getcompareMask(PyVkStencilOpState *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->compareMask));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkStencilOpState_getwriteMask(PyVkStencilOpState *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->writeMask));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkStencilOpState_getreference(PyVkStencilOpState *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->reference));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkStencilOpState_getsetters[] = {
        
            {"failOp", (getter)PyVkStencilOpState_getfailOp, NULL, "", NULL},
        
            {"passOp", (getter)PyVkStencilOpState_getpassOp, NULL, "", NULL},
        
            {"depthFailOp", (getter)PyVkStencilOpState_getdepthFailOp, NULL, "", NULL},
        
            {"compareOp", (getter)PyVkStencilOpState_getcompareOp, NULL, "", NULL},
        
            {"compareMask", (getter)PyVkStencilOpState_getcompareMask, NULL, "", NULL},
        
            {"writeMask", (getter)PyVkStencilOpState_getwriteMask, NULL, "", NULL},
        
            {"reference", (getter)PyVkStencilOpState_getreference, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPipelineDepthStencilStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPipelineDepthStencilStateCreateInfo *self = (PyVkPipelineDepthStencilStateCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPipelineDepthStencilStateCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPipelineDepthStencilStateCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPipelineDepthStencilStateCreateInfo_del(PyVkPipelineDepthStencilStateCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPipelineDepthStencilStateCreateInfo_init(PyVkPipelineDepthStencilStateCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkPipelineDepthStencilStateCreateFlags flags;
VkBool32 depthTestEnable;
VkBool32 depthWriteEnable;
VkCompareOp depthCompareOp;
VkBool32 depthBoundsTestEnable;
VkBool32 stencilTestEnable;
VkStencilOpState front;
VkStencilOpState back;
float minDepthBounds;
float maxDepthBounds;

            static char *kwlist[] = {"sType","flags","depthTestEnable","depthWriteEnable","depthCompareOp","depthBoundsTestEnable","stencilTestEnable","front","back","minDepthBounds","maxDepthBounds",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkPipelineDepthStencilStateCreateFlags_converter,&flags,pyc_flag_base_VkBool32_converter,&depthTestEnable,pyc_flag_base_VkBool32_converter,&depthWriteEnable,pyc_flag_base_VkCompareOp_converter,&depthCompareOp,pyc_flag_base_VkBool32_converter,&depthBoundsTestEnable,pyc_flag_base_VkBool32_converter,&stencilTestEnable,pyc_struct_base_VkStencilOpState_converter,&front,pyc_struct_base_VkStencilOpState_converter,&back,pyc_float_converter,&minDepthBounds,pyc_float_converter,&maxDepthBounds))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->depthTestEnable = depthTestEnable;
            
            
            
                (self->base)->depthWriteEnable = depthWriteEnable;
            
            
            
                (self->base)->depthCompareOp = depthCompareOp;
            
            
            
                (self->base)->depthBoundsTestEnable = depthBoundsTestEnable;
            
            
            
                (self->base)->stencilTestEnable = stencilTestEnable;
            
            
            
                (self->base)->front = front;
            
            
            
                (self->base)->back = back;
            
            
            
                (self->base)->minDepthBounds = minDepthBounds;
            
            
            
                (self->base)->maxDepthBounds = maxDepthBounds;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkPipelineDepthStencilStateCreateFlags_converter_free(&flags);
pyc_flag_base_VkBool32_converter_free(&depthTestEnable);
pyc_flag_base_VkBool32_converter_free(&depthWriteEnable);
pyc_flag_base_VkCompareOp_converter_free(&depthCompareOp);
pyc_flag_base_VkBool32_converter_free(&depthBoundsTestEnable);
pyc_flag_base_VkBool32_converter_free(&stencilTestEnable);
pyc_struct_base_VkStencilOpState_converter_free(&front);
pyc_struct_base_VkStencilOpState_converter_free(&back);
pyc_float_converter_free(&minDepthBounds);
pyc_float_converter_free(&maxDepthBounds);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPipelineDepthStencilStateCreateInfo_getsType(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineDepthStencilStateCreateInfo_getpNext(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineDepthStencilStateCreateInfo_getflags(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineDepthStencilStateCreateInfo_getdepthTestEnable(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->depthTestEnable));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineDepthStencilStateCreateInfo_getdepthWriteEnable(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->depthWriteEnable));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineDepthStencilStateCreateInfo_getdepthCompareOp(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->depthCompareOp));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineDepthStencilStateCreateInfo_getdepthBoundsTestEnable(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->depthBoundsTestEnable));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineDepthStencilStateCreateInfo_getstencilTestEnable(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->stencilTestEnable));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineDepthStencilStateCreateInfo_getfront(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkStencilOpStateType);
            if (!pyvalue)
                return NULL;
            ((PyVkStencilOpState*) pyvalue)->base = &((self->base)->front);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineDepthStencilStateCreateInfo_getback(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkStencilOpStateType);
            if (!pyvalue)
                return NULL;
            ((PyVkStencilOpState*) pyvalue)->base = &((self->base)->back);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineDepthStencilStateCreateInfo_getminDepthBounds(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->minDepthBounds));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineDepthStencilStateCreateInfo_getmaxDepthBounds(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->maxDepthBounds));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPipelineDepthStencilStateCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkPipelineDepthStencilStateCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkPipelineDepthStencilStateCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkPipelineDepthStencilStateCreateInfo_getflags, NULL, "", NULL},
        
            {"depthTestEnable", (getter)PyVkPipelineDepthStencilStateCreateInfo_getdepthTestEnable, NULL, "", NULL},
        
            {"depthWriteEnable", (getter)PyVkPipelineDepthStencilStateCreateInfo_getdepthWriteEnable, NULL, "", NULL},
        
            {"depthCompareOp", (getter)PyVkPipelineDepthStencilStateCreateInfo_getdepthCompareOp, NULL, "", NULL},
        
            {"depthBoundsTestEnable", (getter)PyVkPipelineDepthStencilStateCreateInfo_getdepthBoundsTestEnable, NULL, "", NULL},
        
            {"stencilTestEnable", (getter)PyVkPipelineDepthStencilStateCreateInfo_getstencilTestEnable, NULL, "", NULL},
        
            {"front", (getter)PyVkPipelineDepthStencilStateCreateInfo_getfront, NULL, "", NULL},
        
            {"back", (getter)PyVkPipelineDepthStencilStateCreateInfo_getback, NULL, "", NULL},
        
            {"minDepthBounds", (getter)PyVkPipelineDepthStencilStateCreateInfo_getminDepthBounds, NULL, "", NULL},
        
            {"maxDepthBounds", (getter)PyVkPipelineDepthStencilStateCreateInfo_getmaxDepthBounds, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkGraphicsPipelineCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkGraphicsPipelineCreateInfo *self = (PyVkGraphicsPipelineCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkGraphicsPipelineCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkGraphicsPipelineCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkGraphicsPipelineCreateInfo_del(PyVkGraphicsPipelineCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkGraphicsPipelineCreateInfo_init(PyVkGraphicsPipelineCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkPipelineCreateFlags flags;
uint32_t stageCount;
VkPipelineShaderStageCreateInfo* pStages;
VkPipelineVertexInputStateCreateInfo* pVertexInputState;
VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState;
VkPipelineTessellationStateCreateInfo* pTessellationState;
VkPipelineViewportStateCreateInfo* pViewportState;
VkPipelineRasterizationStateCreateInfo* pRasterizationState;
VkPipelineMultisampleStateCreateInfo* pMultisampleState;
VkPipelineDepthStencilStateCreateInfo* pDepthStencilState;
VkPipelineColorBlendStateCreateInfo* pColorBlendState;
VkPipelineDynamicStateCreateInfo* pDynamicState;
VkPipelineLayout layout;
VkRenderPass renderPass;
uint32_t subpass;
VkPipeline basePipelineHandle;
int32_t basePipelineIndex;

            static char *kwlist[] = {"sType","flags","stageCount","pStages","pVertexInputState","pInputAssemblyState","pTessellationState","pViewportState","pRasterizationState","pMultisampleState","pDepthStencilState","pColorBlendState","pDynamicState","layout","renderPass","subpass","basePipelineHandle","basePipelineIndex",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkPipelineCreateFlags_converter,&flags,pyc_uint32_t_converter,&stageCount,pyc_struct_array_VkPipelineShaderStageCreateInfo_converter,&pStages,pyc_struct_pointer_VkPipelineVertexInputStateCreateInfo_converter,&pVertexInputState,pyc_struct_pointer_VkPipelineInputAssemblyStateCreateInfo_converter,&pInputAssemblyState,pyc_struct_pointer_VkPipelineTessellationStateCreateInfo_converter,&pTessellationState,pyc_struct_pointer_VkPipelineViewportStateCreateInfo_converter,&pViewportState,pyc_struct_pointer_VkPipelineRasterizationStateCreateInfo_converter,&pRasterizationState,pyc_struct_pointer_VkPipelineMultisampleStateCreateInfo_converter,&pMultisampleState,pyc_struct_pointer_VkPipelineDepthStencilStateCreateInfo_converter,&pDepthStencilState,pyc_struct_pointer_VkPipelineColorBlendStateCreateInfo_converter,&pColorBlendState,pyc_struct_pointer_VkPipelineDynamicStateCreateInfo_converter,&pDynamicState,pyc_handle_base_VkPipelineLayout_converter,&layout,pyc_handle_base_VkRenderPass_converter,&renderPass,pyc_uint32_t_converter,&subpass,pyc_handle_base_VkPipeline_converter,&basePipelineHandle,pyc_int32_t_converter,&basePipelineIndex))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->stageCount = stageCount;
            
            
            
                (self->base)->pStages = pStages;
            
            
            
                (self->base)->pVertexInputState = pVertexInputState;
            
            
            
                (self->base)->pInputAssemblyState = pInputAssemblyState;
            
            
            
                (self->base)->pTessellationState = pTessellationState;
            
            
            
                (self->base)->pViewportState = pViewportState;
            
            
            
                (self->base)->pRasterizationState = pRasterizationState;
            
            
            
                (self->base)->pMultisampleState = pMultisampleState;
            
            
            
                (self->base)->pDepthStencilState = pDepthStencilState;
            
            
            
                (self->base)->pColorBlendState = pColorBlendState;
            
            
            
                (self->base)->pDynamicState = pDynamicState;
            
            
            
                (self->base)->layout = layout;
            
            
            
                (self->base)->renderPass = renderPass;
            
            
            
                (self->base)->subpass = subpass;
            
            
            
                (self->base)->basePipelineHandle = basePipelineHandle;
            
            
            
                (self->base)->basePipelineIndex = basePipelineIndex;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkPipelineCreateFlags_converter_free(&flags);
pyc_uint32_t_converter_free(&stageCount);
pyc_struct_array_VkPipelineShaderStageCreateInfo_converter_free(&pStages);
pyc_struct_pointer_VkPipelineVertexInputStateCreateInfo_converter_free(&pVertexInputState);
pyc_struct_pointer_VkPipelineInputAssemblyStateCreateInfo_converter_free(&pInputAssemblyState);
pyc_struct_pointer_VkPipelineTessellationStateCreateInfo_converter_free(&pTessellationState);
pyc_struct_pointer_VkPipelineViewportStateCreateInfo_converter_free(&pViewportState);
pyc_struct_pointer_VkPipelineRasterizationStateCreateInfo_converter_free(&pRasterizationState);
pyc_struct_pointer_VkPipelineMultisampleStateCreateInfo_converter_free(&pMultisampleState);
pyc_struct_pointer_VkPipelineDepthStencilStateCreateInfo_converter_free(&pDepthStencilState);
pyc_struct_pointer_VkPipelineColorBlendStateCreateInfo_converter_free(&pColorBlendState);
pyc_struct_pointer_VkPipelineDynamicStateCreateInfo_converter_free(&pDynamicState);
pyc_handle_base_VkPipelineLayout_converter_free(&layout);
pyc_handle_base_VkRenderPass_converter_free(&renderPass);
pyc_uint32_t_converter_free(&subpass);
pyc_handle_base_VkPipeline_converter_free(&basePipelineHandle);
pyc_int32_t_converter_free(&basePipelineIndex);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkGraphicsPipelineCreateInfo_getsType(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkGraphicsPipelineCreateInfo_getpNext(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkGraphicsPipelineCreateInfo_getflags(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkGraphicsPipelineCreateInfo_getstageCount(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->stageCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkGraphicsPipelineCreateInfo_getpStages(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkPipelineShaderStageCreateInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkPipelineShaderStageCreateInfo*) pyvalue)->base = ((self->base)->pStages);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkGraphicsPipelineCreateInfo_getpVertexInputState(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkPipelineVertexInputStateCreateInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkPipelineVertexInputStateCreateInfo*) pyvalue)->base = ((self->base)->pVertexInputState);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkGraphicsPipelineCreateInfo_getpInputAssemblyState(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkPipelineInputAssemblyStateCreateInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkPipelineInputAssemblyStateCreateInfo*) pyvalue)->base = ((self->base)->pInputAssemblyState);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkGraphicsPipelineCreateInfo_getpTessellationState(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkPipelineTessellationStateCreateInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkPipelineTessellationStateCreateInfo*) pyvalue)->base = ((self->base)->pTessellationState);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkGraphicsPipelineCreateInfo_getpViewportState(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkPipelineViewportStateCreateInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkPipelineViewportStateCreateInfo*) pyvalue)->base = ((self->base)->pViewportState);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkGraphicsPipelineCreateInfo_getpRasterizationState(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkPipelineRasterizationStateCreateInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkPipelineRasterizationStateCreateInfo*) pyvalue)->base = ((self->base)->pRasterizationState);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkGraphicsPipelineCreateInfo_getpMultisampleState(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkPipelineMultisampleStateCreateInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkPipelineMultisampleStateCreateInfo*) pyvalue)->base = ((self->base)->pMultisampleState);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkGraphicsPipelineCreateInfo_getpDepthStencilState(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkPipelineDepthStencilStateCreateInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkPipelineDepthStencilStateCreateInfo*) pyvalue)->base = ((self->base)->pDepthStencilState);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkGraphicsPipelineCreateInfo_getpColorBlendState(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkPipelineColorBlendStateCreateInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkPipelineColorBlendStateCreateInfo*) pyvalue)->base = ((self->base)->pColorBlendState);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkGraphicsPipelineCreateInfo_getpDynamicState(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkPipelineDynamicStateCreateInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkPipelineDynamicStateCreateInfo*) pyvalue)->base = ((self->base)->pDynamicState);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkGraphicsPipelineCreateInfo_getlayout(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkGraphicsPipelineCreateInfo_getrenderPass(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkGraphicsPipelineCreateInfo_getsubpass(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->subpass));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkGraphicsPipelineCreateInfo_getbasePipelineHandle(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkGraphicsPipelineCreateInfo_getbasePipelineIndex(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->basePipelineIndex));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkGraphicsPipelineCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkGraphicsPipelineCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkGraphicsPipelineCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkGraphicsPipelineCreateInfo_getflags, NULL, "", NULL},
        
            {"stageCount", (getter)PyVkGraphicsPipelineCreateInfo_getstageCount, NULL, "", NULL},
        
            {"pStages", (getter)PyVkGraphicsPipelineCreateInfo_getpStages, NULL, "", NULL},
        
            {"pVertexInputState", (getter)PyVkGraphicsPipelineCreateInfo_getpVertexInputState, NULL, "", NULL},
        
            {"pInputAssemblyState", (getter)PyVkGraphicsPipelineCreateInfo_getpInputAssemblyState, NULL, "", NULL},
        
            {"pTessellationState", (getter)PyVkGraphicsPipelineCreateInfo_getpTessellationState, NULL, "", NULL},
        
            {"pViewportState", (getter)PyVkGraphicsPipelineCreateInfo_getpViewportState, NULL, "", NULL},
        
            {"pRasterizationState", (getter)PyVkGraphicsPipelineCreateInfo_getpRasterizationState, NULL, "", NULL},
        
            {"pMultisampleState", (getter)PyVkGraphicsPipelineCreateInfo_getpMultisampleState, NULL, "", NULL},
        
            {"pDepthStencilState", (getter)PyVkGraphicsPipelineCreateInfo_getpDepthStencilState, NULL, "", NULL},
        
            {"pColorBlendState", (getter)PyVkGraphicsPipelineCreateInfo_getpColorBlendState, NULL, "", NULL},
        
            {"pDynamicState", (getter)PyVkGraphicsPipelineCreateInfo_getpDynamicState, NULL, "", NULL},
        
            {"layout", (getter)PyVkGraphicsPipelineCreateInfo_getlayout, NULL, "", NULL},
        
            {"renderPass", (getter)PyVkGraphicsPipelineCreateInfo_getrenderPass, NULL, "", NULL},
        
            {"subpass", (getter)PyVkGraphicsPipelineCreateInfo_getsubpass, NULL, "", NULL},
        
            {"basePipelineHandle", (getter)PyVkGraphicsPipelineCreateInfo_getbasePipelineHandle, NULL, "", NULL},
        
            {"basePipelineIndex", (getter)PyVkGraphicsPipelineCreateInfo_getbasePipelineIndex, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPipelineCacheCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPipelineCacheCreateInfo *self = (PyVkPipelineCacheCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPipelineCacheCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPipelineCacheCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPipelineCacheCreateInfo_del(PyVkPipelineCacheCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPipelineCacheCreateInfo_init(PyVkPipelineCacheCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkPipelineCacheCreateFlags flags;
size_t initialDataSize;
void * pInitialData;

            static char *kwlist[] = {"sType","flags","initialDataSize","pInitialData",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkPipelineCacheCreateFlags_converter,&flags,pyc_size_t_converter,&initialDataSize,pyc_void_x_converter,&pInitialData))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->initialDataSize = initialDataSize;
            
            
            
                (self->base)->pInitialData = pInitialData;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkPipelineCacheCreateFlags_converter_free(&flags);
pyc_size_t_converter_free(&initialDataSize);
pyc_void_x_converter_free(&pInitialData);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPipelineCacheCreateInfo_getsType(PyVkPipelineCacheCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineCacheCreateInfo_getpNext(PyVkPipelineCacheCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineCacheCreateInfo_getflags(PyVkPipelineCacheCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineCacheCreateInfo_getinitialDataSize(PyVkPipelineCacheCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->initialDataSize));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineCacheCreateInfo_getpInitialData(PyVkPipelineCacheCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPipelineCacheCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkPipelineCacheCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkPipelineCacheCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkPipelineCacheCreateInfo_getflags, NULL, "", NULL},
        
            {"initialDataSize", (getter)PyVkPipelineCacheCreateInfo_getinitialDataSize, NULL, "", NULL},
        
            {"pInitialData", (getter)PyVkPipelineCacheCreateInfo_getpInitialData, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPushConstantRange_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPushConstantRange *self = (PyVkPushConstantRange *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPushConstantRange));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPushConstantRange");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPushConstantRange_del(PyVkPushConstantRange* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPushConstantRange_init(PyVkPushConstantRange *self, PyObject *args, PyObject *kwds) {
        
            VkShaderStageFlags stageFlags;
uint32_t offset;
uint32_t size;

            static char *kwlist[] = {"stageFlags","offset","size",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_flag_base_VkShaderStageFlags_converter,&stageFlags,pyc_uint32_t_converter,&offset,pyc_uint32_t_converter,&size))
        return -1;
    

            
            
                (self->base)->stageFlags = stageFlags;
            
            
            
                (self->base)->offset = offset;
            
            
            
                (self->base)->size = size;
            
            

            pyc_flag_base_VkShaderStageFlags_converter_free(&stageFlags);
pyc_uint32_t_converter_free(&offset);
pyc_uint32_t_converter_free(&size);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPushConstantRange_getstageFlags(PyVkPushConstantRange *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->stageFlags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPushConstantRange_getoffset(PyVkPushConstantRange *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->offset));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPushConstantRange_getsize(PyVkPushConstantRange *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->size));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPushConstantRange_getsetters[] = {
        
            {"stageFlags", (getter)PyVkPushConstantRange_getstageFlags, NULL, "", NULL},
        
            {"offset", (getter)PyVkPushConstantRange_getoffset, NULL, "", NULL},
        
            {"size", (getter)PyVkPushConstantRange_getsize, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPipelineLayoutCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPipelineLayoutCreateInfo *self = (PyVkPipelineLayoutCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPipelineLayoutCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPipelineLayoutCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPipelineLayoutCreateInfo_del(PyVkPipelineLayoutCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPipelineLayoutCreateInfo_init(PyVkPipelineLayoutCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkPipelineLayoutCreateFlags flags;
uint32_t setLayoutCount;
VkDescriptorSetLayout* pSetLayouts;
uint32_t pushConstantRangeCount;
VkPushConstantRange* pPushConstantRanges;

            static char *kwlist[] = {"sType","flags","setLayoutCount","pSetLayouts","pushConstantRangeCount","pPushConstantRanges",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkPipelineLayoutCreateFlags_converter,&flags,pyc_uint32_t_converter,&setLayoutCount,pyc_handle_array_VkDescriptorSetLayout_converter,&pSetLayouts,pyc_uint32_t_converter,&pushConstantRangeCount,pyc_struct_array_VkPushConstantRange_converter,&pPushConstantRanges))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->setLayoutCount = setLayoutCount;
            
            
            
                (self->base)->pSetLayouts = pSetLayouts;
            
            
            
                (self->base)->pushConstantRangeCount = pushConstantRangeCount;
            
            
            
                (self->base)->pPushConstantRanges = pPushConstantRanges;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkPipelineLayoutCreateFlags_converter_free(&flags);
pyc_uint32_t_converter_free(&setLayoutCount);
pyc_handle_array_VkDescriptorSetLayout_converter_free(&pSetLayouts);
pyc_uint32_t_converter_free(&pushConstantRangeCount);
pyc_struct_array_VkPushConstantRange_converter_free(&pPushConstantRanges);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPipelineLayoutCreateInfo_getsType(PyVkPipelineLayoutCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineLayoutCreateInfo_getpNext(PyVkPipelineLayoutCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineLayoutCreateInfo_getflags(PyVkPipelineLayoutCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineLayoutCreateInfo_getsetLayoutCount(PyVkPipelineLayoutCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->setLayoutCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineLayoutCreateInfo_getpSetLayouts(PyVkPipelineLayoutCreateInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkPipelineLayoutCreateInfo_getpushConstantRangeCount(PyVkPipelineLayoutCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->pushConstantRangeCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineLayoutCreateInfo_getpPushConstantRanges(PyVkPipelineLayoutCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkPushConstantRangeType);
            if (!pyvalue)
                return NULL;
            ((PyVkPushConstantRange*) pyvalue)->base = ((self->base)->pPushConstantRanges);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPipelineLayoutCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkPipelineLayoutCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkPipelineLayoutCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkPipelineLayoutCreateInfo_getflags, NULL, "", NULL},
        
            {"setLayoutCount", (getter)PyVkPipelineLayoutCreateInfo_getsetLayoutCount, NULL, "", NULL},
        
            {"pSetLayouts", (getter)PyVkPipelineLayoutCreateInfo_getpSetLayouts, NULL, "", NULL},
        
            {"pushConstantRangeCount", (getter)PyVkPipelineLayoutCreateInfo_getpushConstantRangeCount, NULL, "", NULL},
        
            {"pPushConstantRanges", (getter)PyVkPipelineLayoutCreateInfo_getpPushConstantRanges, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkSamplerCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkSamplerCreateInfo *self = (PyVkSamplerCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkSamplerCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkSamplerCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkSamplerCreateInfo_del(PyVkSamplerCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkSamplerCreateInfo_init(PyVkSamplerCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkSamplerCreateFlags flags;
VkFilter magFilter;
VkFilter minFilter;
VkSamplerMipmapMode mipmapMode;
VkSamplerAddressMode addressModeU;
VkSamplerAddressMode addressModeV;
VkSamplerAddressMode addressModeW;
float mipLodBias;
VkBool32 anisotropyEnable;
float maxAnisotropy;
VkBool32 compareEnable;
VkCompareOp compareOp;
float minLod;
float maxLod;
VkBorderColor borderColor;
VkBool32 unnormalizedCoordinates;

            static char *kwlist[] = {"sType","flags","magFilter","minFilter","mipmapMode","addressModeU","addressModeV","addressModeW","mipLodBias","anisotropyEnable","maxAnisotropy","compareEnable","compareOp","minLod","maxLod","borderColor","unnormalizedCoordinates",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkSamplerCreateFlags_converter,&flags,pyc_flag_base_VkFilter_converter,&magFilter,pyc_flag_base_VkFilter_converter,&minFilter,pyc_flag_base_VkSamplerMipmapMode_converter,&mipmapMode,pyc_flag_base_VkSamplerAddressMode_converter,&addressModeU,pyc_flag_base_VkSamplerAddressMode_converter,&addressModeV,pyc_flag_base_VkSamplerAddressMode_converter,&addressModeW,pyc_float_converter,&mipLodBias,pyc_flag_base_VkBool32_converter,&anisotropyEnable,pyc_float_converter,&maxAnisotropy,pyc_flag_base_VkBool32_converter,&compareEnable,pyc_flag_base_VkCompareOp_converter,&compareOp,pyc_float_converter,&minLod,pyc_float_converter,&maxLod,pyc_flag_base_VkBorderColor_converter,&borderColor,pyc_flag_base_VkBool32_converter,&unnormalizedCoordinates))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->magFilter = magFilter;
            
            
            
                (self->base)->minFilter = minFilter;
            
            
            
                (self->base)->mipmapMode = mipmapMode;
            
            
            
                (self->base)->addressModeU = addressModeU;
            
            
            
                (self->base)->addressModeV = addressModeV;
            
            
            
                (self->base)->addressModeW = addressModeW;
            
            
            
                (self->base)->mipLodBias = mipLodBias;
            
            
            
                (self->base)->anisotropyEnable = anisotropyEnable;
            
            
            
                (self->base)->maxAnisotropy = maxAnisotropy;
            
            
            
                (self->base)->compareEnable = compareEnable;
            
            
            
                (self->base)->compareOp = compareOp;
            
            
            
                (self->base)->minLod = minLod;
            
            
            
                (self->base)->maxLod = maxLod;
            
            
            
                (self->base)->borderColor = borderColor;
            
            
            
                (self->base)->unnormalizedCoordinates = unnormalizedCoordinates;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkSamplerCreateFlags_converter_free(&flags);
pyc_flag_base_VkFilter_converter_free(&magFilter);
pyc_flag_base_VkFilter_converter_free(&minFilter);
pyc_flag_base_VkSamplerMipmapMode_converter_free(&mipmapMode);
pyc_flag_base_VkSamplerAddressMode_converter_free(&addressModeU);
pyc_flag_base_VkSamplerAddressMode_converter_free(&addressModeV);
pyc_flag_base_VkSamplerAddressMode_converter_free(&addressModeW);
pyc_float_converter_free(&mipLodBias);
pyc_flag_base_VkBool32_converter_free(&anisotropyEnable);
pyc_float_converter_free(&maxAnisotropy);
pyc_flag_base_VkBool32_converter_free(&compareEnable);
pyc_flag_base_VkCompareOp_converter_free(&compareOp);
pyc_float_converter_free(&minLod);
pyc_float_converter_free(&maxLod);
pyc_flag_base_VkBorderColor_converter_free(&borderColor);
pyc_flag_base_VkBool32_converter_free(&unnormalizedCoordinates);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkSamplerCreateInfo_getsType(PyVkSamplerCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSamplerCreateInfo_getpNext(PyVkSamplerCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSamplerCreateInfo_getflags(PyVkSamplerCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSamplerCreateInfo_getmagFilter(PyVkSamplerCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->magFilter));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSamplerCreateInfo_getminFilter(PyVkSamplerCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->minFilter));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSamplerCreateInfo_getmipmapMode(PyVkSamplerCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->mipmapMode));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSamplerCreateInfo_getaddressModeU(PyVkSamplerCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->addressModeU));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSamplerCreateInfo_getaddressModeV(PyVkSamplerCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->addressModeV));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSamplerCreateInfo_getaddressModeW(PyVkSamplerCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->addressModeW));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSamplerCreateInfo_getmipLodBias(PyVkSamplerCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->mipLodBias));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSamplerCreateInfo_getanisotropyEnable(PyVkSamplerCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->anisotropyEnable));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSamplerCreateInfo_getmaxAnisotropy(PyVkSamplerCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->maxAnisotropy));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSamplerCreateInfo_getcompareEnable(PyVkSamplerCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->compareEnable));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSamplerCreateInfo_getcompareOp(PyVkSamplerCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->compareOp));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSamplerCreateInfo_getminLod(PyVkSamplerCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->minLod));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSamplerCreateInfo_getmaxLod(PyVkSamplerCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->maxLod));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSamplerCreateInfo_getborderColor(PyVkSamplerCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->borderColor));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSamplerCreateInfo_getunnormalizedCoordinates(PyVkSamplerCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->unnormalizedCoordinates));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkSamplerCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkSamplerCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkSamplerCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkSamplerCreateInfo_getflags, NULL, "", NULL},
        
            {"magFilter", (getter)PyVkSamplerCreateInfo_getmagFilter, NULL, "", NULL},
        
            {"minFilter", (getter)PyVkSamplerCreateInfo_getminFilter, NULL, "", NULL},
        
            {"mipmapMode", (getter)PyVkSamplerCreateInfo_getmipmapMode, NULL, "", NULL},
        
            {"addressModeU", (getter)PyVkSamplerCreateInfo_getaddressModeU, NULL, "", NULL},
        
            {"addressModeV", (getter)PyVkSamplerCreateInfo_getaddressModeV, NULL, "", NULL},
        
            {"addressModeW", (getter)PyVkSamplerCreateInfo_getaddressModeW, NULL, "", NULL},
        
            {"mipLodBias", (getter)PyVkSamplerCreateInfo_getmipLodBias, NULL, "", NULL},
        
            {"anisotropyEnable", (getter)PyVkSamplerCreateInfo_getanisotropyEnable, NULL, "", NULL},
        
            {"maxAnisotropy", (getter)PyVkSamplerCreateInfo_getmaxAnisotropy, NULL, "", NULL},
        
            {"compareEnable", (getter)PyVkSamplerCreateInfo_getcompareEnable, NULL, "", NULL},
        
            {"compareOp", (getter)PyVkSamplerCreateInfo_getcompareOp, NULL, "", NULL},
        
            {"minLod", (getter)PyVkSamplerCreateInfo_getminLod, NULL, "", NULL},
        
            {"maxLod", (getter)PyVkSamplerCreateInfo_getmaxLod, NULL, "", NULL},
        
            {"borderColor", (getter)PyVkSamplerCreateInfo_getborderColor, NULL, "", NULL},
        
            {"unnormalizedCoordinates", (getter)PyVkSamplerCreateInfo_getunnormalizedCoordinates, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkCommandPoolCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkCommandPoolCreateInfo *self = (PyVkCommandPoolCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkCommandPoolCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkCommandPoolCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkCommandPoolCreateInfo_del(PyVkCommandPoolCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkCommandPoolCreateInfo_init(PyVkCommandPoolCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkCommandPoolCreateFlags flags;
uint32_t queueFamilyIndex;

            static char *kwlist[] = {"sType","flags","queueFamilyIndex",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkCommandPoolCreateFlags_converter,&flags,pyc_uint32_t_converter,&queueFamilyIndex))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->queueFamilyIndex = queueFamilyIndex;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkCommandPoolCreateFlags_converter_free(&flags);
pyc_uint32_t_converter_free(&queueFamilyIndex);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkCommandPoolCreateInfo_getsType(PyVkCommandPoolCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCommandPoolCreateInfo_getpNext(PyVkCommandPoolCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCommandPoolCreateInfo_getflags(PyVkCommandPoolCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCommandPoolCreateInfo_getqueueFamilyIndex(PyVkCommandPoolCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->queueFamilyIndex));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkCommandPoolCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkCommandPoolCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkCommandPoolCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkCommandPoolCreateInfo_getflags, NULL, "", NULL},
        
            {"queueFamilyIndex", (getter)PyVkCommandPoolCreateInfo_getqueueFamilyIndex, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkCommandBufferAllocateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkCommandBufferAllocateInfo *self = (PyVkCommandBufferAllocateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkCommandBufferAllocateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkCommandBufferAllocateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkCommandBufferAllocateInfo_del(PyVkCommandBufferAllocateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkCommandBufferAllocateInfo_init(PyVkCommandBufferAllocateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkCommandPool commandPool;
VkCommandBufferLevel level;
uint32_t commandBufferCount;

            static char *kwlist[] = {"sType","commandPool","level","commandBufferCount",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_handle_base_VkCommandPool_converter,&commandPool,pyc_flag_base_VkCommandBufferLevel_converter,&level,pyc_uint32_t_converter,&commandBufferCount))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->commandPool = commandPool;
            
            
            
                (self->base)->level = level;
            
            
            
                (self->base)->commandBufferCount = commandBufferCount;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_handle_base_VkCommandPool_converter_free(&commandPool);
pyc_flag_base_VkCommandBufferLevel_converter_free(&level);
pyc_uint32_t_converter_free(&commandBufferCount);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkCommandBufferAllocateInfo_getsType(PyVkCommandBufferAllocateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCommandBufferAllocateInfo_getpNext(PyVkCommandBufferAllocateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCommandBufferAllocateInfo_getcommandPool(PyVkCommandBufferAllocateInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkCommandBufferAllocateInfo_getlevel(PyVkCommandBufferAllocateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->level));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCommandBufferAllocateInfo_getcommandBufferCount(PyVkCommandBufferAllocateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->commandBufferCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkCommandBufferAllocateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkCommandBufferAllocateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkCommandBufferAllocateInfo_getpNext, NULL, "", NULL},
        
            {"commandPool", (getter)PyVkCommandBufferAllocateInfo_getcommandPool, NULL, "", NULL},
        
            {"level", (getter)PyVkCommandBufferAllocateInfo_getlevel, NULL, "", NULL},
        
            {"commandBufferCount", (getter)PyVkCommandBufferAllocateInfo_getcommandBufferCount, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkCommandBufferInheritanceInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkCommandBufferInheritanceInfo *self = (PyVkCommandBufferInheritanceInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkCommandBufferInheritanceInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkCommandBufferInheritanceInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkCommandBufferInheritanceInfo_del(PyVkCommandBufferInheritanceInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkCommandBufferInheritanceInfo_init(PyVkCommandBufferInheritanceInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkRenderPass renderPass;
uint32_t subpass;
VkFramebuffer framebuffer;
VkBool32 occlusionQueryEnable;
VkQueryControlFlags queryFlags;
VkQueryPipelineStatisticFlags pipelineStatistics;

            static char *kwlist[] = {"sType","renderPass","subpass","framebuffer","occlusionQueryEnable","queryFlags","pipelineStatistics",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_handle_base_VkRenderPass_converter,&renderPass,pyc_uint32_t_converter,&subpass,pyc_handle_base_VkFramebuffer_converter,&framebuffer,pyc_flag_base_VkBool32_converter,&occlusionQueryEnable,pyc_flag_base_VkQueryControlFlags_converter,&queryFlags,pyc_flag_base_VkQueryPipelineStatisticFlags_converter,&pipelineStatistics))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->renderPass = renderPass;
            
            
            
                (self->base)->subpass = subpass;
            
            
            
                (self->base)->framebuffer = framebuffer;
            
            
            
                (self->base)->occlusionQueryEnable = occlusionQueryEnable;
            
            
            
                (self->base)->queryFlags = queryFlags;
            
            
            
                (self->base)->pipelineStatistics = pipelineStatistics;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_handle_base_VkRenderPass_converter_free(&renderPass);
pyc_uint32_t_converter_free(&subpass);
pyc_handle_base_VkFramebuffer_converter_free(&framebuffer);
pyc_flag_base_VkBool32_converter_free(&occlusionQueryEnable);
pyc_flag_base_VkQueryControlFlags_converter_free(&queryFlags);
pyc_flag_base_VkQueryPipelineStatisticFlags_converter_free(&pipelineStatistics);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkCommandBufferInheritanceInfo_getsType(PyVkCommandBufferInheritanceInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCommandBufferInheritanceInfo_getpNext(PyVkCommandBufferInheritanceInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCommandBufferInheritanceInfo_getrenderPass(PyVkCommandBufferInheritanceInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkCommandBufferInheritanceInfo_getsubpass(PyVkCommandBufferInheritanceInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->subpass));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCommandBufferInheritanceInfo_getframebuffer(PyVkCommandBufferInheritanceInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkCommandBufferInheritanceInfo_getocclusionQueryEnable(PyVkCommandBufferInheritanceInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->occlusionQueryEnable));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCommandBufferInheritanceInfo_getqueryFlags(PyVkCommandBufferInheritanceInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->queryFlags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCommandBufferInheritanceInfo_getpipelineStatistics(PyVkCommandBufferInheritanceInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->pipelineStatistics));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkCommandBufferInheritanceInfo_getsetters[] = {
        
            {"sType", (getter)PyVkCommandBufferInheritanceInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkCommandBufferInheritanceInfo_getpNext, NULL, "", NULL},
        
            {"renderPass", (getter)PyVkCommandBufferInheritanceInfo_getrenderPass, NULL, "", NULL},
        
            {"subpass", (getter)PyVkCommandBufferInheritanceInfo_getsubpass, NULL, "", NULL},
        
            {"framebuffer", (getter)PyVkCommandBufferInheritanceInfo_getframebuffer, NULL, "", NULL},
        
            {"occlusionQueryEnable", (getter)PyVkCommandBufferInheritanceInfo_getocclusionQueryEnable, NULL, "", NULL},
        
            {"queryFlags", (getter)PyVkCommandBufferInheritanceInfo_getqueryFlags, NULL, "", NULL},
        
            {"pipelineStatistics", (getter)PyVkCommandBufferInheritanceInfo_getpipelineStatistics, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkCommandBufferBeginInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkCommandBufferBeginInfo *self = (PyVkCommandBufferBeginInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkCommandBufferBeginInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkCommandBufferBeginInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkCommandBufferBeginInfo_del(PyVkCommandBufferBeginInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkCommandBufferBeginInfo_init(PyVkCommandBufferBeginInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkCommandBufferUsageFlags flags;
VkCommandBufferInheritanceInfo* pInheritanceInfo;

            static char *kwlist[] = {"sType","flags","pInheritanceInfo",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkCommandBufferUsageFlags_converter,&flags,pyc_struct_pointer_VkCommandBufferInheritanceInfo_converter,&pInheritanceInfo))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->pInheritanceInfo = pInheritanceInfo;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkCommandBufferUsageFlags_converter_free(&flags);
pyc_struct_pointer_VkCommandBufferInheritanceInfo_converter_free(&pInheritanceInfo);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkCommandBufferBeginInfo_getsType(PyVkCommandBufferBeginInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCommandBufferBeginInfo_getpNext(PyVkCommandBufferBeginInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCommandBufferBeginInfo_getflags(PyVkCommandBufferBeginInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkCommandBufferBeginInfo_getpInheritanceInfo(PyVkCommandBufferBeginInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkCommandBufferInheritanceInfoType);
            if (!pyvalue)
                return NULL;
            ((PyVkCommandBufferInheritanceInfo*) pyvalue)->base = ((self->base)->pInheritanceInfo);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkCommandBufferBeginInfo_getsetters[] = {
        
            {"sType", (getter)PyVkCommandBufferBeginInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkCommandBufferBeginInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkCommandBufferBeginInfo_getflags, NULL, "", NULL},
        
            {"pInheritanceInfo", (getter)PyVkCommandBufferBeginInfo_getpInheritanceInfo, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkRenderPassBeginInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkRenderPassBeginInfo *self = (PyVkRenderPassBeginInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkRenderPassBeginInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkRenderPassBeginInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkRenderPassBeginInfo_del(PyVkRenderPassBeginInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkRenderPassBeginInfo_init(PyVkRenderPassBeginInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkRenderPass renderPass;
VkFramebuffer framebuffer;
VkRect2D renderArea;
uint32_t clearValueCount;
VkClearValue* pClearValues;

            static char *kwlist[] = {"sType","renderPass","framebuffer","renderArea","clearValueCount","pClearValues",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_handle_base_VkRenderPass_converter,&renderPass,pyc_handle_base_VkFramebuffer_converter,&framebuffer,pyc_struct_base_VkRect2D_converter,&renderArea,pyc_uint32_t_converter,&clearValueCount,pyc_struct_array_VkClearValue_converter,&pClearValues))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->renderPass = renderPass;
            
            
            
                (self->base)->framebuffer = framebuffer;
            
            
            
                (self->base)->renderArea = renderArea;
            
            
            
                (self->base)->clearValueCount = clearValueCount;
            
            
            
                (self->base)->pClearValues = pClearValues;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_handle_base_VkRenderPass_converter_free(&renderPass);
pyc_handle_base_VkFramebuffer_converter_free(&framebuffer);
pyc_struct_base_VkRect2D_converter_free(&renderArea);
pyc_uint32_t_converter_free(&clearValueCount);
pyc_struct_array_VkClearValue_converter_free(&pClearValues);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkRenderPassBeginInfo_getsType(PyVkRenderPassBeginInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkRenderPassBeginInfo_getpNext(PyVkRenderPassBeginInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkRenderPassBeginInfo_getrenderPass(PyVkRenderPassBeginInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkRenderPassBeginInfo_getframebuffer(PyVkRenderPassBeginInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkRenderPassBeginInfo_getrenderArea(PyVkRenderPassBeginInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkRect2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkRect2D*) pyvalue)->base = &((self->base)->renderArea);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkRenderPassBeginInfo_getclearValueCount(PyVkRenderPassBeginInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->clearValueCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkRenderPassBeginInfo_getpClearValues(PyVkRenderPassBeginInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkClearValueType);
            if (!pyvalue)
                return NULL;
            ((PyVkClearValue*) pyvalue)->base = ((self->base)->pClearValues);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkRenderPassBeginInfo_getsetters[] = {
        
            {"sType", (getter)PyVkRenderPassBeginInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkRenderPassBeginInfo_getpNext, NULL, "", NULL},
        
            {"renderPass", (getter)PyVkRenderPassBeginInfo_getrenderPass, NULL, "", NULL},
        
            {"framebuffer", (getter)PyVkRenderPassBeginInfo_getframebuffer, NULL, "", NULL},
        
            {"renderArea", (getter)PyVkRenderPassBeginInfo_getrenderArea, NULL, "", NULL},
        
            {"clearValueCount", (getter)PyVkRenderPassBeginInfo_getclearValueCount, NULL, "", NULL},
        
            {"pClearValues", (getter)PyVkRenderPassBeginInfo_getpClearValues, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkClearDepthStencilValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkClearDepthStencilValue *self = (PyVkClearDepthStencilValue *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkClearDepthStencilValue));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkClearDepthStencilValue");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkClearDepthStencilValue_del(PyVkClearDepthStencilValue* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkClearDepthStencilValue_init(PyVkClearDepthStencilValue *self, PyObject *args, PyObject *kwds) {
        
            float depth;
uint32_t stencil;

            static char *kwlist[] = {"depth","stencil",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_float_converter,&depth,pyc_uint32_t_converter,&stencil))
        return -1;
    

            
            
                (self->base)->depth = depth;
            
            
            
                (self->base)->stencil = stencil;
            
            

            pyc_float_converter_free(&depth);
pyc_uint32_t_converter_free(&stencil);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkClearDepthStencilValue_getdepth(PyVkClearDepthStencilValue *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->depth));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkClearDepthStencilValue_getstencil(PyVkClearDepthStencilValue *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->stencil));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkClearDepthStencilValue_getsetters[] = {
        
            {"depth", (getter)PyVkClearDepthStencilValue_getdepth, NULL, "", NULL},
        
            {"stencil", (getter)PyVkClearDepthStencilValue_getstencil, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkClearAttachment_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkClearAttachment *self = (PyVkClearAttachment *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkClearAttachment));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkClearAttachment");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkClearAttachment_del(PyVkClearAttachment* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkClearAttachment_init(PyVkClearAttachment *self, PyObject *args, PyObject *kwds) {
        
            VkImageAspectFlags aspectMask;
uint32_t colorAttachment;
VkClearValue clearValue;

            static char *kwlist[] = {"aspectMask","colorAttachment","clearValue",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_flag_base_VkImageAspectFlags_converter,&aspectMask,pyc_uint32_t_converter,&colorAttachment,pyc_struct_base_VkClearValue_converter,&clearValue))
        return -1;
    

            
            
                (self->base)->aspectMask = aspectMask;
            
            
            
                (self->base)->colorAttachment = colorAttachment;
            
            
            
                (self->base)->clearValue = clearValue;
            
            

            pyc_flag_base_VkImageAspectFlags_converter_free(&aspectMask);
pyc_uint32_t_converter_free(&colorAttachment);
pyc_struct_base_VkClearValue_converter_free(&clearValue);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkClearAttachment_getaspectMask(PyVkClearAttachment *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->aspectMask));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkClearAttachment_getcolorAttachment(PyVkClearAttachment *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->colorAttachment));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkClearAttachment_getclearValue(PyVkClearAttachment *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkClearValueType);
            if (!pyvalue)
                return NULL;
            ((PyVkClearValue*) pyvalue)->base = &((self->base)->clearValue);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkClearAttachment_getsetters[] = {
        
            {"aspectMask", (getter)PyVkClearAttachment_getaspectMask, NULL, "", NULL},
        
            {"colorAttachment", (getter)PyVkClearAttachment_getcolorAttachment, NULL, "", NULL},
        
            {"clearValue", (getter)PyVkClearAttachment_getclearValue, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkAttachmentDescription_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkAttachmentDescription *self = (PyVkAttachmentDescription *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkAttachmentDescription));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkAttachmentDescription");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkAttachmentDescription_del(PyVkAttachmentDescription* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkAttachmentDescription_init(PyVkAttachmentDescription *self, PyObject *args, PyObject *kwds) {
        
            VkAttachmentDescriptionFlags flags;
VkFormat format;
VkSampleCountFlagBits samples;
VkAttachmentLoadOp loadOp;
VkAttachmentStoreOp storeOp;
VkAttachmentLoadOp stencilLoadOp;
VkAttachmentStoreOp stencilStoreOp;
VkImageLayout initialLayout;
VkImageLayout finalLayout;

            static char *kwlist[] = {"flags","format","samples","loadOp","storeOp","stencilLoadOp","stencilStoreOp","initialLayout","finalLayout",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkAttachmentDescriptionFlags_converter,&flags,pyc_flag_base_VkFormat_converter,&format,pyc_flag_base_VkSampleCountFlagBits_converter,&samples,pyc_flag_base_VkAttachmentLoadOp_converter,&loadOp,pyc_flag_base_VkAttachmentStoreOp_converter,&storeOp,pyc_flag_base_VkAttachmentLoadOp_converter,&stencilLoadOp,pyc_flag_base_VkAttachmentStoreOp_converter,&stencilStoreOp,pyc_flag_base_VkImageLayout_converter,&initialLayout,pyc_flag_base_VkImageLayout_converter,&finalLayout))
        return -1;
    

            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->format = format;
            
            
            
                (self->base)->samples = samples;
            
            
            
                (self->base)->loadOp = loadOp;
            
            
            
                (self->base)->storeOp = storeOp;
            
            
            
                (self->base)->stencilLoadOp = stencilLoadOp;
            
            
            
                (self->base)->stencilStoreOp = stencilStoreOp;
            
            
            
                (self->base)->initialLayout = initialLayout;
            
            
            
                (self->base)->finalLayout = finalLayout;
            
            

            pyc_flag_base_VkAttachmentDescriptionFlags_converter_free(&flags);
pyc_flag_base_VkFormat_converter_free(&format);
pyc_flag_base_VkSampleCountFlagBits_converter_free(&samples);
pyc_flag_base_VkAttachmentLoadOp_converter_free(&loadOp);
pyc_flag_base_VkAttachmentStoreOp_converter_free(&storeOp);
pyc_flag_base_VkAttachmentLoadOp_converter_free(&stencilLoadOp);
pyc_flag_base_VkAttachmentStoreOp_converter_free(&stencilStoreOp);
pyc_flag_base_VkImageLayout_converter_free(&initialLayout);
pyc_flag_base_VkImageLayout_converter_free(&finalLayout);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkAttachmentDescription_getflags(PyVkAttachmentDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkAttachmentDescription_getformat(PyVkAttachmentDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->format));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkAttachmentDescription_getsamples(PyVkAttachmentDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->samples));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkAttachmentDescription_getloadOp(PyVkAttachmentDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->loadOp));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkAttachmentDescription_getstoreOp(PyVkAttachmentDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->storeOp));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkAttachmentDescription_getstencilLoadOp(PyVkAttachmentDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->stencilLoadOp));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkAttachmentDescription_getstencilStoreOp(PyVkAttachmentDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->stencilStoreOp));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkAttachmentDescription_getinitialLayout(PyVkAttachmentDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->initialLayout));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkAttachmentDescription_getfinalLayout(PyVkAttachmentDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->finalLayout));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkAttachmentDescription_getsetters[] = {
        
            {"flags", (getter)PyVkAttachmentDescription_getflags, NULL, "", NULL},
        
            {"format", (getter)PyVkAttachmentDescription_getformat, NULL, "", NULL},
        
            {"samples", (getter)PyVkAttachmentDescription_getsamples, NULL, "", NULL},
        
            {"loadOp", (getter)PyVkAttachmentDescription_getloadOp, NULL, "", NULL},
        
            {"storeOp", (getter)PyVkAttachmentDescription_getstoreOp, NULL, "", NULL},
        
            {"stencilLoadOp", (getter)PyVkAttachmentDescription_getstencilLoadOp, NULL, "", NULL},
        
            {"stencilStoreOp", (getter)PyVkAttachmentDescription_getstencilStoreOp, NULL, "", NULL},
        
            {"initialLayout", (getter)PyVkAttachmentDescription_getinitialLayout, NULL, "", NULL},
        
            {"finalLayout", (getter)PyVkAttachmentDescription_getfinalLayout, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkAttachmentReference_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkAttachmentReference *self = (PyVkAttachmentReference *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkAttachmentReference));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkAttachmentReference");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkAttachmentReference_del(PyVkAttachmentReference* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkAttachmentReference_init(PyVkAttachmentReference *self, PyObject *args, PyObject *kwds) {
        
            uint32_t attachment;
VkImageLayout layout;

            static char *kwlist[] = {"attachment","layout",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_uint32_t_converter,&attachment,pyc_flag_base_VkImageLayout_converter,&layout))
        return -1;
    

            
            
                (self->base)->attachment = attachment;
            
            
            
                (self->base)->layout = layout;
            
            

            pyc_uint32_t_converter_free(&attachment);
pyc_flag_base_VkImageLayout_converter_free(&layout);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkAttachmentReference_getattachment(PyVkAttachmentReference *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->attachment));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkAttachmentReference_getlayout(PyVkAttachmentReference *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->layout));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkAttachmentReference_getsetters[] = {
        
            {"attachment", (getter)PyVkAttachmentReference_getattachment, NULL, "", NULL},
        
            {"layout", (getter)PyVkAttachmentReference_getlayout, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkSubpassDescription_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkSubpassDescription *self = (PyVkSubpassDescription *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkSubpassDescription));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkSubpassDescription");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkSubpassDescription_del(PyVkSubpassDescription* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkSubpassDescription_init(PyVkSubpassDescription *self, PyObject *args, PyObject *kwds) {
        
            VkSubpassDescriptionFlags flags;
VkPipelineBindPoint pipelineBindPoint;
uint32_t inputAttachmentCount;
VkAttachmentReference* pInputAttachments;
uint32_t colorAttachmentCount;
VkAttachmentReference* pColorAttachments;
VkAttachmentReference* pResolveAttachments;
VkAttachmentReference* pDepthStencilAttachment;
uint32_t preserveAttachmentCount;
uint32_t* pPreserveAttachments;

            static char *kwlist[] = {"flags","pipelineBindPoint","inputAttachmentCount","pInputAttachments","colorAttachmentCount","pColorAttachments","pResolveAttachments","pDepthStencilAttachment","preserveAttachmentCount","pPreserveAttachments",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkSubpassDescriptionFlags_converter,&flags,pyc_flag_base_VkPipelineBindPoint_converter,&pipelineBindPoint,pyc_uint32_t_converter,&inputAttachmentCount,pyc_struct_array_VkAttachmentReference_converter,&pInputAttachments,pyc_uint32_t_converter,&colorAttachmentCount,pyc_struct_array_VkAttachmentReference_converter,&pColorAttachments,pyc_struct_array_VkAttachmentReference_converter,&pResolveAttachments,pyc_struct_pointer_VkAttachmentReference_converter,&pDepthStencilAttachment,pyc_uint32_t_converter,&preserveAttachmentCount,pyc_array_uint32_t_converter,&pPreserveAttachments))
        return -1;
    

            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->pipelineBindPoint = pipelineBindPoint;
            
            
            
                (self->base)->inputAttachmentCount = inputAttachmentCount;
            
            
            
                (self->base)->pInputAttachments = pInputAttachments;
            
            
            
                (self->base)->colorAttachmentCount = colorAttachmentCount;
            
            
            
                (self->base)->pColorAttachments = pColorAttachments;
            
            
            
                (self->base)->pResolveAttachments = pResolveAttachments;
            
            
            
                (self->base)->pDepthStencilAttachment = pDepthStencilAttachment;
            
            
            
                (self->base)->preserveAttachmentCount = preserveAttachmentCount;
            
            
            
                (self->base)->pPreserveAttachments = pPreserveAttachments;
            
            

            pyc_flag_base_VkSubpassDescriptionFlags_converter_free(&flags);
pyc_flag_base_VkPipelineBindPoint_converter_free(&pipelineBindPoint);
pyc_uint32_t_converter_free(&inputAttachmentCount);
pyc_struct_array_VkAttachmentReference_converter_free(&pInputAttachments);
pyc_uint32_t_converter_free(&colorAttachmentCount);
pyc_struct_array_VkAttachmentReference_converter_free(&pColorAttachments);
pyc_struct_array_VkAttachmentReference_converter_free(&pResolveAttachments);
pyc_struct_pointer_VkAttachmentReference_converter_free(&pDepthStencilAttachment);
pyc_uint32_t_converter_free(&preserveAttachmentCount);
pyc_array_uint32_t_converter_free(&pPreserveAttachments);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkSubpassDescription_getflags(PyVkSubpassDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubpassDescription_getpipelineBindPoint(PyVkSubpassDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->pipelineBindPoint));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubpassDescription_getinputAttachmentCount(PyVkSubpassDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->inputAttachmentCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubpassDescription_getpInputAttachments(PyVkSubpassDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkAttachmentReferenceType);
            if (!pyvalue)
                return NULL;
            ((PyVkAttachmentReference*) pyvalue)->base = ((self->base)->pInputAttachments);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubpassDescription_getcolorAttachmentCount(PyVkSubpassDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->colorAttachmentCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubpassDescription_getpColorAttachments(PyVkSubpassDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkAttachmentReferenceType);
            if (!pyvalue)
                return NULL;
            ((PyVkAttachmentReference*) pyvalue)->base = ((self->base)->pColorAttachments);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubpassDescription_getpResolveAttachments(PyVkSubpassDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkAttachmentReferenceType);
            if (!pyvalue)
                return NULL;
            ((PyVkAttachmentReference*) pyvalue)->base = ((self->base)->pResolveAttachments);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubpassDescription_getpDepthStencilAttachment(PyVkSubpassDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkAttachmentReferenceType);
            if (!pyvalue)
                return NULL;
            ((PyVkAttachmentReference*) pyvalue)->base = ((self->base)->pDepthStencilAttachment);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubpassDescription_getpreserveAttachmentCount(PyVkSubpassDescription *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->preserveAttachmentCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubpassDescription_getpPreserveAttachments(PyVkSubpassDescription *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyLong_FromLong((long) (*(((self->base)->pPreserveAttachments))));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkSubpassDescription_getsetters[] = {
        
            {"flags", (getter)PyVkSubpassDescription_getflags, NULL, "", NULL},
        
            {"pipelineBindPoint", (getter)PyVkSubpassDescription_getpipelineBindPoint, NULL, "", NULL},
        
            {"inputAttachmentCount", (getter)PyVkSubpassDescription_getinputAttachmentCount, NULL, "", NULL},
        
            {"pInputAttachments", (getter)PyVkSubpassDescription_getpInputAttachments, NULL, "", NULL},
        
            {"colorAttachmentCount", (getter)PyVkSubpassDescription_getcolorAttachmentCount, NULL, "", NULL},
        
            {"pColorAttachments", (getter)PyVkSubpassDescription_getpColorAttachments, NULL, "", NULL},
        
            {"pResolveAttachments", (getter)PyVkSubpassDescription_getpResolveAttachments, NULL, "", NULL},
        
            {"pDepthStencilAttachment", (getter)PyVkSubpassDescription_getpDepthStencilAttachment, NULL, "", NULL},
        
            {"preserveAttachmentCount", (getter)PyVkSubpassDescription_getpreserveAttachmentCount, NULL, "", NULL},
        
            {"pPreserveAttachments", (getter)PyVkSubpassDescription_getpPreserveAttachments, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkSubpassDependency_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkSubpassDependency *self = (PyVkSubpassDependency *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkSubpassDependency));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkSubpassDependency");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkSubpassDependency_del(PyVkSubpassDependency* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkSubpassDependency_init(PyVkSubpassDependency *self, PyObject *args, PyObject *kwds) {
        
            uint32_t srcSubpass;
uint32_t dstSubpass;
VkPipelineStageFlags srcStageMask;
VkPipelineStageFlags dstStageMask;
VkAccessFlags srcAccessMask;
VkAccessFlags dstAccessMask;
VkDependencyFlags dependencyFlags;

            static char *kwlist[] = {"srcSubpass","dstSubpass","srcStageMask","dstStageMask","srcAccessMask","dstAccessMask","dependencyFlags",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&", kwlist, pyc_uint32_t_converter,&srcSubpass,pyc_uint32_t_converter,&dstSubpass,pyc_flag_base_VkPipelineStageFlags_converter,&srcStageMask,pyc_flag_base_VkPipelineStageFlags_converter,&dstStageMask,pyc_flag_base_VkAccessFlags_converter,&srcAccessMask,pyc_flag_base_VkAccessFlags_converter,&dstAccessMask,pyc_flag_base_VkDependencyFlags_converter,&dependencyFlags))
        return -1;
    

            
            
                (self->base)->srcSubpass = srcSubpass;
            
            
            
                (self->base)->dstSubpass = dstSubpass;
            
            
            
                (self->base)->srcStageMask = srcStageMask;
            
            
            
                (self->base)->dstStageMask = dstStageMask;
            
            
            
                (self->base)->srcAccessMask = srcAccessMask;
            
            
            
                (self->base)->dstAccessMask = dstAccessMask;
            
            
            
                (self->base)->dependencyFlags = dependencyFlags;
            
            

            pyc_uint32_t_converter_free(&srcSubpass);
pyc_uint32_t_converter_free(&dstSubpass);
pyc_flag_base_VkPipelineStageFlags_converter_free(&srcStageMask);
pyc_flag_base_VkPipelineStageFlags_converter_free(&dstStageMask);
pyc_flag_base_VkAccessFlags_converter_free(&srcAccessMask);
pyc_flag_base_VkAccessFlags_converter_free(&dstAccessMask);
pyc_flag_base_VkDependencyFlags_converter_free(&dependencyFlags);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkSubpassDependency_getsrcSubpass(PyVkSubpassDependency *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->srcSubpass));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubpassDependency_getdstSubpass(PyVkSubpassDependency *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->dstSubpass));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubpassDependency_getsrcStageMask(PyVkSubpassDependency *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->srcStageMask));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubpassDependency_getdstStageMask(PyVkSubpassDependency *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->dstStageMask));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubpassDependency_getsrcAccessMask(PyVkSubpassDependency *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->srcAccessMask));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubpassDependency_getdstAccessMask(PyVkSubpassDependency *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->dstAccessMask));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubpassDependency_getdependencyFlags(PyVkSubpassDependency *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->dependencyFlags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkSubpassDependency_getsetters[] = {
        
            {"srcSubpass", (getter)PyVkSubpassDependency_getsrcSubpass, NULL, "", NULL},
        
            {"dstSubpass", (getter)PyVkSubpassDependency_getdstSubpass, NULL, "", NULL},
        
            {"srcStageMask", (getter)PyVkSubpassDependency_getsrcStageMask, NULL, "", NULL},
        
            {"dstStageMask", (getter)PyVkSubpassDependency_getdstStageMask, NULL, "", NULL},
        
            {"srcAccessMask", (getter)PyVkSubpassDependency_getsrcAccessMask, NULL, "", NULL},
        
            {"dstAccessMask", (getter)PyVkSubpassDependency_getdstAccessMask, NULL, "", NULL},
        
            {"dependencyFlags", (getter)PyVkSubpassDependency_getdependencyFlags, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkRenderPassCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkRenderPassCreateInfo *self = (PyVkRenderPassCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkRenderPassCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkRenderPassCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkRenderPassCreateInfo_del(PyVkRenderPassCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkRenderPassCreateInfo_init(PyVkRenderPassCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkRenderPassCreateFlags flags;
uint32_t attachmentCount;
VkAttachmentDescription* pAttachments;
uint32_t subpassCount;
VkSubpassDescription* pSubpasses;
uint32_t dependencyCount;
VkSubpassDependency* pDependencies;

            static char *kwlist[] = {"sType","flags","attachmentCount","pAttachments","subpassCount","pSubpasses","dependencyCount","pDependencies",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkRenderPassCreateFlags_converter,&flags,pyc_uint32_t_converter,&attachmentCount,pyc_struct_array_VkAttachmentDescription_converter,&pAttachments,pyc_uint32_t_converter,&subpassCount,pyc_struct_array_VkSubpassDescription_converter,&pSubpasses,pyc_uint32_t_converter,&dependencyCount,pyc_struct_array_VkSubpassDependency_converter,&pDependencies))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->attachmentCount = attachmentCount;
            
            
            
                (self->base)->pAttachments = pAttachments;
            
            
            
                (self->base)->subpassCount = subpassCount;
            
            
            
                (self->base)->pSubpasses = pSubpasses;
            
            
            
                (self->base)->dependencyCount = dependencyCount;
            
            
            
                (self->base)->pDependencies = pDependencies;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkRenderPassCreateFlags_converter_free(&flags);
pyc_uint32_t_converter_free(&attachmentCount);
pyc_struct_array_VkAttachmentDescription_converter_free(&pAttachments);
pyc_uint32_t_converter_free(&subpassCount);
pyc_struct_array_VkSubpassDescription_converter_free(&pSubpasses);
pyc_uint32_t_converter_free(&dependencyCount);
pyc_struct_array_VkSubpassDependency_converter_free(&pDependencies);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkRenderPassCreateInfo_getsType(PyVkRenderPassCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkRenderPassCreateInfo_getpNext(PyVkRenderPassCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkRenderPassCreateInfo_getflags(PyVkRenderPassCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkRenderPassCreateInfo_getattachmentCount(PyVkRenderPassCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->attachmentCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkRenderPassCreateInfo_getpAttachments(PyVkRenderPassCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkAttachmentDescriptionType);
            if (!pyvalue)
                return NULL;
            ((PyVkAttachmentDescription*) pyvalue)->base = ((self->base)->pAttachments);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkRenderPassCreateInfo_getsubpassCount(PyVkRenderPassCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->subpassCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkRenderPassCreateInfo_getpSubpasses(PyVkRenderPassCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkSubpassDescriptionType);
            if (!pyvalue)
                return NULL;
            ((PyVkSubpassDescription*) pyvalue)->base = ((self->base)->pSubpasses);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkRenderPassCreateInfo_getdependencyCount(PyVkRenderPassCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->dependencyCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkRenderPassCreateInfo_getpDependencies(PyVkRenderPassCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkSubpassDependencyType);
            if (!pyvalue)
                return NULL;
            ((PyVkSubpassDependency*) pyvalue)->base = ((self->base)->pDependencies);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkRenderPassCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkRenderPassCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkRenderPassCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkRenderPassCreateInfo_getflags, NULL, "", NULL},
        
            {"attachmentCount", (getter)PyVkRenderPassCreateInfo_getattachmentCount, NULL, "", NULL},
        
            {"pAttachments", (getter)PyVkRenderPassCreateInfo_getpAttachments, NULL, "", NULL},
        
            {"subpassCount", (getter)PyVkRenderPassCreateInfo_getsubpassCount, NULL, "", NULL},
        
            {"pSubpasses", (getter)PyVkRenderPassCreateInfo_getpSubpasses, NULL, "", NULL},
        
            {"dependencyCount", (getter)PyVkRenderPassCreateInfo_getdependencyCount, NULL, "", NULL},
        
            {"pDependencies", (getter)PyVkRenderPassCreateInfo_getpDependencies, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkEventCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkEventCreateInfo *self = (PyVkEventCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkEventCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkEventCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkEventCreateInfo_del(PyVkEventCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkEventCreateInfo_init(PyVkEventCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkEventCreateFlags flags;

            static char *kwlist[] = {"sType","flags",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkEventCreateFlags_converter,&flags))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkEventCreateFlags_converter_free(&flags);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkEventCreateInfo_getsType(PyVkEventCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkEventCreateInfo_getpNext(PyVkEventCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkEventCreateInfo_getflags(PyVkEventCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkEventCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkEventCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkEventCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkEventCreateInfo_getflags, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkFenceCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkFenceCreateInfo *self = (PyVkFenceCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkFenceCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkFenceCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkFenceCreateInfo_del(PyVkFenceCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkFenceCreateInfo_init(PyVkFenceCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkFenceCreateFlags flags;

            static char *kwlist[] = {"sType","flags",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkFenceCreateFlags_converter,&flags))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkFenceCreateFlags_converter_free(&flags);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkFenceCreateInfo_getsType(PyVkFenceCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkFenceCreateInfo_getpNext(PyVkFenceCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkFenceCreateInfo_getflags(PyVkFenceCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkFenceCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkFenceCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkFenceCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkFenceCreateInfo_getflags, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPhysicalDeviceFeatures_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPhysicalDeviceFeatures *self = (PyVkPhysicalDeviceFeatures *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPhysicalDeviceFeatures));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPhysicalDeviceFeatures");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPhysicalDeviceFeatures_del(PyVkPhysicalDeviceFeatures* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPhysicalDeviceFeatures_init(PyVkPhysicalDeviceFeatures *self, PyObject *args, PyObject *kwds) {
        
            VkBool32 robustBufferAccess;
VkBool32 fullDrawIndexUint32;
VkBool32 imageCubeArray;
VkBool32 independentBlend;
VkBool32 geometryShader;
VkBool32 tessellationShader;
VkBool32 sampleRateShading;
VkBool32 dualSrcBlend;
VkBool32 logicOp;
VkBool32 multiDrawIndirect;
VkBool32 drawIndirectFirstInstance;
VkBool32 depthClamp;
VkBool32 depthBiasClamp;
VkBool32 fillModeNonSolid;
VkBool32 depthBounds;
VkBool32 wideLines;
VkBool32 largePoints;
VkBool32 alphaToOne;
VkBool32 multiViewport;
VkBool32 samplerAnisotropy;
VkBool32 textureCompressionETC2;
VkBool32 textureCompressionASTC_LDR;
VkBool32 textureCompressionBC;
VkBool32 occlusionQueryPrecise;
VkBool32 pipelineStatisticsQuery;
VkBool32 vertexPipelineStoresAndAtomics;
VkBool32 fragmentStoresAndAtomics;
VkBool32 shaderTessellationAndGeometryPointSize;
VkBool32 shaderImageGatherExtended;
VkBool32 shaderStorageImageExtendedFormats;
VkBool32 shaderStorageImageMultisample;
VkBool32 shaderStorageImageReadWithoutFormat;
VkBool32 shaderStorageImageWriteWithoutFormat;
VkBool32 shaderUniformBufferArrayDynamicIndexing;
VkBool32 shaderSampledImageArrayDynamicIndexing;
VkBool32 shaderStorageBufferArrayDynamicIndexing;
VkBool32 shaderStorageImageArrayDynamicIndexing;
VkBool32 shaderClipDistance;
VkBool32 shaderCullDistance;
VkBool32 shaderFloat64;
VkBool32 shaderInt64;
VkBool32 shaderInt16;
VkBool32 shaderResourceResidency;
VkBool32 shaderResourceMinLod;
VkBool32 sparseBinding;
VkBool32 sparseResidencyBuffer;
VkBool32 sparseResidencyImage2D;
VkBool32 sparseResidencyImage3D;
VkBool32 sparseResidency2Samples;
VkBool32 sparseResidency4Samples;
VkBool32 sparseResidency8Samples;
VkBool32 sparseResidency16Samples;
VkBool32 sparseResidencyAliased;
VkBool32 variableMultisampleRate;
VkBool32 inheritedQueries;

            static char *kwlist[] = {"robustBufferAccess","fullDrawIndexUint32","imageCubeArray","independentBlend","geometryShader","tessellationShader","sampleRateShading","dualSrcBlend","logicOp","multiDrawIndirect","drawIndirectFirstInstance","depthClamp","depthBiasClamp","fillModeNonSolid","depthBounds","wideLines","largePoints","alphaToOne","multiViewport","samplerAnisotropy","textureCompressionETC2","textureCompressionASTC_LDR","textureCompressionBC","occlusionQueryPrecise","pipelineStatisticsQuery","vertexPipelineStoresAndAtomics","fragmentStoresAndAtomics","shaderTessellationAndGeometryPointSize","shaderImageGatherExtended","shaderStorageImageExtendedFormats","shaderStorageImageMultisample","shaderStorageImageReadWithoutFormat","shaderStorageImageWriteWithoutFormat","shaderUniformBufferArrayDynamicIndexing","shaderSampledImageArrayDynamicIndexing","shaderStorageBufferArrayDynamicIndexing","shaderStorageImageArrayDynamicIndexing","shaderClipDistance","shaderCullDistance","shaderFloat64","shaderInt64","shaderInt16","shaderResourceResidency","shaderResourceMinLod","sparseBinding","sparseResidencyBuffer","sparseResidencyImage2D","sparseResidencyImage3D","sparseResidency2Samples","sparseResidency4Samples","sparseResidency8Samples","sparseResidency16Samples","sparseResidencyAliased","variableMultisampleRate","inheritedQueries",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkBool32_converter,&robustBufferAccess,pyc_flag_base_VkBool32_converter,&fullDrawIndexUint32,pyc_flag_base_VkBool32_converter,&imageCubeArray,pyc_flag_base_VkBool32_converter,&independentBlend,pyc_flag_base_VkBool32_converter,&geometryShader,pyc_flag_base_VkBool32_converter,&tessellationShader,pyc_flag_base_VkBool32_converter,&sampleRateShading,pyc_flag_base_VkBool32_converter,&dualSrcBlend,pyc_flag_base_VkBool32_converter,&logicOp,pyc_flag_base_VkBool32_converter,&multiDrawIndirect,pyc_flag_base_VkBool32_converter,&drawIndirectFirstInstance,pyc_flag_base_VkBool32_converter,&depthClamp,pyc_flag_base_VkBool32_converter,&depthBiasClamp,pyc_flag_base_VkBool32_converter,&fillModeNonSolid,pyc_flag_base_VkBool32_converter,&depthBounds,pyc_flag_base_VkBool32_converter,&wideLines,pyc_flag_base_VkBool32_converter,&largePoints,pyc_flag_base_VkBool32_converter,&alphaToOne,pyc_flag_base_VkBool32_converter,&multiViewport,pyc_flag_base_VkBool32_converter,&samplerAnisotropy,pyc_flag_base_VkBool32_converter,&textureCompressionETC2,pyc_flag_base_VkBool32_converter,&textureCompressionASTC_LDR,pyc_flag_base_VkBool32_converter,&textureCompressionBC,pyc_flag_base_VkBool32_converter,&occlusionQueryPrecise,pyc_flag_base_VkBool32_converter,&pipelineStatisticsQuery,pyc_flag_base_VkBool32_converter,&vertexPipelineStoresAndAtomics,pyc_flag_base_VkBool32_converter,&fragmentStoresAndAtomics,pyc_flag_base_VkBool32_converter,&shaderTessellationAndGeometryPointSize,pyc_flag_base_VkBool32_converter,&shaderImageGatherExtended,pyc_flag_base_VkBool32_converter,&shaderStorageImageExtendedFormats,pyc_flag_base_VkBool32_converter,&shaderStorageImageMultisample,pyc_flag_base_VkBool32_converter,&shaderStorageImageReadWithoutFormat,pyc_flag_base_VkBool32_converter,&shaderStorageImageWriteWithoutFormat,pyc_flag_base_VkBool32_converter,&shaderUniformBufferArrayDynamicIndexing,pyc_flag_base_VkBool32_converter,&shaderSampledImageArrayDynamicIndexing,pyc_flag_base_VkBool32_converter,&shaderStorageBufferArrayDynamicIndexing,pyc_flag_base_VkBool32_converter,&shaderStorageImageArrayDynamicIndexing,pyc_flag_base_VkBool32_converter,&shaderClipDistance,pyc_flag_base_VkBool32_converter,&shaderCullDistance,pyc_flag_base_VkBool32_converter,&shaderFloat64,pyc_flag_base_VkBool32_converter,&shaderInt64,pyc_flag_base_VkBool32_converter,&shaderInt16,pyc_flag_base_VkBool32_converter,&shaderResourceResidency,pyc_flag_base_VkBool32_converter,&shaderResourceMinLod,pyc_flag_base_VkBool32_converter,&sparseBinding,pyc_flag_base_VkBool32_converter,&sparseResidencyBuffer,pyc_flag_base_VkBool32_converter,&sparseResidencyImage2D,pyc_flag_base_VkBool32_converter,&sparseResidencyImage3D,pyc_flag_base_VkBool32_converter,&sparseResidency2Samples,pyc_flag_base_VkBool32_converter,&sparseResidency4Samples,pyc_flag_base_VkBool32_converter,&sparseResidency8Samples,pyc_flag_base_VkBool32_converter,&sparseResidency16Samples,pyc_flag_base_VkBool32_converter,&sparseResidencyAliased,pyc_flag_base_VkBool32_converter,&variableMultisampleRate,pyc_flag_base_VkBool32_converter,&inheritedQueries))
        return -1;
    

            
            
                (self->base)->robustBufferAccess = robustBufferAccess;
            
            
            
                (self->base)->fullDrawIndexUint32 = fullDrawIndexUint32;
            
            
            
                (self->base)->imageCubeArray = imageCubeArray;
            
            
            
                (self->base)->independentBlend = independentBlend;
            
            
            
                (self->base)->geometryShader = geometryShader;
            
            
            
                (self->base)->tessellationShader = tessellationShader;
            
            
            
                (self->base)->sampleRateShading = sampleRateShading;
            
            
            
                (self->base)->dualSrcBlend = dualSrcBlend;
            
            
            
                (self->base)->logicOp = logicOp;
            
            
            
                (self->base)->multiDrawIndirect = multiDrawIndirect;
            
            
            
                (self->base)->drawIndirectFirstInstance = drawIndirectFirstInstance;
            
            
            
                (self->base)->depthClamp = depthClamp;
            
            
            
                (self->base)->depthBiasClamp = depthBiasClamp;
            
            
            
                (self->base)->fillModeNonSolid = fillModeNonSolid;
            
            
            
                (self->base)->depthBounds = depthBounds;
            
            
            
                (self->base)->wideLines = wideLines;
            
            
            
                (self->base)->largePoints = largePoints;
            
            
            
                (self->base)->alphaToOne = alphaToOne;
            
            
            
                (self->base)->multiViewport = multiViewport;
            
            
            
                (self->base)->samplerAnisotropy = samplerAnisotropy;
            
            
            
                (self->base)->textureCompressionETC2 = textureCompressionETC2;
            
            
            
                (self->base)->textureCompressionASTC_LDR = textureCompressionASTC_LDR;
            
            
            
                (self->base)->textureCompressionBC = textureCompressionBC;
            
            
            
                (self->base)->occlusionQueryPrecise = occlusionQueryPrecise;
            
            
            
                (self->base)->pipelineStatisticsQuery = pipelineStatisticsQuery;
            
            
            
                (self->base)->vertexPipelineStoresAndAtomics = vertexPipelineStoresAndAtomics;
            
            
            
                (self->base)->fragmentStoresAndAtomics = fragmentStoresAndAtomics;
            
            
            
                (self->base)->shaderTessellationAndGeometryPointSize = shaderTessellationAndGeometryPointSize;
            
            
            
                (self->base)->shaderImageGatherExtended = shaderImageGatherExtended;
            
            
            
                (self->base)->shaderStorageImageExtendedFormats = shaderStorageImageExtendedFormats;
            
            
            
                (self->base)->shaderStorageImageMultisample = shaderStorageImageMultisample;
            
            
            
                (self->base)->shaderStorageImageReadWithoutFormat = shaderStorageImageReadWithoutFormat;
            
            
            
                (self->base)->shaderStorageImageWriteWithoutFormat = shaderStorageImageWriteWithoutFormat;
            
            
            
                (self->base)->shaderUniformBufferArrayDynamicIndexing = shaderUniformBufferArrayDynamicIndexing;
            
            
            
                (self->base)->shaderSampledImageArrayDynamicIndexing = shaderSampledImageArrayDynamicIndexing;
            
            
            
                (self->base)->shaderStorageBufferArrayDynamicIndexing = shaderStorageBufferArrayDynamicIndexing;
            
            
            
                (self->base)->shaderStorageImageArrayDynamicIndexing = shaderStorageImageArrayDynamicIndexing;
            
            
            
                (self->base)->shaderClipDistance = shaderClipDistance;
            
            
            
                (self->base)->shaderCullDistance = shaderCullDistance;
            
            
            
                (self->base)->shaderFloat64 = shaderFloat64;
            
            
            
                (self->base)->shaderInt64 = shaderInt64;
            
            
            
                (self->base)->shaderInt16 = shaderInt16;
            
            
            
                (self->base)->shaderResourceResidency = shaderResourceResidency;
            
            
            
                (self->base)->shaderResourceMinLod = shaderResourceMinLod;
            
            
            
                (self->base)->sparseBinding = sparseBinding;
            
            
            
                (self->base)->sparseResidencyBuffer = sparseResidencyBuffer;
            
            
            
                (self->base)->sparseResidencyImage2D = sparseResidencyImage2D;
            
            
            
                (self->base)->sparseResidencyImage3D = sparseResidencyImage3D;
            
            
            
                (self->base)->sparseResidency2Samples = sparseResidency2Samples;
            
            
            
                (self->base)->sparseResidency4Samples = sparseResidency4Samples;
            
            
            
                (self->base)->sparseResidency8Samples = sparseResidency8Samples;
            
            
            
                (self->base)->sparseResidency16Samples = sparseResidency16Samples;
            
            
            
                (self->base)->sparseResidencyAliased = sparseResidencyAliased;
            
            
            
                (self->base)->variableMultisampleRate = variableMultisampleRate;
            
            
            
                (self->base)->inheritedQueries = inheritedQueries;
            
            

            pyc_flag_base_VkBool32_converter_free(&robustBufferAccess);
pyc_flag_base_VkBool32_converter_free(&fullDrawIndexUint32);
pyc_flag_base_VkBool32_converter_free(&imageCubeArray);
pyc_flag_base_VkBool32_converter_free(&independentBlend);
pyc_flag_base_VkBool32_converter_free(&geometryShader);
pyc_flag_base_VkBool32_converter_free(&tessellationShader);
pyc_flag_base_VkBool32_converter_free(&sampleRateShading);
pyc_flag_base_VkBool32_converter_free(&dualSrcBlend);
pyc_flag_base_VkBool32_converter_free(&logicOp);
pyc_flag_base_VkBool32_converter_free(&multiDrawIndirect);
pyc_flag_base_VkBool32_converter_free(&drawIndirectFirstInstance);
pyc_flag_base_VkBool32_converter_free(&depthClamp);
pyc_flag_base_VkBool32_converter_free(&depthBiasClamp);
pyc_flag_base_VkBool32_converter_free(&fillModeNonSolid);
pyc_flag_base_VkBool32_converter_free(&depthBounds);
pyc_flag_base_VkBool32_converter_free(&wideLines);
pyc_flag_base_VkBool32_converter_free(&largePoints);
pyc_flag_base_VkBool32_converter_free(&alphaToOne);
pyc_flag_base_VkBool32_converter_free(&multiViewport);
pyc_flag_base_VkBool32_converter_free(&samplerAnisotropy);
pyc_flag_base_VkBool32_converter_free(&textureCompressionETC2);
pyc_flag_base_VkBool32_converter_free(&textureCompressionASTC_LDR);
pyc_flag_base_VkBool32_converter_free(&textureCompressionBC);
pyc_flag_base_VkBool32_converter_free(&occlusionQueryPrecise);
pyc_flag_base_VkBool32_converter_free(&pipelineStatisticsQuery);
pyc_flag_base_VkBool32_converter_free(&vertexPipelineStoresAndAtomics);
pyc_flag_base_VkBool32_converter_free(&fragmentStoresAndAtomics);
pyc_flag_base_VkBool32_converter_free(&shaderTessellationAndGeometryPointSize);
pyc_flag_base_VkBool32_converter_free(&shaderImageGatherExtended);
pyc_flag_base_VkBool32_converter_free(&shaderStorageImageExtendedFormats);
pyc_flag_base_VkBool32_converter_free(&shaderStorageImageMultisample);
pyc_flag_base_VkBool32_converter_free(&shaderStorageImageReadWithoutFormat);
pyc_flag_base_VkBool32_converter_free(&shaderStorageImageWriteWithoutFormat);
pyc_flag_base_VkBool32_converter_free(&shaderUniformBufferArrayDynamicIndexing);
pyc_flag_base_VkBool32_converter_free(&shaderSampledImageArrayDynamicIndexing);
pyc_flag_base_VkBool32_converter_free(&shaderStorageBufferArrayDynamicIndexing);
pyc_flag_base_VkBool32_converter_free(&shaderStorageImageArrayDynamicIndexing);
pyc_flag_base_VkBool32_converter_free(&shaderClipDistance);
pyc_flag_base_VkBool32_converter_free(&shaderCullDistance);
pyc_flag_base_VkBool32_converter_free(&shaderFloat64);
pyc_flag_base_VkBool32_converter_free(&shaderInt64);
pyc_flag_base_VkBool32_converter_free(&shaderInt16);
pyc_flag_base_VkBool32_converter_free(&shaderResourceResidency);
pyc_flag_base_VkBool32_converter_free(&shaderResourceMinLod);
pyc_flag_base_VkBool32_converter_free(&sparseBinding);
pyc_flag_base_VkBool32_converter_free(&sparseResidencyBuffer);
pyc_flag_base_VkBool32_converter_free(&sparseResidencyImage2D);
pyc_flag_base_VkBool32_converter_free(&sparseResidencyImage3D);
pyc_flag_base_VkBool32_converter_free(&sparseResidency2Samples);
pyc_flag_base_VkBool32_converter_free(&sparseResidency4Samples);
pyc_flag_base_VkBool32_converter_free(&sparseResidency8Samples);
pyc_flag_base_VkBool32_converter_free(&sparseResidency16Samples);
pyc_flag_base_VkBool32_converter_free(&sparseResidencyAliased);
pyc_flag_base_VkBool32_converter_free(&variableMultisampleRate);
pyc_flag_base_VkBool32_converter_free(&inheritedQueries);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPhysicalDeviceFeatures_getrobustBufferAccess(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->robustBufferAccess));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getfullDrawIndexUint32(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->fullDrawIndexUint32));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getimageCubeArray(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->imageCubeArray));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getindependentBlend(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->independentBlend));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getgeometryShader(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->geometryShader));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_gettessellationShader(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->tessellationShader));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getsampleRateShading(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sampleRateShading));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getdualSrcBlend(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->dualSrcBlend));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getlogicOp(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->logicOp));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getmultiDrawIndirect(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->multiDrawIndirect));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getdrawIndirectFirstInstance(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->drawIndirectFirstInstance));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getdepthClamp(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->depthClamp));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getdepthBiasClamp(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->depthBiasClamp));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getfillModeNonSolid(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->fillModeNonSolid));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getdepthBounds(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->depthBounds));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getwideLines(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->wideLines));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getlargePoints(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->largePoints));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getalphaToOne(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->alphaToOne));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getmultiViewport(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->multiViewport));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getsamplerAnisotropy(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->samplerAnisotropy));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_gettextureCompressionETC2(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->textureCompressionETC2));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_gettextureCompressionASTC_LDR(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->textureCompressionASTC_LDR));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_gettextureCompressionBC(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->textureCompressionBC));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getocclusionQueryPrecise(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->occlusionQueryPrecise));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getpipelineStatisticsQuery(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->pipelineStatisticsQuery));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getvertexPipelineStoresAndAtomics(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->vertexPipelineStoresAndAtomics));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getfragmentStoresAndAtomics(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->fragmentStoresAndAtomics));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getshaderTessellationAndGeometryPointSize(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->shaderTessellationAndGeometryPointSize));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getshaderImageGatherExtended(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->shaderImageGatherExtended));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getshaderStorageImageExtendedFormats(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->shaderStorageImageExtendedFormats));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getshaderStorageImageMultisample(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->shaderStorageImageMultisample));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getshaderStorageImageReadWithoutFormat(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->shaderStorageImageReadWithoutFormat));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getshaderStorageImageWriteWithoutFormat(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->shaderStorageImageWriteWithoutFormat));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getshaderUniformBufferArrayDynamicIndexing(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->shaderUniformBufferArrayDynamicIndexing));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getshaderSampledImageArrayDynamicIndexing(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->shaderSampledImageArrayDynamicIndexing));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getshaderStorageBufferArrayDynamicIndexing(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->shaderStorageBufferArrayDynamicIndexing));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getshaderStorageImageArrayDynamicIndexing(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->shaderStorageImageArrayDynamicIndexing));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getshaderClipDistance(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->shaderClipDistance));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getshaderCullDistance(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->shaderCullDistance));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getshaderFloat64(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->shaderFloat64));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getshaderInt64(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->shaderInt64));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getshaderInt16(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->shaderInt16));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getshaderResourceResidency(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->shaderResourceResidency));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getshaderResourceMinLod(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->shaderResourceMinLod));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getsparseBinding(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sparseBinding));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getsparseResidencyBuffer(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sparseResidencyBuffer));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getsparseResidencyImage2D(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sparseResidencyImage2D));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getsparseResidencyImage3D(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sparseResidencyImage3D));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getsparseResidency2Samples(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sparseResidency2Samples));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getsparseResidency4Samples(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sparseResidency4Samples));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getsparseResidency8Samples(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sparseResidency8Samples));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getsparseResidency16Samples(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sparseResidency16Samples));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getsparseResidencyAliased(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sparseResidencyAliased));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getvariableMultisampleRate(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->variableMultisampleRate));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceFeatures_getinheritedQueries(PyVkPhysicalDeviceFeatures *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->inheritedQueries));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPhysicalDeviceFeatures_getsetters[] = {
        
            {"robustBufferAccess", (getter)PyVkPhysicalDeviceFeatures_getrobustBufferAccess, NULL, "", NULL},
        
            {"fullDrawIndexUint32", (getter)PyVkPhysicalDeviceFeatures_getfullDrawIndexUint32, NULL, "", NULL},
        
            {"imageCubeArray", (getter)PyVkPhysicalDeviceFeatures_getimageCubeArray, NULL, "", NULL},
        
            {"independentBlend", (getter)PyVkPhysicalDeviceFeatures_getindependentBlend, NULL, "", NULL},
        
            {"geometryShader", (getter)PyVkPhysicalDeviceFeatures_getgeometryShader, NULL, "", NULL},
        
            {"tessellationShader", (getter)PyVkPhysicalDeviceFeatures_gettessellationShader, NULL, "", NULL},
        
            {"sampleRateShading", (getter)PyVkPhysicalDeviceFeatures_getsampleRateShading, NULL, "", NULL},
        
            {"dualSrcBlend", (getter)PyVkPhysicalDeviceFeatures_getdualSrcBlend, NULL, "", NULL},
        
            {"logicOp", (getter)PyVkPhysicalDeviceFeatures_getlogicOp, NULL, "", NULL},
        
            {"multiDrawIndirect", (getter)PyVkPhysicalDeviceFeatures_getmultiDrawIndirect, NULL, "", NULL},
        
            {"drawIndirectFirstInstance", (getter)PyVkPhysicalDeviceFeatures_getdrawIndirectFirstInstance, NULL, "", NULL},
        
            {"depthClamp", (getter)PyVkPhysicalDeviceFeatures_getdepthClamp, NULL, "", NULL},
        
            {"depthBiasClamp", (getter)PyVkPhysicalDeviceFeatures_getdepthBiasClamp, NULL, "", NULL},
        
            {"fillModeNonSolid", (getter)PyVkPhysicalDeviceFeatures_getfillModeNonSolid, NULL, "", NULL},
        
            {"depthBounds", (getter)PyVkPhysicalDeviceFeatures_getdepthBounds, NULL, "", NULL},
        
            {"wideLines", (getter)PyVkPhysicalDeviceFeatures_getwideLines, NULL, "", NULL},
        
            {"largePoints", (getter)PyVkPhysicalDeviceFeatures_getlargePoints, NULL, "", NULL},
        
            {"alphaToOne", (getter)PyVkPhysicalDeviceFeatures_getalphaToOne, NULL, "", NULL},
        
            {"multiViewport", (getter)PyVkPhysicalDeviceFeatures_getmultiViewport, NULL, "", NULL},
        
            {"samplerAnisotropy", (getter)PyVkPhysicalDeviceFeatures_getsamplerAnisotropy, NULL, "", NULL},
        
            {"textureCompressionETC2", (getter)PyVkPhysicalDeviceFeatures_gettextureCompressionETC2, NULL, "", NULL},
        
            {"textureCompressionASTC_LDR", (getter)PyVkPhysicalDeviceFeatures_gettextureCompressionASTC_LDR, NULL, "", NULL},
        
            {"textureCompressionBC", (getter)PyVkPhysicalDeviceFeatures_gettextureCompressionBC, NULL, "", NULL},
        
            {"occlusionQueryPrecise", (getter)PyVkPhysicalDeviceFeatures_getocclusionQueryPrecise, NULL, "", NULL},
        
            {"pipelineStatisticsQuery", (getter)PyVkPhysicalDeviceFeatures_getpipelineStatisticsQuery, NULL, "", NULL},
        
            {"vertexPipelineStoresAndAtomics", (getter)PyVkPhysicalDeviceFeatures_getvertexPipelineStoresAndAtomics, NULL, "", NULL},
        
            {"fragmentStoresAndAtomics", (getter)PyVkPhysicalDeviceFeatures_getfragmentStoresAndAtomics, NULL, "", NULL},
        
            {"shaderTessellationAndGeometryPointSize", (getter)PyVkPhysicalDeviceFeatures_getshaderTessellationAndGeometryPointSize, NULL, "", NULL},
        
            {"shaderImageGatherExtended", (getter)PyVkPhysicalDeviceFeatures_getshaderImageGatherExtended, NULL, "", NULL},
        
            {"shaderStorageImageExtendedFormats", (getter)PyVkPhysicalDeviceFeatures_getshaderStorageImageExtendedFormats, NULL, "", NULL},
        
            {"shaderStorageImageMultisample", (getter)PyVkPhysicalDeviceFeatures_getshaderStorageImageMultisample, NULL, "", NULL},
        
            {"shaderStorageImageReadWithoutFormat", (getter)PyVkPhysicalDeviceFeatures_getshaderStorageImageReadWithoutFormat, NULL, "", NULL},
        
            {"shaderStorageImageWriteWithoutFormat", (getter)PyVkPhysicalDeviceFeatures_getshaderStorageImageWriteWithoutFormat, NULL, "", NULL},
        
            {"shaderUniformBufferArrayDynamicIndexing", (getter)PyVkPhysicalDeviceFeatures_getshaderUniformBufferArrayDynamicIndexing, NULL, "", NULL},
        
            {"shaderSampledImageArrayDynamicIndexing", (getter)PyVkPhysicalDeviceFeatures_getshaderSampledImageArrayDynamicIndexing, NULL, "", NULL},
        
            {"shaderStorageBufferArrayDynamicIndexing", (getter)PyVkPhysicalDeviceFeatures_getshaderStorageBufferArrayDynamicIndexing, NULL, "", NULL},
        
            {"shaderStorageImageArrayDynamicIndexing", (getter)PyVkPhysicalDeviceFeatures_getshaderStorageImageArrayDynamicIndexing, NULL, "", NULL},
        
            {"shaderClipDistance", (getter)PyVkPhysicalDeviceFeatures_getshaderClipDistance, NULL, "", NULL},
        
            {"shaderCullDistance", (getter)PyVkPhysicalDeviceFeatures_getshaderCullDistance, NULL, "", NULL},
        
            {"shaderFloat64", (getter)PyVkPhysicalDeviceFeatures_getshaderFloat64, NULL, "", NULL},
        
            {"shaderInt64", (getter)PyVkPhysicalDeviceFeatures_getshaderInt64, NULL, "", NULL},
        
            {"shaderInt16", (getter)PyVkPhysicalDeviceFeatures_getshaderInt16, NULL, "", NULL},
        
            {"shaderResourceResidency", (getter)PyVkPhysicalDeviceFeatures_getshaderResourceResidency, NULL, "", NULL},
        
            {"shaderResourceMinLod", (getter)PyVkPhysicalDeviceFeatures_getshaderResourceMinLod, NULL, "", NULL},
        
            {"sparseBinding", (getter)PyVkPhysicalDeviceFeatures_getsparseBinding, NULL, "", NULL},
        
            {"sparseResidencyBuffer", (getter)PyVkPhysicalDeviceFeatures_getsparseResidencyBuffer, NULL, "", NULL},
        
            {"sparseResidencyImage2D", (getter)PyVkPhysicalDeviceFeatures_getsparseResidencyImage2D, NULL, "", NULL},
        
            {"sparseResidencyImage3D", (getter)PyVkPhysicalDeviceFeatures_getsparseResidencyImage3D, NULL, "", NULL},
        
            {"sparseResidency2Samples", (getter)PyVkPhysicalDeviceFeatures_getsparseResidency2Samples, NULL, "", NULL},
        
            {"sparseResidency4Samples", (getter)PyVkPhysicalDeviceFeatures_getsparseResidency4Samples, NULL, "", NULL},
        
            {"sparseResidency8Samples", (getter)PyVkPhysicalDeviceFeatures_getsparseResidency8Samples, NULL, "", NULL},
        
            {"sparseResidency16Samples", (getter)PyVkPhysicalDeviceFeatures_getsparseResidency16Samples, NULL, "", NULL},
        
            {"sparseResidencyAliased", (getter)PyVkPhysicalDeviceFeatures_getsparseResidencyAliased, NULL, "", NULL},
        
            {"variableMultisampleRate", (getter)PyVkPhysicalDeviceFeatures_getvariableMultisampleRate, NULL, "", NULL},
        
            {"inheritedQueries", (getter)PyVkPhysicalDeviceFeatures_getinheritedQueries, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPhysicalDeviceSparseProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPhysicalDeviceSparseProperties *self = (PyVkPhysicalDeviceSparseProperties *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPhysicalDeviceSparseProperties));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPhysicalDeviceSparseProperties");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPhysicalDeviceSparseProperties_del(PyVkPhysicalDeviceSparseProperties* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPhysicalDeviceSparseProperties_init(PyVkPhysicalDeviceSparseProperties *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPhysicalDeviceSparseProperties_getresidencyStandard2DBlockShape(PyVkPhysicalDeviceSparseProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->residencyStandard2DBlockShape));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceSparseProperties_getresidencyStandard2DMultisampleBlockShape(PyVkPhysicalDeviceSparseProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->residencyStandard2DMultisampleBlockShape));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceSparseProperties_getresidencyStandard3DBlockShape(PyVkPhysicalDeviceSparseProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->residencyStandard3DBlockShape));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceSparseProperties_getresidencyAlignedMipSize(PyVkPhysicalDeviceSparseProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->residencyAlignedMipSize));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceSparseProperties_getresidencyNonResidentStrict(PyVkPhysicalDeviceSparseProperties *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->residencyNonResidentStrict));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPhysicalDeviceSparseProperties_getsetters[] = {
        
            {"residencyStandard2DBlockShape", (getter)PyVkPhysicalDeviceSparseProperties_getresidencyStandard2DBlockShape, NULL, "", NULL},
        
            {"residencyStandard2DMultisampleBlockShape", (getter)PyVkPhysicalDeviceSparseProperties_getresidencyStandard2DMultisampleBlockShape, NULL, "", NULL},
        
            {"residencyStandard3DBlockShape", (getter)PyVkPhysicalDeviceSparseProperties_getresidencyStandard3DBlockShape, NULL, "", NULL},
        
            {"residencyAlignedMipSize", (getter)PyVkPhysicalDeviceSparseProperties_getresidencyAlignedMipSize, NULL, "", NULL},
        
            {"residencyNonResidentStrict", (getter)PyVkPhysicalDeviceSparseProperties_getresidencyNonResidentStrict, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPhysicalDeviceLimits_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPhysicalDeviceLimits *self = (PyVkPhysicalDeviceLimits *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPhysicalDeviceLimits));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPhysicalDeviceLimits");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPhysicalDeviceLimits_del(PyVkPhysicalDeviceLimits* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPhysicalDeviceLimits_init(PyVkPhysicalDeviceLimits *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxImageDimension1D(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxImageDimension1D));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxImageDimension2D(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxImageDimension2D));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxImageDimension3D(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxImageDimension3D));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxImageDimensionCube(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxImageDimensionCube));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxImageArrayLayers(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxImageArrayLayers));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxTexelBufferElements(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxTexelBufferElements));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxUniformBufferRange(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxUniformBufferRange));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxStorageBufferRange(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxStorageBufferRange));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxPushConstantsSize(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxPushConstantsSize));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxMemoryAllocationCount(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxMemoryAllocationCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxSamplerAllocationCount(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxSamplerAllocationCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getbufferImageGranularity(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->bufferImageGranularity));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getsparseAddressSpaceSize(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sparseAddressSpaceSize));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxBoundDescriptorSets(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxBoundDescriptorSets));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorSamplers(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxPerStageDescriptorSamplers));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorUniformBuffers(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxPerStageDescriptorUniformBuffers));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorStorageBuffers(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxPerStageDescriptorStorageBuffers));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorSampledImages(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxPerStageDescriptorSampledImages));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorStorageImages(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxPerStageDescriptorStorageImages));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorInputAttachments(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxPerStageDescriptorInputAttachments));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxPerStageResources(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxPerStageResources));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxDescriptorSetSamplers(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxDescriptorSetSamplers));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxDescriptorSetUniformBuffers(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxDescriptorSetUniformBuffers));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxDescriptorSetUniformBuffersDynamic(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxDescriptorSetUniformBuffersDynamic));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageBuffers(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxDescriptorSetStorageBuffers));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageBuffersDynamic(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxDescriptorSetStorageBuffersDynamic));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxDescriptorSetSampledImages(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxDescriptorSetSampledImages));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageImages(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxDescriptorSetStorageImages));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxDescriptorSetInputAttachments(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxDescriptorSetInputAttachments));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxVertexInputAttributes(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxVertexInputAttributes));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxVertexInputBindings(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxVertexInputBindings));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxVertexInputAttributeOffset(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxVertexInputAttributeOffset));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxVertexInputBindingStride(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxVertexInputBindingStride));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxVertexOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxVertexOutputComponents));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxTessellationGenerationLevel(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxTessellationGenerationLevel));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxTessellationPatchSize(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxTessellationPatchSize));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxTessellationControlPerVertexInputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxTessellationControlPerVertexInputComponents));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxTessellationControlPerVertexOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxTessellationControlPerVertexOutputComponents));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxTessellationControlPerPatchOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxTessellationControlPerPatchOutputComponents));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxTessellationControlTotalOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxTessellationControlTotalOutputComponents));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxTessellationEvaluationInputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxTessellationEvaluationInputComponents));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxTessellationEvaluationOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxTessellationEvaluationOutputComponents));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxGeometryShaderInvocations(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxGeometryShaderInvocations));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxGeometryInputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxGeometryInputComponents));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxGeometryOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxGeometryOutputComponents));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxGeometryOutputVertices(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxGeometryOutputVertices));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxGeometryTotalOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxGeometryTotalOutputComponents));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxFragmentInputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxFragmentInputComponents));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxFragmentOutputAttachments(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxFragmentOutputAttachments));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxFragmentDualSrcAttachments(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxFragmentDualSrcAttachments));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxFragmentCombinedOutputResources(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxFragmentCombinedOutputResources));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxComputeSharedMemorySize(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxComputeSharedMemorySize));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupCount(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyList_New(0);
        int nb = sizeof(((self->base)->maxComputeWorkGroupCount)) / sizeof(((self->base)->maxComputeWorkGroupCount)[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* tmp = PyLong_FromLong((long) ((self->base)->maxComputeWorkGroupCount)[i]);
            PyList_Append(pyvalue, tmp);
        }
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupInvocations(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxComputeWorkGroupInvocations));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupSize(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyList_New(0);
        int nb = sizeof(((self->base)->maxComputeWorkGroupSize)) / sizeof(((self->base)->maxComputeWorkGroupSize)[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* tmp = PyLong_FromLong((long) ((self->base)->maxComputeWorkGroupSize)[i]);
            PyList_Append(pyvalue, tmp);
        }
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getsubPixelPrecisionBits(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->subPixelPrecisionBits));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getsubTexelPrecisionBits(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->subTexelPrecisionBits));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmipmapPrecisionBits(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->mipmapPrecisionBits));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxDrawIndexedIndexValue(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxDrawIndexedIndexValue));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxDrawIndirectCount(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxDrawIndirectCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxSamplerLodBias(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->maxSamplerLodBias));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxSamplerAnisotropy(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->maxSamplerAnisotropy));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxViewports(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxViewports));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxViewportDimensions(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyList_New(0);
        int nb = sizeof(((self->base)->maxViewportDimensions)) / sizeof(((self->base)->maxViewportDimensions)[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* tmp = PyLong_FromLong((long) ((self->base)->maxViewportDimensions)[i]);
            PyList_Append(pyvalue, tmp);
        }
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getviewportBoundsRange(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyList_New(0);
        int nb = sizeof(((self->base)->viewportBoundsRange)) / sizeof(((self->base)->viewportBoundsRange)[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* tmp = PyFloat_FromDouble((double) ((self->base)->viewportBoundsRange)[i]);
            PyList_Append(pyvalue, tmp);
        }
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getviewportSubPixelBits(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->viewportSubPixelBits));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getminMemoryMapAlignment(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->minMemoryMapAlignment));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getminTexelBufferOffsetAlignment(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->minTexelBufferOffsetAlignment));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getminUniformBufferOffsetAlignment(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->minUniformBufferOffsetAlignment));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getminStorageBufferOffsetAlignment(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->minStorageBufferOffsetAlignment));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getminTexelOffset(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->minTexelOffset));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxTexelOffset(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxTexelOffset));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getminTexelGatherOffset(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->minTexelGatherOffset));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxTexelGatherOffset(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxTexelGatherOffset));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getminInterpolationOffset(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->minInterpolationOffset));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxInterpolationOffset(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->maxInterpolationOffset));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getsubPixelInterpolationOffsetBits(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->subPixelInterpolationOffsetBits));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxFramebufferWidth(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxFramebufferWidth));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxFramebufferHeight(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxFramebufferHeight));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxFramebufferLayers(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxFramebufferLayers));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getframebufferColorSampleCounts(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->framebufferColorSampleCounts));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getframebufferDepthSampleCounts(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->framebufferDepthSampleCounts));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getframebufferStencilSampleCounts(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->framebufferStencilSampleCounts));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getframebufferNoAttachmentsSampleCounts(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->framebufferNoAttachmentsSampleCounts));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxColorAttachments(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxColorAttachments));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getsampledImageColorSampleCounts(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sampledImageColorSampleCounts));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getsampledImageIntegerSampleCounts(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sampledImageIntegerSampleCounts));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getsampledImageDepthSampleCounts(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sampledImageDepthSampleCounts));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getsampledImageStencilSampleCounts(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sampledImageStencilSampleCounts));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getstorageImageSampleCounts(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->storageImageSampleCounts));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxSampleMaskWords(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxSampleMaskWords));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_gettimestampComputeAndGraphics(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->timestampComputeAndGraphics));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_gettimestampPeriod(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->timestampPeriod));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxClipDistances(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxClipDistances));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxCullDistances(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxCullDistances));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getmaxCombinedClipAndCullDistances(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxCombinedClipAndCullDistances));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getdiscreteQueuePriorities(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->discreteQueuePriorities));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getpointSizeRange(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyList_New(0);
        int nb = sizeof(((self->base)->pointSizeRange)) / sizeof(((self->base)->pointSizeRange)[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* tmp = PyFloat_FromDouble((double) ((self->base)->pointSizeRange)[i]);
            PyList_Append(pyvalue, tmp);
        }
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getlineWidthRange(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyList_New(0);
        int nb = sizeof(((self->base)->lineWidthRange)) / sizeof(((self->base)->lineWidthRange)[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* tmp = PyFloat_FromDouble((double) ((self->base)->lineWidthRange)[i]);
            PyList_Append(pyvalue, tmp);
        }
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getpointSizeGranularity(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->pointSizeGranularity));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getlineWidthGranularity(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->lineWidthGranularity));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getstrictLines(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->strictLines));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getstandardSampleLocations(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->standardSampleLocations));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getoptimalBufferCopyOffsetAlignment(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->optimalBufferCopyOffsetAlignment));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getoptimalBufferCopyRowPitchAlignment(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->optimalBufferCopyRowPitchAlignment));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPhysicalDeviceLimits_getnonCoherentAtomSize(PyVkPhysicalDeviceLimits *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->nonCoherentAtomSize));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPhysicalDeviceLimits_getsetters[] = {
        
            {"maxImageDimension1D", (getter)PyVkPhysicalDeviceLimits_getmaxImageDimension1D, NULL, "", NULL},
        
            {"maxImageDimension2D", (getter)PyVkPhysicalDeviceLimits_getmaxImageDimension2D, NULL, "", NULL},
        
            {"maxImageDimension3D", (getter)PyVkPhysicalDeviceLimits_getmaxImageDimension3D, NULL, "", NULL},
        
            {"maxImageDimensionCube", (getter)PyVkPhysicalDeviceLimits_getmaxImageDimensionCube, NULL, "", NULL},
        
            {"maxImageArrayLayers", (getter)PyVkPhysicalDeviceLimits_getmaxImageArrayLayers, NULL, "", NULL},
        
            {"maxTexelBufferElements", (getter)PyVkPhysicalDeviceLimits_getmaxTexelBufferElements, NULL, "", NULL},
        
            {"maxUniformBufferRange", (getter)PyVkPhysicalDeviceLimits_getmaxUniformBufferRange, NULL, "", NULL},
        
            {"maxStorageBufferRange", (getter)PyVkPhysicalDeviceLimits_getmaxStorageBufferRange, NULL, "", NULL},
        
            {"maxPushConstantsSize", (getter)PyVkPhysicalDeviceLimits_getmaxPushConstantsSize, NULL, "", NULL},
        
            {"maxMemoryAllocationCount", (getter)PyVkPhysicalDeviceLimits_getmaxMemoryAllocationCount, NULL, "", NULL},
        
            {"maxSamplerAllocationCount", (getter)PyVkPhysicalDeviceLimits_getmaxSamplerAllocationCount, NULL, "", NULL},
        
            {"bufferImageGranularity", (getter)PyVkPhysicalDeviceLimits_getbufferImageGranularity, NULL, "", NULL},
        
            {"sparseAddressSpaceSize", (getter)PyVkPhysicalDeviceLimits_getsparseAddressSpaceSize, NULL, "", NULL},
        
            {"maxBoundDescriptorSets", (getter)PyVkPhysicalDeviceLimits_getmaxBoundDescriptorSets, NULL, "", NULL},
        
            {"maxPerStageDescriptorSamplers", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorSamplers, NULL, "", NULL},
        
            {"maxPerStageDescriptorUniformBuffers", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorUniformBuffers, NULL, "", NULL},
        
            {"maxPerStageDescriptorStorageBuffers", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorStorageBuffers, NULL, "", NULL},
        
            {"maxPerStageDescriptorSampledImages", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorSampledImages, NULL, "", NULL},
        
            {"maxPerStageDescriptorStorageImages", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorStorageImages, NULL, "", NULL},
        
            {"maxPerStageDescriptorInputAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorInputAttachments, NULL, "", NULL},
        
            {"maxPerStageResources", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageResources, NULL, "", NULL},
        
            {"maxDescriptorSetSamplers", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetSamplers, NULL, "", NULL},
        
            {"maxDescriptorSetUniformBuffers", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetUniformBuffers, NULL, "", NULL},
        
            {"maxDescriptorSetUniformBuffersDynamic", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetUniformBuffersDynamic, NULL, "", NULL},
        
            {"maxDescriptorSetStorageBuffers", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageBuffers, NULL, "", NULL},
        
            {"maxDescriptorSetStorageBuffersDynamic", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageBuffersDynamic, NULL, "", NULL},
        
            {"maxDescriptorSetSampledImages", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetSampledImages, NULL, "", NULL},
        
            {"maxDescriptorSetStorageImages", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageImages, NULL, "", NULL},
        
            {"maxDescriptorSetInputAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetInputAttachments, NULL, "", NULL},
        
            {"maxVertexInputAttributes", (getter)PyVkPhysicalDeviceLimits_getmaxVertexInputAttributes, NULL, "", NULL},
        
            {"maxVertexInputBindings", (getter)PyVkPhysicalDeviceLimits_getmaxVertexInputBindings, NULL, "", NULL},
        
            {"maxVertexInputAttributeOffset", (getter)PyVkPhysicalDeviceLimits_getmaxVertexInputAttributeOffset, NULL, "", NULL},
        
            {"maxVertexInputBindingStride", (getter)PyVkPhysicalDeviceLimits_getmaxVertexInputBindingStride, NULL, "", NULL},
        
            {"maxVertexOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxVertexOutputComponents, NULL, "", NULL},
        
            {"maxTessellationGenerationLevel", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationGenerationLevel, NULL, "", NULL},
        
            {"maxTessellationPatchSize", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationPatchSize, NULL, "", NULL},
        
            {"maxTessellationControlPerVertexInputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationControlPerVertexInputComponents, NULL, "", NULL},
        
            {"maxTessellationControlPerVertexOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationControlPerVertexOutputComponents, NULL, "", NULL},
        
            {"maxTessellationControlPerPatchOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationControlPerPatchOutputComponents, NULL, "", NULL},
        
            {"maxTessellationControlTotalOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationControlTotalOutputComponents, NULL, "", NULL},
        
            {"maxTessellationEvaluationInputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationEvaluationInputComponents, NULL, "", NULL},
        
            {"maxTessellationEvaluationOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationEvaluationOutputComponents, NULL, "", NULL},
        
            {"maxGeometryShaderInvocations", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryShaderInvocations, NULL, "", NULL},
        
            {"maxGeometryInputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryInputComponents, NULL, "", NULL},
        
            {"maxGeometryOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryOutputComponents, NULL, "", NULL},
        
            {"maxGeometryOutputVertices", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryOutputVertices, NULL, "", NULL},
        
            {"maxGeometryTotalOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryTotalOutputComponents, NULL, "", NULL},
        
            {"maxFragmentInputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxFragmentInputComponents, NULL, "", NULL},
        
            {"maxFragmentOutputAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxFragmentOutputAttachments, NULL, "", NULL},
        
            {"maxFragmentDualSrcAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxFragmentDualSrcAttachments, NULL, "", NULL},
        
            {"maxFragmentCombinedOutputResources", (getter)PyVkPhysicalDeviceLimits_getmaxFragmentCombinedOutputResources, NULL, "", NULL},
        
            {"maxComputeSharedMemorySize", (getter)PyVkPhysicalDeviceLimits_getmaxComputeSharedMemorySize, NULL, "", NULL},
        
            {"maxComputeWorkGroupCount", (getter)PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupCount, NULL, "", NULL},
        
            {"maxComputeWorkGroupInvocations", (getter)PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupInvocations, NULL, "", NULL},
        
            {"maxComputeWorkGroupSize", (getter)PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupSize, NULL, "", NULL},
        
            {"subPixelPrecisionBits", (getter)PyVkPhysicalDeviceLimits_getsubPixelPrecisionBits, NULL, "", NULL},
        
            {"subTexelPrecisionBits", (getter)PyVkPhysicalDeviceLimits_getsubTexelPrecisionBits, NULL, "", NULL},
        
            {"mipmapPrecisionBits", (getter)PyVkPhysicalDeviceLimits_getmipmapPrecisionBits, NULL, "", NULL},
        
            {"maxDrawIndexedIndexValue", (getter)PyVkPhysicalDeviceLimits_getmaxDrawIndexedIndexValue, NULL, "", NULL},
        
            {"maxDrawIndirectCount", (getter)PyVkPhysicalDeviceLimits_getmaxDrawIndirectCount, NULL, "", NULL},
        
            {"maxSamplerLodBias", (getter)PyVkPhysicalDeviceLimits_getmaxSamplerLodBias, NULL, "", NULL},
        
            {"maxSamplerAnisotropy", (getter)PyVkPhysicalDeviceLimits_getmaxSamplerAnisotropy, NULL, "", NULL},
        
            {"maxViewports", (getter)PyVkPhysicalDeviceLimits_getmaxViewports, NULL, "", NULL},
        
            {"maxViewportDimensions", (getter)PyVkPhysicalDeviceLimits_getmaxViewportDimensions, NULL, "", NULL},
        
            {"viewportBoundsRange", (getter)PyVkPhysicalDeviceLimits_getviewportBoundsRange, NULL, "", NULL},
        
            {"viewportSubPixelBits", (getter)PyVkPhysicalDeviceLimits_getviewportSubPixelBits, NULL, "", NULL},
        
            {"minMemoryMapAlignment", (getter)PyVkPhysicalDeviceLimits_getminMemoryMapAlignment, NULL, "", NULL},
        
            {"minTexelBufferOffsetAlignment", (getter)PyVkPhysicalDeviceLimits_getminTexelBufferOffsetAlignment, NULL, "", NULL},
        
            {"minUniformBufferOffsetAlignment", (getter)PyVkPhysicalDeviceLimits_getminUniformBufferOffsetAlignment, NULL, "", NULL},
        
            {"minStorageBufferOffsetAlignment", (getter)PyVkPhysicalDeviceLimits_getminStorageBufferOffsetAlignment, NULL, "", NULL},
        
            {"minTexelOffset", (getter)PyVkPhysicalDeviceLimits_getminTexelOffset, NULL, "", NULL},
        
            {"maxTexelOffset", (getter)PyVkPhysicalDeviceLimits_getmaxTexelOffset, NULL, "", NULL},
        
            {"minTexelGatherOffset", (getter)PyVkPhysicalDeviceLimits_getminTexelGatherOffset, NULL, "", NULL},
        
            {"maxTexelGatherOffset", (getter)PyVkPhysicalDeviceLimits_getmaxTexelGatherOffset, NULL, "", NULL},
        
            {"minInterpolationOffset", (getter)PyVkPhysicalDeviceLimits_getminInterpolationOffset, NULL, "", NULL},
        
            {"maxInterpolationOffset", (getter)PyVkPhysicalDeviceLimits_getmaxInterpolationOffset, NULL, "", NULL},
        
            {"subPixelInterpolationOffsetBits", (getter)PyVkPhysicalDeviceLimits_getsubPixelInterpolationOffsetBits, NULL, "", NULL},
        
            {"maxFramebufferWidth", (getter)PyVkPhysicalDeviceLimits_getmaxFramebufferWidth, NULL, "", NULL},
        
            {"maxFramebufferHeight", (getter)PyVkPhysicalDeviceLimits_getmaxFramebufferHeight, NULL, "", NULL},
        
            {"maxFramebufferLayers", (getter)PyVkPhysicalDeviceLimits_getmaxFramebufferLayers, NULL, "", NULL},
        
            {"framebufferColorSampleCounts", (getter)PyVkPhysicalDeviceLimits_getframebufferColorSampleCounts, NULL, "", NULL},
        
            {"framebufferDepthSampleCounts", (getter)PyVkPhysicalDeviceLimits_getframebufferDepthSampleCounts, NULL, "", NULL},
        
            {"framebufferStencilSampleCounts", (getter)PyVkPhysicalDeviceLimits_getframebufferStencilSampleCounts, NULL, "", NULL},
        
            {"framebufferNoAttachmentsSampleCounts", (getter)PyVkPhysicalDeviceLimits_getframebufferNoAttachmentsSampleCounts, NULL, "", NULL},
        
            {"maxColorAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxColorAttachments, NULL, "", NULL},
        
            {"sampledImageColorSampleCounts", (getter)PyVkPhysicalDeviceLimits_getsampledImageColorSampleCounts, NULL, "", NULL},
        
            {"sampledImageIntegerSampleCounts", (getter)PyVkPhysicalDeviceLimits_getsampledImageIntegerSampleCounts, NULL, "", NULL},
        
            {"sampledImageDepthSampleCounts", (getter)PyVkPhysicalDeviceLimits_getsampledImageDepthSampleCounts, NULL, "", NULL},
        
            {"sampledImageStencilSampleCounts", (getter)PyVkPhysicalDeviceLimits_getsampledImageStencilSampleCounts, NULL, "", NULL},
        
            {"storageImageSampleCounts", (getter)PyVkPhysicalDeviceLimits_getstorageImageSampleCounts, NULL, "", NULL},
        
            {"maxSampleMaskWords", (getter)PyVkPhysicalDeviceLimits_getmaxSampleMaskWords, NULL, "", NULL},
        
            {"timestampComputeAndGraphics", (getter)PyVkPhysicalDeviceLimits_gettimestampComputeAndGraphics, NULL, "", NULL},
        
            {"timestampPeriod", (getter)PyVkPhysicalDeviceLimits_gettimestampPeriod, NULL, "", NULL},
        
            {"maxClipDistances", (getter)PyVkPhysicalDeviceLimits_getmaxClipDistances, NULL, "", NULL},
        
            {"maxCullDistances", (getter)PyVkPhysicalDeviceLimits_getmaxCullDistances, NULL, "", NULL},
        
            {"maxCombinedClipAndCullDistances", (getter)PyVkPhysicalDeviceLimits_getmaxCombinedClipAndCullDistances, NULL, "", NULL},
        
            {"discreteQueuePriorities", (getter)PyVkPhysicalDeviceLimits_getdiscreteQueuePriorities, NULL, "", NULL},
        
            {"pointSizeRange", (getter)PyVkPhysicalDeviceLimits_getpointSizeRange, NULL, "", NULL},
        
            {"lineWidthRange", (getter)PyVkPhysicalDeviceLimits_getlineWidthRange, NULL, "", NULL},
        
            {"pointSizeGranularity", (getter)PyVkPhysicalDeviceLimits_getpointSizeGranularity, NULL, "", NULL},
        
            {"lineWidthGranularity", (getter)PyVkPhysicalDeviceLimits_getlineWidthGranularity, NULL, "", NULL},
        
            {"strictLines", (getter)PyVkPhysicalDeviceLimits_getstrictLines, NULL, "", NULL},
        
            {"standardSampleLocations", (getter)PyVkPhysicalDeviceLimits_getstandardSampleLocations, NULL, "", NULL},
        
            {"optimalBufferCopyOffsetAlignment", (getter)PyVkPhysicalDeviceLimits_getoptimalBufferCopyOffsetAlignment, NULL, "", NULL},
        
            {"optimalBufferCopyRowPitchAlignment", (getter)PyVkPhysicalDeviceLimits_getoptimalBufferCopyRowPitchAlignment, NULL, "", NULL},
        
            {"nonCoherentAtomSize", (getter)PyVkPhysicalDeviceLimits_getnonCoherentAtomSize, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkSemaphoreCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkSemaphoreCreateInfo *self = (PyVkSemaphoreCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkSemaphoreCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkSemaphoreCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkSemaphoreCreateInfo_del(PyVkSemaphoreCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkSemaphoreCreateInfo_init(PyVkSemaphoreCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkSemaphoreCreateFlags flags;

            static char *kwlist[] = {"sType","flags",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkSemaphoreCreateFlags_converter,&flags))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkSemaphoreCreateFlags_converter_free(&flags);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkSemaphoreCreateInfo_getsType(PyVkSemaphoreCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSemaphoreCreateInfo_getpNext(PyVkSemaphoreCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSemaphoreCreateInfo_getflags(PyVkSemaphoreCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkSemaphoreCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkSemaphoreCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkSemaphoreCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkSemaphoreCreateInfo_getflags, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkQueryPoolCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkQueryPoolCreateInfo *self = (PyVkQueryPoolCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkQueryPoolCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkQueryPoolCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkQueryPoolCreateInfo_del(PyVkQueryPoolCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkQueryPoolCreateInfo_init(PyVkQueryPoolCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkQueryPoolCreateFlags flags;
VkQueryType queryType;
uint32_t queryCount;
VkQueryPipelineStatisticFlags pipelineStatistics;

            static char *kwlist[] = {"sType","flags","queryType","queryCount","pipelineStatistics",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkQueryPoolCreateFlags_converter,&flags,pyc_flag_base_VkQueryType_converter,&queryType,pyc_uint32_t_converter,&queryCount,pyc_flag_base_VkQueryPipelineStatisticFlags_converter,&pipelineStatistics))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->queryType = queryType;
            
            
            
                (self->base)->queryCount = queryCount;
            
            
            
                (self->base)->pipelineStatistics = pipelineStatistics;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkQueryPoolCreateFlags_converter_free(&flags);
pyc_flag_base_VkQueryType_converter_free(&queryType);
pyc_uint32_t_converter_free(&queryCount);
pyc_flag_base_VkQueryPipelineStatisticFlags_converter_free(&pipelineStatistics);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkQueryPoolCreateInfo_getsType(PyVkQueryPoolCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkQueryPoolCreateInfo_getpNext(PyVkQueryPoolCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkQueryPoolCreateInfo_getflags(PyVkQueryPoolCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkQueryPoolCreateInfo_getqueryType(PyVkQueryPoolCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->queryType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkQueryPoolCreateInfo_getqueryCount(PyVkQueryPoolCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->queryCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkQueryPoolCreateInfo_getpipelineStatistics(PyVkQueryPoolCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->pipelineStatistics));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkQueryPoolCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkQueryPoolCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkQueryPoolCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkQueryPoolCreateInfo_getflags, NULL, "", NULL},
        
            {"queryType", (getter)PyVkQueryPoolCreateInfo_getqueryType, NULL, "", NULL},
        
            {"queryCount", (getter)PyVkQueryPoolCreateInfo_getqueryCount, NULL, "", NULL},
        
            {"pipelineStatistics", (getter)PyVkQueryPoolCreateInfo_getpipelineStatistics, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkFramebufferCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkFramebufferCreateInfo *self = (PyVkFramebufferCreateInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkFramebufferCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkFramebufferCreateInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkFramebufferCreateInfo_del(PyVkFramebufferCreateInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkFramebufferCreateInfo_init(PyVkFramebufferCreateInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkFramebufferCreateFlags flags;
VkRenderPass renderPass;
uint32_t attachmentCount;
VkImageView* pAttachments;
uint32_t width;
uint32_t height;
uint32_t layers;

            static char *kwlist[] = {"sType","flags","renderPass","attachmentCount","pAttachments","width","height","layers",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkFramebufferCreateFlags_converter,&flags,pyc_handle_base_VkRenderPass_converter,&renderPass,pyc_uint32_t_converter,&attachmentCount,pyc_handle_array_VkImageView_converter,&pAttachments,pyc_uint32_t_converter,&width,pyc_uint32_t_converter,&height,pyc_uint32_t_converter,&layers))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->renderPass = renderPass;
            
            
            
                (self->base)->attachmentCount = attachmentCount;
            
            
            
                (self->base)->pAttachments = pAttachments;
            
            
            
                (self->base)->width = width;
            
            
            
                (self->base)->height = height;
            
            
            
                (self->base)->layers = layers;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkFramebufferCreateFlags_converter_free(&flags);
pyc_handle_base_VkRenderPass_converter_free(&renderPass);
pyc_uint32_t_converter_free(&attachmentCount);
pyc_handle_array_VkImageView_converter_free(&pAttachments);
pyc_uint32_t_converter_free(&width);
pyc_uint32_t_converter_free(&height);
pyc_uint32_t_converter_free(&layers);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkFramebufferCreateInfo_getsType(PyVkFramebufferCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkFramebufferCreateInfo_getpNext(PyVkFramebufferCreateInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkFramebufferCreateInfo_getflags(PyVkFramebufferCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkFramebufferCreateInfo_getrenderPass(PyVkFramebufferCreateInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkFramebufferCreateInfo_getattachmentCount(PyVkFramebufferCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->attachmentCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkFramebufferCreateInfo_getpAttachments(PyVkFramebufferCreateInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkFramebufferCreateInfo_getwidth(PyVkFramebufferCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->width));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkFramebufferCreateInfo_getheight(PyVkFramebufferCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->height));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkFramebufferCreateInfo_getlayers(PyVkFramebufferCreateInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->layers));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkFramebufferCreateInfo_getsetters[] = {
        
            {"sType", (getter)PyVkFramebufferCreateInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkFramebufferCreateInfo_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkFramebufferCreateInfo_getflags, NULL, "", NULL},
        
            {"renderPass", (getter)PyVkFramebufferCreateInfo_getrenderPass, NULL, "", NULL},
        
            {"attachmentCount", (getter)PyVkFramebufferCreateInfo_getattachmentCount, NULL, "", NULL},
        
            {"pAttachments", (getter)PyVkFramebufferCreateInfo_getpAttachments, NULL, "", NULL},
        
            {"width", (getter)PyVkFramebufferCreateInfo_getwidth, NULL, "", NULL},
        
            {"height", (getter)PyVkFramebufferCreateInfo_getheight, NULL, "", NULL},
        
            {"layers", (getter)PyVkFramebufferCreateInfo_getlayers, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDrawIndirectCommand_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDrawIndirectCommand *self = (PyVkDrawIndirectCommand *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDrawIndirectCommand));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDrawIndirectCommand");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDrawIndirectCommand_del(PyVkDrawIndirectCommand* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDrawIndirectCommand_init(PyVkDrawIndirectCommand *self, PyObject *args, PyObject *kwds) {
        
            uint32_t vertexCount;
uint32_t instanceCount;
uint32_t firstVertex;
uint32_t firstInstance;

            static char *kwlist[] = {"vertexCount","instanceCount","firstVertex","firstInstance",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_uint32_t_converter,&vertexCount,pyc_uint32_t_converter,&instanceCount,pyc_uint32_t_converter,&firstVertex,pyc_uint32_t_converter,&firstInstance))
        return -1;
    

            
            
                (self->base)->vertexCount = vertexCount;
            
            
            
                (self->base)->instanceCount = instanceCount;
            
            
            
                (self->base)->firstVertex = firstVertex;
            
            
            
                (self->base)->firstInstance = firstInstance;
            
            

            pyc_uint32_t_converter_free(&vertexCount);
pyc_uint32_t_converter_free(&instanceCount);
pyc_uint32_t_converter_free(&firstVertex);
pyc_uint32_t_converter_free(&firstInstance);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDrawIndirectCommand_getvertexCount(PyVkDrawIndirectCommand *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->vertexCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDrawIndirectCommand_getinstanceCount(PyVkDrawIndirectCommand *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->instanceCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDrawIndirectCommand_getfirstVertex(PyVkDrawIndirectCommand *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->firstVertex));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDrawIndirectCommand_getfirstInstance(PyVkDrawIndirectCommand *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->firstInstance));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDrawIndirectCommand_getsetters[] = {
        
            {"vertexCount", (getter)PyVkDrawIndirectCommand_getvertexCount, NULL, "", NULL},
        
            {"instanceCount", (getter)PyVkDrawIndirectCommand_getinstanceCount, NULL, "", NULL},
        
            {"firstVertex", (getter)PyVkDrawIndirectCommand_getfirstVertex, NULL, "", NULL},
        
            {"firstInstance", (getter)PyVkDrawIndirectCommand_getfirstInstance, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDrawIndexedIndirectCommand_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDrawIndexedIndirectCommand *self = (PyVkDrawIndexedIndirectCommand *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDrawIndexedIndirectCommand));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDrawIndexedIndirectCommand");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDrawIndexedIndirectCommand_del(PyVkDrawIndexedIndirectCommand* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDrawIndexedIndirectCommand_init(PyVkDrawIndexedIndirectCommand *self, PyObject *args, PyObject *kwds) {
        
            uint32_t indexCount;
uint32_t instanceCount;
uint32_t firstIndex;
int32_t vertexOffset;
uint32_t firstInstance;

            static char *kwlist[] = {"indexCount","instanceCount","firstIndex","vertexOffset","firstInstance",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_uint32_t_converter,&indexCount,pyc_uint32_t_converter,&instanceCount,pyc_uint32_t_converter,&firstIndex,pyc_int32_t_converter,&vertexOffset,pyc_uint32_t_converter,&firstInstance))
        return -1;
    

            
            
                (self->base)->indexCount = indexCount;
            
            
            
                (self->base)->instanceCount = instanceCount;
            
            
            
                (self->base)->firstIndex = firstIndex;
            
            
            
                (self->base)->vertexOffset = vertexOffset;
            
            
            
                (self->base)->firstInstance = firstInstance;
            
            

            pyc_uint32_t_converter_free(&indexCount);
pyc_uint32_t_converter_free(&instanceCount);
pyc_uint32_t_converter_free(&firstIndex);
pyc_int32_t_converter_free(&vertexOffset);
pyc_uint32_t_converter_free(&firstInstance);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDrawIndexedIndirectCommand_getindexCount(PyVkDrawIndexedIndirectCommand *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->indexCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDrawIndexedIndirectCommand_getinstanceCount(PyVkDrawIndexedIndirectCommand *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->instanceCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDrawIndexedIndirectCommand_getfirstIndex(PyVkDrawIndexedIndirectCommand *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->firstIndex));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDrawIndexedIndirectCommand_getvertexOffset(PyVkDrawIndexedIndirectCommand *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->vertexOffset));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDrawIndexedIndirectCommand_getfirstInstance(PyVkDrawIndexedIndirectCommand *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->firstInstance));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDrawIndexedIndirectCommand_getsetters[] = {
        
            {"indexCount", (getter)PyVkDrawIndexedIndirectCommand_getindexCount, NULL, "", NULL},
        
            {"instanceCount", (getter)PyVkDrawIndexedIndirectCommand_getinstanceCount, NULL, "", NULL},
        
            {"firstIndex", (getter)PyVkDrawIndexedIndirectCommand_getfirstIndex, NULL, "", NULL},
        
            {"vertexOffset", (getter)PyVkDrawIndexedIndirectCommand_getvertexOffset, NULL, "", NULL},
        
            {"firstInstance", (getter)PyVkDrawIndexedIndirectCommand_getfirstInstance, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDispatchIndirectCommand_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDispatchIndirectCommand *self = (PyVkDispatchIndirectCommand *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDispatchIndirectCommand));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDispatchIndirectCommand");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDispatchIndirectCommand_del(PyVkDispatchIndirectCommand* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDispatchIndirectCommand_init(PyVkDispatchIndirectCommand *self, PyObject *args, PyObject *kwds) {
        
            uint32_t x;
uint32_t y;
uint32_t z;

            static char *kwlist[] = {"x","y","z",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_uint32_t_converter,&x,pyc_uint32_t_converter,&y,pyc_uint32_t_converter,&z))
        return -1;
    

            
            
                (self->base)->x = x;
            
            
            
                (self->base)->y = y;
            
            
            
                (self->base)->z = z;
            
            

            pyc_uint32_t_converter_free(&x);
pyc_uint32_t_converter_free(&y);
pyc_uint32_t_converter_free(&z);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDispatchIndirectCommand_getx(PyVkDispatchIndirectCommand *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->x));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDispatchIndirectCommand_gety(PyVkDispatchIndirectCommand *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->y));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDispatchIndirectCommand_getz(PyVkDispatchIndirectCommand *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->z));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDispatchIndirectCommand_getsetters[] = {
        
            {"x", (getter)PyVkDispatchIndirectCommand_getx, NULL, "", NULL},
        
            {"y", (getter)PyVkDispatchIndirectCommand_gety, NULL, "", NULL},
        
            {"z", (getter)PyVkDispatchIndirectCommand_getz, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkSubmitInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkSubmitInfo *self = (PyVkSubmitInfo *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkSubmitInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkSubmitInfo");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkSubmitInfo_del(PyVkSubmitInfo* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkSubmitInfo_init(PyVkSubmitInfo *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
uint32_t waitSemaphoreCount;
VkSemaphore* pWaitSemaphores;
VkPipelineStageFlags* pWaitDstStageMask;
uint32_t commandBufferCount;
VkCommandBuffer* pCommandBuffers;
uint32_t signalSemaphoreCount;
VkSemaphore* pSignalSemaphores;

            static char *kwlist[] = {"sType","waitSemaphoreCount","pWaitSemaphores","pWaitDstStageMask","commandBufferCount","pCommandBuffers","signalSemaphoreCount","pSignalSemaphores",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_uint32_t_converter,&waitSemaphoreCount,pyc_handle_array_VkSemaphore_converter,&pWaitSemaphores,pyc_flag_array_VkPipelineStageFlags_converter,&pWaitDstStageMask,pyc_uint32_t_converter,&commandBufferCount,pyc_handle_array_VkCommandBuffer_converter,&pCommandBuffers,pyc_uint32_t_converter,&signalSemaphoreCount,pyc_handle_array_VkSemaphore_converter,&pSignalSemaphores))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->waitSemaphoreCount = waitSemaphoreCount;
            
            
            
                (self->base)->pWaitSemaphores = pWaitSemaphores;
            
            
            
                (self->base)->pWaitDstStageMask = pWaitDstStageMask;
            
            
            
                (self->base)->commandBufferCount = commandBufferCount;
            
            
            
                (self->base)->pCommandBuffers = pCommandBuffers;
            
            
            
                (self->base)->signalSemaphoreCount = signalSemaphoreCount;
            
            
            
                (self->base)->pSignalSemaphores = pSignalSemaphores;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_uint32_t_converter_free(&waitSemaphoreCount);
pyc_handle_array_VkSemaphore_converter_free(&pWaitSemaphores);
pyc_flag_array_VkPipelineStageFlags_converter_free(&pWaitDstStageMask);
pyc_uint32_t_converter_free(&commandBufferCount);
pyc_handle_array_VkCommandBuffer_converter_free(&pCommandBuffers);
pyc_uint32_t_converter_free(&signalSemaphoreCount);
pyc_handle_array_VkSemaphore_converter_free(&pSignalSemaphores);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkSubmitInfo_getsType(PyVkSubmitInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubmitInfo_getpNext(PyVkSubmitInfo *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubmitInfo_getwaitSemaphoreCount(PyVkSubmitInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->waitSemaphoreCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubmitInfo_getpWaitSemaphores(PyVkSubmitInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkSubmitInfo_getpWaitDstStageMask(PyVkSubmitInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(*((self->base)->pWaitDstStageMask));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubmitInfo_getcommandBufferCount(PyVkSubmitInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->commandBufferCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubmitInfo_getpCommandBuffers(PyVkSubmitInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkSubmitInfo_getsignalSemaphoreCount(PyVkSubmitInfo *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->signalSemaphoreCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSubmitInfo_getpSignalSemaphores(PyVkSubmitInfo *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkSubmitInfo_getsetters[] = {
        
            {"sType", (getter)PyVkSubmitInfo_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkSubmitInfo_getpNext, NULL, "", NULL},
        
            {"waitSemaphoreCount", (getter)PyVkSubmitInfo_getwaitSemaphoreCount, NULL, "", NULL},
        
            {"pWaitSemaphores", (getter)PyVkSubmitInfo_getpWaitSemaphores, NULL, "", NULL},
        
            {"pWaitDstStageMask", (getter)PyVkSubmitInfo_getpWaitDstStageMask, NULL, "", NULL},
        
            {"commandBufferCount", (getter)PyVkSubmitInfo_getcommandBufferCount, NULL, "", NULL},
        
            {"pCommandBuffers", (getter)PyVkSubmitInfo_getpCommandBuffers, NULL, "", NULL},
        
            {"signalSemaphoreCount", (getter)PyVkSubmitInfo_getsignalSemaphoreCount, NULL, "", NULL},
        
            {"pSignalSemaphores", (getter)PyVkSubmitInfo_getpSignalSemaphores, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDisplayPropertiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDisplayPropertiesKHR *self = (PyVkDisplayPropertiesKHR *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDisplayPropertiesKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDisplayPropertiesKHR");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDisplayPropertiesKHR_del(PyVkDisplayPropertiesKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDisplayPropertiesKHR_init(PyVkDisplayPropertiesKHR *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDisplayPropertiesKHR_getdisplay(PyVkDisplayPropertiesKHR *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkDisplayPropertiesKHR_getdisplayName(PyVkDisplayPropertiesKHR *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyUnicode_FromString((const char *) ((self->base)->displayName));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayPropertiesKHR_getphysicalDimensions(PyVkDisplayPropertiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent2D*) pyvalue)->base = &((self->base)->physicalDimensions);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayPropertiesKHR_getphysicalResolution(PyVkDisplayPropertiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent2D*) pyvalue)->base = &((self->base)->physicalResolution);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayPropertiesKHR_getsupportedTransforms(PyVkDisplayPropertiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->supportedTransforms));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayPropertiesKHR_getplaneReorderPossible(PyVkDisplayPropertiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->planeReorderPossible));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayPropertiesKHR_getpersistentContent(PyVkDisplayPropertiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->persistentContent));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDisplayPropertiesKHR_getsetters[] = {
        
            {"display", (getter)PyVkDisplayPropertiesKHR_getdisplay, NULL, "", NULL},
        
            {"displayName", (getter)PyVkDisplayPropertiesKHR_getdisplayName, NULL, "", NULL},
        
            {"physicalDimensions", (getter)PyVkDisplayPropertiesKHR_getphysicalDimensions, NULL, "", NULL},
        
            {"physicalResolution", (getter)PyVkDisplayPropertiesKHR_getphysicalResolution, NULL, "", NULL},
        
            {"supportedTransforms", (getter)PyVkDisplayPropertiesKHR_getsupportedTransforms, NULL, "", NULL},
        
            {"planeReorderPossible", (getter)PyVkDisplayPropertiesKHR_getplaneReorderPossible, NULL, "", NULL},
        
            {"persistentContent", (getter)PyVkDisplayPropertiesKHR_getpersistentContent, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDisplayPlanePropertiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDisplayPlanePropertiesKHR *self = (PyVkDisplayPlanePropertiesKHR *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDisplayPlanePropertiesKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDisplayPlanePropertiesKHR");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDisplayPlanePropertiesKHR_del(PyVkDisplayPlanePropertiesKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDisplayPlanePropertiesKHR_init(PyVkDisplayPlanePropertiesKHR *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDisplayPlanePropertiesKHR_getcurrentDisplay(PyVkDisplayPlanePropertiesKHR *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkDisplayPlanePropertiesKHR_getcurrentStackIndex(PyVkDisplayPlanePropertiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->currentStackIndex));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDisplayPlanePropertiesKHR_getsetters[] = {
        
            {"currentDisplay", (getter)PyVkDisplayPlanePropertiesKHR_getcurrentDisplay, NULL, "", NULL},
        
            {"currentStackIndex", (getter)PyVkDisplayPlanePropertiesKHR_getcurrentStackIndex, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDisplayModeParametersKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDisplayModeParametersKHR *self = (PyVkDisplayModeParametersKHR *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDisplayModeParametersKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDisplayModeParametersKHR");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDisplayModeParametersKHR_del(PyVkDisplayModeParametersKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDisplayModeParametersKHR_init(PyVkDisplayModeParametersKHR *self, PyObject *args, PyObject *kwds) {
        
            VkExtent2D visibleRegion;
uint32_t refreshRate;

            static char *kwlist[] = {"visibleRegion","refreshRate",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_struct_base_VkExtent2D_converter,&visibleRegion,pyc_uint32_t_converter,&refreshRate))
        return -1;
    

            
            
                (self->base)->visibleRegion = visibleRegion;
            
            
            
                (self->base)->refreshRate = refreshRate;
            
            

            pyc_struct_base_VkExtent2D_converter_free(&visibleRegion);
pyc_uint32_t_converter_free(&refreshRate);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDisplayModeParametersKHR_getvisibleRegion(PyVkDisplayModeParametersKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent2D*) pyvalue)->base = &((self->base)->visibleRegion);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayModeParametersKHR_getrefreshRate(PyVkDisplayModeParametersKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->refreshRate));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDisplayModeParametersKHR_getsetters[] = {
        
            {"visibleRegion", (getter)PyVkDisplayModeParametersKHR_getvisibleRegion, NULL, "", NULL},
        
            {"refreshRate", (getter)PyVkDisplayModeParametersKHR_getrefreshRate, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDisplayModePropertiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDisplayModePropertiesKHR *self = (PyVkDisplayModePropertiesKHR *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDisplayModePropertiesKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDisplayModePropertiesKHR");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDisplayModePropertiesKHR_del(PyVkDisplayModePropertiesKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDisplayModePropertiesKHR_init(PyVkDisplayModePropertiesKHR *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDisplayModePropertiesKHR_getdisplayMode(PyVkDisplayModePropertiesKHR *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkDisplayModePropertiesKHR_getparameters(PyVkDisplayModePropertiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkDisplayModeParametersKHRType);
            if (!pyvalue)
                return NULL;
            ((PyVkDisplayModeParametersKHR*) pyvalue)->base = &((self->base)->parameters);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDisplayModePropertiesKHR_getsetters[] = {
        
            {"displayMode", (getter)PyVkDisplayModePropertiesKHR_getdisplayMode, NULL, "", NULL},
        
            {"parameters", (getter)PyVkDisplayModePropertiesKHR_getparameters, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDisplayModeCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDisplayModeCreateInfoKHR *self = (PyVkDisplayModeCreateInfoKHR *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDisplayModeCreateInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDisplayModeCreateInfoKHR");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDisplayModeCreateInfoKHR_del(PyVkDisplayModeCreateInfoKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDisplayModeCreateInfoKHR_init(PyVkDisplayModeCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkDisplayModeCreateFlagsKHR flags;
VkDisplayModeParametersKHR parameters;

            static char *kwlist[] = {"sType","flags","parameters",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkDisplayModeCreateFlagsKHR_converter,&flags,pyc_struct_base_VkDisplayModeParametersKHR_converter,&parameters))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->parameters = parameters;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkDisplayModeCreateFlagsKHR_converter_free(&flags);
pyc_struct_base_VkDisplayModeParametersKHR_converter_free(&parameters);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDisplayModeCreateInfoKHR_getsType(PyVkDisplayModeCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayModeCreateInfoKHR_getpNext(PyVkDisplayModeCreateInfoKHR *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayModeCreateInfoKHR_getflags(PyVkDisplayModeCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayModeCreateInfoKHR_getparameters(PyVkDisplayModeCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkDisplayModeParametersKHRType);
            if (!pyvalue)
                return NULL;
            ((PyVkDisplayModeParametersKHR*) pyvalue)->base = &((self->base)->parameters);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDisplayModeCreateInfoKHR_getsetters[] = {
        
            {"sType", (getter)PyVkDisplayModeCreateInfoKHR_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkDisplayModeCreateInfoKHR_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkDisplayModeCreateInfoKHR_getflags, NULL, "", NULL},
        
            {"parameters", (getter)PyVkDisplayModeCreateInfoKHR_getparameters, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDisplayPlaneCapabilitiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDisplayPlaneCapabilitiesKHR *self = (PyVkDisplayPlaneCapabilitiesKHR *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDisplayPlaneCapabilitiesKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDisplayPlaneCapabilitiesKHR");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDisplayPlaneCapabilitiesKHR_del(PyVkDisplayPlaneCapabilitiesKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDisplayPlaneCapabilitiesKHR_init(PyVkDisplayPlaneCapabilitiesKHR *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDisplayPlaneCapabilitiesKHR_getsupportedAlpha(PyVkDisplayPlaneCapabilitiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->supportedAlpha));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayPlaneCapabilitiesKHR_getminSrcPosition(PyVkDisplayPlaneCapabilitiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkOffset2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkOffset2D*) pyvalue)->base = &((self->base)->minSrcPosition);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayPlaneCapabilitiesKHR_getmaxSrcPosition(PyVkDisplayPlaneCapabilitiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkOffset2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkOffset2D*) pyvalue)->base = &((self->base)->maxSrcPosition);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayPlaneCapabilitiesKHR_getminSrcExtent(PyVkDisplayPlaneCapabilitiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent2D*) pyvalue)->base = &((self->base)->minSrcExtent);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayPlaneCapabilitiesKHR_getmaxSrcExtent(PyVkDisplayPlaneCapabilitiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent2D*) pyvalue)->base = &((self->base)->maxSrcExtent);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayPlaneCapabilitiesKHR_getminDstPosition(PyVkDisplayPlaneCapabilitiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkOffset2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkOffset2D*) pyvalue)->base = &((self->base)->minDstPosition);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayPlaneCapabilitiesKHR_getmaxDstPosition(PyVkDisplayPlaneCapabilitiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkOffset2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkOffset2D*) pyvalue)->base = &((self->base)->maxDstPosition);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayPlaneCapabilitiesKHR_getminDstExtent(PyVkDisplayPlaneCapabilitiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent2D*) pyvalue)->base = &((self->base)->minDstExtent);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayPlaneCapabilitiesKHR_getmaxDstExtent(PyVkDisplayPlaneCapabilitiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent2D*) pyvalue)->base = &((self->base)->maxDstExtent);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDisplayPlaneCapabilitiesKHR_getsetters[] = {
        
            {"supportedAlpha", (getter)PyVkDisplayPlaneCapabilitiesKHR_getsupportedAlpha, NULL, "", NULL},
        
            {"minSrcPosition", (getter)PyVkDisplayPlaneCapabilitiesKHR_getminSrcPosition, NULL, "", NULL},
        
            {"maxSrcPosition", (getter)PyVkDisplayPlaneCapabilitiesKHR_getmaxSrcPosition, NULL, "", NULL},
        
            {"minSrcExtent", (getter)PyVkDisplayPlaneCapabilitiesKHR_getminSrcExtent, NULL, "", NULL},
        
            {"maxSrcExtent", (getter)PyVkDisplayPlaneCapabilitiesKHR_getmaxSrcExtent, NULL, "", NULL},
        
            {"minDstPosition", (getter)PyVkDisplayPlaneCapabilitiesKHR_getminDstPosition, NULL, "", NULL},
        
            {"maxDstPosition", (getter)PyVkDisplayPlaneCapabilitiesKHR_getmaxDstPosition, NULL, "", NULL},
        
            {"minDstExtent", (getter)PyVkDisplayPlaneCapabilitiesKHR_getminDstExtent, NULL, "", NULL},
        
            {"maxDstExtent", (getter)PyVkDisplayPlaneCapabilitiesKHR_getmaxDstExtent, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDisplaySurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDisplaySurfaceCreateInfoKHR *self = (PyVkDisplaySurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDisplaySurfaceCreateInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDisplaySurfaceCreateInfoKHR");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDisplaySurfaceCreateInfoKHR_del(PyVkDisplaySurfaceCreateInfoKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDisplaySurfaceCreateInfoKHR_init(PyVkDisplaySurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkDisplaySurfaceCreateFlagsKHR flags;
VkDisplayModeKHR displayMode;
uint32_t planeIndex;
uint32_t planeStackIndex;
VkSurfaceTransformFlagBitsKHR transform;
float globalAlpha;
VkDisplayPlaneAlphaFlagBitsKHR alphaMode;
VkExtent2D imageExtent;

            static char *kwlist[] = {"sType","flags","displayMode","planeIndex","planeStackIndex","transform","globalAlpha","alphaMode","imageExtent",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkDisplaySurfaceCreateFlagsKHR_converter,&flags,pyc_handle_base_VkDisplayModeKHR_converter,&displayMode,pyc_uint32_t_converter,&planeIndex,pyc_uint32_t_converter,&planeStackIndex,pyc_flag_base_VkSurfaceTransformFlagBitsKHR_converter,&transform,pyc_float_converter,&globalAlpha,pyc_flag_base_VkDisplayPlaneAlphaFlagBitsKHR_converter,&alphaMode,pyc_struct_base_VkExtent2D_converter,&imageExtent))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->displayMode = displayMode;
            
            
            
                (self->base)->planeIndex = planeIndex;
            
            
            
                (self->base)->planeStackIndex = planeStackIndex;
            
            
            
                (self->base)->transform = transform;
            
            
            
                (self->base)->globalAlpha = globalAlpha;
            
            
            
                (self->base)->alphaMode = alphaMode;
            
            
            
                (self->base)->imageExtent = imageExtent;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkDisplaySurfaceCreateFlagsKHR_converter_free(&flags);
pyc_handle_base_VkDisplayModeKHR_converter_free(&displayMode);
pyc_uint32_t_converter_free(&planeIndex);
pyc_uint32_t_converter_free(&planeStackIndex);
pyc_flag_base_VkSurfaceTransformFlagBitsKHR_converter_free(&transform);
pyc_float_converter_free(&globalAlpha);
pyc_flag_base_VkDisplayPlaneAlphaFlagBitsKHR_converter_free(&alphaMode);
pyc_struct_base_VkExtent2D_converter_free(&imageExtent);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDisplaySurfaceCreateInfoKHR_getsType(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplaySurfaceCreateInfoKHR_getpNext(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplaySurfaceCreateInfoKHR_getflags(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplaySurfaceCreateInfoKHR_getdisplayMode(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkDisplaySurfaceCreateInfoKHR_getplaneIndex(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->planeIndex));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplaySurfaceCreateInfoKHR_getplaneStackIndex(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->planeStackIndex));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplaySurfaceCreateInfoKHR_gettransform(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->transform));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplaySurfaceCreateInfoKHR_getglobalAlpha(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyFloat_FromDouble((double) ((self->base)->globalAlpha));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplaySurfaceCreateInfoKHR_getalphaMode(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->alphaMode));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplaySurfaceCreateInfoKHR_getimageExtent(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent2D*) pyvalue)->base = &((self->base)->imageExtent);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDisplaySurfaceCreateInfoKHR_getsetters[] = {
        
            {"sType", (getter)PyVkDisplaySurfaceCreateInfoKHR_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkDisplaySurfaceCreateInfoKHR_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkDisplaySurfaceCreateInfoKHR_getflags, NULL, "", NULL},
        
            {"displayMode", (getter)PyVkDisplaySurfaceCreateInfoKHR_getdisplayMode, NULL, "", NULL},
        
            {"planeIndex", (getter)PyVkDisplaySurfaceCreateInfoKHR_getplaneIndex, NULL, "", NULL},
        
            {"planeStackIndex", (getter)PyVkDisplaySurfaceCreateInfoKHR_getplaneStackIndex, NULL, "", NULL},
        
            {"transform", (getter)PyVkDisplaySurfaceCreateInfoKHR_gettransform, NULL, "", NULL},
        
            {"globalAlpha", (getter)PyVkDisplaySurfaceCreateInfoKHR_getglobalAlpha, NULL, "", NULL},
        
            {"alphaMode", (getter)PyVkDisplaySurfaceCreateInfoKHR_getalphaMode, NULL, "", NULL},
        
            {"imageExtent", (getter)PyVkDisplaySurfaceCreateInfoKHR_getimageExtent, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDisplayPresentInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDisplayPresentInfoKHR *self = (PyVkDisplayPresentInfoKHR *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDisplayPresentInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDisplayPresentInfoKHR");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDisplayPresentInfoKHR_del(PyVkDisplayPresentInfoKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDisplayPresentInfoKHR_init(PyVkDisplayPresentInfoKHR *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkRect2D srcRect;
VkRect2D dstRect;
VkBool32 persistent;

            static char *kwlist[] = {"sType","srcRect","dstRect","persistent",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_struct_base_VkRect2D_converter,&srcRect,pyc_struct_base_VkRect2D_converter,&dstRect,pyc_flag_base_VkBool32_converter,&persistent))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->srcRect = srcRect;
            
            
            
                (self->base)->dstRect = dstRect;
            
            
            
                (self->base)->persistent = persistent;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_struct_base_VkRect2D_converter_free(&srcRect);
pyc_struct_base_VkRect2D_converter_free(&dstRect);
pyc_flag_base_VkBool32_converter_free(&persistent);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDisplayPresentInfoKHR_getsType(PyVkDisplayPresentInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayPresentInfoKHR_getpNext(PyVkDisplayPresentInfoKHR *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayPresentInfoKHR_getsrcRect(PyVkDisplayPresentInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkRect2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkRect2D*) pyvalue)->base = &((self->base)->srcRect);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayPresentInfoKHR_getdstRect(PyVkDisplayPresentInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkRect2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkRect2D*) pyvalue)->base = &((self->base)->dstRect);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDisplayPresentInfoKHR_getpersistent(PyVkDisplayPresentInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->persistent));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDisplayPresentInfoKHR_getsetters[] = {
        
            {"sType", (getter)PyVkDisplayPresentInfoKHR_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkDisplayPresentInfoKHR_getpNext, NULL, "", NULL},
        
            {"srcRect", (getter)PyVkDisplayPresentInfoKHR_getsrcRect, NULL, "", NULL},
        
            {"dstRect", (getter)PyVkDisplayPresentInfoKHR_getdstRect, NULL, "", NULL},
        
            {"persistent", (getter)PyVkDisplayPresentInfoKHR_getpersistent, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkSurfaceCapabilitiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkSurfaceCapabilitiesKHR *self = (PyVkSurfaceCapabilitiesKHR *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkSurfaceCapabilitiesKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkSurfaceCapabilitiesKHR");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkSurfaceCapabilitiesKHR_del(PyVkSurfaceCapabilitiesKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkSurfaceCapabilitiesKHR_init(PyVkSurfaceCapabilitiesKHR *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkSurfaceCapabilitiesKHR_getminImageCount(PyVkSurfaceCapabilitiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->minImageCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSurfaceCapabilitiesKHR_getmaxImageCount(PyVkSurfaceCapabilitiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxImageCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSurfaceCapabilitiesKHR_getcurrentExtent(PyVkSurfaceCapabilitiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent2D*) pyvalue)->base = &((self->base)->currentExtent);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSurfaceCapabilitiesKHR_getminImageExtent(PyVkSurfaceCapabilitiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent2D*) pyvalue)->base = &((self->base)->minImageExtent);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSurfaceCapabilitiesKHR_getmaxImageExtent(PyVkSurfaceCapabilitiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent2D*) pyvalue)->base = &((self->base)->maxImageExtent);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSurfaceCapabilitiesKHR_getmaxImageArrayLayers(PyVkSurfaceCapabilitiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->maxImageArrayLayers));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSurfaceCapabilitiesKHR_getsupportedTransforms(PyVkSurfaceCapabilitiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->supportedTransforms));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSurfaceCapabilitiesKHR_getcurrentTransform(PyVkSurfaceCapabilitiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->currentTransform));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSurfaceCapabilitiesKHR_getsupportedCompositeAlpha(PyVkSurfaceCapabilitiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->supportedCompositeAlpha));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSurfaceCapabilitiesKHR_getsupportedUsageFlags(PyVkSurfaceCapabilitiesKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->supportedUsageFlags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkSurfaceCapabilitiesKHR_getsetters[] = {
        
            {"minImageCount", (getter)PyVkSurfaceCapabilitiesKHR_getminImageCount, NULL, "", NULL},
        
            {"maxImageCount", (getter)PyVkSurfaceCapabilitiesKHR_getmaxImageCount, NULL, "", NULL},
        
            {"currentExtent", (getter)PyVkSurfaceCapabilitiesKHR_getcurrentExtent, NULL, "", NULL},
        
            {"minImageExtent", (getter)PyVkSurfaceCapabilitiesKHR_getminImageExtent, NULL, "", NULL},
        
            {"maxImageExtent", (getter)PyVkSurfaceCapabilitiesKHR_getmaxImageExtent, NULL, "", NULL},
        
            {"maxImageArrayLayers", (getter)PyVkSurfaceCapabilitiesKHR_getmaxImageArrayLayers, NULL, "", NULL},
        
            {"supportedTransforms", (getter)PyVkSurfaceCapabilitiesKHR_getsupportedTransforms, NULL, "", NULL},
        
            {"currentTransform", (getter)PyVkSurfaceCapabilitiesKHR_getcurrentTransform, NULL, "", NULL},
        
            {"supportedCompositeAlpha", (getter)PyVkSurfaceCapabilitiesKHR_getsupportedCompositeAlpha, NULL, "", NULL},
        
            {"supportedUsageFlags", (getter)PyVkSurfaceCapabilitiesKHR_getsupportedUsageFlags, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
     #ifdef VK_USE_PLATFORM_ANDROID_KHR 
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkAndroidSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkAndroidSurfaceCreateInfoKHR *self = (PyVkAndroidSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkAndroidSurfaceCreateInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkAndroidSurfaceCreateInfoKHR");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkAndroidSurfaceCreateInfoKHR_del(PyVkAndroidSurfaceCreateInfoKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkAndroidSurfaceCreateInfoKHR_init(PyVkAndroidSurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkAndroidSurfaceCreateFlagsKHR flags;
ANativeWindow * window;

            static char *kwlist[] = {"sType","flags","window",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkAndroidSurfaceCreateFlagsKHR_converter,&flags,pyc_ANativeWindow_x_converter,&window))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->window = window;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkAndroidSurfaceCreateFlagsKHR_converter_free(&flags);
pyc_ANativeWindow_x_converter_free(&window);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkAndroidSurfaceCreateInfoKHR_getsType(PyVkAndroidSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkAndroidSurfaceCreateInfoKHR_getpNext(PyVkAndroidSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkAndroidSurfaceCreateInfoKHR_getflags(PyVkAndroidSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkAndroidSurfaceCreateInfoKHR_getwindow(PyVkAndroidSurfaceCreateInfoKHR *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkAndroidSurfaceCreateInfoKHR_getsetters[] = {
        
            {"sType", (getter)PyVkAndroidSurfaceCreateInfoKHR_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkAndroidSurfaceCreateInfoKHR_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkAndroidSurfaceCreateInfoKHR_getflags, NULL, "", NULL},
        
            {"window", (getter)PyVkAndroidSurfaceCreateInfoKHR_getwindow, NULL, "", NULL},
        
        {NULL}
    };




    
     #endif 


    
     #ifdef VK_USE_PLATFORM_MIR_KHR 
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkMirSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkMirSurfaceCreateInfoKHR *self = (PyVkMirSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkMirSurfaceCreateInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkMirSurfaceCreateInfoKHR");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkMirSurfaceCreateInfoKHR_del(PyVkMirSurfaceCreateInfoKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkMirSurfaceCreateInfoKHR_init(PyVkMirSurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkMirSurfaceCreateFlagsKHR flags;
MirConnection * connection;
MirSurface * mirSurface;

            static char *kwlist[] = {"sType","flags","connection","mirSurface",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkMirSurfaceCreateFlagsKHR_converter,&flags,pyc_MirConnection_x_converter,&connection,pyc_MirSurface_x_converter,&mirSurface))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->connection = connection;
            
            
            
                (self->base)->mirSurface = mirSurface;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkMirSurfaceCreateFlagsKHR_converter_free(&flags);
pyc_MirConnection_x_converter_free(&connection);
pyc_MirSurface_x_converter_free(&mirSurface);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkMirSurfaceCreateInfoKHR_getsType(PyVkMirSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkMirSurfaceCreateInfoKHR_getpNext(PyVkMirSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkMirSurfaceCreateInfoKHR_getflags(PyVkMirSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkMirSurfaceCreateInfoKHR_getconnection(PyVkMirSurfaceCreateInfoKHR *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkMirSurfaceCreateInfoKHR_getmirSurface(PyVkMirSurfaceCreateInfoKHR *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkMirSurfaceCreateInfoKHR_getsetters[] = {
        
            {"sType", (getter)PyVkMirSurfaceCreateInfoKHR_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkMirSurfaceCreateInfoKHR_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkMirSurfaceCreateInfoKHR_getflags, NULL, "", NULL},
        
            {"connection", (getter)PyVkMirSurfaceCreateInfoKHR_getconnection, NULL, "", NULL},
        
            {"mirSurface", (getter)PyVkMirSurfaceCreateInfoKHR_getmirSurface, NULL, "", NULL},
        
        {NULL}
    };




    
     #endif 


    
     #ifdef VK_USE_PLATFORM_WAYLAND_KHR 
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkWaylandSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkWaylandSurfaceCreateInfoKHR *self = (PyVkWaylandSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkWaylandSurfaceCreateInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkWaylandSurfaceCreateInfoKHR");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkWaylandSurfaceCreateInfoKHR_del(PyVkWaylandSurfaceCreateInfoKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkWaylandSurfaceCreateInfoKHR_init(PyVkWaylandSurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkWaylandSurfaceCreateFlagsKHR flags;
struct wl_display* display;
struct wl_surface* surface;

            static char *kwlist[] = {"sType","flags","display","surface",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkWaylandSurfaceCreateFlagsKHR_converter,&flags,pyc_wl_display_converter,&display,pyc_wl_surface_converter,&surface))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->display = display;
            
            
            
                (self->base)->surface = surface;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkWaylandSurfaceCreateFlagsKHR_converter_free(&flags);
pyc_wl_display_converter_free(&display);
pyc_wl_surface_converter_free(&surface);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkWaylandSurfaceCreateInfoKHR_getsType(PyVkWaylandSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWaylandSurfaceCreateInfoKHR_getpNext(PyVkWaylandSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWaylandSurfaceCreateInfoKHR_getflags(PyVkWaylandSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWaylandSurfaceCreateInfoKHR_getdisplay(PyVkWaylandSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWaylandSurfaceCreateInfoKHR_getsurface(PyVkWaylandSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkWaylandSurfaceCreateInfoKHR_getsetters[] = {
        
            {"sType", (getter)PyVkWaylandSurfaceCreateInfoKHR_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkWaylandSurfaceCreateInfoKHR_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkWaylandSurfaceCreateInfoKHR_getflags, NULL, "", NULL},
        
            {"display", (getter)PyVkWaylandSurfaceCreateInfoKHR_getdisplay, NULL, "", NULL},
        
            {"surface", (getter)PyVkWaylandSurfaceCreateInfoKHR_getsurface, NULL, "", NULL},
        
        {NULL}
    };




    
     #endif 


    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkWin32SurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkWin32SurfaceCreateInfoKHR *self = (PyVkWin32SurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkWin32SurfaceCreateInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkWin32SurfaceCreateInfoKHR");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkWin32SurfaceCreateInfoKHR_del(PyVkWin32SurfaceCreateInfoKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkWin32SurfaceCreateInfoKHR_init(PyVkWin32SurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkWin32SurfaceCreateFlagsKHR flags;
HINSTANCE hinstance;
HWND hwnd;

            static char *kwlist[] = {"sType","flags","hinstance","hwnd",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkWin32SurfaceCreateFlagsKHR_converter,&flags,pyc_HINSTANCE_converter,&hinstance,pyc_HWND_converter,&hwnd))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->hinstance = hinstance;
            
            
            
                (self->base)->hwnd = hwnd;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkWin32SurfaceCreateFlagsKHR_converter_free(&flags);
pyc_HINSTANCE_converter_free(&hinstance);
pyc_HWND_converter_free(&hwnd);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkWin32SurfaceCreateInfoKHR_getsType(PyVkWin32SurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWin32SurfaceCreateInfoKHR_getpNext(PyVkWin32SurfaceCreateInfoKHR *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWin32SurfaceCreateInfoKHR_getflags(PyVkWin32SurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWin32SurfaceCreateInfoKHR_gethinstance(PyVkWin32SurfaceCreateInfoKHR *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkWin32SurfaceCreateInfoKHR_gethwnd(PyVkWin32SurfaceCreateInfoKHR *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkWin32SurfaceCreateInfoKHR_getsetters[] = {
        
            {"sType", (getter)PyVkWin32SurfaceCreateInfoKHR_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkWin32SurfaceCreateInfoKHR_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkWin32SurfaceCreateInfoKHR_getflags, NULL, "", NULL},
        
            {"hinstance", (getter)PyVkWin32SurfaceCreateInfoKHR_gethinstance, NULL, "", NULL},
        
            {"hwnd", (getter)PyVkWin32SurfaceCreateInfoKHR_gethwnd, NULL, "", NULL},
        
        {NULL}
    };




    
     #endif 


    
     #ifdef VK_USE_PLATFORM_XLIB_KHR 
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkXlibSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkXlibSurfaceCreateInfoKHR *self = (PyVkXlibSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkXlibSurfaceCreateInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkXlibSurfaceCreateInfoKHR");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkXlibSurfaceCreateInfoKHR_del(PyVkXlibSurfaceCreateInfoKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkXlibSurfaceCreateInfoKHR_init(PyVkXlibSurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkXlibSurfaceCreateFlagsKHR flags;
Display * dpy;
Window window;

            static char *kwlist[] = {"sType","flags","dpy","window",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkXlibSurfaceCreateFlagsKHR_converter,&flags,pyc_Display_x_converter,&dpy,pyc_Window_converter,&window))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->dpy = dpy;
            
            
            
                (self->base)->window = window;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkXlibSurfaceCreateFlagsKHR_converter_free(&flags);
pyc_Display_x_converter_free(&dpy);
pyc_Window_converter_free(&window);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkXlibSurfaceCreateInfoKHR_getsType(PyVkXlibSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkXlibSurfaceCreateInfoKHR_getpNext(PyVkXlibSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkXlibSurfaceCreateInfoKHR_getflags(PyVkXlibSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkXlibSurfaceCreateInfoKHR_getdpy(PyVkXlibSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkXlibSurfaceCreateInfoKHR_getwindow(PyVkXlibSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkXlibSurfaceCreateInfoKHR_getsetters[] = {
        
            {"sType", (getter)PyVkXlibSurfaceCreateInfoKHR_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkXlibSurfaceCreateInfoKHR_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkXlibSurfaceCreateInfoKHR_getflags, NULL, "", NULL},
        
            {"dpy", (getter)PyVkXlibSurfaceCreateInfoKHR_getdpy, NULL, "", NULL},
        
            {"window", (getter)PyVkXlibSurfaceCreateInfoKHR_getwindow, NULL, "", NULL},
        
        {NULL}
    };




    
     #endif 


    
     #ifdef VK_USE_PLATFORM_XCB_KHR 
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkXcbSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkXcbSurfaceCreateInfoKHR *self = (PyVkXcbSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkXcbSurfaceCreateInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkXcbSurfaceCreateInfoKHR");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkXcbSurfaceCreateInfoKHR_del(PyVkXcbSurfaceCreateInfoKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkXcbSurfaceCreateInfoKHR_init(PyVkXcbSurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkXcbSurfaceCreateFlagsKHR flags;
xcb_connection_t * connection;
xcb_window_t window;

            static char *kwlist[] = {"sType","flags","connection","window",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkXcbSurfaceCreateFlagsKHR_converter,&flags,pyc_xcb_connection_t_x_converter,&connection,pyc_xcb_window_t_converter,&window))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->connection = connection;
            
            
            
                (self->base)->window = window;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkXcbSurfaceCreateFlagsKHR_converter_free(&flags);
pyc_xcb_connection_t_x_converter_free(&connection);
pyc_xcb_window_t_converter_free(&window);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkXcbSurfaceCreateInfoKHR_getsType(PyVkXcbSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkXcbSurfaceCreateInfoKHR_getpNext(PyVkXcbSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkXcbSurfaceCreateInfoKHR_getflags(PyVkXcbSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkXcbSurfaceCreateInfoKHR_getconnection(PyVkXcbSurfaceCreateInfoKHR *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkXcbSurfaceCreateInfoKHR_getwindow(PyVkXcbSurfaceCreateInfoKHR *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkXcbSurfaceCreateInfoKHR_getsetters[] = {
        
            {"sType", (getter)PyVkXcbSurfaceCreateInfoKHR_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkXcbSurfaceCreateInfoKHR_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkXcbSurfaceCreateInfoKHR_getflags, NULL, "", NULL},
        
            {"connection", (getter)PyVkXcbSurfaceCreateInfoKHR_getconnection, NULL, "", NULL},
        
            {"window", (getter)PyVkXcbSurfaceCreateInfoKHR_getwindow, NULL, "", NULL},
        
        {NULL}
    };




    
     #endif 


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkSurfaceFormatKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkSurfaceFormatKHR *self = (PyVkSurfaceFormatKHR *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkSurfaceFormatKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkSurfaceFormatKHR");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkSurfaceFormatKHR_del(PyVkSurfaceFormatKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkSurfaceFormatKHR_init(PyVkSurfaceFormatKHR *self, PyObject *args, PyObject *kwds) {
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkSurfaceFormatKHR_getformat(PyVkSurfaceFormatKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->format));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSurfaceFormatKHR_getcolorSpace(PyVkSurfaceFormatKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->colorSpace));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkSurfaceFormatKHR_getsetters[] = {
        
            {"format", (getter)PyVkSurfaceFormatKHR_getformat, NULL, "", NULL},
        
            {"colorSpace", (getter)PyVkSurfaceFormatKHR_getcolorSpace, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkSwapchainCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkSwapchainCreateInfoKHR *self = (PyVkSwapchainCreateInfoKHR *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkSwapchainCreateInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkSwapchainCreateInfoKHR");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkSwapchainCreateInfoKHR_del(PyVkSwapchainCreateInfoKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkSwapchainCreateInfoKHR_init(PyVkSwapchainCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkSwapchainCreateFlagsKHR flags;
VkSurfaceKHR surface;
uint32_t minImageCount;
VkFormat imageFormat;
VkColorSpaceKHR imageColorSpace;
VkExtent2D imageExtent;
uint32_t imageArrayLayers;
VkImageUsageFlags imageUsage;
VkSharingMode imageSharingMode;
uint32_t queueFamilyIndexCount;
uint32_t* pQueueFamilyIndices;
VkSurfaceTransformFlagBitsKHR preTransform;
VkCompositeAlphaFlagBitsKHR compositeAlpha;
VkPresentModeKHR presentMode;
VkBool32 clipped;
VkSwapchainKHR oldSwapchain;

            static char *kwlist[] = {"sType","flags","surface","minImageCount","imageFormat","imageColorSpace","imageExtent","imageArrayLayers","imageUsage","imageSharingMode","queueFamilyIndexCount","pQueueFamilyIndices","preTransform","compositeAlpha","presentMode","clipped","oldSwapchain",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkSwapchainCreateFlagsKHR_converter,&flags,pyc_handle_base_VkSurfaceKHR_converter,&surface,pyc_uint32_t_converter,&minImageCount,pyc_flag_base_VkFormat_converter,&imageFormat,pyc_flag_base_VkColorSpaceKHR_converter,&imageColorSpace,pyc_struct_base_VkExtent2D_converter,&imageExtent,pyc_uint32_t_converter,&imageArrayLayers,pyc_flag_base_VkImageUsageFlags_converter,&imageUsage,pyc_flag_base_VkSharingMode_converter,&imageSharingMode,pyc_uint32_t_converter,&queueFamilyIndexCount,pyc_array_uint32_t_converter,&pQueueFamilyIndices,pyc_flag_base_VkSurfaceTransformFlagBitsKHR_converter,&preTransform,pyc_flag_base_VkCompositeAlphaFlagBitsKHR_converter,&compositeAlpha,pyc_flag_base_VkPresentModeKHR_converter,&presentMode,pyc_flag_base_VkBool32_converter,&clipped,pyc_handle_base_VkSwapchainKHR_converter,&oldSwapchain))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->flags = flags;
            
            
            
                (self->base)->surface = surface;
            
            
            
                (self->base)->minImageCount = minImageCount;
            
            
            
                (self->base)->imageFormat = imageFormat;
            
            
            
                (self->base)->imageColorSpace = imageColorSpace;
            
            
            
                (self->base)->imageExtent = imageExtent;
            
            
            
                (self->base)->imageArrayLayers = imageArrayLayers;
            
            
            
                (self->base)->imageUsage = imageUsage;
            
            
            
                (self->base)->imageSharingMode = imageSharingMode;
            
            
            
                (self->base)->queueFamilyIndexCount = queueFamilyIndexCount;
            
            
            
                (self->base)->pQueueFamilyIndices = pQueueFamilyIndices;
            
            
            
                (self->base)->preTransform = preTransform;
            
            
            
                (self->base)->compositeAlpha = compositeAlpha;
            
            
            
                (self->base)->presentMode = presentMode;
            
            
            
                (self->base)->clipped = clipped;
            
            
            
                (self->base)->oldSwapchain = oldSwapchain;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkSwapchainCreateFlagsKHR_converter_free(&flags);
pyc_handle_base_VkSurfaceKHR_converter_free(&surface);
pyc_uint32_t_converter_free(&minImageCount);
pyc_flag_base_VkFormat_converter_free(&imageFormat);
pyc_flag_base_VkColorSpaceKHR_converter_free(&imageColorSpace);
pyc_struct_base_VkExtent2D_converter_free(&imageExtent);
pyc_uint32_t_converter_free(&imageArrayLayers);
pyc_flag_base_VkImageUsageFlags_converter_free(&imageUsage);
pyc_flag_base_VkSharingMode_converter_free(&imageSharingMode);
pyc_uint32_t_converter_free(&queueFamilyIndexCount);
pyc_array_uint32_t_converter_free(&pQueueFamilyIndices);
pyc_flag_base_VkSurfaceTransformFlagBitsKHR_converter_free(&preTransform);
pyc_flag_base_VkCompositeAlphaFlagBitsKHR_converter_free(&compositeAlpha);
pyc_flag_base_VkPresentModeKHR_converter_free(&presentMode);
pyc_flag_base_VkBool32_converter_free(&clipped);
pyc_handle_base_VkSwapchainKHR_converter_free(&oldSwapchain);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkSwapchainCreateInfoKHR_getsType(PyVkSwapchainCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSwapchainCreateInfoKHR_getpNext(PyVkSwapchainCreateInfoKHR *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSwapchainCreateInfoKHR_getflags(PyVkSwapchainCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->flags));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSwapchainCreateInfoKHR_getsurface(PyVkSwapchainCreateInfoKHR *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkSwapchainCreateInfoKHR_getminImageCount(PyVkSwapchainCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->minImageCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSwapchainCreateInfoKHR_getimageFormat(PyVkSwapchainCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->imageFormat));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSwapchainCreateInfoKHR_getimageColorSpace(PyVkSwapchainCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->imageColorSpace));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSwapchainCreateInfoKHR_getimageExtent(PyVkSwapchainCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkExtent2DType);
            if (!pyvalue)
                return NULL;
            ((PyVkExtent2D*) pyvalue)->base = &((self->base)->imageExtent);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSwapchainCreateInfoKHR_getimageArrayLayers(PyVkSwapchainCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->imageArrayLayers));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSwapchainCreateInfoKHR_getimageUsage(PyVkSwapchainCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->imageUsage));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSwapchainCreateInfoKHR_getimageSharingMode(PyVkSwapchainCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->imageSharingMode));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSwapchainCreateInfoKHR_getqueueFamilyIndexCount(PyVkSwapchainCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->queueFamilyIndexCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSwapchainCreateInfoKHR_getpQueueFamilyIndices(PyVkSwapchainCreateInfoKHR *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyLong_FromLong((long) (*(((self->base)->pQueueFamilyIndices))));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSwapchainCreateInfoKHR_getpreTransform(PyVkSwapchainCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->preTransform));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSwapchainCreateInfoKHR_getcompositeAlpha(PyVkSwapchainCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->compositeAlpha));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSwapchainCreateInfoKHR_getpresentMode(PyVkSwapchainCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->presentMode));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSwapchainCreateInfoKHR_getclipped(PyVkSwapchainCreateInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->clipped));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkSwapchainCreateInfoKHR_getoldSwapchain(PyVkSwapchainCreateInfoKHR *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkSwapchainCreateInfoKHR_getsetters[] = {
        
            {"sType", (getter)PyVkSwapchainCreateInfoKHR_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkSwapchainCreateInfoKHR_getpNext, NULL, "", NULL},
        
            {"flags", (getter)PyVkSwapchainCreateInfoKHR_getflags, NULL, "", NULL},
        
            {"surface", (getter)PyVkSwapchainCreateInfoKHR_getsurface, NULL, "", NULL},
        
            {"minImageCount", (getter)PyVkSwapchainCreateInfoKHR_getminImageCount, NULL, "", NULL},
        
            {"imageFormat", (getter)PyVkSwapchainCreateInfoKHR_getimageFormat, NULL, "", NULL},
        
            {"imageColorSpace", (getter)PyVkSwapchainCreateInfoKHR_getimageColorSpace, NULL, "", NULL},
        
            {"imageExtent", (getter)PyVkSwapchainCreateInfoKHR_getimageExtent, NULL, "", NULL},
        
            {"imageArrayLayers", (getter)PyVkSwapchainCreateInfoKHR_getimageArrayLayers, NULL, "", NULL},
        
            {"imageUsage", (getter)PyVkSwapchainCreateInfoKHR_getimageUsage, NULL, "", NULL},
        
            {"imageSharingMode", (getter)PyVkSwapchainCreateInfoKHR_getimageSharingMode, NULL, "", NULL},
        
            {"queueFamilyIndexCount", (getter)PyVkSwapchainCreateInfoKHR_getqueueFamilyIndexCount, NULL, "", NULL},
        
            {"pQueueFamilyIndices", (getter)PyVkSwapchainCreateInfoKHR_getpQueueFamilyIndices, NULL, "", NULL},
        
            {"preTransform", (getter)PyVkSwapchainCreateInfoKHR_getpreTransform, NULL, "", NULL},
        
            {"compositeAlpha", (getter)PyVkSwapchainCreateInfoKHR_getcompositeAlpha, NULL, "", NULL},
        
            {"presentMode", (getter)PyVkSwapchainCreateInfoKHR_getpresentMode, NULL, "", NULL},
        
            {"clipped", (getter)PyVkSwapchainCreateInfoKHR_getclipped, NULL, "", NULL},
        
            {"oldSwapchain", (getter)PyVkSwapchainCreateInfoKHR_getoldSwapchain, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPresentInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPresentInfoKHR *self = (PyVkPresentInfoKHR *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPresentInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPresentInfoKHR");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPresentInfoKHR_del(PyVkPresentInfoKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPresentInfoKHR_init(PyVkPresentInfoKHR *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
uint32_t waitSemaphoreCount;
VkSemaphore* pWaitSemaphores;
uint32_t swapchainCount;
VkSwapchainKHR* pSwapchains;
uint32_t* pImageIndices;
VkResult* pResults;

            static char *kwlist[] = {"sType","waitSemaphoreCount","pWaitSemaphores","swapchainCount","pSwapchains","pImageIndices","pResults",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_uint32_t_converter,&waitSemaphoreCount,pyc_handle_array_VkSemaphore_converter,&pWaitSemaphores,pyc_uint32_t_converter,&swapchainCount,pyc_handle_array_VkSwapchainKHR_converter,&pSwapchains,pyc_array_uint32_t_converter,&pImageIndices,pyc_flag_array_VkResult_converter,&pResults))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->waitSemaphoreCount = waitSemaphoreCount;
            
            
            
                (self->base)->pWaitSemaphores = pWaitSemaphores;
            
            
            
                (self->base)->swapchainCount = swapchainCount;
            
            
            
                (self->base)->pSwapchains = pSwapchains;
            
            
            
                (self->base)->pImageIndices = pImageIndices;
            
            
            
                (self->base)->pResults = pResults;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_uint32_t_converter_free(&waitSemaphoreCount);
pyc_handle_array_VkSemaphore_converter_free(&pWaitSemaphores);
pyc_uint32_t_converter_free(&swapchainCount);
pyc_handle_array_VkSwapchainKHR_converter_free(&pSwapchains);
pyc_array_uint32_t_converter_free(&pImageIndices);
pyc_flag_array_VkResult_converter_free(&pResults);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPresentInfoKHR_getsType(PyVkPresentInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPresentInfoKHR_getpNext(PyVkPresentInfoKHR *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPresentInfoKHR_getwaitSemaphoreCount(PyVkPresentInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->waitSemaphoreCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPresentInfoKHR_getpWaitSemaphores(PyVkPresentInfoKHR *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkPresentInfoKHR_getswapchainCount(PyVkPresentInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->swapchainCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPresentInfoKHR_getpSwapchains(PyVkPresentInfoKHR *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkPresentInfoKHR_getpImageIndices(PyVkPresentInfoKHR *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyLong_FromLong((long) (*(((self->base)->pImageIndices))));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPresentInfoKHR_getpResults(PyVkPresentInfoKHR *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(*((self->base)->pResults));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPresentInfoKHR_getsetters[] = {
        
            {"sType", (getter)PyVkPresentInfoKHR_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkPresentInfoKHR_getpNext, NULL, "", NULL},
        
            {"waitSemaphoreCount", (getter)PyVkPresentInfoKHR_getwaitSemaphoreCount, NULL, "", NULL},
        
            {"pWaitSemaphores", (getter)PyVkPresentInfoKHR_getpWaitSemaphores, NULL, "", NULL},
        
            {"swapchainCount", (getter)PyVkPresentInfoKHR_getswapchainCount, NULL, "", NULL},
        
            {"pSwapchains", (getter)PyVkPresentInfoKHR_getpSwapchains, NULL, "", NULL},
        
            {"pImageIndices", (getter)PyVkPresentInfoKHR_getpImageIndices, NULL, "", NULL},
        
            {"pResults", (getter)PyVkPresentInfoKHR_getpResults, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkValidationFlagsEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkValidationFlagsEXT *self = (PyVkValidationFlagsEXT *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkValidationFlagsEXT));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkValidationFlagsEXT");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkValidationFlagsEXT_del(PyVkValidationFlagsEXT* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkValidationFlagsEXT_init(PyVkValidationFlagsEXT *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
uint32_t disabledValidationCheckCount;
VkValidationCheckEXT* pDisabledValidationChecks;

            static char *kwlist[] = {"sType","disabledValidationCheckCount","pDisabledValidationChecks",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_uint32_t_converter,&disabledValidationCheckCount,pyc_flag_array_VkValidationCheckEXT_converter,&pDisabledValidationChecks))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->disabledValidationCheckCount = disabledValidationCheckCount;
            
            
            
                (self->base)->pDisabledValidationChecks = pDisabledValidationChecks;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_uint32_t_converter_free(&disabledValidationCheckCount);
pyc_flag_array_VkValidationCheckEXT_converter_free(&pDisabledValidationChecks);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkValidationFlagsEXT_getsType(PyVkValidationFlagsEXT *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkValidationFlagsEXT_getpNext(PyVkValidationFlagsEXT *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkValidationFlagsEXT_getdisabledValidationCheckCount(PyVkValidationFlagsEXT *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->disabledValidationCheckCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkValidationFlagsEXT_getpDisabledValidationChecks(PyVkValidationFlagsEXT *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(*((self->base)->pDisabledValidationChecks));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkValidationFlagsEXT_getsetters[] = {
        
            {"sType", (getter)PyVkValidationFlagsEXT_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkValidationFlagsEXT_getpNext, NULL, "", NULL},
        
            {"disabledValidationCheckCount", (getter)PyVkValidationFlagsEXT_getdisabledValidationCheckCount, NULL, "", NULL},
        
            {"pDisabledValidationChecks", (getter)PyVkValidationFlagsEXT_getpDisabledValidationChecks, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkPipelineRasterizationStateRasterizationOrderAMD_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkPipelineRasterizationStateRasterizationOrderAMD *self = (PyVkPipelineRasterizationStateRasterizationOrderAMD *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkPipelineRasterizationStateRasterizationOrderAMD));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkPipelineRasterizationStateRasterizationOrderAMD");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkPipelineRasterizationStateRasterizationOrderAMD_del(PyVkPipelineRasterizationStateRasterizationOrderAMD* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkPipelineRasterizationStateRasterizationOrderAMD_init(PyVkPipelineRasterizationStateRasterizationOrderAMD *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkRasterizationOrderAMD rasterizationOrder;

            static char *kwlist[] = {"sType","rasterizationOrder",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkRasterizationOrderAMD_converter,&rasterizationOrder))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->rasterizationOrder = rasterizationOrder;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkRasterizationOrderAMD_converter_free(&rasterizationOrder);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkPipelineRasterizationStateRasterizationOrderAMD_getsType(PyVkPipelineRasterizationStateRasterizationOrderAMD *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineRasterizationStateRasterizationOrderAMD_getpNext(PyVkPipelineRasterizationStateRasterizationOrderAMD *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkPipelineRasterizationStateRasterizationOrderAMD_getrasterizationOrder(PyVkPipelineRasterizationStateRasterizationOrderAMD *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->rasterizationOrder));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkPipelineRasterizationStateRasterizationOrderAMD_getsetters[] = {
        
            {"sType", (getter)PyVkPipelineRasterizationStateRasterizationOrderAMD_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkPipelineRasterizationStateRasterizationOrderAMD_getpNext, NULL, "", NULL},
        
            {"rasterizationOrder", (getter)PyVkPipelineRasterizationStateRasterizationOrderAMD_getrasterizationOrder, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDebugMarkerObjectNameInfoEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDebugMarkerObjectNameInfoEXT *self = (PyVkDebugMarkerObjectNameInfoEXT *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDebugMarkerObjectNameInfoEXT));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDebugMarkerObjectNameInfoEXT");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDebugMarkerObjectNameInfoEXT_del(PyVkDebugMarkerObjectNameInfoEXT* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDebugMarkerObjectNameInfoEXT_init(PyVkDebugMarkerObjectNameInfoEXT *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkDebugReportObjectTypeEXT objectType;
uint64_t object;
char* pObjectName;

            static char *kwlist[] = {"sType","objectType","object","pObjectName",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkDebugReportObjectTypeEXT_converter,&objectType,pyc_uint64_t_converter,&object,pyc_string_converter,&pObjectName))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->objectType = objectType;
            
            
            
                (self->base)->object = object;
            
            
            
                (self->base)->pObjectName = pObjectName;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkDebugReportObjectTypeEXT_converter_free(&objectType);
pyc_uint64_t_converter_free(&object);
pyc_string_converter_free(&pObjectName);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDebugMarkerObjectNameInfoEXT_getsType(PyVkDebugMarkerObjectNameInfoEXT *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDebugMarkerObjectNameInfoEXT_getpNext(PyVkDebugMarkerObjectNameInfoEXT *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDebugMarkerObjectNameInfoEXT_getobjectType(PyVkDebugMarkerObjectNameInfoEXT *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->objectType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDebugMarkerObjectNameInfoEXT_getobject(PyVkDebugMarkerObjectNameInfoEXT *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->object));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDebugMarkerObjectNameInfoEXT_getpObjectName(PyVkDebugMarkerObjectNameInfoEXT *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyUnicode_FromString((const char *) ((self->base)->pObjectName));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDebugMarkerObjectNameInfoEXT_getsetters[] = {
        
            {"sType", (getter)PyVkDebugMarkerObjectNameInfoEXT_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkDebugMarkerObjectNameInfoEXT_getpNext, NULL, "", NULL},
        
            {"objectType", (getter)PyVkDebugMarkerObjectNameInfoEXT_getobjectType, NULL, "", NULL},
        
            {"object", (getter)PyVkDebugMarkerObjectNameInfoEXT_getobject, NULL, "", NULL},
        
            {"pObjectName", (getter)PyVkDebugMarkerObjectNameInfoEXT_getpObjectName, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDebugMarkerObjectTagInfoEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDebugMarkerObjectTagInfoEXT *self = (PyVkDebugMarkerObjectTagInfoEXT *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDebugMarkerObjectTagInfoEXT));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDebugMarkerObjectTagInfoEXT");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDebugMarkerObjectTagInfoEXT_del(PyVkDebugMarkerObjectTagInfoEXT* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDebugMarkerObjectTagInfoEXT_init(PyVkDebugMarkerObjectTagInfoEXT *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkDebugReportObjectTypeEXT objectType;
uint64_t object;
uint64_t tagName;
size_t tagSize;
void * pTag;

            static char *kwlist[] = {"sType","objectType","object","tagName","tagSize","pTag",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkDebugReportObjectTypeEXT_converter,&objectType,pyc_uint64_t_converter,&object,pyc_uint64_t_converter,&tagName,pyc_size_t_converter,&tagSize,pyc_void_x_converter,&pTag))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->objectType = objectType;
            
            
            
                (self->base)->object = object;
            
            
            
                (self->base)->tagName = tagName;
            
            
            
                (self->base)->tagSize = tagSize;
            
            
            
                (self->base)->pTag = pTag;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkDebugReportObjectTypeEXT_converter_free(&objectType);
pyc_uint64_t_converter_free(&object);
pyc_uint64_t_converter_free(&tagName);
pyc_size_t_converter_free(&tagSize);
pyc_void_x_converter_free(&pTag);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDebugMarkerObjectTagInfoEXT_getsType(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDebugMarkerObjectTagInfoEXT_getpNext(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDebugMarkerObjectTagInfoEXT_getobjectType(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->objectType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDebugMarkerObjectTagInfoEXT_getobject(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->object));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDebugMarkerObjectTagInfoEXT_gettagName(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->tagName));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDebugMarkerObjectTagInfoEXT_gettagSize(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->tagSize));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDebugMarkerObjectTagInfoEXT_getpTag(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDebugMarkerObjectTagInfoEXT_getsetters[] = {
        
            {"sType", (getter)PyVkDebugMarkerObjectTagInfoEXT_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkDebugMarkerObjectTagInfoEXT_getpNext, NULL, "", NULL},
        
            {"objectType", (getter)PyVkDebugMarkerObjectTagInfoEXT_getobjectType, NULL, "", NULL},
        
            {"object", (getter)PyVkDebugMarkerObjectTagInfoEXT_getobject, NULL, "", NULL},
        
            {"tagName", (getter)PyVkDebugMarkerObjectTagInfoEXT_gettagName, NULL, "", NULL},
        
            {"tagSize", (getter)PyVkDebugMarkerObjectTagInfoEXT_gettagSize, NULL, "", NULL},
        
            {"pTag", (getter)PyVkDebugMarkerObjectTagInfoEXT_getpTag, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDebugMarkerMarkerInfoEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDebugMarkerMarkerInfoEXT *self = (PyVkDebugMarkerMarkerInfoEXT *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDebugMarkerMarkerInfoEXT));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDebugMarkerMarkerInfoEXT");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDebugMarkerMarkerInfoEXT_del(PyVkDebugMarkerMarkerInfoEXT* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDebugMarkerMarkerInfoEXT_init(PyVkDebugMarkerMarkerInfoEXT *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
char* pMarkerName;
float* color;

            static char *kwlist[] = {"sType","pMarkerName","color",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_string_converter,&pMarkerName,pyc_array_float_converter,&color))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->pMarkerName = pMarkerName;
            
            
            
                
        memcpy((self->base)->color, color, 4 * sizeof(float));
        
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_string_converter_free(&pMarkerName);
pyc_array_float_converter_free(&color);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDebugMarkerMarkerInfoEXT_getsType(PyVkDebugMarkerMarkerInfoEXT *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDebugMarkerMarkerInfoEXT_getpNext(PyVkDebugMarkerMarkerInfoEXT *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDebugMarkerMarkerInfoEXT_getpMarkerName(PyVkDebugMarkerMarkerInfoEXT *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyUnicode_FromString((const char *) ((self->base)->pMarkerName));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDebugMarkerMarkerInfoEXT_getcolor(PyVkDebugMarkerMarkerInfoEXT *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyList_New(0);
        int nb = sizeof(((self->base)->color)) / sizeof(((self->base)->color)[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* tmp = PyFloat_FromDouble((double) ((self->base)->color)[i]);
            PyList_Append(pyvalue, tmp);
        }
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDebugMarkerMarkerInfoEXT_getsetters[] = {
        
            {"sType", (getter)PyVkDebugMarkerMarkerInfoEXT_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkDebugMarkerMarkerInfoEXT_getpNext, NULL, "", NULL},
        
            {"pMarkerName", (getter)PyVkDebugMarkerMarkerInfoEXT_getpMarkerName, NULL, "", NULL},
        
            {"color", (getter)PyVkDebugMarkerMarkerInfoEXT_getcolor, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDedicatedAllocationImageCreateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDedicatedAllocationImageCreateInfoNV *self = (PyVkDedicatedAllocationImageCreateInfoNV *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDedicatedAllocationImageCreateInfoNV));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDedicatedAllocationImageCreateInfoNV");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDedicatedAllocationImageCreateInfoNV_del(PyVkDedicatedAllocationImageCreateInfoNV* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDedicatedAllocationImageCreateInfoNV_init(PyVkDedicatedAllocationImageCreateInfoNV *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkBool32 dedicatedAllocation;

            static char *kwlist[] = {"sType","dedicatedAllocation",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkBool32_converter,&dedicatedAllocation))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->dedicatedAllocation = dedicatedAllocation;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkBool32_converter_free(&dedicatedAllocation);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDedicatedAllocationImageCreateInfoNV_getsType(PyVkDedicatedAllocationImageCreateInfoNV *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDedicatedAllocationImageCreateInfoNV_getpNext(PyVkDedicatedAllocationImageCreateInfoNV *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDedicatedAllocationImageCreateInfoNV_getdedicatedAllocation(PyVkDedicatedAllocationImageCreateInfoNV *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->dedicatedAllocation));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDedicatedAllocationImageCreateInfoNV_getsetters[] = {
        
            {"sType", (getter)PyVkDedicatedAllocationImageCreateInfoNV_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkDedicatedAllocationImageCreateInfoNV_getpNext, NULL, "", NULL},
        
            {"dedicatedAllocation", (getter)PyVkDedicatedAllocationImageCreateInfoNV_getdedicatedAllocation, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDedicatedAllocationBufferCreateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDedicatedAllocationBufferCreateInfoNV *self = (PyVkDedicatedAllocationBufferCreateInfoNV *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDedicatedAllocationBufferCreateInfoNV));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDedicatedAllocationBufferCreateInfoNV");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDedicatedAllocationBufferCreateInfoNV_del(PyVkDedicatedAllocationBufferCreateInfoNV* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDedicatedAllocationBufferCreateInfoNV_init(PyVkDedicatedAllocationBufferCreateInfoNV *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkBool32 dedicatedAllocation;

            static char *kwlist[] = {"sType","dedicatedAllocation",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkBool32_converter,&dedicatedAllocation))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->dedicatedAllocation = dedicatedAllocation;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkBool32_converter_free(&dedicatedAllocation);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDedicatedAllocationBufferCreateInfoNV_getsType(PyVkDedicatedAllocationBufferCreateInfoNV *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDedicatedAllocationBufferCreateInfoNV_getpNext(PyVkDedicatedAllocationBufferCreateInfoNV *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDedicatedAllocationBufferCreateInfoNV_getdedicatedAllocation(PyVkDedicatedAllocationBufferCreateInfoNV *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->dedicatedAllocation));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDedicatedAllocationBufferCreateInfoNV_getsetters[] = {
        
            {"sType", (getter)PyVkDedicatedAllocationBufferCreateInfoNV_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkDedicatedAllocationBufferCreateInfoNV_getpNext, NULL, "", NULL},
        
            {"dedicatedAllocation", (getter)PyVkDedicatedAllocationBufferCreateInfoNV_getdedicatedAllocation, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkDedicatedAllocationMemoryAllocateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkDedicatedAllocationMemoryAllocateInfoNV *self = (PyVkDedicatedAllocationMemoryAllocateInfoNV *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkDedicatedAllocationMemoryAllocateInfoNV));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkDedicatedAllocationMemoryAllocateInfoNV");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkDedicatedAllocationMemoryAllocateInfoNV_del(PyVkDedicatedAllocationMemoryAllocateInfoNV* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkDedicatedAllocationMemoryAllocateInfoNV_init(PyVkDedicatedAllocationMemoryAllocateInfoNV *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkImage image;
VkBuffer buffer;

            static char *kwlist[] = {"sType","image","buffer",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_handle_base_VkImage_converter,&image,pyc_handle_base_VkBuffer_converter,&buffer))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->image = image;
            
            
            
                (self->base)->buffer = buffer;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_handle_base_VkImage_converter_free(&image);
pyc_handle_base_VkBuffer_converter_free(&buffer);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkDedicatedAllocationMemoryAllocateInfoNV_getsType(PyVkDedicatedAllocationMemoryAllocateInfoNV *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDedicatedAllocationMemoryAllocateInfoNV_getpNext(PyVkDedicatedAllocationMemoryAllocateInfoNV *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkDedicatedAllocationMemoryAllocateInfoNV_getimage(PyVkDedicatedAllocationMemoryAllocateInfoNV *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkDedicatedAllocationMemoryAllocateInfoNV_getbuffer(PyVkDedicatedAllocationMemoryAllocateInfoNV *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkDedicatedAllocationMemoryAllocateInfoNV_getsetters[] = {
        
            {"sType", (getter)PyVkDedicatedAllocationMemoryAllocateInfoNV_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkDedicatedAllocationMemoryAllocateInfoNV_getpNext, NULL, "", NULL},
        
            {"image", (getter)PyVkDedicatedAllocationMemoryAllocateInfoNV_getimage, NULL, "", NULL},
        
            {"buffer", (getter)PyVkDedicatedAllocationMemoryAllocateInfoNV_getbuffer, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkExternalImageFormatPropertiesNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkExternalImageFormatPropertiesNV *self = (PyVkExternalImageFormatPropertiesNV *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkExternalImageFormatPropertiesNV));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkExternalImageFormatPropertiesNV");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkExternalImageFormatPropertiesNV_del(PyVkExternalImageFormatPropertiesNV* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkExternalImageFormatPropertiesNV_init(PyVkExternalImageFormatPropertiesNV *self, PyObject *args, PyObject *kwds) {
        
            VkImageFormatProperties imageFormatProperties;
VkExternalMemoryFeatureFlagsNV externalMemoryFeatures;
VkExternalMemoryHandleTypeFlagsNV exportFromImportedHandleTypes;
VkExternalMemoryHandleTypeFlagsNV compatibleHandleTypes;

            static char *kwlist[] = {"imageFormatProperties","externalMemoryFeatures","exportFromImportedHandleTypes","compatibleHandleTypes",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_struct_base_VkImageFormatProperties_converter,&imageFormatProperties,pyc_flag_base_VkExternalMemoryFeatureFlagsNV_converter,&externalMemoryFeatures,pyc_flag_base_VkExternalMemoryHandleTypeFlagsNV_converter,&exportFromImportedHandleTypes,pyc_flag_base_VkExternalMemoryHandleTypeFlagsNV_converter,&compatibleHandleTypes))
        return -1;
    

            
            
                (self->base)->imageFormatProperties = imageFormatProperties;
            
            
            
                (self->base)->externalMemoryFeatures = externalMemoryFeatures;
            
            
            
                (self->base)->exportFromImportedHandleTypes = exportFromImportedHandleTypes;
            
            
            
                (self->base)->compatibleHandleTypes = compatibleHandleTypes;
            
            

            pyc_struct_base_VkImageFormatProperties_converter_free(&imageFormatProperties);
pyc_flag_base_VkExternalMemoryFeatureFlagsNV_converter_free(&externalMemoryFeatures);
pyc_flag_base_VkExternalMemoryHandleTypeFlagsNV_converter_free(&exportFromImportedHandleTypes);
pyc_flag_base_VkExternalMemoryHandleTypeFlagsNV_converter_free(&compatibleHandleTypes);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkExternalImageFormatPropertiesNV_getimageFormatProperties(PyVkExternalImageFormatPropertiesNV *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkImageFormatPropertiesType);
            if (!pyvalue)
                return NULL;
            ((PyVkImageFormatProperties*) pyvalue)->base = &((self->base)->imageFormatProperties);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkExternalImageFormatPropertiesNV_getexternalMemoryFeatures(PyVkExternalImageFormatPropertiesNV *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->externalMemoryFeatures));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkExternalImageFormatPropertiesNV_getexportFromImportedHandleTypes(PyVkExternalImageFormatPropertiesNV *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->exportFromImportedHandleTypes));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkExternalImageFormatPropertiesNV_getcompatibleHandleTypes(PyVkExternalImageFormatPropertiesNV *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->compatibleHandleTypes));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkExternalImageFormatPropertiesNV_getsetters[] = {
        
            {"imageFormatProperties", (getter)PyVkExternalImageFormatPropertiesNV_getimageFormatProperties, NULL, "", NULL},
        
            {"externalMemoryFeatures", (getter)PyVkExternalImageFormatPropertiesNV_getexternalMemoryFeatures, NULL, "", NULL},
        
            {"exportFromImportedHandleTypes", (getter)PyVkExternalImageFormatPropertiesNV_getexportFromImportedHandleTypes, NULL, "", NULL},
        
            {"compatibleHandleTypes", (getter)PyVkExternalImageFormatPropertiesNV_getcompatibleHandleTypes, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkExternalMemoryImageCreateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkExternalMemoryImageCreateInfoNV *self = (PyVkExternalMemoryImageCreateInfoNV *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkExternalMemoryImageCreateInfoNV));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkExternalMemoryImageCreateInfoNV");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkExternalMemoryImageCreateInfoNV_del(PyVkExternalMemoryImageCreateInfoNV* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkExternalMemoryImageCreateInfoNV_init(PyVkExternalMemoryImageCreateInfoNV *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkExternalMemoryHandleTypeFlagsNV handleTypes;

            static char *kwlist[] = {"sType","handleTypes",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkExternalMemoryHandleTypeFlagsNV_converter,&handleTypes))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->handleTypes = handleTypes;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkExternalMemoryHandleTypeFlagsNV_converter_free(&handleTypes);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkExternalMemoryImageCreateInfoNV_getsType(PyVkExternalMemoryImageCreateInfoNV *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkExternalMemoryImageCreateInfoNV_getpNext(PyVkExternalMemoryImageCreateInfoNV *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkExternalMemoryImageCreateInfoNV_gethandleTypes(PyVkExternalMemoryImageCreateInfoNV *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->handleTypes));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkExternalMemoryImageCreateInfoNV_getsetters[] = {
        
            {"sType", (getter)PyVkExternalMemoryImageCreateInfoNV_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkExternalMemoryImageCreateInfoNV_getpNext, NULL, "", NULL},
        
            {"handleTypes", (getter)PyVkExternalMemoryImageCreateInfoNV_gethandleTypes, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkExportMemoryAllocateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkExportMemoryAllocateInfoNV *self = (PyVkExportMemoryAllocateInfoNV *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkExportMemoryAllocateInfoNV));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkExportMemoryAllocateInfoNV");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkExportMemoryAllocateInfoNV_del(PyVkExportMemoryAllocateInfoNV* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkExportMemoryAllocateInfoNV_init(PyVkExportMemoryAllocateInfoNV *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkExternalMemoryHandleTypeFlagsNV handleTypes;

            static char *kwlist[] = {"sType","handleTypes",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkExternalMemoryHandleTypeFlagsNV_converter,&handleTypes))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->handleTypes = handleTypes;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkExternalMemoryHandleTypeFlagsNV_converter_free(&handleTypes);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkExportMemoryAllocateInfoNV_getsType(PyVkExportMemoryAllocateInfoNV *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkExportMemoryAllocateInfoNV_getpNext(PyVkExportMemoryAllocateInfoNV *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkExportMemoryAllocateInfoNV_gethandleTypes(PyVkExportMemoryAllocateInfoNV *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->handleTypes));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkExportMemoryAllocateInfoNV_getsetters[] = {
        
            {"sType", (getter)PyVkExportMemoryAllocateInfoNV_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkExportMemoryAllocateInfoNV_getpNext, NULL, "", NULL},
        
            {"handleTypes", (getter)PyVkExportMemoryAllocateInfoNV_gethandleTypes, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkImportMemoryWin32HandleInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkImportMemoryWin32HandleInfoNV *self = (PyVkImportMemoryWin32HandleInfoNV *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkImportMemoryWin32HandleInfoNV));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkImportMemoryWin32HandleInfoNV");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkImportMemoryWin32HandleInfoNV_del(PyVkImportMemoryWin32HandleInfoNV* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkImportMemoryWin32HandleInfoNV_init(PyVkImportMemoryWin32HandleInfoNV *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
VkExternalMemoryHandleTypeFlagsNV handleType;
HANDLE handle;

            static char *kwlist[] = {"sType","handleType","handle",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_flag_base_VkExternalMemoryHandleTypeFlagsNV_converter,&handleType,pyc_HANDLE_converter,&handle))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->handleType = handleType;
            
            
            
                (self->base)->handle = handle;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_flag_base_VkExternalMemoryHandleTypeFlagsNV_converter_free(&handleType);
pyc_HANDLE_converter_free(&handle);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkImportMemoryWin32HandleInfoNV_getsType(PyVkImportMemoryWin32HandleInfoNV *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImportMemoryWin32HandleInfoNV_getpNext(PyVkImportMemoryWin32HandleInfoNV *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImportMemoryWin32HandleInfoNV_gethandleType(PyVkImportMemoryWin32HandleInfoNV *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->handleType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkImportMemoryWin32HandleInfoNV_gethandle(PyVkImportMemoryWin32HandleInfoNV *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkImportMemoryWin32HandleInfoNV_getsetters[] = {
        
            {"sType", (getter)PyVkImportMemoryWin32HandleInfoNV_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkImportMemoryWin32HandleInfoNV_getpNext, NULL, "", NULL},
        
            {"handleType", (getter)PyVkImportMemoryWin32HandleInfoNV_gethandleType, NULL, "", NULL},
        
            {"handle", (getter)PyVkImportMemoryWin32HandleInfoNV_gethandle, NULL, "", NULL},
        
        {NULL}
    };




    
     #endif 


    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkExportMemoryWin32HandleInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkExportMemoryWin32HandleInfoNV *self = (PyVkExportMemoryWin32HandleInfoNV *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkExportMemoryWin32HandleInfoNV));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkExportMemoryWin32HandleInfoNV");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkExportMemoryWin32HandleInfoNV_del(PyVkExportMemoryWin32HandleInfoNV* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkExportMemoryWin32HandleInfoNV_init(PyVkExportMemoryWin32HandleInfoNV *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
SECURITY_ATTRIBUTES * pAttributes;
DWORD dwAccess;

            static char *kwlist[] = {"sType","pAttributes","dwAccess",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_SECURITY_ATTRIBUTES_x_converter,&pAttributes,pyc_DWORD_converter,&dwAccess))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->pAttributes = pAttributes;
            
            
            
                (self->base)->dwAccess = dwAccess;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_SECURITY_ATTRIBUTES_x_converter_free(&pAttributes);
pyc_DWORD_converter_free(&dwAccess);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkExportMemoryWin32HandleInfoNV_getsType(PyVkExportMemoryWin32HandleInfoNV *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkExportMemoryWin32HandleInfoNV_getpNext(PyVkExportMemoryWin32HandleInfoNV *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkExportMemoryWin32HandleInfoNV_getpAttributes(PyVkExportMemoryWin32HandleInfoNV *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkExportMemoryWin32HandleInfoNV_getdwAccess(PyVkExportMemoryWin32HandleInfoNV *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkExportMemoryWin32HandleInfoNV_getsetters[] = {
        
            {"sType", (getter)PyVkExportMemoryWin32HandleInfoNV_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkExportMemoryWin32HandleInfoNV_getpNext, NULL, "", NULL},
        
            {"pAttributes", (getter)PyVkExportMemoryWin32HandleInfoNV_getpAttributes, NULL, "", NULL},
        
            {"dwAccess", (getter)PyVkExportMemoryWin32HandleInfoNV_getdwAccess, NULL, "", NULL},
        
        {NULL}
    };




    
     #endif 


    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkWin32KeyedMutexAcquireReleaseInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkWin32KeyedMutexAcquireReleaseInfoNV *self = (PyVkWin32KeyedMutexAcquireReleaseInfoNV *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkWin32KeyedMutexAcquireReleaseInfoNV));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkWin32KeyedMutexAcquireReleaseInfoNV");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkWin32KeyedMutexAcquireReleaseInfoNV_del(PyVkWin32KeyedMutexAcquireReleaseInfoNV* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
    static int PyVkWin32KeyedMutexAcquireReleaseInfoNV_init(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, PyObject *args, PyObject *kwds) {
        
            VkStructureType sType;
uint32_t acquireCount;
VkDeviceMemory* pAcquireSyncs;
uint64_t* pAcquireKeys;
uint32_t* pAcquireTimeoutMilliseconds;
uint32_t releaseCount;
VkDeviceMemory* pReleaseSyncs;
uint64_t* pReleaseKeys;

            static char *kwlist[] = {"sType","acquireCount","pAcquireSyncs","pAcquireKeys","pAcquireTimeoutMilliseconds","releaseCount","pReleaseSyncs","pReleaseKeys",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&", kwlist, pyc_flag_base_VkStructureType_converter,&sType,pyc_uint32_t_converter,&acquireCount,pyc_handle_array_VkDeviceMemory_converter,&pAcquireSyncs,pyc_array_uint64_t_converter,&pAcquireKeys,pyc_array_uint32_t_converter,&pAcquireTimeoutMilliseconds,pyc_uint32_t_converter,&releaseCount,pyc_handle_array_VkDeviceMemory_converter,&pReleaseSyncs,pyc_array_uint64_t_converter,&pReleaseKeys))
        return -1;
    

            
            
                (self->base)->sType = sType;
            
            
            
                (self->base)->pNext = NULL;
            
            
            
                (self->base)->acquireCount = acquireCount;
            
            
            
                (self->base)->pAcquireSyncs = pAcquireSyncs;
            
            
            
                (self->base)->pAcquireKeys = pAcquireKeys;
            
            
            
                (self->base)->pAcquireTimeoutMilliseconds = pAcquireTimeoutMilliseconds;
            
            
            
                (self->base)->releaseCount = releaseCount;
            
            
            
                (self->base)->pReleaseSyncs = pReleaseSyncs;
            
            
            
                (self->base)->pReleaseKeys = pReleaseKeys;
            
            

            pyc_flag_base_VkStructureType_converter_free(&sType);
pyc_uint32_t_converter_free(&acquireCount);
pyc_handle_array_VkDeviceMemory_converter_free(&pAcquireSyncs);
pyc_array_uint64_t_converter_free(&pAcquireKeys);
pyc_array_uint32_t_converter_free(&pAcquireTimeoutMilliseconds);
pyc_uint32_t_converter_free(&releaseCount);
pyc_handle_array_VkDeviceMemory_converter_free(&pReleaseSyncs);
pyc_array_uint64_t_converter_free(&pReleaseKeys);

        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkWin32KeyedMutexAcquireReleaseInfoNV_getsType(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong(((self->base)->sType));
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpNext(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure) {
            
            
                
        Py_INCREF(Py_None);
        PyObject* pyvalue = Py_None;
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWin32KeyedMutexAcquireReleaseInfoNV_getacquireCount(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->acquireCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpAcquireSyncs(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpAcquireKeys(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpAcquireTimeoutMilliseconds(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyLong_FromLong((long) (*(((self->base)->pAcquireTimeoutMilliseconds))));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWin32KeyedMutexAcquireReleaseInfoNV_getreleaseCount(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure) {
            
            
                
            PyObject* pyvalue = PyLong_FromLong((long) ((self->base)->releaseCount));
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpReleaseSyncs(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    
        static PyObject* PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpReleaseKeys(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure) {
            
            
                PyErr_SetString(PyExc_ImportError, "Not Implemented, ask to the maintener");
                return NULL;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkWin32KeyedMutexAcquireReleaseInfoNV_getsetters[] = {
        
            {"sType", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getsType, NULL, "", NULL},
        
            {"pNext", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpNext, NULL, "", NULL},
        
            {"acquireCount", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getacquireCount, NULL, "", NULL},
        
            {"pAcquireSyncs", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpAcquireSyncs, NULL, "", NULL},
        
            {"pAcquireKeys", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpAcquireKeys, NULL, "", NULL},
        
            {"pAcquireTimeoutMilliseconds", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpAcquireTimeoutMilliseconds, NULL, "", NULL},
        
            {"releaseCount", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getreleaseCount, NULL, "", NULL},
        
            {"pReleaseSyncs", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpReleaseSyncs, NULL, "", NULL},
        
            {"pReleaseKeys", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpReleaseKeys, NULL, "", NULL},
        
        {NULL}
    };




    
     #endif 


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkClearColorValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkClearColorValue *self = (PyVkClearColorValue *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkClearColorValue));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkClearColorValue");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkClearColorValue_del(PyVkClearColorValue* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
        static int PyVkClearColorValue_init(PyVkClearColorValue *self, PyObject *args, PyObject *kwds) {
    PyObject* float32 = NULL;
    PyObject* int32 = NULL;
    PyObject* uint32 = NULL;

    static char *kwlist[] = {"float32","int32","uint32",NULL};

    if( !PyArg_ParseTupleAndKeywords(args, kwds, "|OOO", kwlist, &float32,&int32,&uint32))
        return -1;

     if (float32 != NULL) {
        float* c_float32 = NULL;
        if (float32 == Py_None) {
            c_float32 = VK_NULL_HANDLE;
        }
        else if (PyBytes_CheckExact(float32)) {
            c_float32 = (float*) PyBytes_AsString(float32);
        }
        else {
            int size = PyList_Size(float32);
            c_float32 = malloc(sizeof(float) * size);
            int i;
            for (i = 0; i < size; i++) {
                float r = (float) PyFloat_AsDouble(
                    PyList_GetItem(float32, i));
                memcpy(c_float32 + i, &r, sizeof(float));
            }
        }

        memcpy((self->base)->float32, c_float32, 4 * sizeof(float));
    }

    if (int32 != NULL) {
        int32_t* c_int32 = NULL;
        if (int32 == Py_None) {
            c_int32 = VK_NULL_HANDLE;
        }
        else if (PyBytes_CheckExact(int32)) {
            c_int32 = (int32_t*) PyBytes_AsString(int32);
        }
        else {
            int size = PyList_Size(int32);
            c_int32 = malloc(sizeof(int32_t) * size);
            int i;
            for (i = 0; i < size; i++) {
                int32_t r = (int32_t) PyLong_AsLong(
                    PyList_GetItem(int32, i));
                memcpy(c_int32 + i, &r, sizeof(int32_t));
            }
        }
        memcpy((self->base)->int32, c_int32, 4 * sizeof(int32_t));
             }

             if (uint32 != NULL) {
        uint32_t* c_uint32 = NULL;
        if (uint32 == Py_None) {
            c_uint32 = VK_NULL_HANDLE;
        }
        else if (PyBytes_CheckExact(uint32)) {
            c_uint32 = (uint32_t*) PyBytes_AsString(uint32);
        }
        else {
            int size = PyList_Size(uint32);
            c_uint32 = malloc(sizeof(uint32_t) * size);
            int i;
            for (i = 0; i < size; i++) {
                uint32_t r = (uint32_t) PyLong_AsLong(
                    PyList_GetItem(uint32, i));
                memcpy(c_uint32 + i, &r, sizeof(uint32_t));
            }
        }
        memcpy((self->base)->uint32, c_uint32, 4 * sizeof(uint32_t));
             }
        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkClearColorValue_getfloat32(PyVkClearColorValue *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyList_New(0);
        int nb = sizeof(((self->base)->float32)) / sizeof(((self->base)->float32)[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* tmp = PyFloat_FromDouble((double) ((self->base)->float32)[i]);
            PyList_Append(pyvalue, tmp);
        }
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkClearColorValue_getint32(PyVkClearColorValue *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyList_New(0);
        int nb = sizeof(((self->base)->int32)) / sizeof(((self->base)->int32)[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* tmp = PyLong_FromLong((long) ((self->base)->int32)[i]);
            PyList_Append(pyvalue, tmp);
        }
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkClearColorValue_getuint32(PyVkClearColorValue *self, void *closure) {
            
            
                
        PyObject* pyvalue = PyList_New(0);
        int nb = sizeof(((self->base)->uint32)) / sizeof(((self->base)->uint32)[0]);
        int i = 0;
        for (i = 0; i < nb; i++) {
            PyObject* tmp = PyLong_FromLong((long) ((self->base)->uint32)[i]);
            PyList_Append(pyvalue, tmp);
        }
        
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkClearColorValue_getsetters[] = {
        
            {"float32", (getter)PyVkClearColorValue_getfloat32, NULL, "", NULL},
        
            {"int32", (getter)PyVkClearColorValue_getint32, NULL, "", NULL},
        
            {"uint32", (getter)PyVkClearColorValue_getuint32, NULL, "", NULL},
        
        {NULL}
    };




    
    


    
    
        


    // ----------
    // New
    // ----------
    static PyObject * PyVkClearValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyVkClearValue *self = (PyVkClearValue *)type->tp_alloc(type, 0);
        if (self == NULL) return NULL;
        self->base = malloc(sizeof(VkClearValue));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError, "Cannot allocate memory for VkClearValue");
            return NULL;
        }

        return (PyObject *)self;
    }


    // ----------
    // Del
    // ---------
    static void PyVkClearValue_del(PyVkClearValue* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }


    // ----------
    // Init
    // ----------
    
    
        static int PyVkClearValue_init(PyVkClearValue *self, PyObject *args, PyObject *kwds) {
        
            PyObject* color = NULL;
PyObject* depthStencil = NULL;

            static char *kwlist[] = {"color","depthStencil",NULL};
            
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "|OO", kwlist, &color,&depthStencil))
        return 0;
    

            
             if (color != NULL) { 
                    
                    
                    
                        
                VkClearColorValue c_color = *(((PyVkClearColorValue*)color)->base);
                
                        (self->base)->color = c_color;
                    
             } 
            
             if (depthStencil != NULL) { 
                    
                    
                    
                        
                VkClearDepthStencilValue c_depthStencil = *(((PyVkClearDepthStencilValue*)depthStencil)->base);
                
                        (self->base)->depthStencil = c_depthStencil;
                    
             } 
            
        

        return 0;
    }
    


    // ----------
    // Get
    // ----------
    
        static PyObject* PyVkClearValue_getcolor(PyVkClearValue *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkClearColorValueType);
            if (!pyvalue)
                return NULL;
            ((PyVkClearColorValue*) pyvalue)->base = &((self->base)->color);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    
        static PyObject* PyVkClearValue_getdepthStencil(PyVkClearValue *self, void *closure) {
            
            
                
            PyObject* pyvalue = _PyObject_New(&PyVkClearDepthStencilValueType);
            if (!pyvalue)
                return NULL;
            ((PyVkClearDepthStencilValue*) pyvalue)->base = &((self->base)->depthStencil);
            
                Py_INCREF(pyvalue);
                return pyvalue;
            
        }
    


    // ----------
    // PyGetSetDef
    // ----------
    static PyGetSetDef PyVkClearValue_getsetters[] = {
        
            {"color", (getter)PyVkClearValue_getcolor, NULL, "", NULL},
        
            {"depthStencil", (getter)PyVkClearValue_getdepthStencil, NULL, "", NULL},
        
        {NULL}
    };




    
    



// PyType objects are declared in a function because there are
// initialized in the main function.
// All the pytype signatures are create before.
void init_pytype_objects(void) {
    
        
    
        
            PyVkOffset2DType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkOffset2D", sizeof(PyVkOffset2D), 0,
                (destructor)PyVkOffset2D_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkOffset2D object",0,0,0,0,0,0,0,0,
                PyVkOffset2D_getsetters,0,0,0,0,0,
                (initproc)PyVkOffset2D_init,0,PyVkOffset2D_new,
            };
        
    

    
        
    
        
            PyVkOffset3DType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkOffset3D", sizeof(PyVkOffset3D), 0,
                (destructor)PyVkOffset3D_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkOffset3D object",0,0,0,0,0,0,0,0,
                PyVkOffset3D_getsetters,0,0,0,0,0,
                (initproc)PyVkOffset3D_init,0,PyVkOffset3D_new,
            };
        
    

    
        
    
        
            PyVkExtent2DType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkExtent2D", sizeof(PyVkExtent2D), 0,
                (destructor)PyVkExtent2D_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkExtent2D object",0,0,0,0,0,0,0,0,
                PyVkExtent2D_getsetters,0,0,0,0,0,
                (initproc)PyVkExtent2D_init,0,PyVkExtent2D_new,
            };
        
    

    
        
    
        
            PyVkExtent3DType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkExtent3D", sizeof(PyVkExtent3D), 0,
                (destructor)PyVkExtent3D_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkExtent3D object",0,0,0,0,0,0,0,0,
                PyVkExtent3D_getsetters,0,0,0,0,0,
                (initproc)PyVkExtent3D_init,0,PyVkExtent3D_new,
            };
        
    

    
        
    
        
            PyVkViewportType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkViewport", sizeof(PyVkViewport), 0,
                (destructor)PyVkViewport_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkViewport object",0,0,0,0,0,0,0,0,
                PyVkViewport_getsetters,0,0,0,0,0,
                (initproc)PyVkViewport_init,0,PyVkViewport_new,
            };
        
    

    
        
    
        
            PyVkRect2DType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkRect2D", sizeof(PyVkRect2D), 0,
                (destructor)PyVkRect2D_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkRect2D object",0,0,0,0,0,0,0,0,
                PyVkRect2D_getsetters,0,0,0,0,0,
                (initproc)PyVkRect2D_init,0,PyVkRect2D_new,
            };
        
    

    
        
     #ifdef hackdefine 
        
            PyVkRect3DType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkRect3D", sizeof(PyVkRect3D), 0,
                (destructor)PyVkRect3D_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkRect3D object",0,0,0,0,0,0,0,0,
                PyVkRect3D_getsetters,0,0,0,0,0,
                (initproc)PyVkRect3D_init,0,PyVkRect3D_new,
            };
        
     #endif 

    
        
    
        
            PyVkClearRectType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkClearRect", sizeof(PyVkClearRect), 0,
                (destructor)PyVkClearRect_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkClearRect object",0,0,0,0,0,0,0,0,
                PyVkClearRect_getsetters,0,0,0,0,0,
                (initproc)PyVkClearRect_init,0,PyVkClearRect_new,
            };
        
    

    
        
    
        
            PyVkComponentMappingType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkComponentMapping", sizeof(PyVkComponentMapping), 0,
                (destructor)PyVkComponentMapping_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkComponentMapping object",0,0,0,0,0,0,0,0,
                PyVkComponentMapping_getsetters,0,0,0,0,0,
                (initproc)PyVkComponentMapping_init,0,PyVkComponentMapping_new,
            };
        
    

    
        
    
        
            PyVkPhysicalDevicePropertiesType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPhysicalDeviceProperties", sizeof(PyVkPhysicalDeviceProperties), 0,
                (destructor)PyVkPhysicalDeviceProperties_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPhysicalDeviceProperties object",0,0,0,0,0,0,0,0,
                PyVkPhysicalDeviceProperties_getsetters,0,0,0,0,0,
                (initproc)PyVkPhysicalDeviceProperties_init,0,PyVkPhysicalDeviceProperties_new,
            };
        
    

    
        
    
        
            PyVkExtensionPropertiesType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkExtensionProperties", sizeof(PyVkExtensionProperties), 0,
                (destructor)PyVkExtensionProperties_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkExtensionProperties object",0,0,0,0,0,0,0,0,
                PyVkExtensionProperties_getsetters,0,0,0,0,0,
                (initproc)PyVkExtensionProperties_init,0,PyVkExtensionProperties_new,
            };
        
    

    
        
    
        
            PyVkLayerPropertiesType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkLayerProperties", sizeof(PyVkLayerProperties), 0,
                (destructor)PyVkLayerProperties_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkLayerProperties object",0,0,0,0,0,0,0,0,
                PyVkLayerProperties_getsetters,0,0,0,0,0,
                (initproc)PyVkLayerProperties_init,0,PyVkLayerProperties_new,
            };
        
    

    
        
    
        
            PyVkApplicationInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkApplicationInfo", sizeof(PyVkApplicationInfo), 0,
                (destructor)PyVkApplicationInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkApplicationInfo object",0,0,0,0,0,0,0,0,
                PyVkApplicationInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkApplicationInfo_init,0,PyVkApplicationInfo_new,
            };
        
    

    
        
    
        
            PyVkAllocationCallbacksType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkAllocationCallbacks", sizeof(PyVkAllocationCallbacks), 0,
                (destructor)PyVkAllocationCallbacks_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkAllocationCallbacks object",0,0,0,0,0,0,0,0,
                PyVkAllocationCallbacks_getsetters,0,0,0,0,0,
                (initproc)PyVkAllocationCallbacks_init,0,PyVkAllocationCallbacks_new,
            };
        
    

    
        
    
        
            PyVkDeviceQueueCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDeviceQueueCreateInfo", sizeof(PyVkDeviceQueueCreateInfo), 0,
                (destructor)PyVkDeviceQueueCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDeviceQueueCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkDeviceQueueCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkDeviceQueueCreateInfo_init,0,PyVkDeviceQueueCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkDeviceCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDeviceCreateInfo", sizeof(PyVkDeviceCreateInfo), 0,
                (destructor)PyVkDeviceCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDeviceCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkDeviceCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkDeviceCreateInfo_init,0,PyVkDeviceCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkInstanceCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkInstanceCreateInfo", sizeof(PyVkInstanceCreateInfo), 0,
                (destructor)PyVkInstanceCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkInstanceCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkInstanceCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkInstanceCreateInfo_init,0,PyVkInstanceCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkQueueFamilyPropertiesType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkQueueFamilyProperties", sizeof(PyVkQueueFamilyProperties), 0,
                (destructor)PyVkQueueFamilyProperties_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkQueueFamilyProperties object",0,0,0,0,0,0,0,0,
                PyVkQueueFamilyProperties_getsetters,0,0,0,0,0,
                (initproc)PyVkQueueFamilyProperties_init,0,PyVkQueueFamilyProperties_new,
            };
        
    

    
        
    
        
            PyVkPhysicalDeviceMemoryPropertiesType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPhysicalDeviceMemoryProperties", sizeof(PyVkPhysicalDeviceMemoryProperties), 0,
                (destructor)PyVkPhysicalDeviceMemoryProperties_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPhysicalDeviceMemoryProperties object",0,0,0,0,0,0,0,0,
                PyVkPhysicalDeviceMemoryProperties_getsetters,0,0,0,0,0,
                (initproc)PyVkPhysicalDeviceMemoryProperties_init,0,PyVkPhysicalDeviceMemoryProperties_new,
            };
        
    

    
        
    
        
            PyVkMemoryAllocateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkMemoryAllocateInfo", sizeof(PyVkMemoryAllocateInfo), 0,
                (destructor)PyVkMemoryAllocateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkMemoryAllocateInfo object",0,0,0,0,0,0,0,0,
                PyVkMemoryAllocateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkMemoryAllocateInfo_init,0,PyVkMemoryAllocateInfo_new,
            };
        
    

    
        
    
        
            PyVkMemoryRequirementsType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkMemoryRequirements", sizeof(PyVkMemoryRequirements), 0,
                (destructor)PyVkMemoryRequirements_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkMemoryRequirements object",0,0,0,0,0,0,0,0,
                PyVkMemoryRequirements_getsetters,0,0,0,0,0,
                (initproc)PyVkMemoryRequirements_init,0,PyVkMemoryRequirements_new,
            };
        
    

    
        
    
        
            PyVkSparseImageFormatPropertiesType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSparseImageFormatProperties", sizeof(PyVkSparseImageFormatProperties), 0,
                (destructor)PyVkSparseImageFormatProperties_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSparseImageFormatProperties object",0,0,0,0,0,0,0,0,
                PyVkSparseImageFormatProperties_getsetters,0,0,0,0,0,
                (initproc)PyVkSparseImageFormatProperties_init,0,PyVkSparseImageFormatProperties_new,
            };
        
    

    
        
    
        
            PyVkSparseImageMemoryRequirementsType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSparseImageMemoryRequirements", sizeof(PyVkSparseImageMemoryRequirements), 0,
                (destructor)PyVkSparseImageMemoryRequirements_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSparseImageMemoryRequirements object",0,0,0,0,0,0,0,0,
                PyVkSparseImageMemoryRequirements_getsetters,0,0,0,0,0,
                (initproc)PyVkSparseImageMemoryRequirements_init,0,PyVkSparseImageMemoryRequirements_new,
            };
        
    

    
        
    
        
            PyVkMemoryTypeType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkMemoryType", sizeof(PyVkMemoryType), 0,
                (destructor)PyVkMemoryType_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkMemoryType object",0,0,0,0,0,0,0,0,
                PyVkMemoryType_getsetters,0,0,0,0,0,
                (initproc)PyVkMemoryType_init,0,PyVkMemoryType_new,
            };
        
    

    
        
    
        
            PyVkMemoryHeapType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkMemoryHeap", sizeof(PyVkMemoryHeap), 0,
                (destructor)PyVkMemoryHeap_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkMemoryHeap object",0,0,0,0,0,0,0,0,
                PyVkMemoryHeap_getsetters,0,0,0,0,0,
                (initproc)PyVkMemoryHeap_init,0,PyVkMemoryHeap_new,
            };
        
    

    
        
    
        
            PyVkMappedMemoryRangeType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkMappedMemoryRange", sizeof(PyVkMappedMemoryRange), 0,
                (destructor)PyVkMappedMemoryRange_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkMappedMemoryRange object",0,0,0,0,0,0,0,0,
                PyVkMappedMemoryRange_getsetters,0,0,0,0,0,
                (initproc)PyVkMappedMemoryRange_init,0,PyVkMappedMemoryRange_new,
            };
        
    

    
        
    
        
            PyVkFormatPropertiesType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkFormatProperties", sizeof(PyVkFormatProperties), 0,
                (destructor)PyVkFormatProperties_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkFormatProperties object",0,0,0,0,0,0,0,0,
                PyVkFormatProperties_getsetters,0,0,0,0,0,
                (initproc)PyVkFormatProperties_init,0,PyVkFormatProperties_new,
            };
        
    

    
        
    
        
            PyVkImageFormatPropertiesType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageFormatProperties", sizeof(PyVkImageFormatProperties), 0,
                (destructor)PyVkImageFormatProperties_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageFormatProperties object",0,0,0,0,0,0,0,0,
                PyVkImageFormatProperties_getsetters,0,0,0,0,0,
                (initproc)PyVkImageFormatProperties_init,0,PyVkImageFormatProperties_new,
            };
        
    

    
        
    
        
            PyVkDescriptorBufferInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDescriptorBufferInfo", sizeof(PyVkDescriptorBufferInfo), 0,
                (destructor)PyVkDescriptorBufferInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDescriptorBufferInfo object",0,0,0,0,0,0,0,0,
                PyVkDescriptorBufferInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkDescriptorBufferInfo_init,0,PyVkDescriptorBufferInfo_new,
            };
        
    

    
        
    
        
            PyVkDescriptorImageInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDescriptorImageInfo", sizeof(PyVkDescriptorImageInfo), 0,
                (destructor)PyVkDescriptorImageInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDescriptorImageInfo object",0,0,0,0,0,0,0,0,
                PyVkDescriptorImageInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkDescriptorImageInfo_init,0,PyVkDescriptorImageInfo_new,
            };
        
    

    
        
    
        
            PyVkWriteDescriptorSetType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkWriteDescriptorSet", sizeof(PyVkWriteDescriptorSet), 0,
                (destructor)PyVkWriteDescriptorSet_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkWriteDescriptorSet object",0,0,0,0,0,0,0,0,
                PyVkWriteDescriptorSet_getsetters,0,0,0,0,0,
                (initproc)PyVkWriteDescriptorSet_init,0,PyVkWriteDescriptorSet_new,
            };
        
    

    
        
    
        
            PyVkCopyDescriptorSetType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkCopyDescriptorSet", sizeof(PyVkCopyDescriptorSet), 0,
                (destructor)PyVkCopyDescriptorSet_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkCopyDescriptorSet object",0,0,0,0,0,0,0,0,
                PyVkCopyDescriptorSet_getsetters,0,0,0,0,0,
                (initproc)PyVkCopyDescriptorSet_init,0,PyVkCopyDescriptorSet_new,
            };
        
    

    
        
    
        
            PyVkBufferCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkBufferCreateInfo", sizeof(PyVkBufferCreateInfo), 0,
                (destructor)PyVkBufferCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkBufferCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkBufferCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkBufferCreateInfo_init,0,PyVkBufferCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkBufferViewCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkBufferViewCreateInfo", sizeof(PyVkBufferViewCreateInfo), 0,
                (destructor)PyVkBufferViewCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkBufferViewCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkBufferViewCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkBufferViewCreateInfo_init,0,PyVkBufferViewCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkImageSubresourceType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageSubresource", sizeof(PyVkImageSubresource), 0,
                (destructor)PyVkImageSubresource_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageSubresource object",0,0,0,0,0,0,0,0,
                PyVkImageSubresource_getsetters,0,0,0,0,0,
                (initproc)PyVkImageSubresource_init,0,PyVkImageSubresource_new,
            };
        
    

    
        
    
        
            PyVkImageSubresourceLayersType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageSubresourceLayers", sizeof(PyVkImageSubresourceLayers), 0,
                (destructor)PyVkImageSubresourceLayers_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageSubresourceLayers object",0,0,0,0,0,0,0,0,
                PyVkImageSubresourceLayers_getsetters,0,0,0,0,0,
                (initproc)PyVkImageSubresourceLayers_init,0,PyVkImageSubresourceLayers_new,
            };
        
    

    
        
    
        
            PyVkImageSubresourceRangeType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageSubresourceRange", sizeof(PyVkImageSubresourceRange), 0,
                (destructor)PyVkImageSubresourceRange_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageSubresourceRange object",0,0,0,0,0,0,0,0,
                PyVkImageSubresourceRange_getsetters,0,0,0,0,0,
                (initproc)PyVkImageSubresourceRange_init,0,PyVkImageSubresourceRange_new,
            };
        
    

    
        
    
        
            PyVkMemoryBarrierType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkMemoryBarrier", sizeof(PyVkMemoryBarrier), 0,
                (destructor)PyVkMemoryBarrier_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkMemoryBarrier object",0,0,0,0,0,0,0,0,
                PyVkMemoryBarrier_getsetters,0,0,0,0,0,
                (initproc)PyVkMemoryBarrier_init,0,PyVkMemoryBarrier_new,
            };
        
    

    
        
    
        
            PyVkBufferMemoryBarrierType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkBufferMemoryBarrier", sizeof(PyVkBufferMemoryBarrier), 0,
                (destructor)PyVkBufferMemoryBarrier_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkBufferMemoryBarrier object",0,0,0,0,0,0,0,0,
                PyVkBufferMemoryBarrier_getsetters,0,0,0,0,0,
                (initproc)PyVkBufferMemoryBarrier_init,0,PyVkBufferMemoryBarrier_new,
            };
        
    

    
        
    
        
            PyVkImageMemoryBarrierType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageMemoryBarrier", sizeof(PyVkImageMemoryBarrier), 0,
                (destructor)PyVkImageMemoryBarrier_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageMemoryBarrier object",0,0,0,0,0,0,0,0,
                PyVkImageMemoryBarrier_getsetters,0,0,0,0,0,
                (initproc)PyVkImageMemoryBarrier_init,0,PyVkImageMemoryBarrier_new,
            };
        
    

    
        
    
        
            PyVkImageCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageCreateInfo", sizeof(PyVkImageCreateInfo), 0,
                (destructor)PyVkImageCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkImageCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkImageCreateInfo_init,0,PyVkImageCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkSubresourceLayoutType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSubresourceLayout", sizeof(PyVkSubresourceLayout), 0,
                (destructor)PyVkSubresourceLayout_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSubresourceLayout object",0,0,0,0,0,0,0,0,
                PyVkSubresourceLayout_getsetters,0,0,0,0,0,
                (initproc)PyVkSubresourceLayout_init,0,PyVkSubresourceLayout_new,
            };
        
    

    
        
    
        
            PyVkImageViewCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageViewCreateInfo", sizeof(PyVkImageViewCreateInfo), 0,
                (destructor)PyVkImageViewCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageViewCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkImageViewCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkImageViewCreateInfo_init,0,PyVkImageViewCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkBufferCopyType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkBufferCopy", sizeof(PyVkBufferCopy), 0,
                (destructor)PyVkBufferCopy_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkBufferCopy object",0,0,0,0,0,0,0,0,
                PyVkBufferCopy_getsetters,0,0,0,0,0,
                (initproc)PyVkBufferCopy_init,0,PyVkBufferCopy_new,
            };
        
    

    
        
    
        
            PyVkSparseMemoryBindType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSparseMemoryBind", sizeof(PyVkSparseMemoryBind), 0,
                (destructor)PyVkSparseMemoryBind_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSparseMemoryBind object",0,0,0,0,0,0,0,0,
                PyVkSparseMemoryBind_getsetters,0,0,0,0,0,
                (initproc)PyVkSparseMemoryBind_init,0,PyVkSparseMemoryBind_new,
            };
        
    

    
        
    
        
            PyVkSparseImageMemoryBindType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSparseImageMemoryBind", sizeof(PyVkSparseImageMemoryBind), 0,
                (destructor)PyVkSparseImageMemoryBind_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSparseImageMemoryBind object",0,0,0,0,0,0,0,0,
                PyVkSparseImageMemoryBind_getsetters,0,0,0,0,0,
                (initproc)PyVkSparseImageMemoryBind_init,0,PyVkSparseImageMemoryBind_new,
            };
        
    

    
        
    
        
            PyVkSparseBufferMemoryBindInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSparseBufferMemoryBindInfo", sizeof(PyVkSparseBufferMemoryBindInfo), 0,
                (destructor)PyVkSparseBufferMemoryBindInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSparseBufferMemoryBindInfo object",0,0,0,0,0,0,0,0,
                PyVkSparseBufferMemoryBindInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkSparseBufferMemoryBindInfo_init,0,PyVkSparseBufferMemoryBindInfo_new,
            };
        
    

    
        
    
        
            PyVkSparseImageOpaqueMemoryBindInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSparseImageOpaqueMemoryBindInfo", sizeof(PyVkSparseImageOpaqueMemoryBindInfo), 0,
                (destructor)PyVkSparseImageOpaqueMemoryBindInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSparseImageOpaqueMemoryBindInfo object",0,0,0,0,0,0,0,0,
                PyVkSparseImageOpaqueMemoryBindInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkSparseImageOpaqueMemoryBindInfo_init,0,PyVkSparseImageOpaqueMemoryBindInfo_new,
            };
        
    

    
        
    
        
            PyVkSparseImageMemoryBindInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSparseImageMemoryBindInfo", sizeof(PyVkSparseImageMemoryBindInfo), 0,
                (destructor)PyVkSparseImageMemoryBindInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSparseImageMemoryBindInfo object",0,0,0,0,0,0,0,0,
                PyVkSparseImageMemoryBindInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkSparseImageMemoryBindInfo_init,0,PyVkSparseImageMemoryBindInfo_new,
            };
        
    

    
        
    
        
            PyVkBindSparseInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkBindSparseInfo", sizeof(PyVkBindSparseInfo), 0,
                (destructor)PyVkBindSparseInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkBindSparseInfo object",0,0,0,0,0,0,0,0,
                PyVkBindSparseInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkBindSparseInfo_init,0,PyVkBindSparseInfo_new,
            };
        
    

    
        
    
        
            PyVkImageCopyType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageCopy", sizeof(PyVkImageCopy), 0,
                (destructor)PyVkImageCopy_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageCopy object",0,0,0,0,0,0,0,0,
                PyVkImageCopy_getsetters,0,0,0,0,0,
                (initproc)PyVkImageCopy_init,0,PyVkImageCopy_new,
            };
        
    

    
        
    
        
            PyVkImageBlitType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageBlit", sizeof(PyVkImageBlit), 0,
                (destructor)PyVkImageBlit_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageBlit object",0,0,0,0,0,0,0,0,
                PyVkImageBlit_getsetters,0,0,0,0,0,
                (initproc)PyVkImageBlit_init,0,PyVkImageBlit_new,
            };
        
    

    
        
    
        
            PyVkBufferImageCopyType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkBufferImageCopy", sizeof(PyVkBufferImageCopy), 0,
                (destructor)PyVkBufferImageCopy_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkBufferImageCopy object",0,0,0,0,0,0,0,0,
                PyVkBufferImageCopy_getsetters,0,0,0,0,0,
                (initproc)PyVkBufferImageCopy_init,0,PyVkBufferImageCopy_new,
            };
        
    

    
        
    
        
            PyVkImageResolveType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImageResolve", sizeof(PyVkImageResolve), 0,
                (destructor)PyVkImageResolve_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImageResolve object",0,0,0,0,0,0,0,0,
                PyVkImageResolve_getsetters,0,0,0,0,0,
                (initproc)PyVkImageResolve_init,0,PyVkImageResolve_new,
            };
        
    

    
        
    
        
            PyVkShaderModuleCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkShaderModuleCreateInfo", sizeof(PyVkShaderModuleCreateInfo), 0,
                (destructor)PyVkShaderModuleCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkShaderModuleCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkShaderModuleCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkShaderModuleCreateInfo_init,0,PyVkShaderModuleCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkDescriptorSetLayoutBindingType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDescriptorSetLayoutBinding", sizeof(PyVkDescriptorSetLayoutBinding), 0,
                (destructor)PyVkDescriptorSetLayoutBinding_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDescriptorSetLayoutBinding object",0,0,0,0,0,0,0,0,
                PyVkDescriptorSetLayoutBinding_getsetters,0,0,0,0,0,
                (initproc)PyVkDescriptorSetLayoutBinding_init,0,PyVkDescriptorSetLayoutBinding_new,
            };
        
    

    
        
    
        
            PyVkDescriptorSetLayoutCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDescriptorSetLayoutCreateInfo", sizeof(PyVkDescriptorSetLayoutCreateInfo), 0,
                (destructor)PyVkDescriptorSetLayoutCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDescriptorSetLayoutCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkDescriptorSetLayoutCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkDescriptorSetLayoutCreateInfo_init,0,PyVkDescriptorSetLayoutCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkDescriptorPoolSizeType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDescriptorPoolSize", sizeof(PyVkDescriptorPoolSize), 0,
                (destructor)PyVkDescriptorPoolSize_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDescriptorPoolSize object",0,0,0,0,0,0,0,0,
                PyVkDescriptorPoolSize_getsetters,0,0,0,0,0,
                (initproc)PyVkDescriptorPoolSize_init,0,PyVkDescriptorPoolSize_new,
            };
        
    

    
        
    
        
            PyVkDescriptorPoolCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDescriptorPoolCreateInfo", sizeof(PyVkDescriptorPoolCreateInfo), 0,
                (destructor)PyVkDescriptorPoolCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDescriptorPoolCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkDescriptorPoolCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkDescriptorPoolCreateInfo_init,0,PyVkDescriptorPoolCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkDescriptorSetAllocateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDescriptorSetAllocateInfo", sizeof(PyVkDescriptorSetAllocateInfo), 0,
                (destructor)PyVkDescriptorSetAllocateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDescriptorSetAllocateInfo object",0,0,0,0,0,0,0,0,
                PyVkDescriptorSetAllocateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkDescriptorSetAllocateInfo_init,0,PyVkDescriptorSetAllocateInfo_new,
            };
        
    

    
        
    
        
            PyVkSpecializationMapEntryType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSpecializationMapEntry", sizeof(PyVkSpecializationMapEntry), 0,
                (destructor)PyVkSpecializationMapEntry_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSpecializationMapEntry object",0,0,0,0,0,0,0,0,
                PyVkSpecializationMapEntry_getsetters,0,0,0,0,0,
                (initproc)PyVkSpecializationMapEntry_init,0,PyVkSpecializationMapEntry_new,
            };
        
    

    
        
    
        
            PyVkSpecializationInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSpecializationInfo", sizeof(PyVkSpecializationInfo), 0,
                (destructor)PyVkSpecializationInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSpecializationInfo object",0,0,0,0,0,0,0,0,
                PyVkSpecializationInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkSpecializationInfo_init,0,PyVkSpecializationInfo_new,
            };
        
    

    
        
    
        
            PyVkPipelineShaderStageCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineShaderStageCreateInfo", sizeof(PyVkPipelineShaderStageCreateInfo), 0,
                (destructor)PyVkPipelineShaderStageCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineShaderStageCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineShaderStageCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkPipelineShaderStageCreateInfo_init,0,PyVkPipelineShaderStageCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkComputePipelineCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkComputePipelineCreateInfo", sizeof(PyVkComputePipelineCreateInfo), 0,
                (destructor)PyVkComputePipelineCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkComputePipelineCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkComputePipelineCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkComputePipelineCreateInfo_init,0,PyVkComputePipelineCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkVertexInputBindingDescriptionType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkVertexInputBindingDescription", sizeof(PyVkVertexInputBindingDescription), 0,
                (destructor)PyVkVertexInputBindingDescription_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkVertexInputBindingDescription object",0,0,0,0,0,0,0,0,
                PyVkVertexInputBindingDescription_getsetters,0,0,0,0,0,
                (initproc)PyVkVertexInputBindingDescription_init,0,PyVkVertexInputBindingDescription_new,
            };
        
    

    
        
    
        
            PyVkVertexInputAttributeDescriptionType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkVertexInputAttributeDescription", sizeof(PyVkVertexInputAttributeDescription), 0,
                (destructor)PyVkVertexInputAttributeDescription_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkVertexInputAttributeDescription object",0,0,0,0,0,0,0,0,
                PyVkVertexInputAttributeDescription_getsetters,0,0,0,0,0,
                (initproc)PyVkVertexInputAttributeDescription_init,0,PyVkVertexInputAttributeDescription_new,
            };
        
    

    
        
    
        
            PyVkPipelineVertexInputStateCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineVertexInputStateCreateInfo", sizeof(PyVkPipelineVertexInputStateCreateInfo), 0,
                (destructor)PyVkPipelineVertexInputStateCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineVertexInputStateCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineVertexInputStateCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkPipelineVertexInputStateCreateInfo_init,0,PyVkPipelineVertexInputStateCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkPipelineInputAssemblyStateCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineInputAssemblyStateCreateInfo", sizeof(PyVkPipelineInputAssemblyStateCreateInfo), 0,
                (destructor)PyVkPipelineInputAssemblyStateCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineInputAssemblyStateCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineInputAssemblyStateCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkPipelineInputAssemblyStateCreateInfo_init,0,PyVkPipelineInputAssemblyStateCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkPipelineTessellationStateCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineTessellationStateCreateInfo", sizeof(PyVkPipelineTessellationStateCreateInfo), 0,
                (destructor)PyVkPipelineTessellationStateCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineTessellationStateCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineTessellationStateCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkPipelineTessellationStateCreateInfo_init,0,PyVkPipelineTessellationStateCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkPipelineViewportStateCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineViewportStateCreateInfo", sizeof(PyVkPipelineViewportStateCreateInfo), 0,
                (destructor)PyVkPipelineViewportStateCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineViewportStateCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineViewportStateCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkPipelineViewportStateCreateInfo_init,0,PyVkPipelineViewportStateCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkPipelineRasterizationStateCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineRasterizationStateCreateInfo", sizeof(PyVkPipelineRasterizationStateCreateInfo), 0,
                (destructor)PyVkPipelineRasterizationStateCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineRasterizationStateCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineRasterizationStateCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkPipelineRasterizationStateCreateInfo_init,0,PyVkPipelineRasterizationStateCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkPipelineMultisampleStateCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineMultisampleStateCreateInfo", sizeof(PyVkPipelineMultisampleStateCreateInfo), 0,
                (destructor)PyVkPipelineMultisampleStateCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineMultisampleStateCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineMultisampleStateCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkPipelineMultisampleStateCreateInfo_init,0,PyVkPipelineMultisampleStateCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkPipelineColorBlendAttachmentStateType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineColorBlendAttachmentState", sizeof(PyVkPipelineColorBlendAttachmentState), 0,
                (destructor)PyVkPipelineColorBlendAttachmentState_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineColorBlendAttachmentState object",0,0,0,0,0,0,0,0,
                PyVkPipelineColorBlendAttachmentState_getsetters,0,0,0,0,0,
                (initproc)PyVkPipelineColorBlendAttachmentState_init,0,PyVkPipelineColorBlendAttachmentState_new,
            };
        
    

    
        
    
        
            PyVkPipelineColorBlendStateCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineColorBlendStateCreateInfo", sizeof(PyVkPipelineColorBlendStateCreateInfo), 0,
                (destructor)PyVkPipelineColorBlendStateCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineColorBlendStateCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineColorBlendStateCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkPipelineColorBlendStateCreateInfo_init,0,PyVkPipelineColorBlendStateCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkPipelineDynamicStateCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineDynamicStateCreateInfo", sizeof(PyVkPipelineDynamicStateCreateInfo), 0,
                (destructor)PyVkPipelineDynamicStateCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineDynamicStateCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineDynamicStateCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkPipelineDynamicStateCreateInfo_init,0,PyVkPipelineDynamicStateCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkStencilOpStateType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkStencilOpState", sizeof(PyVkStencilOpState), 0,
                (destructor)PyVkStencilOpState_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkStencilOpState object",0,0,0,0,0,0,0,0,
                PyVkStencilOpState_getsetters,0,0,0,0,0,
                (initproc)PyVkStencilOpState_init,0,PyVkStencilOpState_new,
            };
        
    

    
        
    
        
            PyVkPipelineDepthStencilStateCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineDepthStencilStateCreateInfo", sizeof(PyVkPipelineDepthStencilStateCreateInfo), 0,
                (destructor)PyVkPipelineDepthStencilStateCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineDepthStencilStateCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineDepthStencilStateCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkPipelineDepthStencilStateCreateInfo_init,0,PyVkPipelineDepthStencilStateCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkGraphicsPipelineCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkGraphicsPipelineCreateInfo", sizeof(PyVkGraphicsPipelineCreateInfo), 0,
                (destructor)PyVkGraphicsPipelineCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkGraphicsPipelineCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkGraphicsPipelineCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkGraphicsPipelineCreateInfo_init,0,PyVkGraphicsPipelineCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkPipelineCacheCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineCacheCreateInfo", sizeof(PyVkPipelineCacheCreateInfo), 0,
                (destructor)PyVkPipelineCacheCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineCacheCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineCacheCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkPipelineCacheCreateInfo_init,0,PyVkPipelineCacheCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkPushConstantRangeType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPushConstantRange", sizeof(PyVkPushConstantRange), 0,
                (destructor)PyVkPushConstantRange_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPushConstantRange object",0,0,0,0,0,0,0,0,
                PyVkPushConstantRange_getsetters,0,0,0,0,0,
                (initproc)PyVkPushConstantRange_init,0,PyVkPushConstantRange_new,
            };
        
    

    
        
    
        
            PyVkPipelineLayoutCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineLayoutCreateInfo", sizeof(PyVkPipelineLayoutCreateInfo), 0,
                (destructor)PyVkPipelineLayoutCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineLayoutCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkPipelineLayoutCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkPipelineLayoutCreateInfo_init,0,PyVkPipelineLayoutCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkSamplerCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSamplerCreateInfo", sizeof(PyVkSamplerCreateInfo), 0,
                (destructor)PyVkSamplerCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSamplerCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkSamplerCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkSamplerCreateInfo_init,0,PyVkSamplerCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkCommandPoolCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkCommandPoolCreateInfo", sizeof(PyVkCommandPoolCreateInfo), 0,
                (destructor)PyVkCommandPoolCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkCommandPoolCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkCommandPoolCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkCommandPoolCreateInfo_init,0,PyVkCommandPoolCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkCommandBufferAllocateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkCommandBufferAllocateInfo", sizeof(PyVkCommandBufferAllocateInfo), 0,
                (destructor)PyVkCommandBufferAllocateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkCommandBufferAllocateInfo object",0,0,0,0,0,0,0,0,
                PyVkCommandBufferAllocateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkCommandBufferAllocateInfo_init,0,PyVkCommandBufferAllocateInfo_new,
            };
        
    

    
        
    
        
            PyVkCommandBufferInheritanceInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkCommandBufferInheritanceInfo", sizeof(PyVkCommandBufferInheritanceInfo), 0,
                (destructor)PyVkCommandBufferInheritanceInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkCommandBufferInheritanceInfo object",0,0,0,0,0,0,0,0,
                PyVkCommandBufferInheritanceInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkCommandBufferInheritanceInfo_init,0,PyVkCommandBufferInheritanceInfo_new,
            };
        
    

    
        
    
        
            PyVkCommandBufferBeginInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkCommandBufferBeginInfo", sizeof(PyVkCommandBufferBeginInfo), 0,
                (destructor)PyVkCommandBufferBeginInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkCommandBufferBeginInfo object",0,0,0,0,0,0,0,0,
                PyVkCommandBufferBeginInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkCommandBufferBeginInfo_init,0,PyVkCommandBufferBeginInfo_new,
            };
        
    

    
        
    
        
            PyVkRenderPassBeginInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkRenderPassBeginInfo", sizeof(PyVkRenderPassBeginInfo), 0,
                (destructor)PyVkRenderPassBeginInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkRenderPassBeginInfo object",0,0,0,0,0,0,0,0,
                PyVkRenderPassBeginInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkRenderPassBeginInfo_init,0,PyVkRenderPassBeginInfo_new,
            };
        
    

    
        
    
        
            PyVkClearDepthStencilValueType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkClearDepthStencilValue", sizeof(PyVkClearDepthStencilValue), 0,
                (destructor)PyVkClearDepthStencilValue_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkClearDepthStencilValue object",0,0,0,0,0,0,0,0,
                PyVkClearDepthStencilValue_getsetters,0,0,0,0,0,
                (initproc)PyVkClearDepthStencilValue_init,0,PyVkClearDepthStencilValue_new,
            };
        
    

    
        
    
        
            PyVkClearAttachmentType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkClearAttachment", sizeof(PyVkClearAttachment), 0,
                (destructor)PyVkClearAttachment_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkClearAttachment object",0,0,0,0,0,0,0,0,
                PyVkClearAttachment_getsetters,0,0,0,0,0,
                (initproc)PyVkClearAttachment_init,0,PyVkClearAttachment_new,
            };
        
    

    
        
    
        
            PyVkAttachmentDescriptionType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkAttachmentDescription", sizeof(PyVkAttachmentDescription), 0,
                (destructor)PyVkAttachmentDescription_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkAttachmentDescription object",0,0,0,0,0,0,0,0,
                PyVkAttachmentDescription_getsetters,0,0,0,0,0,
                (initproc)PyVkAttachmentDescription_init,0,PyVkAttachmentDescription_new,
            };
        
    

    
        
    
        
            PyVkAttachmentReferenceType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkAttachmentReference", sizeof(PyVkAttachmentReference), 0,
                (destructor)PyVkAttachmentReference_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkAttachmentReference object",0,0,0,0,0,0,0,0,
                PyVkAttachmentReference_getsetters,0,0,0,0,0,
                (initproc)PyVkAttachmentReference_init,0,PyVkAttachmentReference_new,
            };
        
    

    
        
    
        
            PyVkSubpassDescriptionType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSubpassDescription", sizeof(PyVkSubpassDescription), 0,
                (destructor)PyVkSubpassDescription_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSubpassDescription object",0,0,0,0,0,0,0,0,
                PyVkSubpassDescription_getsetters,0,0,0,0,0,
                (initproc)PyVkSubpassDescription_init,0,PyVkSubpassDescription_new,
            };
        
    

    
        
    
        
            PyVkSubpassDependencyType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSubpassDependency", sizeof(PyVkSubpassDependency), 0,
                (destructor)PyVkSubpassDependency_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSubpassDependency object",0,0,0,0,0,0,0,0,
                PyVkSubpassDependency_getsetters,0,0,0,0,0,
                (initproc)PyVkSubpassDependency_init,0,PyVkSubpassDependency_new,
            };
        
    

    
        
    
        
            PyVkRenderPassCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkRenderPassCreateInfo", sizeof(PyVkRenderPassCreateInfo), 0,
                (destructor)PyVkRenderPassCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkRenderPassCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkRenderPassCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkRenderPassCreateInfo_init,0,PyVkRenderPassCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkEventCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkEventCreateInfo", sizeof(PyVkEventCreateInfo), 0,
                (destructor)PyVkEventCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkEventCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkEventCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkEventCreateInfo_init,0,PyVkEventCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkFenceCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkFenceCreateInfo", sizeof(PyVkFenceCreateInfo), 0,
                (destructor)PyVkFenceCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkFenceCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkFenceCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkFenceCreateInfo_init,0,PyVkFenceCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkPhysicalDeviceFeaturesType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPhysicalDeviceFeatures", sizeof(PyVkPhysicalDeviceFeatures), 0,
                (destructor)PyVkPhysicalDeviceFeatures_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPhysicalDeviceFeatures object",0,0,0,0,0,0,0,0,
                PyVkPhysicalDeviceFeatures_getsetters,0,0,0,0,0,
                (initproc)PyVkPhysicalDeviceFeatures_init,0,PyVkPhysicalDeviceFeatures_new,
            };
        
    

    
        
    
        
            PyVkPhysicalDeviceSparsePropertiesType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPhysicalDeviceSparseProperties", sizeof(PyVkPhysicalDeviceSparseProperties), 0,
                (destructor)PyVkPhysicalDeviceSparseProperties_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPhysicalDeviceSparseProperties object",0,0,0,0,0,0,0,0,
                PyVkPhysicalDeviceSparseProperties_getsetters,0,0,0,0,0,
                (initproc)PyVkPhysicalDeviceSparseProperties_init,0,PyVkPhysicalDeviceSparseProperties_new,
            };
        
    

    
        
    
        
            PyVkPhysicalDeviceLimitsType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPhysicalDeviceLimits", sizeof(PyVkPhysicalDeviceLimits), 0,
                (destructor)PyVkPhysicalDeviceLimits_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPhysicalDeviceLimits object",0,0,0,0,0,0,0,0,
                PyVkPhysicalDeviceLimits_getsetters,0,0,0,0,0,
                (initproc)PyVkPhysicalDeviceLimits_init,0,PyVkPhysicalDeviceLimits_new,
            };
        
    

    
        
    
        
            PyVkSemaphoreCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSemaphoreCreateInfo", sizeof(PyVkSemaphoreCreateInfo), 0,
                (destructor)PyVkSemaphoreCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSemaphoreCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkSemaphoreCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkSemaphoreCreateInfo_init,0,PyVkSemaphoreCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkQueryPoolCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkQueryPoolCreateInfo", sizeof(PyVkQueryPoolCreateInfo), 0,
                (destructor)PyVkQueryPoolCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkQueryPoolCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkQueryPoolCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkQueryPoolCreateInfo_init,0,PyVkQueryPoolCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkFramebufferCreateInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkFramebufferCreateInfo", sizeof(PyVkFramebufferCreateInfo), 0,
                (destructor)PyVkFramebufferCreateInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkFramebufferCreateInfo object",0,0,0,0,0,0,0,0,
                PyVkFramebufferCreateInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkFramebufferCreateInfo_init,0,PyVkFramebufferCreateInfo_new,
            };
        
    

    
        
    
        
            PyVkDrawIndirectCommandType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDrawIndirectCommand", sizeof(PyVkDrawIndirectCommand), 0,
                (destructor)PyVkDrawIndirectCommand_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDrawIndirectCommand object",0,0,0,0,0,0,0,0,
                PyVkDrawIndirectCommand_getsetters,0,0,0,0,0,
                (initproc)PyVkDrawIndirectCommand_init,0,PyVkDrawIndirectCommand_new,
            };
        
    

    
        
    
        
            PyVkDrawIndexedIndirectCommandType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDrawIndexedIndirectCommand", sizeof(PyVkDrawIndexedIndirectCommand), 0,
                (destructor)PyVkDrawIndexedIndirectCommand_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDrawIndexedIndirectCommand object",0,0,0,0,0,0,0,0,
                PyVkDrawIndexedIndirectCommand_getsetters,0,0,0,0,0,
                (initproc)PyVkDrawIndexedIndirectCommand_init,0,PyVkDrawIndexedIndirectCommand_new,
            };
        
    

    
        
    
        
            PyVkDispatchIndirectCommandType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDispatchIndirectCommand", sizeof(PyVkDispatchIndirectCommand), 0,
                (destructor)PyVkDispatchIndirectCommand_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDispatchIndirectCommand object",0,0,0,0,0,0,0,0,
                PyVkDispatchIndirectCommand_getsetters,0,0,0,0,0,
                (initproc)PyVkDispatchIndirectCommand_init,0,PyVkDispatchIndirectCommand_new,
            };
        
    

    
        
    
        
            PyVkSubmitInfoType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSubmitInfo", sizeof(PyVkSubmitInfo), 0,
                (destructor)PyVkSubmitInfo_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSubmitInfo object",0,0,0,0,0,0,0,0,
                PyVkSubmitInfo_getsetters,0,0,0,0,0,
                (initproc)PyVkSubmitInfo_init,0,PyVkSubmitInfo_new,
            };
        
    

    
        
    
        
            PyVkDisplayPropertiesKHRType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDisplayPropertiesKHR", sizeof(PyVkDisplayPropertiesKHR), 0,
                (destructor)PyVkDisplayPropertiesKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDisplayPropertiesKHR object",0,0,0,0,0,0,0,0,
                PyVkDisplayPropertiesKHR_getsetters,0,0,0,0,0,
                (initproc)PyVkDisplayPropertiesKHR_init,0,PyVkDisplayPropertiesKHR_new,
            };
        
    

    
        
    
        
            PyVkDisplayPlanePropertiesKHRType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDisplayPlanePropertiesKHR", sizeof(PyVkDisplayPlanePropertiesKHR), 0,
                (destructor)PyVkDisplayPlanePropertiesKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDisplayPlanePropertiesKHR object",0,0,0,0,0,0,0,0,
                PyVkDisplayPlanePropertiesKHR_getsetters,0,0,0,0,0,
                (initproc)PyVkDisplayPlanePropertiesKHR_init,0,PyVkDisplayPlanePropertiesKHR_new,
            };
        
    

    
        
    
        
            PyVkDisplayModeParametersKHRType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDisplayModeParametersKHR", sizeof(PyVkDisplayModeParametersKHR), 0,
                (destructor)PyVkDisplayModeParametersKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDisplayModeParametersKHR object",0,0,0,0,0,0,0,0,
                PyVkDisplayModeParametersKHR_getsetters,0,0,0,0,0,
                (initproc)PyVkDisplayModeParametersKHR_init,0,PyVkDisplayModeParametersKHR_new,
            };
        
    

    
        
    
        
            PyVkDisplayModePropertiesKHRType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDisplayModePropertiesKHR", sizeof(PyVkDisplayModePropertiesKHR), 0,
                (destructor)PyVkDisplayModePropertiesKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDisplayModePropertiesKHR object",0,0,0,0,0,0,0,0,
                PyVkDisplayModePropertiesKHR_getsetters,0,0,0,0,0,
                (initproc)PyVkDisplayModePropertiesKHR_init,0,PyVkDisplayModePropertiesKHR_new,
            };
        
    

    
        
    
        
            PyVkDisplayModeCreateInfoKHRType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDisplayModeCreateInfoKHR", sizeof(PyVkDisplayModeCreateInfoKHR), 0,
                (destructor)PyVkDisplayModeCreateInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDisplayModeCreateInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkDisplayModeCreateInfoKHR_getsetters,0,0,0,0,0,
                (initproc)PyVkDisplayModeCreateInfoKHR_init,0,PyVkDisplayModeCreateInfoKHR_new,
            };
        
    

    
        
    
        
            PyVkDisplayPlaneCapabilitiesKHRType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDisplayPlaneCapabilitiesKHR", sizeof(PyVkDisplayPlaneCapabilitiesKHR), 0,
                (destructor)PyVkDisplayPlaneCapabilitiesKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDisplayPlaneCapabilitiesKHR object",0,0,0,0,0,0,0,0,
                PyVkDisplayPlaneCapabilitiesKHR_getsetters,0,0,0,0,0,
                (initproc)PyVkDisplayPlaneCapabilitiesKHR_init,0,PyVkDisplayPlaneCapabilitiesKHR_new,
            };
        
    

    
        
    
        
            PyVkDisplaySurfaceCreateInfoKHRType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDisplaySurfaceCreateInfoKHR", sizeof(PyVkDisplaySurfaceCreateInfoKHR), 0,
                (destructor)PyVkDisplaySurfaceCreateInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDisplaySurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkDisplaySurfaceCreateInfoKHR_getsetters,0,0,0,0,0,
                (initproc)PyVkDisplaySurfaceCreateInfoKHR_init,0,PyVkDisplaySurfaceCreateInfoKHR_new,
            };
        
    

    
        
    
        
            PyVkDisplayPresentInfoKHRType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDisplayPresentInfoKHR", sizeof(PyVkDisplayPresentInfoKHR), 0,
                (destructor)PyVkDisplayPresentInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDisplayPresentInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkDisplayPresentInfoKHR_getsetters,0,0,0,0,0,
                (initproc)PyVkDisplayPresentInfoKHR_init,0,PyVkDisplayPresentInfoKHR_new,
            };
        
    

    
        
    
        
            PyVkSurfaceCapabilitiesKHRType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSurfaceCapabilitiesKHR", sizeof(PyVkSurfaceCapabilitiesKHR), 0,
                (destructor)PyVkSurfaceCapabilitiesKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSurfaceCapabilitiesKHR object",0,0,0,0,0,0,0,0,
                PyVkSurfaceCapabilitiesKHR_getsetters,0,0,0,0,0,
                (initproc)PyVkSurfaceCapabilitiesKHR_init,0,PyVkSurfaceCapabilitiesKHR_new,
            };
        
    

    
        
     #ifdef VK_USE_PLATFORM_ANDROID_KHR 
        
            PyVkAndroidSurfaceCreateInfoKHRType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkAndroidSurfaceCreateInfoKHR", sizeof(PyVkAndroidSurfaceCreateInfoKHR), 0,
                (destructor)PyVkAndroidSurfaceCreateInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkAndroidSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkAndroidSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,
                (initproc)PyVkAndroidSurfaceCreateInfoKHR_init,0,PyVkAndroidSurfaceCreateInfoKHR_new,
            };
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_MIR_KHR 
        
            PyVkMirSurfaceCreateInfoKHRType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkMirSurfaceCreateInfoKHR", sizeof(PyVkMirSurfaceCreateInfoKHR), 0,
                (destructor)PyVkMirSurfaceCreateInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkMirSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkMirSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,
                (initproc)PyVkMirSurfaceCreateInfoKHR_init,0,PyVkMirSurfaceCreateInfoKHR_new,
            };
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_WAYLAND_KHR 
        
            PyVkWaylandSurfaceCreateInfoKHRType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkWaylandSurfaceCreateInfoKHR", sizeof(PyVkWaylandSurfaceCreateInfoKHR), 0,
                (destructor)PyVkWaylandSurfaceCreateInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkWaylandSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkWaylandSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,
                (initproc)PyVkWaylandSurfaceCreateInfoKHR_init,0,PyVkWaylandSurfaceCreateInfoKHR_new,
            };
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
            PyVkWin32SurfaceCreateInfoKHRType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkWin32SurfaceCreateInfoKHR", sizeof(PyVkWin32SurfaceCreateInfoKHR), 0,
                (destructor)PyVkWin32SurfaceCreateInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkWin32SurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkWin32SurfaceCreateInfoKHR_getsetters,0,0,0,0,0,
                (initproc)PyVkWin32SurfaceCreateInfoKHR_init,0,PyVkWin32SurfaceCreateInfoKHR_new,
            };
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_XLIB_KHR 
        
            PyVkXlibSurfaceCreateInfoKHRType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkXlibSurfaceCreateInfoKHR", sizeof(PyVkXlibSurfaceCreateInfoKHR), 0,
                (destructor)PyVkXlibSurfaceCreateInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkXlibSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkXlibSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,
                (initproc)PyVkXlibSurfaceCreateInfoKHR_init,0,PyVkXlibSurfaceCreateInfoKHR_new,
            };
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_XCB_KHR 
        
            PyVkXcbSurfaceCreateInfoKHRType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkXcbSurfaceCreateInfoKHR", sizeof(PyVkXcbSurfaceCreateInfoKHR), 0,
                (destructor)PyVkXcbSurfaceCreateInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkXcbSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkXcbSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,
                (initproc)PyVkXcbSurfaceCreateInfoKHR_init,0,PyVkXcbSurfaceCreateInfoKHR_new,
            };
        
     #endif 

    
        
    
        
            PyVkSurfaceFormatKHRType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSurfaceFormatKHR", sizeof(PyVkSurfaceFormatKHR), 0,
                (destructor)PyVkSurfaceFormatKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSurfaceFormatKHR object",0,0,0,0,0,0,0,0,
                PyVkSurfaceFormatKHR_getsetters,0,0,0,0,0,
                (initproc)PyVkSurfaceFormatKHR_init,0,PyVkSurfaceFormatKHR_new,
            };
        
    

    
        
    
        
            PyVkSwapchainCreateInfoKHRType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkSwapchainCreateInfoKHR", sizeof(PyVkSwapchainCreateInfoKHR), 0,
                (destructor)PyVkSwapchainCreateInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkSwapchainCreateInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkSwapchainCreateInfoKHR_getsetters,0,0,0,0,0,
                (initproc)PyVkSwapchainCreateInfoKHR_init,0,PyVkSwapchainCreateInfoKHR_new,
            };
        
    

    
        
    
        
            PyVkPresentInfoKHRType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPresentInfoKHR", sizeof(PyVkPresentInfoKHR), 0,
                (destructor)PyVkPresentInfoKHR_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPresentInfoKHR object",0,0,0,0,0,0,0,0,
                PyVkPresentInfoKHR_getsetters,0,0,0,0,0,
                (initproc)PyVkPresentInfoKHR_init,0,PyVkPresentInfoKHR_new,
            };
        
    

    
        
    
        
            PyVkValidationFlagsEXTType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkValidationFlagsEXT", sizeof(PyVkValidationFlagsEXT), 0,
                (destructor)PyVkValidationFlagsEXT_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkValidationFlagsEXT object",0,0,0,0,0,0,0,0,
                PyVkValidationFlagsEXT_getsetters,0,0,0,0,0,
                (initproc)PyVkValidationFlagsEXT_init,0,PyVkValidationFlagsEXT_new,
            };
        
    

    
        
    
        
            PyVkPipelineRasterizationStateRasterizationOrderAMDType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkPipelineRasterizationStateRasterizationOrderAMD", sizeof(PyVkPipelineRasterizationStateRasterizationOrderAMD), 0,
                (destructor)PyVkPipelineRasterizationStateRasterizationOrderAMD_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkPipelineRasterizationStateRasterizationOrderAMD object",0,0,0,0,0,0,0,0,
                PyVkPipelineRasterizationStateRasterizationOrderAMD_getsetters,0,0,0,0,0,
                (initproc)PyVkPipelineRasterizationStateRasterizationOrderAMD_init,0,PyVkPipelineRasterizationStateRasterizationOrderAMD_new,
            };
        
    

    
        
    
        
            PyVkDebugMarkerObjectNameInfoEXTType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDebugMarkerObjectNameInfoEXT", sizeof(PyVkDebugMarkerObjectNameInfoEXT), 0,
                (destructor)PyVkDebugMarkerObjectNameInfoEXT_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDebugMarkerObjectNameInfoEXT object",0,0,0,0,0,0,0,0,
                PyVkDebugMarkerObjectNameInfoEXT_getsetters,0,0,0,0,0,
                (initproc)PyVkDebugMarkerObjectNameInfoEXT_init,0,PyVkDebugMarkerObjectNameInfoEXT_new,
            };
        
    

    
        
    
        
            PyVkDebugMarkerObjectTagInfoEXTType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDebugMarkerObjectTagInfoEXT", sizeof(PyVkDebugMarkerObjectTagInfoEXT), 0,
                (destructor)PyVkDebugMarkerObjectTagInfoEXT_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDebugMarkerObjectTagInfoEXT object",0,0,0,0,0,0,0,0,
                PyVkDebugMarkerObjectTagInfoEXT_getsetters,0,0,0,0,0,
                (initproc)PyVkDebugMarkerObjectTagInfoEXT_init,0,PyVkDebugMarkerObjectTagInfoEXT_new,
            };
        
    

    
        
    
        
            PyVkDebugMarkerMarkerInfoEXTType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDebugMarkerMarkerInfoEXT", sizeof(PyVkDebugMarkerMarkerInfoEXT), 0,
                (destructor)PyVkDebugMarkerMarkerInfoEXT_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDebugMarkerMarkerInfoEXT object",0,0,0,0,0,0,0,0,
                PyVkDebugMarkerMarkerInfoEXT_getsetters,0,0,0,0,0,
                (initproc)PyVkDebugMarkerMarkerInfoEXT_init,0,PyVkDebugMarkerMarkerInfoEXT_new,
            };
        
    

    
        
    
        
            PyVkDedicatedAllocationImageCreateInfoNVType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDedicatedAllocationImageCreateInfoNV", sizeof(PyVkDedicatedAllocationImageCreateInfoNV), 0,
                (destructor)PyVkDedicatedAllocationImageCreateInfoNV_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDedicatedAllocationImageCreateInfoNV object",0,0,0,0,0,0,0,0,
                PyVkDedicatedAllocationImageCreateInfoNV_getsetters,0,0,0,0,0,
                (initproc)PyVkDedicatedAllocationImageCreateInfoNV_init,0,PyVkDedicatedAllocationImageCreateInfoNV_new,
            };
        
    

    
        
    
        
            PyVkDedicatedAllocationBufferCreateInfoNVType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDedicatedAllocationBufferCreateInfoNV", sizeof(PyVkDedicatedAllocationBufferCreateInfoNV), 0,
                (destructor)PyVkDedicatedAllocationBufferCreateInfoNV_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDedicatedAllocationBufferCreateInfoNV object",0,0,0,0,0,0,0,0,
                PyVkDedicatedAllocationBufferCreateInfoNV_getsetters,0,0,0,0,0,
                (initproc)PyVkDedicatedAllocationBufferCreateInfoNV_init,0,PyVkDedicatedAllocationBufferCreateInfoNV_new,
            };
        
    

    
        
    
        
            PyVkDedicatedAllocationMemoryAllocateInfoNVType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkDedicatedAllocationMemoryAllocateInfoNV", sizeof(PyVkDedicatedAllocationMemoryAllocateInfoNV), 0,
                (destructor)PyVkDedicatedAllocationMemoryAllocateInfoNV_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkDedicatedAllocationMemoryAllocateInfoNV object",0,0,0,0,0,0,0,0,
                PyVkDedicatedAllocationMemoryAllocateInfoNV_getsetters,0,0,0,0,0,
                (initproc)PyVkDedicatedAllocationMemoryAllocateInfoNV_init,0,PyVkDedicatedAllocationMemoryAllocateInfoNV_new,
            };
        
    

    
        
    
        
            PyVkExternalImageFormatPropertiesNVType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkExternalImageFormatPropertiesNV", sizeof(PyVkExternalImageFormatPropertiesNV), 0,
                (destructor)PyVkExternalImageFormatPropertiesNV_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkExternalImageFormatPropertiesNV object",0,0,0,0,0,0,0,0,
                PyVkExternalImageFormatPropertiesNV_getsetters,0,0,0,0,0,
                (initproc)PyVkExternalImageFormatPropertiesNV_init,0,PyVkExternalImageFormatPropertiesNV_new,
            };
        
    

    
        
    
        
            PyVkExternalMemoryImageCreateInfoNVType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkExternalMemoryImageCreateInfoNV", sizeof(PyVkExternalMemoryImageCreateInfoNV), 0,
                (destructor)PyVkExternalMemoryImageCreateInfoNV_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkExternalMemoryImageCreateInfoNV object",0,0,0,0,0,0,0,0,
                PyVkExternalMemoryImageCreateInfoNV_getsetters,0,0,0,0,0,
                (initproc)PyVkExternalMemoryImageCreateInfoNV_init,0,PyVkExternalMemoryImageCreateInfoNV_new,
            };
        
    

    
        
    
        
            PyVkExportMemoryAllocateInfoNVType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkExportMemoryAllocateInfoNV", sizeof(PyVkExportMemoryAllocateInfoNV), 0,
                (destructor)PyVkExportMemoryAllocateInfoNV_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkExportMemoryAllocateInfoNV object",0,0,0,0,0,0,0,0,
                PyVkExportMemoryAllocateInfoNV_getsetters,0,0,0,0,0,
                (initproc)PyVkExportMemoryAllocateInfoNV_init,0,PyVkExportMemoryAllocateInfoNV_new,
            };
        
    

    
        
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
            PyVkImportMemoryWin32HandleInfoNVType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkImportMemoryWin32HandleInfoNV", sizeof(PyVkImportMemoryWin32HandleInfoNV), 0,
                (destructor)PyVkImportMemoryWin32HandleInfoNV_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkImportMemoryWin32HandleInfoNV object",0,0,0,0,0,0,0,0,
                PyVkImportMemoryWin32HandleInfoNV_getsetters,0,0,0,0,0,
                (initproc)PyVkImportMemoryWin32HandleInfoNV_init,0,PyVkImportMemoryWin32HandleInfoNV_new,
            };
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
            PyVkExportMemoryWin32HandleInfoNVType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkExportMemoryWin32HandleInfoNV", sizeof(PyVkExportMemoryWin32HandleInfoNV), 0,
                (destructor)PyVkExportMemoryWin32HandleInfoNV_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkExportMemoryWin32HandleInfoNV object",0,0,0,0,0,0,0,0,
                PyVkExportMemoryWin32HandleInfoNV_getsetters,0,0,0,0,0,
                (initproc)PyVkExportMemoryWin32HandleInfoNV_init,0,PyVkExportMemoryWin32HandleInfoNV_new,
            };
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
            PyVkWin32KeyedMutexAcquireReleaseInfoNVType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkWin32KeyedMutexAcquireReleaseInfoNV", sizeof(PyVkWin32KeyedMutexAcquireReleaseInfoNV), 0,
                (destructor)PyVkWin32KeyedMutexAcquireReleaseInfoNV_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkWin32KeyedMutexAcquireReleaseInfoNV object",0,0,0,0,0,0,0,0,
                PyVkWin32KeyedMutexAcquireReleaseInfoNV_getsetters,0,0,0,0,0,
                (initproc)PyVkWin32KeyedMutexAcquireReleaseInfoNV_init,0,PyVkWin32KeyedMutexAcquireReleaseInfoNV_new,
            };
        
     #endif 

    
        
    
        
            PyVkClearColorValueType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkClearColorValue", sizeof(PyVkClearColorValue), 0,
                (destructor)PyVkClearColorValue_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkClearColorValue object",0,0,0,0,0,0,0,0,
                PyVkClearColorValue_getsetters,0,0,0,0,0,
                (initproc)PyVkClearColorValue_init,0,PyVkClearColorValue_new,
            };
        
    

    
        
    
        
            PyVkClearValueType = (PyTypeObject) {
                PyVarObject_HEAD_INIT(NULL, 0)
                "vulkan.VkClearValue", sizeof(PyVkClearValue), 0,
                (destructor)PyVkClearValue_del,
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                "VkClearValue object",0,0,0,0,0,0,0,0,
                PyVkClearValue_getsetters,0,0,0,0,0,
                (initproc)PyVkClearValue_init,0,PyVkClearValue_new,
            };
        
    

    
    PyVkDebugReportCallbackCreateInfoEXTType = (PyTypeObject) {
        PyVarObject_HEAD_INIT(NULL, 0)
        "vulkan.VkDebugReportCallbackCreateInfoEXT", sizeof(PyVkDebugReportCallbackCreateInfoEXT), 0,
        (destructor)PyVkDebugReportCallbackCreateInfoEXT_del,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
        "VkDebugReportCallbackCreateInfoEXT object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyVkDebugReportCallbackCreateInfoEXT_init,0,PyVkDebugReportCallbackCreateInfoEXT_new,
    };
}


// ---------------
// CREATE PYTHON FUNCTIONS
// ---------------



   
    
        

    static PyObject* PyvkCreateInstance(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkInstanceCreateInfo* pCreateInfo;

    static char *kwlist[] = {"pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&", kwlist, pyc_struct_pointer_VkInstanceCreateInfo_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkInstance *value = malloc(allocate_size * sizeof(VkInstance));
        
        
            if (raise(vkCreateInstance(pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkInstance", NULL);
            
        

    

    pyc_struct_pointer_VkInstanceCreateInfo_converter_free(&pCreateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroyInstance(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkInstance instance;

    static char *kwlist[] = {"instance",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&", kwlist, pyc_handle_base_VkInstance_converter,&instance))
        return NULL;
    

    

    
        

        
            vkDestroyInstance(instance,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkInstance_converter_free(&instance);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkEnumeratePhysicalDevices(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkInstance instance;

    static char *kwlist[] = {"instance",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&", kwlist, pyc_handle_base_VkInstance_converter,&instance))
        return NULL;
    

    

    
        uint32_t count;

        
        
            if (raise(vkEnumeratePhysicalDevices(instance,&count, NULL)))
                return NULL;
        

        VkPhysicalDevice *values = malloc(count * sizeof(VkPhysicalDevice));

        
        
            if (raise(vkEnumeratePhysicalDevices(instance,&count, values)))
                return NULL;
        

        PyObject* return_value = PyList_New(0);
        uint32_t i;
        for (i = 0; i < count; i++) {
            VkPhysicalDevice* value = malloc(sizeof(VkPhysicalDevice));
            memcpy(value, values + i, sizeof(VkPhysicalDevice));

            
                PyObject* pyreturn = PyCapsule_New(value, "VkPhysicalDevice", NULL);
            
            PyList_Append(return_value, pyreturn);
        }
        free(values);

    

    pyc_handle_base_VkInstance_converter_free(&instance);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkGetPhysicalDeviceProperties(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkPhysicalDevice physicalDevice;

    static char *kwlist[] = {"physicalDevice",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkPhysicalDeviceProperties *value = malloc(allocate_size * sizeof(VkPhysicalDeviceProperties));
        
        
            vkGetPhysicalDeviceProperties(physicalDevice,value);
        


        
            
                PyObject* return_value = _PyObject_New(&PyVkPhysicalDevicePropertiesType);
                if (!return_value)
                    return NULL;
                ((PyVkPhysicalDeviceProperties*)return_value)->base = value;
            
        

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkGetPhysicalDeviceQueueFamilyProperties(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkPhysicalDevice physicalDevice;

    static char *kwlist[] = {"physicalDevice",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice))
        return NULL;
    

    

    
        uint32_t count;

        
        
            vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice,&count, NULL);
        

        VkQueueFamilyProperties *values = malloc(count * sizeof(VkQueueFamilyProperties));

        
        
            vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice,&count, values);
        

        PyObject* return_value = PyList_New(0);
        uint32_t i;
        for (i = 0; i < count; i++) {
            VkQueueFamilyProperties* value = malloc(sizeof(VkQueueFamilyProperties));
            memcpy(value, values + i, sizeof(VkQueueFamilyProperties));

            
                PyObject* pyreturn = _PyObject_New(&PyVkQueueFamilyPropertiesType);
                if (!pyreturn)
                    return NULL;
                ((PyVkQueueFamilyProperties*)pyreturn)->base = value;
            
            PyList_Append(return_value, pyreturn);
        }
        free(values);

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkGetPhysicalDeviceMemoryProperties(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkPhysicalDevice physicalDevice;

    static char *kwlist[] = {"physicalDevice",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkPhysicalDeviceMemoryProperties *value = malloc(allocate_size * sizeof(VkPhysicalDeviceMemoryProperties));
        
        
            vkGetPhysicalDeviceMemoryProperties(physicalDevice,value);
        


        
            
                PyObject* return_value = _PyObject_New(&PyVkPhysicalDeviceMemoryPropertiesType);
                if (!return_value)
                    return NULL;
                ((PyVkPhysicalDeviceMemoryProperties*)return_value)->base = value;
            
        

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkGetPhysicalDeviceFeatures(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkPhysicalDevice physicalDevice;

    static char *kwlist[] = {"physicalDevice",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkPhysicalDeviceFeatures *value = malloc(allocate_size * sizeof(VkPhysicalDeviceFeatures));
        
        
            vkGetPhysicalDeviceFeatures(physicalDevice,value);
        


        
            
                PyObject* return_value = _PyObject_New(&PyVkPhysicalDeviceFeaturesType);
                if (!return_value)
                    return NULL;
                ((PyVkPhysicalDeviceFeatures*)return_value)->base = value;
            
        

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkGetPhysicalDeviceFormatProperties(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkPhysicalDevice physicalDevice;
VkFormat format;

    static char *kwlist[] = {"physicalDevice","format",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice,pyc_flag_base_VkFormat_converter,&format))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkFormatProperties *value = malloc(allocate_size * sizeof(VkFormatProperties));
        
        
            vkGetPhysicalDeviceFormatProperties(physicalDevice,format,value);
        


        
            
                PyObject* return_value = _PyObject_New(&PyVkFormatPropertiesType);
                if (!return_value)
                    return NULL;
                ((PyVkFormatProperties*)return_value)->base = value;
            
        

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);
pyc_flag_base_VkFormat_converter_free(&format);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkGetPhysicalDeviceImageFormatProperties(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkPhysicalDevice physicalDevice;
VkFormat format;
VkImageType type;
VkImageTiling tiling;
VkImageUsageFlags usage;
VkImageCreateFlags flags;

    static char *kwlist[] = {"physicalDevice","format","type","tiling","usage","flags",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice,pyc_flag_base_VkFormat_converter,&format,pyc_flag_base_VkImageType_converter,&type,pyc_flag_base_VkImageTiling_converter,&tiling,pyc_flag_base_VkImageUsageFlags_converter,&usage,pyc_flag_base_VkImageCreateFlags_converter,&flags))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkImageFormatProperties *value = malloc(allocate_size * sizeof(VkImageFormatProperties));
        
        
            if (raise(vkGetPhysicalDeviceImageFormatProperties(physicalDevice,format,type,tiling,usage,flags,value)))
                return NULL;
        


        
            
                PyObject* return_value = _PyObject_New(&PyVkImageFormatPropertiesType);
                if (!return_value)
                    return NULL;
                ((PyVkImageFormatProperties*)return_value)->base = value;
            
        

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);
pyc_flag_base_VkFormat_converter_free(&format);
pyc_flag_base_VkImageType_converter_free(&type);
pyc_flag_base_VkImageTiling_converter_free(&tiling);
pyc_flag_base_VkImageUsageFlags_converter_free(&usage);
pyc_flag_base_VkImageCreateFlags_converter_free(&flags);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreateDevice(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkPhysicalDevice physicalDevice;
VkDeviceCreateInfo* pCreateInfo;

    static char *kwlist[] = {"physicalDevice","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice,pyc_struct_pointer_VkDeviceCreateInfo_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkDevice *value = malloc(allocate_size * sizeof(VkDevice));
        
        
            if (raise(vkCreateDevice(physicalDevice,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkDevice", NULL);
            
        

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);
pyc_struct_pointer_VkDeviceCreateInfo_converter_free(&pCreateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroyDevice(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;

    static char *kwlist[] = {"device",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&", kwlist, pyc_handle_base_VkDevice_converter,&device))
        return NULL;
    

    

    
        

        
            vkDestroyDevice(device,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkEnumerateInstanceLayerProperties(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    
    
    

    

    
        uint32_t count;

        
        
            if (raise(vkEnumerateInstanceLayerProperties(&count, NULL)))
                return NULL;
        

        VkLayerProperties *values = malloc(count * sizeof(VkLayerProperties));

        
        
            if (raise(vkEnumerateInstanceLayerProperties(&count, values)))
                return NULL;
        

        PyObject* return_value = PyList_New(0);
        uint32_t i;
        for (i = 0; i < count; i++) {
            VkLayerProperties* value = malloc(sizeof(VkLayerProperties));
            memcpy(value, values + i, sizeof(VkLayerProperties));

            
                PyObject* pyreturn = _PyObject_New(&PyVkLayerPropertiesType);
                if (!pyreturn)
                    return NULL;
                ((PyVkLayerProperties*)pyreturn)->base = value;
            
            PyList_Append(return_value, pyreturn);
        }
        free(values);

    

    

    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkEnumerateInstanceExtensionProperties(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    char* pLayerName;

    static char *kwlist[] = {"pLayerName",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&", kwlist, pyc_string_converter,&pLayerName))
        return NULL;
    

    

    
        uint32_t count;

        
        
            if (raise(vkEnumerateInstanceExtensionProperties(pLayerName,&count, NULL)))
                return NULL;
        

        VkExtensionProperties *values = malloc(count * sizeof(VkExtensionProperties));

        
        
            if (raise(vkEnumerateInstanceExtensionProperties(pLayerName,&count, values)))
                return NULL;
        

        PyObject* return_value = PyList_New(0);
        uint32_t i;
        for (i = 0; i < count; i++) {
            VkExtensionProperties* value = malloc(sizeof(VkExtensionProperties));
            memcpy(value, values + i, sizeof(VkExtensionProperties));

            
                PyObject* pyreturn = _PyObject_New(&PyVkExtensionPropertiesType);
                if (!pyreturn)
                    return NULL;
                ((PyVkExtensionProperties*)pyreturn)->base = value;
            
            PyList_Append(return_value, pyreturn);
        }
        free(values);

    

    pyc_string_converter_free(&pLayerName);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkEnumerateDeviceLayerProperties(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkPhysicalDevice physicalDevice;

    static char *kwlist[] = {"physicalDevice",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice))
        return NULL;
    

    

    
        uint32_t count;

        
        
            if (raise(vkEnumerateDeviceLayerProperties(physicalDevice,&count, NULL)))
                return NULL;
        

        VkLayerProperties *values = malloc(count * sizeof(VkLayerProperties));

        
        
            if (raise(vkEnumerateDeviceLayerProperties(physicalDevice,&count, values)))
                return NULL;
        

        PyObject* return_value = PyList_New(0);
        uint32_t i;
        for (i = 0; i < count; i++) {
            VkLayerProperties* value = malloc(sizeof(VkLayerProperties));
            memcpy(value, values + i, sizeof(VkLayerProperties));

            
                PyObject* pyreturn = _PyObject_New(&PyVkLayerPropertiesType);
                if (!pyreturn)
                    return NULL;
                ((PyVkLayerProperties*)pyreturn)->base = value;
            
            PyList_Append(return_value, pyreturn);
        }
        free(values);

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkEnumerateDeviceExtensionProperties(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkPhysicalDevice physicalDevice;
char* pLayerName;

    static char *kwlist[] = {"physicalDevice","pLayerName",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice,pyc_string_converter,&pLayerName))
        return NULL;
    

    

    
        uint32_t count;

        
        
            if (raise(vkEnumerateDeviceExtensionProperties(physicalDevice,pLayerName,&count, NULL)))
                return NULL;
        

        VkExtensionProperties *values = malloc(count * sizeof(VkExtensionProperties));

        
        
            if (raise(vkEnumerateDeviceExtensionProperties(physicalDevice,pLayerName,&count, values)))
                return NULL;
        

        PyObject* return_value = PyList_New(0);
        uint32_t i;
        for (i = 0; i < count; i++) {
            VkExtensionProperties* value = malloc(sizeof(VkExtensionProperties));
            memcpy(value, values + i, sizeof(VkExtensionProperties));

            
                PyObject* pyreturn = _PyObject_New(&PyVkExtensionPropertiesType);
                if (!pyreturn)
                    return NULL;
                ((PyVkExtensionProperties*)pyreturn)->base = value;
            
            PyList_Append(return_value, pyreturn);
        }
        free(values);

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);
pyc_string_converter_free(&pLayerName);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkGetDeviceQueue(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
uint32_t queueFamilyIndex;
uint32_t queueIndex;

    static char *kwlist[] = {"device","queueFamilyIndex","queueIndex",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_uint32_t_converter,&queueFamilyIndex,pyc_uint32_t_converter,&queueIndex))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkQueue *value = malloc(allocate_size * sizeof(VkQueue));
        
        
            vkGetDeviceQueue(device,queueFamilyIndex,queueIndex,value);
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkQueue", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_uint32_t_converter_free(&queueFamilyIndex);
pyc_uint32_t_converter_free(&queueIndex);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkQueueSubmit(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkQueue queue;
uint32_t submitCount;
VkSubmitInfo* pSubmits;
VkFence fence;

    static char *kwlist[] = {"queue","submitCount","pSubmits","fence",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_handle_base_VkQueue_converter,&queue,pyc_uint32_t_converter,&submitCount,pyc_struct_pointer_VkSubmitInfo_converter,&pSubmits,pyc_handle_base_VkFence_converter,&fence))
        return NULL;
    

    

    
        

        
            vkQueueSubmit(queue,submitCount,pSubmits,fence);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkQueue_converter_free(&queue);
pyc_uint32_t_converter_free(&submitCount);
pyc_struct_pointer_VkSubmitInfo_converter_free(&pSubmits);
pyc_handle_base_VkFence_converter_free(&fence);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkQueueWaitIdle(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkQueue queue;

    static char *kwlist[] = {"queue",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&", kwlist, pyc_handle_base_VkQueue_converter,&queue))
        return NULL;
    

    

    
        

        
            vkQueueWaitIdle(queue);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkQueue_converter_free(&queue);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDeviceWaitIdle(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;

    static char *kwlist[] = {"device",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&", kwlist, pyc_handle_base_VkDevice_converter,&device))
        return NULL;
    

    

    
        

        
            vkDeviceWaitIdle(device);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkAllocateMemory(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkMemoryAllocateInfo* pAllocateInfo;

    static char *kwlist[] = {"device","pAllocateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkMemoryAllocateInfo_converter,&pAllocateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkDeviceMemory *value = malloc(allocate_size * sizeof(VkDeviceMemory));
        
        
            if (raise(vkAllocateMemory(device,pAllocateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkDeviceMemory", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkMemoryAllocateInfo_converter_free(&pAllocateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkFreeMemory(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkDeviceMemory memory;

    static char *kwlist[] = {"device","memory",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkDeviceMemory_converter,&memory))
        return NULL;
    

    

    
        

        
            vkFreeMemory(device,memory,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkDeviceMemory_converter_free(&memory);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkUnmapMemory(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkDeviceMemory memory;

    static char *kwlist[] = {"device","memory",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkDeviceMemory_converter,&memory))
        return NULL;
    

    

    
        

        
            vkUnmapMemory(device,memory);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkDeviceMemory_converter_free(&memory);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkFlushMappedMemoryRanges(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
uint32_t memoryRangeCount;
VkMappedMemoryRange* pMemoryRanges;

    static char *kwlist[] = {"device","memoryRangeCount","pMemoryRanges",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_uint32_t_converter,&memoryRangeCount,pyc_struct_pointer_VkMappedMemoryRange_converter,&pMemoryRanges))
        return NULL;
    

    

    
        

        
            vkFlushMappedMemoryRanges(device,memoryRangeCount,pMemoryRanges);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_uint32_t_converter_free(&memoryRangeCount);
pyc_struct_pointer_VkMappedMemoryRange_converter_free(&pMemoryRanges);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkInvalidateMappedMemoryRanges(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
uint32_t memoryRangeCount;
VkMappedMemoryRange* pMemoryRanges;

    static char *kwlist[] = {"device","memoryRangeCount","pMemoryRanges",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_uint32_t_converter,&memoryRangeCount,pyc_struct_pointer_VkMappedMemoryRange_converter,&pMemoryRanges))
        return NULL;
    

    

    
        

        
            vkInvalidateMappedMemoryRanges(device,memoryRangeCount,pMemoryRanges);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_uint32_t_converter_free(&memoryRangeCount);
pyc_struct_pointer_VkMappedMemoryRange_converter_free(&pMemoryRanges);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkGetDeviceMemoryCommitment(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkDeviceMemory memory;

    static char *kwlist[] = {"device","memory",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkDeviceMemory_converter,&memory))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkDeviceSize *value = malloc(allocate_size * sizeof(VkDeviceSize));
        
        
            vkGetDeviceMemoryCommitment(device,memory,value);
        


        
            
                PyObject* return_value = PyLong_FromLong((long) *value);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkDeviceMemory_converter_free(&memory);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkGetBufferMemoryRequirements(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkBuffer buffer;

    static char *kwlist[] = {"device","buffer",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkBuffer_converter,&buffer))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkMemoryRequirements *value = malloc(allocate_size * sizeof(VkMemoryRequirements));
        
        
            vkGetBufferMemoryRequirements(device,buffer,value);
        


        
            
                PyObject* return_value = _PyObject_New(&PyVkMemoryRequirementsType);
                if (!return_value)
                    return NULL;
                ((PyVkMemoryRequirements*)return_value)->base = value;
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkBuffer_converter_free(&buffer);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkBindBufferMemory(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkBuffer buffer;
VkDeviceMemory memory;
VkDeviceSize memoryOffset;

    static char *kwlist[] = {"device","buffer","memory","memoryOffset",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkBuffer_converter,&buffer,pyc_handle_base_VkDeviceMemory_converter,&memory,pyc_flag_base_VkDeviceSize_converter,&memoryOffset))
        return NULL;
    

    

    
        

        
            vkBindBufferMemory(device,buffer,memory,memoryOffset);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkBuffer_converter_free(&buffer);
pyc_handle_base_VkDeviceMemory_converter_free(&memory);
pyc_flag_base_VkDeviceSize_converter_free(&memoryOffset);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkGetImageMemoryRequirements(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkImage image;

    static char *kwlist[] = {"device","image",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkImage_converter,&image))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkMemoryRequirements *value = malloc(allocate_size * sizeof(VkMemoryRequirements));
        
        
            vkGetImageMemoryRequirements(device,image,value);
        


        
            
                PyObject* return_value = _PyObject_New(&PyVkMemoryRequirementsType);
                if (!return_value)
                    return NULL;
                ((PyVkMemoryRequirements*)return_value)->base = value;
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkImage_converter_free(&image);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkBindImageMemory(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkImage image;
VkDeviceMemory memory;
VkDeviceSize memoryOffset;

    static char *kwlist[] = {"device","image","memory","memoryOffset",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkImage_converter,&image,pyc_handle_base_VkDeviceMemory_converter,&memory,pyc_flag_base_VkDeviceSize_converter,&memoryOffset))
        return NULL;
    

    

    
        

        
            vkBindImageMemory(device,image,memory,memoryOffset);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkImage_converter_free(&image);
pyc_handle_base_VkDeviceMemory_converter_free(&memory);
pyc_flag_base_VkDeviceSize_converter_free(&memoryOffset);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkGetImageSparseMemoryRequirements(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkImage image;

    static char *kwlist[] = {"device","image",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkImage_converter,&image))
        return NULL;
    

    

    
        uint32_t count;

        
        
            vkGetImageSparseMemoryRequirements(device,image,&count, NULL);
        

        VkSparseImageMemoryRequirements *values = malloc(count * sizeof(VkSparseImageMemoryRequirements));

        
        
            vkGetImageSparseMemoryRequirements(device,image,&count, values);
        

        PyObject* return_value = PyList_New(0);
        uint32_t i;
        for (i = 0; i < count; i++) {
            VkSparseImageMemoryRequirements* value = malloc(sizeof(VkSparseImageMemoryRequirements));
            memcpy(value, values + i, sizeof(VkSparseImageMemoryRequirements));

            
                PyObject* pyreturn = _PyObject_New(&PyVkSparseImageMemoryRequirementsType);
                if (!pyreturn)
                    return NULL;
                ((PyVkSparseImageMemoryRequirements*)pyreturn)->base = value;
            
            PyList_Append(return_value, pyreturn);
        }
        free(values);

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkImage_converter_free(&image);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkGetPhysicalDeviceSparseImageFormatProperties(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkPhysicalDevice physicalDevice;
VkFormat format;
VkImageType type;
VkSampleCountFlagBits samples;
VkImageUsageFlags usage;
VkImageTiling tiling;

    static char *kwlist[] = {"physicalDevice","format","type","samples","usage","tiling",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice,pyc_flag_base_VkFormat_converter,&format,pyc_flag_base_VkImageType_converter,&type,pyc_flag_base_VkSampleCountFlagBits_converter,&samples,pyc_flag_base_VkImageUsageFlags_converter,&usage,pyc_flag_base_VkImageTiling_converter,&tiling))
        return NULL;
    

    

    
        uint32_t count;

        
        
            vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice,format,type,samples,usage,tiling,&count, NULL);
        

        VkSparseImageFormatProperties *values = malloc(count * sizeof(VkSparseImageFormatProperties));

        
        
            vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice,format,type,samples,usage,tiling,&count, values);
        

        PyObject* return_value = PyList_New(0);
        uint32_t i;
        for (i = 0; i < count; i++) {
            VkSparseImageFormatProperties* value = malloc(sizeof(VkSparseImageFormatProperties));
            memcpy(value, values + i, sizeof(VkSparseImageFormatProperties));

            
                PyObject* pyreturn = _PyObject_New(&PyVkSparseImageFormatPropertiesType);
                if (!pyreturn)
                    return NULL;
                ((PyVkSparseImageFormatProperties*)pyreturn)->base = value;
            
            PyList_Append(return_value, pyreturn);
        }
        free(values);

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);
pyc_flag_base_VkFormat_converter_free(&format);
pyc_flag_base_VkImageType_converter_free(&type);
pyc_flag_base_VkSampleCountFlagBits_converter_free(&samples);
pyc_flag_base_VkImageUsageFlags_converter_free(&usage);
pyc_flag_base_VkImageTiling_converter_free(&tiling);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkQueueBindSparse(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkQueue queue;
uint32_t bindInfoCount;
VkBindSparseInfo* pBindInfo;
VkFence fence;

    static char *kwlist[] = {"queue","bindInfoCount","pBindInfo","fence",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_handle_base_VkQueue_converter,&queue,pyc_uint32_t_converter,&bindInfoCount,pyc_struct_pointer_VkBindSparseInfo_converter,&pBindInfo,pyc_handle_base_VkFence_converter,&fence))
        return NULL;
    

    

    
        

        
            vkQueueBindSparse(queue,bindInfoCount,pBindInfo,fence);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkQueue_converter_free(&queue);
pyc_uint32_t_converter_free(&bindInfoCount);
pyc_struct_pointer_VkBindSparseInfo_converter_free(&pBindInfo);
pyc_handle_base_VkFence_converter_free(&fence);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreateFence(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkFenceCreateInfo* pCreateInfo;

    static char *kwlist[] = {"device","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkFenceCreateInfo_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkFence *value = malloc(allocate_size * sizeof(VkFence));
        
        
            if (raise(vkCreateFence(device,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkFence", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkFenceCreateInfo_converter_free(&pCreateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroyFence(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkFence fence;

    static char *kwlist[] = {"device","fence",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkFence_converter,&fence))
        return NULL;
    

    

    
        

        
            vkDestroyFence(device,fence,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkFence_converter_free(&fence);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkResetFences(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
uint32_t fenceCount;
VkFence* pFences;

    static char *kwlist[] = {"device","fenceCount","pFences",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_uint32_t_converter,&fenceCount,pyc_handle_pointer_VkFence_converter,&pFences))
        return NULL;
    

    

    
        

        
            vkResetFences(device,fenceCount,pFences);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_uint32_t_converter_free(&fenceCount);
pyc_handle_pointer_VkFence_converter_free(&pFences);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkGetFenceStatus(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkFence fence;

    static char *kwlist[] = {"device","fence",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkFence_converter,&fence))
        return NULL;
    

    

    
        

        
            vkGetFenceStatus(device,fence);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkFence_converter_free(&fence);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkWaitForFences(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
uint32_t fenceCount;
VkFence* pFences;
VkBool32 waitAll;
uint64_t timeout;

    static char *kwlist[] = {"device","fenceCount","pFences","waitAll","timeout",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_uint32_t_converter,&fenceCount,pyc_handle_pointer_VkFence_converter,&pFences,pyc_flag_base_VkBool32_converter,&waitAll,pyc_uint64_t_converter,&timeout))
        return NULL;
    

    

    
        

        
            vkWaitForFences(device,fenceCount,pFences,waitAll,timeout);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_uint32_t_converter_free(&fenceCount);
pyc_handle_pointer_VkFence_converter_free(&pFences);
pyc_flag_base_VkBool32_converter_free(&waitAll);
pyc_uint64_t_converter_free(&timeout);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreateSemaphore(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkSemaphoreCreateInfo* pCreateInfo;

    static char *kwlist[] = {"device","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkSemaphoreCreateInfo_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkSemaphore *value = malloc(allocate_size * sizeof(VkSemaphore));
        
        
            if (raise(vkCreateSemaphore(device,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkSemaphore", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkSemaphoreCreateInfo_converter_free(&pCreateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroySemaphore(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkSemaphore semaphore;

    static char *kwlist[] = {"device","semaphore",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkSemaphore_converter,&semaphore))
        return NULL;
    

    

    
        

        
            vkDestroySemaphore(device,semaphore,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkSemaphore_converter_free(&semaphore);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreateEvent(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkEventCreateInfo* pCreateInfo;

    static char *kwlist[] = {"device","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkEventCreateInfo_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkEvent *value = malloc(allocate_size * sizeof(VkEvent));
        
        
            if (raise(vkCreateEvent(device,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkEvent", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkEventCreateInfo_converter_free(&pCreateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroyEvent(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkEvent event;

    static char *kwlist[] = {"device","event",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkEvent_converter,&event))
        return NULL;
    

    

    
        

        
            vkDestroyEvent(device,event,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkEvent_converter_free(&event);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkGetEventStatus(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkEvent event;

    static char *kwlist[] = {"device","event",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkEvent_converter,&event))
        return NULL;
    

    

    
        

        
            vkGetEventStatus(device,event);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkEvent_converter_free(&event);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkSetEvent(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkEvent event;

    static char *kwlist[] = {"device","event",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkEvent_converter,&event))
        return NULL;
    

    

    
        

        
            vkSetEvent(device,event);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkEvent_converter_free(&event);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkResetEvent(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkEvent event;

    static char *kwlist[] = {"device","event",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkEvent_converter,&event))
        return NULL;
    

    

    
        

        
            vkResetEvent(device,event);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkEvent_converter_free(&event);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreateQueryPool(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkQueryPoolCreateInfo* pCreateInfo;

    static char *kwlist[] = {"device","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkQueryPoolCreateInfo_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkQueryPool *value = malloc(allocate_size * sizeof(VkQueryPool));
        
        
            if (raise(vkCreateQueryPool(device,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkQueryPool", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkQueryPoolCreateInfo_converter_free(&pCreateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroyQueryPool(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkQueryPool queryPool;

    static char *kwlist[] = {"device","queryPool",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkQueryPool_converter,&queryPool))
        return NULL;
    

    

    
        

        
            vkDestroyQueryPool(device,queryPool,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkQueryPool_converter_free(&queryPool);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkGetQueryPoolResults(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkQueryPool queryPool;
uint32_t firstQuery;
uint32_t queryCount;
size_t dataSize;
void * pData;
VkDeviceSize stride;
VkQueryResultFlags flags;

    static char *kwlist[] = {"device","queryPool","firstQuery","queryCount","dataSize","pData","stride","flags",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkQueryPool_converter,&queryPool,pyc_uint32_t_converter,&firstQuery,pyc_uint32_t_converter,&queryCount,pyc_size_t_converter,&dataSize,pyc_void_x_converter,&pData,pyc_flag_base_VkDeviceSize_converter,&stride,pyc_flag_base_VkQueryResultFlags_converter,&flags))
        return NULL;
    

    

    
        

        
            vkGetQueryPoolResults(device,queryPool,firstQuery,queryCount,dataSize,pData,stride,flags);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkQueryPool_converter_free(&queryPool);
pyc_uint32_t_converter_free(&firstQuery);
pyc_uint32_t_converter_free(&queryCount);
pyc_size_t_converter_free(&dataSize);
pyc_void_x_converter_free(&pData);
pyc_flag_base_VkDeviceSize_converter_free(&stride);
pyc_flag_base_VkQueryResultFlags_converter_free(&flags);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreateBuffer(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkBufferCreateInfo* pCreateInfo;

    static char *kwlist[] = {"device","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkBufferCreateInfo_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkBuffer *value = malloc(allocate_size * sizeof(VkBuffer));
        
        
            if (raise(vkCreateBuffer(device,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkBuffer", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkBufferCreateInfo_converter_free(&pCreateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroyBuffer(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkBuffer buffer;

    static char *kwlist[] = {"device","buffer",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkBuffer_converter,&buffer))
        return NULL;
    

    

    
        

        
            vkDestroyBuffer(device,buffer,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkBuffer_converter_free(&buffer);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreateBufferView(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkBufferViewCreateInfo* pCreateInfo;

    static char *kwlist[] = {"device","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkBufferViewCreateInfo_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkBufferView *value = malloc(allocate_size * sizeof(VkBufferView));
        
        
            if (raise(vkCreateBufferView(device,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkBufferView", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkBufferViewCreateInfo_converter_free(&pCreateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroyBufferView(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkBufferView bufferView;

    static char *kwlist[] = {"device","bufferView",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkBufferView_converter,&bufferView))
        return NULL;
    

    

    
        

        
            vkDestroyBufferView(device,bufferView,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkBufferView_converter_free(&bufferView);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreateImage(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkImageCreateInfo* pCreateInfo;

    static char *kwlist[] = {"device","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkImageCreateInfo_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkImage *value = malloc(allocate_size * sizeof(VkImage));
        
        
            if (raise(vkCreateImage(device,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkImage", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkImageCreateInfo_converter_free(&pCreateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroyImage(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkImage image;

    static char *kwlist[] = {"device","image",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkImage_converter,&image))
        return NULL;
    

    

    
        

        
            vkDestroyImage(device,image,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkImage_converter_free(&image);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkGetImageSubresourceLayout(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkImage image;
VkImageSubresource* pSubresource;

    static char *kwlist[] = {"device","image","pSubresource",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkImage_converter,&image,pyc_struct_pointer_VkImageSubresource_converter,&pSubresource))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkSubresourceLayout *value = malloc(allocate_size * sizeof(VkSubresourceLayout));
        
        
            vkGetImageSubresourceLayout(device,image,pSubresource,value);
        


        
            
                PyObject* return_value = _PyObject_New(&PyVkSubresourceLayoutType);
                if (!return_value)
                    return NULL;
                ((PyVkSubresourceLayout*)return_value)->base = value;
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkImage_converter_free(&image);
pyc_struct_pointer_VkImageSubresource_converter_free(&pSubresource);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreateImageView(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkImageViewCreateInfo* pCreateInfo;

    static char *kwlist[] = {"device","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkImageViewCreateInfo_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkImageView *value = malloc(allocate_size * sizeof(VkImageView));
        
        
            if (raise(vkCreateImageView(device,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkImageView", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkImageViewCreateInfo_converter_free(&pCreateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroyImageView(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkImageView imageView;

    static char *kwlist[] = {"device","imageView",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkImageView_converter,&imageView))
        return NULL;
    

    

    
        

        
            vkDestroyImageView(device,imageView,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkImageView_converter_free(&imageView);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreateShaderModule(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkShaderModuleCreateInfo* pCreateInfo;

    static char *kwlist[] = {"device","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkShaderModuleCreateInfo_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkShaderModule *value = malloc(allocate_size * sizeof(VkShaderModule));
        
        
            if (raise(vkCreateShaderModule(device,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkShaderModule", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkShaderModuleCreateInfo_converter_free(&pCreateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroyShaderModule(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkShaderModule shaderModule;

    static char *kwlist[] = {"device","shaderModule",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkShaderModule_converter,&shaderModule))
        return NULL;
    

    

    
        

        
            vkDestroyShaderModule(device,shaderModule,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkShaderModule_converter_free(&shaderModule);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreatePipelineCache(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkPipelineCacheCreateInfo* pCreateInfo;

    static char *kwlist[] = {"device","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkPipelineCacheCreateInfo_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkPipelineCache *value = malloc(allocate_size * sizeof(VkPipelineCache));
        
        
            if (raise(vkCreatePipelineCache(device,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkPipelineCache", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkPipelineCacheCreateInfo_converter_free(&pCreateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroyPipelineCache(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkPipelineCache pipelineCache;

    static char *kwlist[] = {"device","pipelineCache",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkPipelineCache_converter,&pipelineCache))
        return NULL;
    

    

    
        

        
            vkDestroyPipelineCache(device,pipelineCache,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkPipelineCache_converter_free(&pipelineCache);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkMergePipelineCaches(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkPipelineCache dstCache;
uint32_t srcCacheCount;
VkPipelineCache* pSrcCaches;

    static char *kwlist[] = {"device","dstCache","srcCacheCount","pSrcCaches",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkPipelineCache_converter,&dstCache,pyc_uint32_t_converter,&srcCacheCount,pyc_handle_pointer_VkPipelineCache_converter,&pSrcCaches))
        return NULL;
    

    

    
        

        
            vkMergePipelineCaches(device,dstCache,srcCacheCount,pSrcCaches);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkPipelineCache_converter_free(&dstCache);
pyc_uint32_t_converter_free(&srcCacheCount);
pyc_handle_pointer_VkPipelineCache_converter_free(&pSrcCaches);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreateGraphicsPipelines(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkPipelineCache pipelineCache;
uint32_t createInfoCount;
VkGraphicsPipelineCreateInfo* pCreateInfos;

    static char *kwlist[] = {"device","pipelineCache","createInfoCount","pCreateInfos",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkPipelineCache_converter,&pipelineCache,pyc_uint32_t_converter,&createInfoCount,pyc_struct_pointer_VkGraphicsPipelineCreateInfo_converter,&pCreateInfos))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkPipeline *value = malloc(allocate_size * sizeof(VkPipeline));
        
        
            if (raise(vkCreateGraphicsPipelines(device,pipelineCache,createInfoCount,pCreateInfos,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkPipeline", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkPipelineCache_converter_free(&pipelineCache);
pyc_uint32_t_converter_free(&createInfoCount);
pyc_struct_pointer_VkGraphicsPipelineCreateInfo_converter_free(&pCreateInfos);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreateComputePipelines(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkPipelineCache pipelineCache;
uint32_t createInfoCount;
VkComputePipelineCreateInfo* pCreateInfos;

    static char *kwlist[] = {"device","pipelineCache","createInfoCount","pCreateInfos",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkPipelineCache_converter,&pipelineCache,pyc_uint32_t_converter,&createInfoCount,pyc_struct_pointer_VkComputePipelineCreateInfo_converter,&pCreateInfos))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkPipeline *value = malloc(allocate_size * sizeof(VkPipeline));
        
        
            if (raise(vkCreateComputePipelines(device,pipelineCache,createInfoCount,pCreateInfos,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkPipeline", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkPipelineCache_converter_free(&pipelineCache);
pyc_uint32_t_converter_free(&createInfoCount);
pyc_struct_pointer_VkComputePipelineCreateInfo_converter_free(&pCreateInfos);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroyPipeline(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkPipeline pipeline;

    static char *kwlist[] = {"device","pipeline",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkPipeline_converter,&pipeline))
        return NULL;
    

    

    
        

        
            vkDestroyPipeline(device,pipeline,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkPipeline_converter_free(&pipeline);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreatePipelineLayout(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkPipelineLayoutCreateInfo* pCreateInfo;

    static char *kwlist[] = {"device","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkPipelineLayoutCreateInfo_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkPipelineLayout *value = malloc(allocate_size * sizeof(VkPipelineLayout));
        
        
            if (raise(vkCreatePipelineLayout(device,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkPipelineLayout", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkPipelineLayoutCreateInfo_converter_free(&pCreateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroyPipelineLayout(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkPipelineLayout pipelineLayout;

    static char *kwlist[] = {"device","pipelineLayout",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkPipelineLayout_converter,&pipelineLayout))
        return NULL;
    

    

    
        

        
            vkDestroyPipelineLayout(device,pipelineLayout,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkPipelineLayout_converter_free(&pipelineLayout);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreateSampler(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkSamplerCreateInfo* pCreateInfo;

    static char *kwlist[] = {"device","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkSamplerCreateInfo_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkSampler *value = malloc(allocate_size * sizeof(VkSampler));
        
        
            if (raise(vkCreateSampler(device,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkSampler", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkSamplerCreateInfo_converter_free(&pCreateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroySampler(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkSampler sampler;

    static char *kwlist[] = {"device","sampler",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkSampler_converter,&sampler))
        return NULL;
    

    

    
        

        
            vkDestroySampler(device,sampler,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkSampler_converter_free(&sampler);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreateDescriptorSetLayout(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkDescriptorSetLayoutCreateInfo* pCreateInfo;

    static char *kwlist[] = {"device","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkDescriptorSetLayoutCreateInfo_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkDescriptorSetLayout *value = malloc(allocate_size * sizeof(VkDescriptorSetLayout));
        
        
            if (raise(vkCreateDescriptorSetLayout(device,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkDescriptorSetLayout", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkDescriptorSetLayoutCreateInfo_converter_free(&pCreateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroyDescriptorSetLayout(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkDescriptorSetLayout descriptorSetLayout;

    static char *kwlist[] = {"device","descriptorSetLayout",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkDescriptorSetLayout_converter,&descriptorSetLayout))
        return NULL;
    

    

    
        

        
            vkDestroyDescriptorSetLayout(device,descriptorSetLayout,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkDescriptorSetLayout_converter_free(&descriptorSetLayout);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreateDescriptorPool(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkDescriptorPoolCreateInfo* pCreateInfo;

    static char *kwlist[] = {"device","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkDescriptorPoolCreateInfo_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkDescriptorPool *value = malloc(allocate_size * sizeof(VkDescriptorPool));
        
        
            if (raise(vkCreateDescriptorPool(device,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkDescriptorPool", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkDescriptorPoolCreateInfo_converter_free(&pCreateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroyDescriptorPool(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkDescriptorPool descriptorPool;

    static char *kwlist[] = {"device","descriptorPool",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkDescriptorPool_converter,&descriptorPool))
        return NULL;
    

    

    
        

        
            vkDestroyDescriptorPool(device,descriptorPool,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkDescriptorPool_converter_free(&descriptorPool);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkResetDescriptorPool(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkDescriptorPool descriptorPool;
VkDescriptorPoolResetFlags flags;

    static char *kwlist[] = {"device","descriptorPool","flags",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkDescriptorPool_converter,&descriptorPool,pyc_flag_base_VkDescriptorPoolResetFlags_converter,&flags))
        return NULL;
    

    

    
        

        
            vkResetDescriptorPool(device,descriptorPool,flags);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkDescriptorPool_converter_free(&descriptorPool);
pyc_flag_base_VkDescriptorPoolResetFlags_converter_free(&flags);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkAllocateDescriptorSets(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkDescriptorSetAllocateInfo* pAllocateInfo;

    static char *kwlist[] = {"device","pAllocateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkDescriptorSetAllocateInfo_converter,&pAllocateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        
            allocate_size = (int) pAllocateInfo->descriptorSetCount;
        

        VkDescriptorSet *value = malloc(allocate_size * sizeof(VkDescriptorSet));
        
        
            if (raise(vkAllocateDescriptorSets(device,pAllocateInfo,value)))
                return NULL;
        


        
            PyObject* return_value = PyList_New(0);
            int i = 0;
            for (i = 0; i < allocate_size; i++) {
                VkDescriptorSet* val = malloc(sizeof(VkDescriptorSet));
                memcpy(val, value + i, sizeof(VkDescriptorSet));

                
                    PyObject* tmp = PyCapsule_New(val, "VkDescriptorSet", NULL);
                
                PyList_Append(return_value, tmp);
            }
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkDescriptorSetAllocateInfo_converter_free(&pAllocateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkFreeDescriptorSets(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkDescriptorPool descriptorPool;
uint32_t descriptorSetCount;
VkDescriptorSet* pDescriptorSets;

    static char *kwlist[] = {"device","descriptorPool","descriptorSetCount","pDescriptorSets",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkDescriptorPool_converter,&descriptorPool,pyc_uint32_t_converter,&descriptorSetCount,pyc_handle_pointer_VkDescriptorSet_converter,&pDescriptorSets))
        return NULL;
    

    

    
        

        
            vkFreeDescriptorSets(device,descriptorPool,descriptorSetCount,pDescriptorSets);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkDescriptorPool_converter_free(&descriptorPool);
pyc_uint32_t_converter_free(&descriptorSetCount);
pyc_handle_pointer_VkDescriptorSet_converter_free(&pDescriptorSets);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkUpdateDescriptorSets(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
uint32_t descriptorWriteCount;
VkWriteDescriptorSet* pDescriptorWrites;
uint32_t descriptorCopyCount;
VkCopyDescriptorSet* pDescriptorCopies;

    static char *kwlist[] = {"device","descriptorWriteCount","pDescriptorWrites","descriptorCopyCount","pDescriptorCopies",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_uint32_t_converter,&descriptorWriteCount,pyc_struct_pointer_VkWriteDescriptorSet_converter,&pDescriptorWrites,pyc_uint32_t_converter,&descriptorCopyCount,pyc_struct_pointer_VkCopyDescriptorSet_converter,&pDescriptorCopies))
        return NULL;
    

    

    
        

        
            vkUpdateDescriptorSets(device,descriptorWriteCount,pDescriptorWrites,descriptorCopyCount,pDescriptorCopies);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_uint32_t_converter_free(&descriptorWriteCount);
pyc_struct_pointer_VkWriteDescriptorSet_converter_free(&pDescriptorWrites);
pyc_uint32_t_converter_free(&descriptorCopyCount);
pyc_struct_pointer_VkCopyDescriptorSet_converter_free(&pDescriptorCopies);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreateFramebuffer(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkFramebufferCreateInfo* pCreateInfo;

    static char *kwlist[] = {"device","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkFramebufferCreateInfo_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkFramebuffer *value = malloc(allocate_size * sizeof(VkFramebuffer));
        
        
            if (raise(vkCreateFramebuffer(device,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkFramebuffer", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkFramebufferCreateInfo_converter_free(&pCreateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroyFramebuffer(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkFramebuffer framebuffer;

    static char *kwlist[] = {"device","framebuffer",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkFramebuffer_converter,&framebuffer))
        return NULL;
    

    

    
        

        
            vkDestroyFramebuffer(device,framebuffer,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkFramebuffer_converter_free(&framebuffer);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreateRenderPass(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkRenderPassCreateInfo* pCreateInfo;

    static char *kwlist[] = {"device","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkRenderPassCreateInfo_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkRenderPass *value = malloc(allocate_size * sizeof(VkRenderPass));
        
        
            if (raise(vkCreateRenderPass(device,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkRenderPass", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkRenderPassCreateInfo_converter_free(&pCreateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroyRenderPass(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkRenderPass renderPass;

    static char *kwlist[] = {"device","renderPass",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkRenderPass_converter,&renderPass))
        return NULL;
    

    

    
        

        
            vkDestroyRenderPass(device,renderPass,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkRenderPass_converter_free(&renderPass);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkGetRenderAreaGranularity(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkRenderPass renderPass;

    static char *kwlist[] = {"device","renderPass",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkRenderPass_converter,&renderPass))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkExtent2D *value = malloc(allocate_size * sizeof(VkExtent2D));
        
        
            vkGetRenderAreaGranularity(device,renderPass,value);
        


        
            
                PyObject* return_value = _PyObject_New(&PyVkExtent2DType);
                if (!return_value)
                    return NULL;
                ((PyVkExtent2D*)return_value)->base = value;
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkRenderPass_converter_free(&renderPass);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCreateCommandPool(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkCommandPoolCreateInfo* pCreateInfo;

    static char *kwlist[] = {"device","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkCommandPoolCreateInfo_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkCommandPool *value = malloc(allocate_size * sizeof(VkCommandPool));
        
        
            if (raise(vkCreateCommandPool(device,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkCommandPool", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkCommandPoolCreateInfo_converter_free(&pCreateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkDestroyCommandPool(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkCommandPool commandPool;

    static char *kwlist[] = {"device","commandPool",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkCommandPool_converter,&commandPool))
        return NULL;
    

    

    
        

        
            vkDestroyCommandPool(device,commandPool,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkCommandPool_converter_free(&commandPool);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkResetCommandPool(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkCommandPool commandPool;
VkCommandPoolResetFlags flags;

    static char *kwlist[] = {"device","commandPool","flags",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkCommandPool_converter,&commandPool,pyc_flag_base_VkCommandPoolResetFlags_converter,&flags))
        return NULL;
    

    

    
        

        
            vkResetCommandPool(device,commandPool,flags);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkCommandPool_converter_free(&commandPool);
pyc_flag_base_VkCommandPoolResetFlags_converter_free(&flags);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkAllocateCommandBuffers(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkCommandBufferAllocateInfo* pAllocateInfo;

    static char *kwlist[] = {"device","pAllocateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkCommandBufferAllocateInfo_converter,&pAllocateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        
            allocate_size = (int) pAllocateInfo->commandBufferCount;
        

        VkCommandBuffer *value = malloc(allocate_size * sizeof(VkCommandBuffer));
        
        
            if (raise(vkAllocateCommandBuffers(device,pAllocateInfo,value)))
                return NULL;
        


        
            PyObject* return_value = PyList_New(0);
            int i = 0;
            for (i = 0; i < allocate_size; i++) {
                VkCommandBuffer* val = malloc(sizeof(VkCommandBuffer));
                memcpy(val, value + i, sizeof(VkCommandBuffer));

                
                    PyObject* tmp = PyCapsule_New(val, "VkCommandBuffer", NULL);
                
                PyList_Append(return_value, tmp);
            }
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkCommandBufferAllocateInfo_converter_free(&pAllocateInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkFreeCommandBuffers(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkDevice device;
VkCommandPool commandPool;
uint32_t commandBufferCount;
VkCommandBuffer* pCommandBuffers;

    static char *kwlist[] = {"device","commandPool","commandBufferCount","pCommandBuffers",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkCommandPool_converter,&commandPool,pyc_uint32_t_converter,&commandBufferCount,pyc_handle_pointer_VkCommandBuffer_converter,&pCommandBuffers))
        return NULL;
    

    

    
        

        
            vkFreeCommandBuffers(device,commandPool,commandBufferCount,pCommandBuffers);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkCommandPool_converter_free(&commandPool);
pyc_uint32_t_converter_free(&commandBufferCount);
pyc_handle_pointer_VkCommandBuffer_converter_free(&pCommandBuffers);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkBeginCommandBuffer(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkCommandBufferBeginInfo* pBeginInfo;

    static char *kwlist[] = {"commandBuffer","pBeginInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_struct_pointer_VkCommandBufferBeginInfo_converter,&pBeginInfo))
        return NULL;
    

    

    
        

        
            vkBeginCommandBuffer(commandBuffer,pBeginInfo);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_struct_pointer_VkCommandBufferBeginInfo_converter_free(&pBeginInfo);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkEndCommandBuffer(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;

    static char *kwlist[] = {"commandBuffer",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer))
        return NULL;
    

    

    
        

        
            vkEndCommandBuffer(commandBuffer);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkResetCommandBuffer(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkCommandBufferResetFlags flags;

    static char *kwlist[] = {"commandBuffer","flags",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_flag_base_VkCommandBufferResetFlags_converter,&flags))
        return NULL;
    

    

    
        

        
            vkResetCommandBuffer(commandBuffer,flags);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_flag_base_VkCommandBufferResetFlags_converter_free(&flags);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdBindPipeline(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkPipelineBindPoint pipelineBindPoint;
VkPipeline pipeline;

    static char *kwlist[] = {"commandBuffer","pipelineBindPoint","pipeline",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_flag_base_VkPipelineBindPoint_converter,&pipelineBindPoint,pyc_handle_base_VkPipeline_converter,&pipeline))
        return NULL;
    

    

    
        

        
            vkCmdBindPipeline(commandBuffer,pipelineBindPoint,pipeline);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_flag_base_VkPipelineBindPoint_converter_free(&pipelineBindPoint);
pyc_handle_base_VkPipeline_converter_free(&pipeline);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdSetViewport(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
uint32_t firstViewport;
uint32_t viewportCount;
VkViewport* pViewports;

    static char *kwlist[] = {"commandBuffer","firstViewport","viewportCount","pViewports",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_uint32_t_converter,&firstViewport,pyc_uint32_t_converter,&viewportCount,pyc_struct_pointer_VkViewport_converter,&pViewports))
        return NULL;
    

    

    
        

        
            vkCmdSetViewport(commandBuffer,firstViewport,viewportCount,pViewports);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_uint32_t_converter_free(&firstViewport);
pyc_uint32_t_converter_free(&viewportCount);
pyc_struct_pointer_VkViewport_converter_free(&pViewports);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdSetScissor(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
uint32_t firstScissor;
uint32_t scissorCount;
VkRect2D* pScissors;

    static char *kwlist[] = {"commandBuffer","firstScissor","scissorCount","pScissors",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_uint32_t_converter,&firstScissor,pyc_uint32_t_converter,&scissorCount,pyc_struct_pointer_VkRect2D_converter,&pScissors))
        return NULL;
    

    

    
        

        
            vkCmdSetScissor(commandBuffer,firstScissor,scissorCount,pScissors);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_uint32_t_converter_free(&firstScissor);
pyc_uint32_t_converter_free(&scissorCount);
pyc_struct_pointer_VkRect2D_converter_free(&pScissors);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdSetLineWidth(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
float lineWidth;

    static char *kwlist[] = {"commandBuffer","lineWidth",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_float_converter,&lineWidth))
        return NULL;
    

    

    
        

        
            vkCmdSetLineWidth(commandBuffer,lineWidth);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_float_converter_free(&lineWidth);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdSetDepthBias(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
float depthBiasConstantFactor;
float depthBiasClamp;
float depthBiasSlopeFactor;

    static char *kwlist[] = {"commandBuffer","depthBiasConstantFactor","depthBiasClamp","depthBiasSlopeFactor",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_float_converter,&depthBiasConstantFactor,pyc_float_converter,&depthBiasClamp,pyc_float_converter,&depthBiasSlopeFactor))
        return NULL;
    

    

    
        

        
            vkCmdSetDepthBias(commandBuffer,depthBiasConstantFactor,depthBiasClamp,depthBiasSlopeFactor);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_float_converter_free(&depthBiasConstantFactor);
pyc_float_converter_free(&depthBiasClamp);
pyc_float_converter_free(&depthBiasSlopeFactor);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdSetBlendConstants(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
float* blendConstants;

    static char *kwlist[] = {"commandBuffer","blendConstants",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_array_float_converter,&blendConstants))
        return NULL;
    

    

    
        

        
            vkCmdSetBlendConstants(commandBuffer,blendConstants);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_array_float_converter_free(&blendConstants);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdSetDepthBounds(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
float minDepthBounds;
float maxDepthBounds;

    static char *kwlist[] = {"commandBuffer","minDepthBounds","maxDepthBounds",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_float_converter,&minDepthBounds,pyc_float_converter,&maxDepthBounds))
        return NULL;
    

    

    
        

        
            vkCmdSetDepthBounds(commandBuffer,minDepthBounds,maxDepthBounds);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_float_converter_free(&minDepthBounds);
pyc_float_converter_free(&maxDepthBounds);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdSetStencilCompareMask(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkStencilFaceFlags faceMask;
uint32_t compareMask;

    static char *kwlist[] = {"commandBuffer","faceMask","compareMask",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_flag_base_VkStencilFaceFlags_converter,&faceMask,pyc_uint32_t_converter,&compareMask))
        return NULL;
    

    

    
        

        
            vkCmdSetStencilCompareMask(commandBuffer,faceMask,compareMask);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_flag_base_VkStencilFaceFlags_converter_free(&faceMask);
pyc_uint32_t_converter_free(&compareMask);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdSetStencilWriteMask(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkStencilFaceFlags faceMask;
uint32_t writeMask;

    static char *kwlist[] = {"commandBuffer","faceMask","writeMask",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_flag_base_VkStencilFaceFlags_converter,&faceMask,pyc_uint32_t_converter,&writeMask))
        return NULL;
    

    

    
        

        
            vkCmdSetStencilWriteMask(commandBuffer,faceMask,writeMask);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_flag_base_VkStencilFaceFlags_converter_free(&faceMask);
pyc_uint32_t_converter_free(&writeMask);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdSetStencilReference(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkStencilFaceFlags faceMask;
uint32_t reference;

    static char *kwlist[] = {"commandBuffer","faceMask","reference",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_flag_base_VkStencilFaceFlags_converter,&faceMask,pyc_uint32_t_converter,&reference))
        return NULL;
    

    

    
        

        
            vkCmdSetStencilReference(commandBuffer,faceMask,reference);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_flag_base_VkStencilFaceFlags_converter_free(&faceMask);
pyc_uint32_t_converter_free(&reference);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdBindDescriptorSets(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkPipelineBindPoint pipelineBindPoint;
VkPipelineLayout layout;
uint32_t firstSet;
uint32_t descriptorSetCount;
VkDescriptorSet* pDescriptorSets;
uint32_t dynamicOffsetCount;
uint32_t* pDynamicOffsets;

    static char *kwlist[] = {"commandBuffer","pipelineBindPoint","layout","firstSet","descriptorSetCount","pDescriptorSets","dynamicOffsetCount","pDynamicOffsets",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_flag_base_VkPipelineBindPoint_converter,&pipelineBindPoint,pyc_handle_base_VkPipelineLayout_converter,&layout,pyc_uint32_t_converter,&firstSet,pyc_uint32_t_converter,&descriptorSetCount,pyc_handle_pointer_VkDescriptorSet_converter,&pDescriptorSets,pyc_uint32_t_converter,&dynamicOffsetCount,pyc_array_uint32_t_converter,&pDynamicOffsets))
        return NULL;
    

    

    
        

        
            vkCmdBindDescriptorSets(commandBuffer,pipelineBindPoint,layout,firstSet,descriptorSetCount,pDescriptorSets,dynamicOffsetCount,pDynamicOffsets);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_flag_base_VkPipelineBindPoint_converter_free(&pipelineBindPoint);
pyc_handle_base_VkPipelineLayout_converter_free(&layout);
pyc_uint32_t_converter_free(&firstSet);
pyc_uint32_t_converter_free(&descriptorSetCount);
pyc_handle_pointer_VkDescriptorSet_converter_free(&pDescriptorSets);
pyc_uint32_t_converter_free(&dynamicOffsetCount);
pyc_array_uint32_t_converter_free(&pDynamicOffsets);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdBindIndexBuffer(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkBuffer buffer;
VkDeviceSize offset;
VkIndexType indexType;

    static char *kwlist[] = {"commandBuffer","buffer","offset","indexType",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkBuffer_converter,&buffer,pyc_flag_base_VkDeviceSize_converter,&offset,pyc_flag_base_VkIndexType_converter,&indexType))
        return NULL;
    

    

    
        

        
            vkCmdBindIndexBuffer(commandBuffer,buffer,offset,indexType);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkBuffer_converter_free(&buffer);
pyc_flag_base_VkDeviceSize_converter_free(&offset);
pyc_flag_base_VkIndexType_converter_free(&indexType);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdBindVertexBuffers(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
uint32_t firstBinding;
uint32_t bindingCount;
VkBuffer* pBuffers;
VkDeviceSize* pOffsets;

    static char *kwlist[] = {"commandBuffer","firstBinding","bindingCount","pBuffers","pOffsets",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_uint32_t_converter,&firstBinding,pyc_uint32_t_converter,&bindingCount,pyc_handle_pointer_VkBuffer_converter,&pBuffers,pyc_flag_pointer_VkDeviceSize_converter,&pOffsets))
        return NULL;
    

    

    
        

        
            vkCmdBindVertexBuffers(commandBuffer,firstBinding,bindingCount,pBuffers,pOffsets);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_uint32_t_converter_free(&firstBinding);
pyc_uint32_t_converter_free(&bindingCount);
pyc_handle_pointer_VkBuffer_converter_free(&pBuffers);
pyc_flag_pointer_VkDeviceSize_converter_free(&pOffsets);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdDraw(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
uint32_t vertexCount;
uint32_t instanceCount;
uint32_t firstVertex;
uint32_t firstInstance;

    static char *kwlist[] = {"commandBuffer","vertexCount","instanceCount","firstVertex","firstInstance",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_uint32_t_converter,&vertexCount,pyc_uint32_t_converter,&instanceCount,pyc_uint32_t_converter,&firstVertex,pyc_uint32_t_converter,&firstInstance))
        return NULL;
    

    

    
        

        
            vkCmdDraw(commandBuffer,vertexCount,instanceCount,firstVertex,firstInstance);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_uint32_t_converter_free(&vertexCount);
pyc_uint32_t_converter_free(&instanceCount);
pyc_uint32_t_converter_free(&firstVertex);
pyc_uint32_t_converter_free(&firstInstance);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdDrawIndexed(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
uint32_t indexCount;
uint32_t instanceCount;
uint32_t firstIndex;
int32_t vertexOffset;
uint32_t firstInstance;

    static char *kwlist[] = {"commandBuffer","indexCount","instanceCount","firstIndex","vertexOffset","firstInstance",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_uint32_t_converter,&indexCount,pyc_uint32_t_converter,&instanceCount,pyc_uint32_t_converter,&firstIndex,pyc_int32_t_converter,&vertexOffset,pyc_uint32_t_converter,&firstInstance))
        return NULL;
    

    

    
        

        
            vkCmdDrawIndexed(commandBuffer,indexCount,instanceCount,firstIndex,vertexOffset,firstInstance);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_uint32_t_converter_free(&indexCount);
pyc_uint32_t_converter_free(&instanceCount);
pyc_uint32_t_converter_free(&firstIndex);
pyc_int32_t_converter_free(&vertexOffset);
pyc_uint32_t_converter_free(&firstInstance);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdDrawIndirect(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkBuffer buffer;
VkDeviceSize offset;
uint32_t drawCount;
uint32_t stride;

    static char *kwlist[] = {"commandBuffer","buffer","offset","drawCount","stride",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkBuffer_converter,&buffer,pyc_flag_base_VkDeviceSize_converter,&offset,pyc_uint32_t_converter,&drawCount,pyc_uint32_t_converter,&stride))
        return NULL;
    

    

    
        

        
            vkCmdDrawIndirect(commandBuffer,buffer,offset,drawCount,stride);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkBuffer_converter_free(&buffer);
pyc_flag_base_VkDeviceSize_converter_free(&offset);
pyc_uint32_t_converter_free(&drawCount);
pyc_uint32_t_converter_free(&stride);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdDrawIndexedIndirect(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkBuffer buffer;
VkDeviceSize offset;
uint32_t drawCount;
uint32_t stride;

    static char *kwlist[] = {"commandBuffer","buffer","offset","drawCount","stride",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkBuffer_converter,&buffer,pyc_flag_base_VkDeviceSize_converter,&offset,pyc_uint32_t_converter,&drawCount,pyc_uint32_t_converter,&stride))
        return NULL;
    

    

    
        

        
            vkCmdDrawIndexedIndirect(commandBuffer,buffer,offset,drawCount,stride);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkBuffer_converter_free(&buffer);
pyc_flag_base_VkDeviceSize_converter_free(&offset);
pyc_uint32_t_converter_free(&drawCount);
pyc_uint32_t_converter_free(&stride);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdDispatch(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
uint32_t x;
uint32_t y;
uint32_t z;

    static char *kwlist[] = {"commandBuffer","x","y","z",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_uint32_t_converter,&x,pyc_uint32_t_converter,&y,pyc_uint32_t_converter,&z))
        return NULL;
    

    

    
        

        
            vkCmdDispatch(commandBuffer,x,y,z);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_uint32_t_converter_free(&x);
pyc_uint32_t_converter_free(&y);
pyc_uint32_t_converter_free(&z);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdDispatchIndirect(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkBuffer buffer;
VkDeviceSize offset;

    static char *kwlist[] = {"commandBuffer","buffer","offset",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkBuffer_converter,&buffer,pyc_flag_base_VkDeviceSize_converter,&offset))
        return NULL;
    

    

    
        

        
            vkCmdDispatchIndirect(commandBuffer,buffer,offset);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkBuffer_converter_free(&buffer);
pyc_flag_base_VkDeviceSize_converter_free(&offset);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdCopyBuffer(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkBuffer srcBuffer;
VkBuffer dstBuffer;
uint32_t regionCount;
VkBufferCopy* pRegions;

    static char *kwlist[] = {"commandBuffer","srcBuffer","dstBuffer","regionCount","pRegions",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkBuffer_converter,&srcBuffer,pyc_handle_base_VkBuffer_converter,&dstBuffer,pyc_uint32_t_converter,&regionCount,pyc_struct_pointer_VkBufferCopy_converter,&pRegions))
        return NULL;
    

    

    
        

        
            vkCmdCopyBuffer(commandBuffer,srcBuffer,dstBuffer,regionCount,pRegions);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkBuffer_converter_free(&srcBuffer);
pyc_handle_base_VkBuffer_converter_free(&dstBuffer);
pyc_uint32_t_converter_free(&regionCount);
pyc_struct_pointer_VkBufferCopy_converter_free(&pRegions);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdCopyImage(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkImage srcImage;
VkImageLayout srcImageLayout;
VkImage dstImage;
VkImageLayout dstImageLayout;
uint32_t regionCount;
VkImageCopy* pRegions;

    static char *kwlist[] = {"commandBuffer","srcImage","srcImageLayout","dstImage","dstImageLayout","regionCount","pRegions",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkImage_converter,&srcImage,pyc_flag_base_VkImageLayout_converter,&srcImageLayout,pyc_handle_base_VkImage_converter,&dstImage,pyc_flag_base_VkImageLayout_converter,&dstImageLayout,pyc_uint32_t_converter,&regionCount,pyc_struct_pointer_VkImageCopy_converter,&pRegions))
        return NULL;
    

    

    
        

        
            vkCmdCopyImage(commandBuffer,srcImage,srcImageLayout,dstImage,dstImageLayout,regionCount,pRegions);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkImage_converter_free(&srcImage);
pyc_flag_base_VkImageLayout_converter_free(&srcImageLayout);
pyc_handle_base_VkImage_converter_free(&dstImage);
pyc_flag_base_VkImageLayout_converter_free(&dstImageLayout);
pyc_uint32_t_converter_free(&regionCount);
pyc_struct_pointer_VkImageCopy_converter_free(&pRegions);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdBlitImage(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkImage srcImage;
VkImageLayout srcImageLayout;
VkImage dstImage;
VkImageLayout dstImageLayout;
uint32_t regionCount;
VkImageBlit* pRegions;
VkFilter filter;

    static char *kwlist[] = {"commandBuffer","srcImage","srcImageLayout","dstImage","dstImageLayout","regionCount","pRegions","filter",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkImage_converter,&srcImage,pyc_flag_base_VkImageLayout_converter,&srcImageLayout,pyc_handle_base_VkImage_converter,&dstImage,pyc_flag_base_VkImageLayout_converter,&dstImageLayout,pyc_uint32_t_converter,&regionCount,pyc_struct_pointer_VkImageBlit_converter,&pRegions,pyc_flag_base_VkFilter_converter,&filter))
        return NULL;
    

    

    
        

        
            vkCmdBlitImage(commandBuffer,srcImage,srcImageLayout,dstImage,dstImageLayout,regionCount,pRegions,filter);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkImage_converter_free(&srcImage);
pyc_flag_base_VkImageLayout_converter_free(&srcImageLayout);
pyc_handle_base_VkImage_converter_free(&dstImage);
pyc_flag_base_VkImageLayout_converter_free(&dstImageLayout);
pyc_uint32_t_converter_free(&regionCount);
pyc_struct_pointer_VkImageBlit_converter_free(&pRegions);
pyc_flag_base_VkFilter_converter_free(&filter);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdCopyBufferToImage(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkBuffer srcBuffer;
VkImage dstImage;
VkImageLayout dstImageLayout;
uint32_t regionCount;
VkBufferImageCopy* pRegions;

    static char *kwlist[] = {"commandBuffer","srcBuffer","dstImage","dstImageLayout","regionCount","pRegions",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkBuffer_converter,&srcBuffer,pyc_handle_base_VkImage_converter,&dstImage,pyc_flag_base_VkImageLayout_converter,&dstImageLayout,pyc_uint32_t_converter,&regionCount,pyc_struct_pointer_VkBufferImageCopy_converter,&pRegions))
        return NULL;
    

    

    
        

        
            vkCmdCopyBufferToImage(commandBuffer,srcBuffer,dstImage,dstImageLayout,regionCount,pRegions);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkBuffer_converter_free(&srcBuffer);
pyc_handle_base_VkImage_converter_free(&dstImage);
pyc_flag_base_VkImageLayout_converter_free(&dstImageLayout);
pyc_uint32_t_converter_free(&regionCount);
pyc_struct_pointer_VkBufferImageCopy_converter_free(&pRegions);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdCopyImageToBuffer(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkImage srcImage;
VkImageLayout srcImageLayout;
VkBuffer dstBuffer;
uint32_t regionCount;
VkBufferImageCopy* pRegions;

    static char *kwlist[] = {"commandBuffer","srcImage","srcImageLayout","dstBuffer","regionCount","pRegions",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkImage_converter,&srcImage,pyc_flag_base_VkImageLayout_converter,&srcImageLayout,pyc_handle_base_VkBuffer_converter,&dstBuffer,pyc_uint32_t_converter,&regionCount,pyc_struct_pointer_VkBufferImageCopy_converter,&pRegions))
        return NULL;
    

    

    
        

        
            vkCmdCopyImageToBuffer(commandBuffer,srcImage,srcImageLayout,dstBuffer,regionCount,pRegions);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkImage_converter_free(&srcImage);
pyc_flag_base_VkImageLayout_converter_free(&srcImageLayout);
pyc_handle_base_VkBuffer_converter_free(&dstBuffer);
pyc_uint32_t_converter_free(&regionCount);
pyc_struct_pointer_VkBufferImageCopy_converter_free(&pRegions);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdUpdateBuffer(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkBuffer dstBuffer;
VkDeviceSize dstOffset;
VkDeviceSize dataSize;
void * pData;

    static char *kwlist[] = {"commandBuffer","dstBuffer","dstOffset","dataSize","pData",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkBuffer_converter,&dstBuffer,pyc_flag_base_VkDeviceSize_converter,&dstOffset,pyc_flag_base_VkDeviceSize_converter,&dataSize,pyc_void_x_converter,&pData))
        return NULL;
    

    

    
        

        
            vkCmdUpdateBuffer(commandBuffer,dstBuffer,dstOffset,dataSize,pData);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkBuffer_converter_free(&dstBuffer);
pyc_flag_base_VkDeviceSize_converter_free(&dstOffset);
pyc_flag_base_VkDeviceSize_converter_free(&dataSize);
pyc_void_x_converter_free(&pData);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdFillBuffer(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkBuffer dstBuffer;
VkDeviceSize dstOffset;
VkDeviceSize size;
uint32_t data;

    static char *kwlist[] = {"commandBuffer","dstBuffer","dstOffset","size","data",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkBuffer_converter,&dstBuffer,pyc_flag_base_VkDeviceSize_converter,&dstOffset,pyc_flag_base_VkDeviceSize_converter,&size,pyc_uint32_t_converter,&data))
        return NULL;
    

    

    
        

        
            vkCmdFillBuffer(commandBuffer,dstBuffer,dstOffset,size,data);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkBuffer_converter_free(&dstBuffer);
pyc_flag_base_VkDeviceSize_converter_free(&dstOffset);
pyc_flag_base_VkDeviceSize_converter_free(&size);
pyc_uint32_t_converter_free(&data);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdClearColorImage(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkImage image;
VkImageLayout imageLayout;
VkClearColorValue* pColor;
uint32_t rangeCount;
VkImageSubresourceRange* pRanges;

    static char *kwlist[] = {"commandBuffer","image","imageLayout","pColor","rangeCount","pRanges",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkImage_converter,&image,pyc_flag_base_VkImageLayout_converter,&imageLayout,pyc_struct_pointer_VkClearColorValue_converter,&pColor,pyc_uint32_t_converter,&rangeCount,pyc_struct_pointer_VkImageSubresourceRange_converter,&pRanges))
        return NULL;
    

    

    
        

        
            vkCmdClearColorImage(commandBuffer,image,imageLayout,pColor,rangeCount,pRanges);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkImage_converter_free(&image);
pyc_flag_base_VkImageLayout_converter_free(&imageLayout);
pyc_struct_pointer_VkClearColorValue_converter_free(&pColor);
pyc_uint32_t_converter_free(&rangeCount);
pyc_struct_pointer_VkImageSubresourceRange_converter_free(&pRanges);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdClearDepthStencilImage(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkImage image;
VkImageLayout imageLayout;
VkClearDepthStencilValue* pDepthStencil;
uint32_t rangeCount;
VkImageSubresourceRange* pRanges;

    static char *kwlist[] = {"commandBuffer","image","imageLayout","pDepthStencil","rangeCount","pRanges",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkImage_converter,&image,pyc_flag_base_VkImageLayout_converter,&imageLayout,pyc_struct_pointer_VkClearDepthStencilValue_converter,&pDepthStencil,pyc_uint32_t_converter,&rangeCount,pyc_struct_pointer_VkImageSubresourceRange_converter,&pRanges))
        return NULL;
    

    

    
        

        
            vkCmdClearDepthStencilImage(commandBuffer,image,imageLayout,pDepthStencil,rangeCount,pRanges);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkImage_converter_free(&image);
pyc_flag_base_VkImageLayout_converter_free(&imageLayout);
pyc_struct_pointer_VkClearDepthStencilValue_converter_free(&pDepthStencil);
pyc_uint32_t_converter_free(&rangeCount);
pyc_struct_pointer_VkImageSubresourceRange_converter_free(&pRanges);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdClearAttachments(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
uint32_t attachmentCount;
VkClearAttachment* pAttachments;
uint32_t rectCount;
VkClearRect* pRects;

    static char *kwlist[] = {"commandBuffer","attachmentCount","pAttachments","rectCount","pRects",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_uint32_t_converter,&attachmentCount,pyc_struct_pointer_VkClearAttachment_converter,&pAttachments,pyc_uint32_t_converter,&rectCount,pyc_struct_pointer_VkClearRect_converter,&pRects))
        return NULL;
    

    

    
        

        
            vkCmdClearAttachments(commandBuffer,attachmentCount,pAttachments,rectCount,pRects);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_uint32_t_converter_free(&attachmentCount);
pyc_struct_pointer_VkClearAttachment_converter_free(&pAttachments);
pyc_uint32_t_converter_free(&rectCount);
pyc_struct_pointer_VkClearRect_converter_free(&pRects);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdResolveImage(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkImage srcImage;
VkImageLayout srcImageLayout;
VkImage dstImage;
VkImageLayout dstImageLayout;
uint32_t regionCount;
VkImageResolve* pRegions;

    static char *kwlist[] = {"commandBuffer","srcImage","srcImageLayout","dstImage","dstImageLayout","regionCount","pRegions",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkImage_converter,&srcImage,pyc_flag_base_VkImageLayout_converter,&srcImageLayout,pyc_handle_base_VkImage_converter,&dstImage,pyc_flag_base_VkImageLayout_converter,&dstImageLayout,pyc_uint32_t_converter,&regionCount,pyc_struct_pointer_VkImageResolve_converter,&pRegions))
        return NULL;
    

    

    
        

        
            vkCmdResolveImage(commandBuffer,srcImage,srcImageLayout,dstImage,dstImageLayout,regionCount,pRegions);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkImage_converter_free(&srcImage);
pyc_flag_base_VkImageLayout_converter_free(&srcImageLayout);
pyc_handle_base_VkImage_converter_free(&dstImage);
pyc_flag_base_VkImageLayout_converter_free(&dstImageLayout);
pyc_uint32_t_converter_free(&regionCount);
pyc_struct_pointer_VkImageResolve_converter_free(&pRegions);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdSetEvent(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkEvent event;
VkPipelineStageFlags stageMask;

    static char *kwlist[] = {"commandBuffer","event","stageMask",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkEvent_converter,&event,pyc_flag_base_VkPipelineStageFlags_converter,&stageMask))
        return NULL;
    

    

    
        

        
            vkCmdSetEvent(commandBuffer,event,stageMask);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkEvent_converter_free(&event);
pyc_flag_base_VkPipelineStageFlags_converter_free(&stageMask);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdResetEvent(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkEvent event;
VkPipelineStageFlags stageMask;

    static char *kwlist[] = {"commandBuffer","event","stageMask",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkEvent_converter,&event,pyc_flag_base_VkPipelineStageFlags_converter,&stageMask))
        return NULL;
    

    

    
        

        
            vkCmdResetEvent(commandBuffer,event,stageMask);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkEvent_converter_free(&event);
pyc_flag_base_VkPipelineStageFlags_converter_free(&stageMask);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdWaitEvents(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
uint32_t eventCount;
VkEvent* pEvents;
VkPipelineStageFlags srcStageMask;
VkPipelineStageFlags dstStageMask;
uint32_t memoryBarrierCount;
VkMemoryBarrier* pMemoryBarriers;
uint32_t bufferMemoryBarrierCount;
VkBufferMemoryBarrier* pBufferMemoryBarriers;
uint32_t imageMemoryBarrierCount;
VkImageMemoryBarrier* pImageMemoryBarriers;

    static char *kwlist[] = {"commandBuffer","eventCount","pEvents","srcStageMask","dstStageMask","memoryBarrierCount","pMemoryBarriers","bufferMemoryBarrierCount","pBufferMemoryBarriers","imageMemoryBarrierCount","pImageMemoryBarriers",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_uint32_t_converter,&eventCount,pyc_handle_pointer_VkEvent_converter,&pEvents,pyc_flag_base_VkPipelineStageFlags_converter,&srcStageMask,pyc_flag_base_VkPipelineStageFlags_converter,&dstStageMask,pyc_uint32_t_converter,&memoryBarrierCount,pyc_struct_pointer_VkMemoryBarrier_converter,&pMemoryBarriers,pyc_uint32_t_converter,&bufferMemoryBarrierCount,pyc_struct_pointer_VkBufferMemoryBarrier_converter,&pBufferMemoryBarriers,pyc_uint32_t_converter,&imageMemoryBarrierCount,pyc_struct_pointer_VkImageMemoryBarrier_converter,&pImageMemoryBarriers))
        return NULL;
    

    

    
        

        
            vkCmdWaitEvents(commandBuffer,eventCount,pEvents,srcStageMask,dstStageMask,memoryBarrierCount,pMemoryBarriers,bufferMemoryBarrierCount,pBufferMemoryBarriers,imageMemoryBarrierCount,pImageMemoryBarriers);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_uint32_t_converter_free(&eventCount);
pyc_handle_pointer_VkEvent_converter_free(&pEvents);
pyc_flag_base_VkPipelineStageFlags_converter_free(&srcStageMask);
pyc_flag_base_VkPipelineStageFlags_converter_free(&dstStageMask);
pyc_uint32_t_converter_free(&memoryBarrierCount);
pyc_struct_pointer_VkMemoryBarrier_converter_free(&pMemoryBarriers);
pyc_uint32_t_converter_free(&bufferMemoryBarrierCount);
pyc_struct_pointer_VkBufferMemoryBarrier_converter_free(&pBufferMemoryBarriers);
pyc_uint32_t_converter_free(&imageMemoryBarrierCount);
pyc_struct_pointer_VkImageMemoryBarrier_converter_free(&pImageMemoryBarriers);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdPipelineBarrier(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkPipelineStageFlags srcStageMask;
VkPipelineStageFlags dstStageMask;
VkDependencyFlags dependencyFlags;
uint32_t memoryBarrierCount;
VkMemoryBarrier* pMemoryBarriers;
uint32_t bufferMemoryBarrierCount;
VkBufferMemoryBarrier* pBufferMemoryBarriers;
uint32_t imageMemoryBarrierCount;
VkImageMemoryBarrier* pImageMemoryBarriers;

    static char *kwlist[] = {"commandBuffer","srcStageMask","dstStageMask","dependencyFlags","memoryBarrierCount","pMemoryBarriers","bufferMemoryBarrierCount","pBufferMemoryBarriers","imageMemoryBarrierCount","pImageMemoryBarriers",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_flag_base_VkPipelineStageFlags_converter,&srcStageMask,pyc_flag_base_VkPipelineStageFlags_converter,&dstStageMask,pyc_flag_base_VkDependencyFlags_converter,&dependencyFlags,pyc_uint32_t_converter,&memoryBarrierCount,pyc_struct_pointer_VkMemoryBarrier_converter,&pMemoryBarriers,pyc_uint32_t_converter,&bufferMemoryBarrierCount,pyc_struct_pointer_VkBufferMemoryBarrier_converter,&pBufferMemoryBarriers,pyc_uint32_t_converter,&imageMemoryBarrierCount,pyc_struct_pointer_VkImageMemoryBarrier_converter,&pImageMemoryBarriers))
        return NULL;
    

    

    
        

        
            vkCmdPipelineBarrier(commandBuffer,srcStageMask,dstStageMask,dependencyFlags,memoryBarrierCount,pMemoryBarriers,bufferMemoryBarrierCount,pBufferMemoryBarriers,imageMemoryBarrierCount,pImageMemoryBarriers);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_flag_base_VkPipelineStageFlags_converter_free(&srcStageMask);
pyc_flag_base_VkPipelineStageFlags_converter_free(&dstStageMask);
pyc_flag_base_VkDependencyFlags_converter_free(&dependencyFlags);
pyc_uint32_t_converter_free(&memoryBarrierCount);
pyc_struct_pointer_VkMemoryBarrier_converter_free(&pMemoryBarriers);
pyc_uint32_t_converter_free(&bufferMemoryBarrierCount);
pyc_struct_pointer_VkBufferMemoryBarrier_converter_free(&pBufferMemoryBarriers);
pyc_uint32_t_converter_free(&imageMemoryBarrierCount);
pyc_struct_pointer_VkImageMemoryBarrier_converter_free(&pImageMemoryBarriers);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdBeginQuery(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkQueryPool queryPool;
uint32_t query;
VkQueryControlFlags flags;

    static char *kwlist[] = {"commandBuffer","queryPool","query","flags",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkQueryPool_converter,&queryPool,pyc_uint32_t_converter,&query,pyc_flag_base_VkQueryControlFlags_converter,&flags))
        return NULL;
    

    

    
        

        
            vkCmdBeginQuery(commandBuffer,queryPool,query,flags);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkQueryPool_converter_free(&queryPool);
pyc_uint32_t_converter_free(&query);
pyc_flag_base_VkQueryControlFlags_converter_free(&flags);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdEndQuery(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkQueryPool queryPool;
uint32_t query;

    static char *kwlist[] = {"commandBuffer","queryPool","query",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkQueryPool_converter,&queryPool,pyc_uint32_t_converter,&query))
        return NULL;
    

    

    
        

        
            vkCmdEndQuery(commandBuffer,queryPool,query);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkQueryPool_converter_free(&queryPool);
pyc_uint32_t_converter_free(&query);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdResetQueryPool(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkQueryPool queryPool;
uint32_t firstQuery;
uint32_t queryCount;

    static char *kwlist[] = {"commandBuffer","queryPool","firstQuery","queryCount",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkQueryPool_converter,&queryPool,pyc_uint32_t_converter,&firstQuery,pyc_uint32_t_converter,&queryCount))
        return NULL;
    

    

    
        

        
            vkCmdResetQueryPool(commandBuffer,queryPool,firstQuery,queryCount);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkQueryPool_converter_free(&queryPool);
pyc_uint32_t_converter_free(&firstQuery);
pyc_uint32_t_converter_free(&queryCount);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdWriteTimestamp(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkPipelineStageFlagBits pipelineStage;
VkQueryPool queryPool;
uint32_t query;

    static char *kwlist[] = {"commandBuffer","pipelineStage","queryPool","query",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_flag_base_VkPipelineStageFlagBits_converter,&pipelineStage,pyc_handle_base_VkQueryPool_converter,&queryPool,pyc_uint32_t_converter,&query))
        return NULL;
    

    

    
        

        
            vkCmdWriteTimestamp(commandBuffer,pipelineStage,queryPool,query);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_flag_base_VkPipelineStageFlagBits_converter_free(&pipelineStage);
pyc_handle_base_VkQueryPool_converter_free(&queryPool);
pyc_uint32_t_converter_free(&query);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdCopyQueryPoolResults(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkQueryPool queryPool;
uint32_t firstQuery;
uint32_t queryCount;
VkBuffer dstBuffer;
VkDeviceSize dstOffset;
VkDeviceSize stride;
VkQueryResultFlags flags;

    static char *kwlist[] = {"commandBuffer","queryPool","firstQuery","queryCount","dstBuffer","dstOffset","stride","flags",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkQueryPool_converter,&queryPool,pyc_uint32_t_converter,&firstQuery,pyc_uint32_t_converter,&queryCount,pyc_handle_base_VkBuffer_converter,&dstBuffer,pyc_flag_base_VkDeviceSize_converter,&dstOffset,pyc_flag_base_VkDeviceSize_converter,&stride,pyc_flag_base_VkQueryResultFlags_converter,&flags))
        return NULL;
    

    

    
        

        
            vkCmdCopyQueryPoolResults(commandBuffer,queryPool,firstQuery,queryCount,dstBuffer,dstOffset,stride,flags);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkQueryPool_converter_free(&queryPool);
pyc_uint32_t_converter_free(&firstQuery);
pyc_uint32_t_converter_free(&queryCount);
pyc_handle_base_VkBuffer_converter_free(&dstBuffer);
pyc_flag_base_VkDeviceSize_converter_free(&dstOffset);
pyc_flag_base_VkDeviceSize_converter_free(&stride);
pyc_flag_base_VkQueryResultFlags_converter_free(&flags);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdPushConstants(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkPipelineLayout layout;
VkShaderStageFlags stageFlags;
uint32_t offset;
uint32_t size;
void * pValues;

    static char *kwlist[] = {"commandBuffer","layout","stageFlags","offset","size","pValues",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkPipelineLayout_converter,&layout,pyc_flag_base_VkShaderStageFlags_converter,&stageFlags,pyc_uint32_t_converter,&offset,pyc_uint32_t_converter,&size,pyc_void_x_converter,&pValues))
        return NULL;
    

    

    
        

        
            vkCmdPushConstants(commandBuffer,layout,stageFlags,offset,size,pValues);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkPipelineLayout_converter_free(&layout);
pyc_flag_base_VkShaderStageFlags_converter_free(&stageFlags);
pyc_uint32_t_converter_free(&offset);
pyc_uint32_t_converter_free(&size);
pyc_void_x_converter_free(&pValues);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdBeginRenderPass(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkRenderPassBeginInfo* pRenderPassBegin;
VkSubpassContents contents;

    static char *kwlist[] = {"commandBuffer","pRenderPassBegin","contents",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_struct_pointer_VkRenderPassBeginInfo_converter,&pRenderPassBegin,pyc_flag_base_VkSubpassContents_converter,&contents))
        return NULL;
    

    

    
        

        
            vkCmdBeginRenderPass(commandBuffer,pRenderPassBegin,contents);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_struct_pointer_VkRenderPassBeginInfo_converter_free(&pRenderPassBegin);
pyc_flag_base_VkSubpassContents_converter_free(&contents);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdNextSubpass(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
VkSubpassContents contents;

    static char *kwlist[] = {"commandBuffer","contents",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_flag_base_VkSubpassContents_converter,&contents))
        return NULL;
    

    

    
        

        
            vkCmdNextSubpass(commandBuffer,contents);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_flag_base_VkSubpassContents_converter_free(&contents);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdEndRenderPass(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;

    static char *kwlist[] = {"commandBuffer",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer))
        return NULL;
    

    

    
        

        
            vkCmdEndRenderPass(commandBuffer);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);


    return return_value;

    }

    
    


   
    
        

    static PyObject* PyvkCmdExecuteCommands(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    

    VkCommandBuffer commandBuffer;
uint32_t commandBufferCount;
VkCommandBuffer* pCommandBuffers;

    static char *kwlist[] = {"commandBuffer","commandBufferCount","pCommandBuffers",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_uint32_t_converter,&commandBufferCount,pyc_handle_pointer_VkCommandBuffer_converter,&pCommandBuffers))
        return NULL;
    

    

    
        

        
            vkCmdExecuteCommands(commandBuffer,commandBufferCount,pCommandBuffers);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_uint32_t_converter_free(&commandBufferCount);
pyc_handle_pointer_VkCommandBuffer_converter_free(&pCommandBuffers);


    return return_value;

    }

    
    





    
     #ifdef VK_USE_PLATFORM_ANDROID_KHR 
        

    typedef struct { PyObject_HEAD PFN_vkCreateAndroidSurfaceKHR pfn; } PyvkCreateAndroidSurfaceKHR;

    static PyObject* PyvkCreateAndroidSurfaceKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkCreateAndroidSurfaceKHR *self;
        self = (PyvkCreateAndroidSurfaceKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkCreateAndroidSurfaceKHR_del(PyvkCreateAndroidSurfaceKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkCreateAndroidSurfaceKHR_init(PyvkCreateAndroidSurfaceKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkCreateAndroidSurfaceKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkCreateAndroidSurfaceKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkInstance instance;
VkAndroidSurfaceCreateInfoKHR* pCreateInfo;

    static char *kwlist[] = {"instance","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkInstance_converter,&instance,pyc_struct_pointer_VkAndroidSurfaceCreateInfoKHR_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkSurfaceKHR *value = malloc(allocate_size * sizeof(VkSurfaceKHR));
        
        
            if (raise((*(((PyvkCreateAndroidSurfaceKHR*)self)->pfn))(instance,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkSurfaceKHR", NULL);
            
        

    

    pyc_handle_base_VkInstance_converter_free(&instance);
pyc_struct_pointer_VkAndroidSurfaceCreateInfoKHR_converter_free(&pCreateInfo);


    return return_value;

    }

    static PyTypeObject PyvkCreateAndroidSurfaceKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkCreateAndroidSurfaceKHR", sizeof(PyvkCreateAndroidSurfaceKHR), 0,
        (destructor)PyvkCreateAndroidSurfaceKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateAndroidSurfaceKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkCreateAndroidSurfaceKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkCreateAndroidSurfaceKHR_init,0,PyvkCreateAndroidSurfaceKHR_new,
    };
    
     #endif 


    
    
        

    typedef struct { PyObject_HEAD PFN_vkGetPhysicalDeviceDisplayPropertiesKHR pfn; } PyvkGetPhysicalDeviceDisplayPropertiesKHR;

    static PyObject* PyvkGetPhysicalDeviceDisplayPropertiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkGetPhysicalDeviceDisplayPropertiesKHR *self;
        self = (PyvkGetPhysicalDeviceDisplayPropertiesKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkGetPhysicalDeviceDisplayPropertiesKHR_del(PyvkGetPhysicalDeviceDisplayPropertiesKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkGetPhysicalDeviceDisplayPropertiesKHR_init(PyvkGetPhysicalDeviceDisplayPropertiesKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkGetPhysicalDeviceDisplayPropertiesKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkGetPhysicalDeviceDisplayPropertiesKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkPhysicalDevice physicalDevice;

    static char *kwlist[] = {"physicalDevice",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice))
        return NULL;
    

    

    
        uint32_t count;

        
        
            if (raise((*(((PyvkGetPhysicalDeviceDisplayPropertiesKHR*)self)->pfn))(physicalDevice,&count, NULL)))
                return NULL;
        

        VkDisplayPropertiesKHR *values = malloc(count * sizeof(VkDisplayPropertiesKHR));

        
        
            if (raise((*(((PyvkGetPhysicalDeviceDisplayPropertiesKHR*)self)->pfn))(physicalDevice,&count, values)))
                return NULL;
        

        PyObject* return_value = PyList_New(0);
        uint32_t i;
        for (i = 0; i < count; i++) {
            VkDisplayPropertiesKHR* value = malloc(sizeof(VkDisplayPropertiesKHR));
            memcpy(value, values + i, sizeof(VkDisplayPropertiesKHR));

            
                PyObject* pyreturn = _PyObject_New(&PyVkDisplayPropertiesKHRType);
                if (!pyreturn)
                    return NULL;
                ((PyVkDisplayPropertiesKHR*)pyreturn)->base = value;
            
            PyList_Append(return_value, pyreturn);
        }
        free(values);

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);


    return return_value;

    }

    static PyTypeObject PyvkGetPhysicalDeviceDisplayPropertiesKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkGetPhysicalDeviceDisplayPropertiesKHR", sizeof(PyvkGetPhysicalDeviceDisplayPropertiesKHR), 0,
        (destructor)PyvkGetPhysicalDeviceDisplayPropertiesKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceDisplayPropertiesKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkGetPhysicalDeviceDisplayPropertiesKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceDisplayPropertiesKHR_init,0,PyvkGetPhysicalDeviceDisplayPropertiesKHR_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR pfn; } PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR;

    static PyObject* PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR *self;
        self = (PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR_del(PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR_init(PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkPhysicalDevice physicalDevice;

    static char *kwlist[] = {"physicalDevice",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice))
        return NULL;
    

    

    
        uint32_t count;

        
        
            if (raise((*(((PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR*)self)->pfn))(physicalDevice,&count, NULL)))
                return NULL;
        

        VkDisplayPlanePropertiesKHR *values = malloc(count * sizeof(VkDisplayPlanePropertiesKHR));

        
        
            if (raise((*(((PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR*)self)->pfn))(physicalDevice,&count, values)))
                return NULL;
        

        PyObject* return_value = PyList_New(0);
        uint32_t i;
        for (i = 0; i < count; i++) {
            VkDisplayPlanePropertiesKHR* value = malloc(sizeof(VkDisplayPlanePropertiesKHR));
            memcpy(value, values + i, sizeof(VkDisplayPlanePropertiesKHR));

            
                PyObject* pyreturn = _PyObject_New(&PyVkDisplayPlanePropertiesKHRType);
                if (!pyreturn)
                    return NULL;
                ((PyVkDisplayPlanePropertiesKHR*)pyreturn)->base = value;
            
            PyList_Append(return_value, pyreturn);
        }
        free(values);

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);


    return return_value;

    }

    static PyTypeObject PyvkGetPhysicalDeviceDisplayPlanePropertiesKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkGetPhysicalDeviceDisplayPlanePropertiesKHR", sizeof(PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR), 0,
        (destructor)PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR_init,0,PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkGetDisplayPlaneSupportedDisplaysKHR pfn; } PyvkGetDisplayPlaneSupportedDisplaysKHR;

    static PyObject* PyvkGetDisplayPlaneSupportedDisplaysKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkGetDisplayPlaneSupportedDisplaysKHR *self;
        self = (PyvkGetDisplayPlaneSupportedDisplaysKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkGetDisplayPlaneSupportedDisplaysKHR_del(PyvkGetDisplayPlaneSupportedDisplaysKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkGetDisplayPlaneSupportedDisplaysKHR_init(PyvkGetDisplayPlaneSupportedDisplaysKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkGetDisplayPlaneSupportedDisplaysKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkGetDisplayPlaneSupportedDisplaysKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkPhysicalDevice physicalDevice;
uint32_t planeIndex;

    static char *kwlist[] = {"physicalDevice","planeIndex",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice,pyc_uint32_t_converter,&planeIndex))
        return NULL;
    

    

    
        uint32_t count;

        
        
            if (raise((*(((PyvkGetDisplayPlaneSupportedDisplaysKHR*)self)->pfn))(physicalDevice,planeIndex,&count, NULL)))
                return NULL;
        

        VkDisplayKHR *values = malloc(count * sizeof(VkDisplayKHR));

        
        
            if (raise((*(((PyvkGetDisplayPlaneSupportedDisplaysKHR*)self)->pfn))(physicalDevice,planeIndex,&count, values)))
                return NULL;
        

        PyObject* return_value = PyList_New(0);
        uint32_t i;
        for (i = 0; i < count; i++) {
            VkDisplayKHR* value = malloc(sizeof(VkDisplayKHR));
            memcpy(value, values + i, sizeof(VkDisplayKHR));

            
                PyObject* pyreturn = PyCapsule_New(value, "VkDisplayKHR", NULL);
            
            PyList_Append(return_value, pyreturn);
        }
        free(values);

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);
pyc_uint32_t_converter_free(&planeIndex);


    return return_value;

    }

    static PyTypeObject PyvkGetDisplayPlaneSupportedDisplaysKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkGetDisplayPlaneSupportedDisplaysKHR", sizeof(PyvkGetDisplayPlaneSupportedDisplaysKHR), 0,
        (destructor)PyvkGetDisplayPlaneSupportedDisplaysKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetDisplayPlaneSupportedDisplaysKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkGetDisplayPlaneSupportedDisplaysKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkGetDisplayPlaneSupportedDisplaysKHR_init,0,PyvkGetDisplayPlaneSupportedDisplaysKHR_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkGetDisplayModePropertiesKHR pfn; } PyvkGetDisplayModePropertiesKHR;

    static PyObject* PyvkGetDisplayModePropertiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkGetDisplayModePropertiesKHR *self;
        self = (PyvkGetDisplayModePropertiesKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkGetDisplayModePropertiesKHR_del(PyvkGetDisplayModePropertiesKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkGetDisplayModePropertiesKHR_init(PyvkGetDisplayModePropertiesKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkGetDisplayModePropertiesKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkGetDisplayModePropertiesKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkPhysicalDevice physicalDevice;
VkDisplayKHR display;

    static char *kwlist[] = {"physicalDevice","display",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice,pyc_handle_base_VkDisplayKHR_converter,&display))
        return NULL;
    

    

    
        uint32_t count;

        
        
            if (raise((*(((PyvkGetDisplayModePropertiesKHR*)self)->pfn))(physicalDevice,display,&count, NULL)))
                return NULL;
        

        VkDisplayModePropertiesKHR *values = malloc(count * sizeof(VkDisplayModePropertiesKHR));

        
        
            if (raise((*(((PyvkGetDisplayModePropertiesKHR*)self)->pfn))(physicalDevice,display,&count, values)))
                return NULL;
        

        PyObject* return_value = PyList_New(0);
        uint32_t i;
        for (i = 0; i < count; i++) {
            VkDisplayModePropertiesKHR* value = malloc(sizeof(VkDisplayModePropertiesKHR));
            memcpy(value, values + i, sizeof(VkDisplayModePropertiesKHR));

            
                PyObject* pyreturn = _PyObject_New(&PyVkDisplayModePropertiesKHRType);
                if (!pyreturn)
                    return NULL;
                ((PyVkDisplayModePropertiesKHR*)pyreturn)->base = value;
            
            PyList_Append(return_value, pyreturn);
        }
        free(values);

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);
pyc_handle_base_VkDisplayKHR_converter_free(&display);


    return return_value;

    }

    static PyTypeObject PyvkGetDisplayModePropertiesKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkGetDisplayModePropertiesKHR", sizeof(PyvkGetDisplayModePropertiesKHR), 0,
        (destructor)PyvkGetDisplayModePropertiesKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetDisplayModePropertiesKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkGetDisplayModePropertiesKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkGetDisplayModePropertiesKHR_init,0,PyvkGetDisplayModePropertiesKHR_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkCreateDisplayModeKHR pfn; } PyvkCreateDisplayModeKHR;

    static PyObject* PyvkCreateDisplayModeKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkCreateDisplayModeKHR *self;
        self = (PyvkCreateDisplayModeKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkCreateDisplayModeKHR_del(PyvkCreateDisplayModeKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkCreateDisplayModeKHR_init(PyvkCreateDisplayModeKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkCreateDisplayModeKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkCreateDisplayModeKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkPhysicalDevice physicalDevice;
VkDisplayKHR display;
VkDisplayModeCreateInfoKHR* pCreateInfo;

    static char *kwlist[] = {"physicalDevice","display","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice,pyc_handle_base_VkDisplayKHR_converter,&display,pyc_struct_pointer_VkDisplayModeCreateInfoKHR_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkDisplayModeKHR *value = malloc(allocate_size * sizeof(VkDisplayModeKHR));
        
        
            if (raise((*(((PyvkCreateDisplayModeKHR*)self)->pfn))(physicalDevice,display,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkDisplayModeKHR", NULL);
            
        

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);
pyc_handle_base_VkDisplayKHR_converter_free(&display);
pyc_struct_pointer_VkDisplayModeCreateInfoKHR_converter_free(&pCreateInfo);


    return return_value;

    }

    static PyTypeObject PyvkCreateDisplayModeKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkCreateDisplayModeKHR", sizeof(PyvkCreateDisplayModeKHR), 0,
        (destructor)PyvkCreateDisplayModeKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateDisplayModeKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkCreateDisplayModeKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkCreateDisplayModeKHR_init,0,PyvkCreateDisplayModeKHR_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkGetDisplayPlaneCapabilitiesKHR pfn; } PyvkGetDisplayPlaneCapabilitiesKHR;

    static PyObject* PyvkGetDisplayPlaneCapabilitiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkGetDisplayPlaneCapabilitiesKHR *self;
        self = (PyvkGetDisplayPlaneCapabilitiesKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkGetDisplayPlaneCapabilitiesKHR_del(PyvkGetDisplayPlaneCapabilitiesKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkGetDisplayPlaneCapabilitiesKHR_init(PyvkGetDisplayPlaneCapabilitiesKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkGetDisplayPlaneCapabilitiesKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkGetDisplayPlaneCapabilitiesKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkPhysicalDevice physicalDevice;
VkDisplayModeKHR mode;
uint32_t planeIndex;

    static char *kwlist[] = {"physicalDevice","mode","planeIndex",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice,pyc_handle_base_VkDisplayModeKHR_converter,&mode,pyc_uint32_t_converter,&planeIndex))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkDisplayPlaneCapabilitiesKHR *value = malloc(allocate_size * sizeof(VkDisplayPlaneCapabilitiesKHR));
        
        
            if (raise((*(((PyvkGetDisplayPlaneCapabilitiesKHR*)self)->pfn))(physicalDevice,mode,planeIndex,value)))
                return NULL;
        


        
            
                PyObject* return_value = _PyObject_New(&PyVkDisplayPlaneCapabilitiesKHRType);
                if (!return_value)
                    return NULL;
                ((PyVkDisplayPlaneCapabilitiesKHR*)return_value)->base = value;
            
        

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);
pyc_handle_base_VkDisplayModeKHR_converter_free(&mode);
pyc_uint32_t_converter_free(&planeIndex);


    return return_value;

    }

    static PyTypeObject PyvkGetDisplayPlaneCapabilitiesKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkGetDisplayPlaneCapabilitiesKHR", sizeof(PyvkGetDisplayPlaneCapabilitiesKHR), 0,
        (destructor)PyvkGetDisplayPlaneCapabilitiesKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetDisplayPlaneCapabilitiesKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkGetDisplayPlaneCapabilitiesKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkGetDisplayPlaneCapabilitiesKHR_init,0,PyvkGetDisplayPlaneCapabilitiesKHR_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkCreateDisplayPlaneSurfaceKHR pfn; } PyvkCreateDisplayPlaneSurfaceKHR;

    static PyObject* PyvkCreateDisplayPlaneSurfaceKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkCreateDisplayPlaneSurfaceKHR *self;
        self = (PyvkCreateDisplayPlaneSurfaceKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkCreateDisplayPlaneSurfaceKHR_del(PyvkCreateDisplayPlaneSurfaceKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkCreateDisplayPlaneSurfaceKHR_init(PyvkCreateDisplayPlaneSurfaceKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkCreateDisplayPlaneSurfaceKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkCreateDisplayPlaneSurfaceKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkInstance instance;
VkDisplaySurfaceCreateInfoKHR* pCreateInfo;

    static char *kwlist[] = {"instance","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkInstance_converter,&instance,pyc_struct_pointer_VkDisplaySurfaceCreateInfoKHR_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkSurfaceKHR *value = malloc(allocate_size * sizeof(VkSurfaceKHR));
        
        
            if (raise((*(((PyvkCreateDisplayPlaneSurfaceKHR*)self)->pfn))(instance,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkSurfaceKHR", NULL);
            
        

    

    pyc_handle_base_VkInstance_converter_free(&instance);
pyc_struct_pointer_VkDisplaySurfaceCreateInfoKHR_converter_free(&pCreateInfo);


    return return_value;

    }

    static PyTypeObject PyvkCreateDisplayPlaneSurfaceKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkCreateDisplayPlaneSurfaceKHR", sizeof(PyvkCreateDisplayPlaneSurfaceKHR), 0,
        (destructor)PyvkCreateDisplayPlaneSurfaceKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateDisplayPlaneSurfaceKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkCreateDisplayPlaneSurfaceKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkCreateDisplayPlaneSurfaceKHR_init,0,PyvkCreateDisplayPlaneSurfaceKHR_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkCreateSharedSwapchainsKHR pfn; } PyvkCreateSharedSwapchainsKHR;

    static PyObject* PyvkCreateSharedSwapchainsKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkCreateSharedSwapchainsKHR *self;
        self = (PyvkCreateSharedSwapchainsKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkCreateSharedSwapchainsKHR_del(PyvkCreateSharedSwapchainsKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkCreateSharedSwapchainsKHR_init(PyvkCreateSharedSwapchainsKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkCreateSharedSwapchainsKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkCreateSharedSwapchainsKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkDevice device;
uint32_t swapchainCount;
VkSwapchainCreateInfoKHR* pCreateInfos;

    static char *kwlist[] = {"device","swapchainCount","pCreateInfos",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_uint32_t_converter,&swapchainCount,pyc_struct_pointer_VkSwapchainCreateInfoKHR_converter,&pCreateInfos))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkSwapchainKHR *value = malloc(allocate_size * sizeof(VkSwapchainKHR));
        
        
            if (raise((*(((PyvkCreateSharedSwapchainsKHR*)self)->pfn))(device,swapchainCount,pCreateInfos,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkSwapchainKHR", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_uint32_t_converter_free(&swapchainCount);
pyc_struct_pointer_VkSwapchainCreateInfoKHR_converter_free(&pCreateInfos);


    return return_value;

    }

    static PyTypeObject PyvkCreateSharedSwapchainsKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkCreateSharedSwapchainsKHR", sizeof(PyvkCreateSharedSwapchainsKHR), 0,
        (destructor)PyvkCreateSharedSwapchainsKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateSharedSwapchainsKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkCreateSharedSwapchainsKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkCreateSharedSwapchainsKHR_init,0,PyvkCreateSharedSwapchainsKHR_new,
    };
    
    


    
     #ifdef VK_USE_PLATFORM_MIR_KHR 
        

    typedef struct { PyObject_HEAD PFN_vkCreateMirSurfaceKHR pfn; } PyvkCreateMirSurfaceKHR;

    static PyObject* PyvkCreateMirSurfaceKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkCreateMirSurfaceKHR *self;
        self = (PyvkCreateMirSurfaceKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkCreateMirSurfaceKHR_del(PyvkCreateMirSurfaceKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkCreateMirSurfaceKHR_init(PyvkCreateMirSurfaceKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkCreateMirSurfaceKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkCreateMirSurfaceKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkInstance instance;
VkMirSurfaceCreateInfoKHR* pCreateInfo;

    static char *kwlist[] = {"instance","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkInstance_converter,&instance,pyc_struct_pointer_VkMirSurfaceCreateInfoKHR_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkSurfaceKHR *value = malloc(allocate_size * sizeof(VkSurfaceKHR));
        
        
            if (raise((*(((PyvkCreateMirSurfaceKHR*)self)->pfn))(instance,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkSurfaceKHR", NULL);
            
        

    

    pyc_handle_base_VkInstance_converter_free(&instance);
pyc_struct_pointer_VkMirSurfaceCreateInfoKHR_converter_free(&pCreateInfo);


    return return_value;

    }

    static PyTypeObject PyvkCreateMirSurfaceKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkCreateMirSurfaceKHR", sizeof(PyvkCreateMirSurfaceKHR), 0,
        (destructor)PyvkCreateMirSurfaceKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateMirSurfaceKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkCreateMirSurfaceKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkCreateMirSurfaceKHR_init,0,PyvkCreateMirSurfaceKHR_new,
    };
    
     #endif 


    
     #ifdef VK_USE_PLATFORM_MIR_KHR 
        

    typedef struct { PyObject_HEAD PFN_vkGetPhysicalDeviceMirPresentationSupportKHR pfn; } PyvkGetPhysicalDeviceMirPresentationSupportKHR;

    static PyObject* PyvkGetPhysicalDeviceMirPresentationSupportKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkGetPhysicalDeviceMirPresentationSupportKHR *self;
        self = (PyvkGetPhysicalDeviceMirPresentationSupportKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkGetPhysicalDeviceMirPresentationSupportKHR_del(PyvkGetPhysicalDeviceMirPresentationSupportKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkGetPhysicalDeviceMirPresentationSupportKHR_init(PyvkGetPhysicalDeviceMirPresentationSupportKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkGetPhysicalDeviceMirPresentationSupportKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkGetPhysicalDeviceMirPresentationSupportKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkPhysicalDevice physicalDevice;
uint32_t queueFamilyIndex;
MirConnection * connection;

    static char *kwlist[] = {"physicalDevice","queueFamilyIndex","connection",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice,pyc_uint32_t_converter,&queueFamilyIndex,pyc_MirConnection_x_converter,&connection))
        return NULL;
    

    

    
        

        
            PyObject* return_value = PyBool_FromLong((*(((PyvkGetPhysicalDeviceMirPresentationSupportKHR*)self)->pfn))(physicalDevice,queueFamilyIndex,connection));
        
    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);
pyc_uint32_t_converter_free(&queueFamilyIndex);
pyc_MirConnection_x_converter_free(&connection);


    return return_value;

    }

    static PyTypeObject PyvkGetPhysicalDeviceMirPresentationSupportKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkGetPhysicalDeviceMirPresentationSupportKHR", sizeof(PyvkGetPhysicalDeviceMirPresentationSupportKHR), 0,
        (destructor)PyvkGetPhysicalDeviceMirPresentationSupportKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceMirPresentationSupportKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkGetPhysicalDeviceMirPresentationSupportKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceMirPresentationSupportKHR_init,0,PyvkGetPhysicalDeviceMirPresentationSupportKHR_new,
    };
    
     #endif 


    
    
        

    typedef struct { PyObject_HEAD PFN_vkDestroySurfaceKHR pfn; } PyvkDestroySurfaceKHR;

    static PyObject* PyvkDestroySurfaceKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkDestroySurfaceKHR *self;
        self = (PyvkDestroySurfaceKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkDestroySurfaceKHR_del(PyvkDestroySurfaceKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkDestroySurfaceKHR_init(PyvkDestroySurfaceKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkDestroySurfaceKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkDestroySurfaceKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkInstance instance;
VkSurfaceKHR surface;

    static char *kwlist[] = {"instance","surface",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkInstance_converter,&instance,pyc_handle_base_VkSurfaceKHR_converter,&surface))
        return NULL;
    

    

    
        

        
            (*(((PyvkDestroySurfaceKHR*)self)->pfn))(instance,surface,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkInstance_converter_free(&instance);
pyc_handle_base_VkSurfaceKHR_converter_free(&surface);


    return return_value;

    }

    static PyTypeObject PyvkDestroySurfaceKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkDestroySurfaceKHR", sizeof(PyvkDestroySurfaceKHR), 0,
        (destructor)PyvkDestroySurfaceKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkDestroySurfaceKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkDestroySurfaceKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkDestroySurfaceKHR_init,0,PyvkDestroySurfaceKHR_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkGetPhysicalDeviceSurfaceSupportKHR pfn; } PyvkGetPhysicalDeviceSurfaceSupportKHR;

    static PyObject* PyvkGetPhysicalDeviceSurfaceSupportKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkGetPhysicalDeviceSurfaceSupportKHR *self;
        self = (PyvkGetPhysicalDeviceSurfaceSupportKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkGetPhysicalDeviceSurfaceSupportKHR_del(PyvkGetPhysicalDeviceSurfaceSupportKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkGetPhysicalDeviceSurfaceSupportKHR_init(PyvkGetPhysicalDeviceSurfaceSupportKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkGetPhysicalDeviceSurfaceSupportKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkGetPhysicalDeviceSurfaceSupportKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkPhysicalDevice physicalDevice;
uint32_t queueFamilyIndex;
VkSurfaceKHR surface;

    static char *kwlist[] = {"physicalDevice","queueFamilyIndex","surface",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice,pyc_uint32_t_converter,&queueFamilyIndex,pyc_handle_base_VkSurfaceKHR_converter,&surface))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkBool32 *value = malloc(allocate_size * sizeof(VkBool32));
        
        
            if (raise((*(((PyvkGetPhysicalDeviceSurfaceSupportKHR*)self)->pfn))(physicalDevice,queueFamilyIndex,surface,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyLong_FromLong((long) *value);
            
        

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);
pyc_uint32_t_converter_free(&queueFamilyIndex);
pyc_handle_base_VkSurfaceKHR_converter_free(&surface);


    return return_value;

    }

    static PyTypeObject PyvkGetPhysicalDeviceSurfaceSupportKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkGetPhysicalDeviceSurfaceSupportKHR", sizeof(PyvkGetPhysicalDeviceSurfaceSupportKHR), 0,
        (destructor)PyvkGetPhysicalDeviceSurfaceSupportKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceSurfaceSupportKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkGetPhysicalDeviceSurfaceSupportKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceSurfaceSupportKHR_init,0,PyvkGetPhysicalDeviceSurfaceSupportKHR_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR pfn; } PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR;

    static PyObject* PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR *self;
        self = (PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR_del(PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR_init(PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkPhysicalDevice physicalDevice;
VkSurfaceKHR surface;

    static char *kwlist[] = {"physicalDevice","surface",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice,pyc_handle_base_VkSurfaceKHR_converter,&surface))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkSurfaceCapabilitiesKHR *value = malloc(allocate_size * sizeof(VkSurfaceCapabilitiesKHR));
        
        
            if (raise((*(((PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR*)self)->pfn))(physicalDevice,surface,value)))
                return NULL;
        


        
            
                PyObject* return_value = _PyObject_New(&PyVkSurfaceCapabilitiesKHRType);
                if (!return_value)
                    return NULL;
                ((PyVkSurfaceCapabilitiesKHR*)return_value)->base = value;
            
        

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);
pyc_handle_base_VkSurfaceKHR_converter_free(&surface);


    return return_value;

    }

    static PyTypeObject PyvkGetPhysicalDeviceSurfaceCapabilitiesKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkGetPhysicalDeviceSurfaceCapabilitiesKHR", sizeof(PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR), 0,
        (destructor)PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR_init,0,PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkGetPhysicalDeviceSurfaceFormatsKHR pfn; } PyvkGetPhysicalDeviceSurfaceFormatsKHR;

    static PyObject* PyvkGetPhysicalDeviceSurfaceFormatsKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkGetPhysicalDeviceSurfaceFormatsKHR *self;
        self = (PyvkGetPhysicalDeviceSurfaceFormatsKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkGetPhysicalDeviceSurfaceFormatsKHR_del(PyvkGetPhysicalDeviceSurfaceFormatsKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkGetPhysicalDeviceSurfaceFormatsKHR_init(PyvkGetPhysicalDeviceSurfaceFormatsKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkGetPhysicalDeviceSurfaceFormatsKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkGetPhysicalDeviceSurfaceFormatsKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkPhysicalDevice physicalDevice;
VkSurfaceKHR surface;

    static char *kwlist[] = {"physicalDevice","surface",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice,pyc_handle_base_VkSurfaceKHR_converter,&surface))
        return NULL;
    

    

    
        uint32_t count;

        
        
            if (raise((*(((PyvkGetPhysicalDeviceSurfaceFormatsKHR*)self)->pfn))(physicalDevice,surface,&count, NULL)))
                return NULL;
        

        VkSurfaceFormatKHR *values = malloc(count * sizeof(VkSurfaceFormatKHR));

        
        
            if (raise((*(((PyvkGetPhysicalDeviceSurfaceFormatsKHR*)self)->pfn))(physicalDevice,surface,&count, values)))
                return NULL;
        

        PyObject* return_value = PyList_New(0);
        uint32_t i;
        for (i = 0; i < count; i++) {
            VkSurfaceFormatKHR* value = malloc(sizeof(VkSurfaceFormatKHR));
            memcpy(value, values + i, sizeof(VkSurfaceFormatKHR));

            
                PyObject* pyreturn = _PyObject_New(&PyVkSurfaceFormatKHRType);
                if (!pyreturn)
                    return NULL;
                ((PyVkSurfaceFormatKHR*)pyreturn)->base = value;
            
            PyList_Append(return_value, pyreturn);
        }
        free(values);

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);
pyc_handle_base_VkSurfaceKHR_converter_free(&surface);


    return return_value;

    }

    static PyTypeObject PyvkGetPhysicalDeviceSurfaceFormatsKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkGetPhysicalDeviceSurfaceFormatsKHR", sizeof(PyvkGetPhysicalDeviceSurfaceFormatsKHR), 0,
        (destructor)PyvkGetPhysicalDeviceSurfaceFormatsKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceSurfaceFormatsKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkGetPhysicalDeviceSurfaceFormatsKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceSurfaceFormatsKHR_init,0,PyvkGetPhysicalDeviceSurfaceFormatsKHR_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkGetPhysicalDeviceSurfacePresentModesKHR pfn; } PyvkGetPhysicalDeviceSurfacePresentModesKHR;

    static PyObject* PyvkGetPhysicalDeviceSurfacePresentModesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkGetPhysicalDeviceSurfacePresentModesKHR *self;
        self = (PyvkGetPhysicalDeviceSurfacePresentModesKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkGetPhysicalDeviceSurfacePresentModesKHR_del(PyvkGetPhysicalDeviceSurfacePresentModesKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkGetPhysicalDeviceSurfacePresentModesKHR_init(PyvkGetPhysicalDeviceSurfacePresentModesKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkGetPhysicalDeviceSurfacePresentModesKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkGetPhysicalDeviceSurfacePresentModesKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkPhysicalDevice physicalDevice;
VkSurfaceKHR surface;

    static char *kwlist[] = {"physicalDevice","surface",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice,pyc_handle_base_VkSurfaceKHR_converter,&surface))
        return NULL;
    

    

    
        uint32_t count;

        
        
            if (raise((*(((PyvkGetPhysicalDeviceSurfacePresentModesKHR*)self)->pfn))(physicalDevice,surface,&count, NULL)))
                return NULL;
        

        VkPresentModeKHR *values = malloc(count * sizeof(VkPresentModeKHR));

        
        
            if (raise((*(((PyvkGetPhysicalDeviceSurfacePresentModesKHR*)self)->pfn))(physicalDevice,surface,&count, values)))
                return NULL;
        

        PyObject* return_value = PyList_New(0);
        uint32_t i;
        for (i = 0; i < count; i++) {
            VkPresentModeKHR* value = malloc(sizeof(VkPresentModeKHR));
            memcpy(value, values + i, sizeof(VkPresentModeKHR));

            
                PyObject* pyreturn = PyLong_FromLong((long) *value);
            
            PyList_Append(return_value, pyreturn);
        }
        free(values);

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);
pyc_handle_base_VkSurfaceKHR_converter_free(&surface);


    return return_value;

    }

    static PyTypeObject PyvkGetPhysicalDeviceSurfacePresentModesKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkGetPhysicalDeviceSurfacePresentModesKHR", sizeof(PyvkGetPhysicalDeviceSurfacePresentModesKHR), 0,
        (destructor)PyvkGetPhysicalDeviceSurfacePresentModesKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceSurfacePresentModesKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkGetPhysicalDeviceSurfacePresentModesKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceSurfacePresentModesKHR_init,0,PyvkGetPhysicalDeviceSurfacePresentModesKHR_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkCreateSwapchainKHR pfn; } PyvkCreateSwapchainKHR;

    static PyObject* PyvkCreateSwapchainKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkCreateSwapchainKHR *self;
        self = (PyvkCreateSwapchainKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkCreateSwapchainKHR_del(PyvkCreateSwapchainKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkCreateSwapchainKHR_init(PyvkCreateSwapchainKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkCreateSwapchainKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkCreateSwapchainKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkDevice device;
VkSwapchainCreateInfoKHR* pCreateInfo;

    static char *kwlist[] = {"device","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkSwapchainCreateInfoKHR_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkSwapchainKHR *value = malloc(allocate_size * sizeof(VkSwapchainKHR));
        
        
            if (raise((*(((PyvkCreateSwapchainKHR*)self)->pfn))(device,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkSwapchainKHR", NULL);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkSwapchainCreateInfoKHR_converter_free(&pCreateInfo);


    return return_value;

    }

    static PyTypeObject PyvkCreateSwapchainKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkCreateSwapchainKHR", sizeof(PyvkCreateSwapchainKHR), 0,
        (destructor)PyvkCreateSwapchainKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateSwapchainKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkCreateSwapchainKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkCreateSwapchainKHR_init,0,PyvkCreateSwapchainKHR_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkDestroySwapchainKHR pfn; } PyvkDestroySwapchainKHR;

    static PyObject* PyvkDestroySwapchainKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkDestroySwapchainKHR *self;
        self = (PyvkDestroySwapchainKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkDestroySwapchainKHR_del(PyvkDestroySwapchainKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkDestroySwapchainKHR_init(PyvkDestroySwapchainKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkDestroySwapchainKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkDestroySwapchainKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkDevice device;
VkSwapchainKHR swapchain;

    static char *kwlist[] = {"device","swapchain",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkSwapchainKHR_converter,&swapchain))
        return NULL;
    

    

    
        

        
            (*(((PyvkDestroySwapchainKHR*)self)->pfn))(device,swapchain,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkSwapchainKHR_converter_free(&swapchain);


    return return_value;

    }

    static PyTypeObject PyvkDestroySwapchainKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkDestroySwapchainKHR", sizeof(PyvkDestroySwapchainKHR), 0,
        (destructor)PyvkDestroySwapchainKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkDestroySwapchainKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkDestroySwapchainKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkDestroySwapchainKHR_init,0,PyvkDestroySwapchainKHR_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkGetSwapchainImagesKHR pfn; } PyvkGetSwapchainImagesKHR;

    static PyObject* PyvkGetSwapchainImagesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkGetSwapchainImagesKHR *self;
        self = (PyvkGetSwapchainImagesKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkGetSwapchainImagesKHR_del(PyvkGetSwapchainImagesKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkGetSwapchainImagesKHR_init(PyvkGetSwapchainImagesKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkGetSwapchainImagesKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkGetSwapchainImagesKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkDevice device;
VkSwapchainKHR swapchain;

    static char *kwlist[] = {"device","swapchain",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkSwapchainKHR_converter,&swapchain))
        return NULL;
    

    

    
        uint32_t count;

        
        
            if (raise((*(((PyvkGetSwapchainImagesKHR*)self)->pfn))(device,swapchain,&count, NULL)))
                return NULL;
        

        VkImage *values = malloc(count * sizeof(VkImage));

        
        
            if (raise((*(((PyvkGetSwapchainImagesKHR*)self)->pfn))(device,swapchain,&count, values)))
                return NULL;
        

        PyObject* return_value = PyList_New(0);
        uint32_t i;
        for (i = 0; i < count; i++) {
            VkImage* value = malloc(sizeof(VkImage));
            memcpy(value, values + i, sizeof(VkImage));

            
                PyObject* pyreturn = PyCapsule_New(value, "VkImage", NULL);
            
            PyList_Append(return_value, pyreturn);
        }
        free(values);

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkSwapchainKHR_converter_free(&swapchain);


    return return_value;

    }

    static PyTypeObject PyvkGetSwapchainImagesKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkGetSwapchainImagesKHR", sizeof(PyvkGetSwapchainImagesKHR), 0,
        (destructor)PyvkGetSwapchainImagesKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetSwapchainImagesKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkGetSwapchainImagesKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkGetSwapchainImagesKHR_init,0,PyvkGetSwapchainImagesKHR_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkAcquireNextImageKHR pfn; } PyvkAcquireNextImageKHR;

    static PyObject* PyvkAcquireNextImageKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkAcquireNextImageKHR *self;
        self = (PyvkAcquireNextImageKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkAcquireNextImageKHR_del(PyvkAcquireNextImageKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkAcquireNextImageKHR_init(PyvkAcquireNextImageKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkAcquireNextImageKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkAcquireNextImageKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkDevice device;
VkSwapchainKHR swapchain;
uint64_t timeout;
VkSemaphore semaphore;
VkFence fence;

    static char *kwlist[] = {"device","swapchain","timeout","semaphore","fence",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkSwapchainKHR_converter,&swapchain,pyc_uint64_t_converter,&timeout,pyc_handle_base_VkSemaphore_converter,&semaphore,pyc_handle_base_VkFence_converter,&fence))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        uint32_t *value = malloc(allocate_size * sizeof(uint32_t));
        
        
            if (raise((*(((PyvkAcquireNextImageKHR*)self)->pfn))(device,swapchain,timeout,semaphore,fence,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyLong_FromLong((long) *value);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkSwapchainKHR_converter_free(&swapchain);
pyc_uint64_t_converter_free(&timeout);
pyc_handle_base_VkSemaphore_converter_free(&semaphore);
pyc_handle_base_VkFence_converter_free(&fence);


    return return_value;

    }

    static PyTypeObject PyvkAcquireNextImageKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkAcquireNextImageKHR", sizeof(PyvkAcquireNextImageKHR), 0,
        (destructor)PyvkAcquireNextImageKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkAcquireNextImageKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkAcquireNextImageKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkAcquireNextImageKHR_init,0,PyvkAcquireNextImageKHR_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkQueuePresentKHR pfn; } PyvkQueuePresentKHR;

    static PyObject* PyvkQueuePresentKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkQueuePresentKHR *self;
        self = (PyvkQueuePresentKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkQueuePresentKHR_del(PyvkQueuePresentKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkQueuePresentKHR_init(PyvkQueuePresentKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkQueuePresentKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkQueuePresentKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkQueue queue;
VkPresentInfoKHR* pPresentInfo;

    static char *kwlist[] = {"queue","pPresentInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkQueue_converter,&queue,pyc_struct_pointer_VkPresentInfoKHR_converter,&pPresentInfo))
        return NULL;
    

    

    
        

        
            (*(((PyvkQueuePresentKHR*)self)->pfn))(queue,pPresentInfo);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkQueue_converter_free(&queue);
pyc_struct_pointer_VkPresentInfoKHR_converter_free(&pPresentInfo);


    return return_value;

    }

    static PyTypeObject PyvkQueuePresentKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkQueuePresentKHR", sizeof(PyvkQueuePresentKHR), 0,
        (destructor)PyvkQueuePresentKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkQueuePresentKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkQueuePresentKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkQueuePresentKHR_init,0,PyvkQueuePresentKHR_new,
    };
    
    


    
     #ifdef VK_USE_PLATFORM_WAYLAND_KHR 
        

    typedef struct { PyObject_HEAD PFN_vkCreateWaylandSurfaceKHR pfn; } PyvkCreateWaylandSurfaceKHR;

    static PyObject* PyvkCreateWaylandSurfaceKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkCreateWaylandSurfaceKHR *self;
        self = (PyvkCreateWaylandSurfaceKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkCreateWaylandSurfaceKHR_del(PyvkCreateWaylandSurfaceKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkCreateWaylandSurfaceKHR_init(PyvkCreateWaylandSurfaceKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkCreateWaylandSurfaceKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkCreateWaylandSurfaceKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkInstance instance;
VkWaylandSurfaceCreateInfoKHR* pCreateInfo;

    static char *kwlist[] = {"instance","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkInstance_converter,&instance,pyc_struct_pointer_VkWaylandSurfaceCreateInfoKHR_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkSurfaceKHR *value = malloc(allocate_size * sizeof(VkSurfaceKHR));
        
        
            if (raise((*(((PyvkCreateWaylandSurfaceKHR*)self)->pfn))(instance,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkSurfaceKHR", NULL);
            
        

    

    pyc_handle_base_VkInstance_converter_free(&instance);
pyc_struct_pointer_VkWaylandSurfaceCreateInfoKHR_converter_free(&pCreateInfo);


    return return_value;

    }

    static PyTypeObject PyvkCreateWaylandSurfaceKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkCreateWaylandSurfaceKHR", sizeof(PyvkCreateWaylandSurfaceKHR), 0,
        (destructor)PyvkCreateWaylandSurfaceKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateWaylandSurfaceKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkCreateWaylandSurfaceKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkCreateWaylandSurfaceKHR_init,0,PyvkCreateWaylandSurfaceKHR_new,
    };
    
     #endif 


    
     #ifdef VK_USE_PLATFORM_WAYLAND_KHR 
        

    typedef struct { PyObject_HEAD PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR pfn; } PyvkGetPhysicalDeviceWaylandPresentationSupportKHR;

    static PyObject* PyvkGetPhysicalDeviceWaylandPresentationSupportKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkGetPhysicalDeviceWaylandPresentationSupportKHR *self;
        self = (PyvkGetPhysicalDeviceWaylandPresentationSupportKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkGetPhysicalDeviceWaylandPresentationSupportKHR_del(PyvkGetPhysicalDeviceWaylandPresentationSupportKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkGetPhysicalDeviceWaylandPresentationSupportKHR_init(PyvkGetPhysicalDeviceWaylandPresentationSupportKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkGetPhysicalDeviceWaylandPresentationSupportKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkPhysicalDevice physicalDevice;
uint32_t queueFamilyIndex;
struct wl_display* display;

    static char *kwlist[] = {"physicalDevice","queueFamilyIndex","display",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice,pyc_uint32_t_converter,&queueFamilyIndex,pyc_wl_display_converter,&display))
        return NULL;
    

    

    
        

        
            PyObject* return_value = PyBool_FromLong((*(((PyvkGetPhysicalDeviceWaylandPresentationSupportKHR*)self)->pfn))(physicalDevice,queueFamilyIndex,display));
        
    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);
pyc_uint32_t_converter_free(&queueFamilyIndex);
pyc_wl_display_converter_free(&display);


    return return_value;

    }

    static PyTypeObject PyvkGetPhysicalDeviceWaylandPresentationSupportKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkGetPhysicalDeviceWaylandPresentationSupportKHR", sizeof(PyvkGetPhysicalDeviceWaylandPresentationSupportKHR), 0,
        (destructor)PyvkGetPhysicalDeviceWaylandPresentationSupportKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceWaylandPresentationSupportKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkGetPhysicalDeviceWaylandPresentationSupportKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceWaylandPresentationSupportKHR_init,0,PyvkGetPhysicalDeviceWaylandPresentationSupportKHR_new,
    };
    
     #endif 


    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        

    typedef struct { PyObject_HEAD PFN_vkCreateWin32SurfaceKHR pfn; } PyvkCreateWin32SurfaceKHR;

    static PyObject* PyvkCreateWin32SurfaceKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkCreateWin32SurfaceKHR *self;
        self = (PyvkCreateWin32SurfaceKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkCreateWin32SurfaceKHR_del(PyvkCreateWin32SurfaceKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkCreateWin32SurfaceKHR_init(PyvkCreateWin32SurfaceKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkCreateWin32SurfaceKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkCreateWin32SurfaceKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkInstance instance;
VkWin32SurfaceCreateInfoKHR* pCreateInfo;

    static char *kwlist[] = {"instance","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkInstance_converter,&instance,pyc_struct_pointer_VkWin32SurfaceCreateInfoKHR_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkSurfaceKHR *value = malloc(allocate_size * sizeof(VkSurfaceKHR));
        
        
            if (raise((*(((PyvkCreateWin32SurfaceKHR*)self)->pfn))(instance,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkSurfaceKHR", NULL);
            
        

    

    pyc_handle_base_VkInstance_converter_free(&instance);
pyc_struct_pointer_VkWin32SurfaceCreateInfoKHR_converter_free(&pCreateInfo);


    return return_value;

    }

    static PyTypeObject PyvkCreateWin32SurfaceKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkCreateWin32SurfaceKHR", sizeof(PyvkCreateWin32SurfaceKHR), 0,
        (destructor)PyvkCreateWin32SurfaceKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateWin32SurfaceKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkCreateWin32SurfaceKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkCreateWin32SurfaceKHR_init,0,PyvkCreateWin32SurfaceKHR_new,
    };
    
     #endif 


    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        

    typedef struct { PyObject_HEAD PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR pfn; } PyvkGetPhysicalDeviceWin32PresentationSupportKHR;

    static PyObject* PyvkGetPhysicalDeviceWin32PresentationSupportKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkGetPhysicalDeviceWin32PresentationSupportKHR *self;
        self = (PyvkGetPhysicalDeviceWin32PresentationSupportKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkGetPhysicalDeviceWin32PresentationSupportKHR_del(PyvkGetPhysicalDeviceWin32PresentationSupportKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkGetPhysicalDeviceWin32PresentationSupportKHR_init(PyvkGetPhysicalDeviceWin32PresentationSupportKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkGetPhysicalDeviceWin32PresentationSupportKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkPhysicalDevice physicalDevice;
uint32_t queueFamilyIndex;

    static char *kwlist[] = {"physicalDevice","queueFamilyIndex",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice,pyc_uint32_t_converter,&queueFamilyIndex))
        return NULL;
    

    

    
        

        
            PyObject* return_value = PyBool_FromLong((*(((PyvkGetPhysicalDeviceWin32PresentationSupportKHR*)self)->pfn))(physicalDevice,queueFamilyIndex));
        
    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);
pyc_uint32_t_converter_free(&queueFamilyIndex);


    return return_value;

    }

    static PyTypeObject PyvkGetPhysicalDeviceWin32PresentationSupportKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkGetPhysicalDeviceWin32PresentationSupportKHR", sizeof(PyvkGetPhysicalDeviceWin32PresentationSupportKHR), 0,
        (destructor)PyvkGetPhysicalDeviceWin32PresentationSupportKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceWin32PresentationSupportKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkGetPhysicalDeviceWin32PresentationSupportKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceWin32PresentationSupportKHR_init,0,PyvkGetPhysicalDeviceWin32PresentationSupportKHR_new,
    };
    
     #endif 


    
     #ifdef VK_USE_PLATFORM_XLIB_KHR 
        

    typedef struct { PyObject_HEAD PFN_vkCreateXlibSurfaceKHR pfn; } PyvkCreateXlibSurfaceKHR;

    static PyObject* PyvkCreateXlibSurfaceKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkCreateXlibSurfaceKHR *self;
        self = (PyvkCreateXlibSurfaceKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkCreateXlibSurfaceKHR_del(PyvkCreateXlibSurfaceKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkCreateXlibSurfaceKHR_init(PyvkCreateXlibSurfaceKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkCreateXlibSurfaceKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkCreateXlibSurfaceKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkInstance instance;
VkXlibSurfaceCreateInfoKHR* pCreateInfo;

    static char *kwlist[] = {"instance","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkInstance_converter,&instance,pyc_struct_pointer_VkXlibSurfaceCreateInfoKHR_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkSurfaceKHR *value = malloc(allocate_size * sizeof(VkSurfaceKHR));
        
        
            if (raise((*(((PyvkCreateXlibSurfaceKHR*)self)->pfn))(instance,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkSurfaceKHR", NULL);
            
        

    

    pyc_handle_base_VkInstance_converter_free(&instance);
pyc_struct_pointer_VkXlibSurfaceCreateInfoKHR_converter_free(&pCreateInfo);


    return return_value;

    }

    static PyTypeObject PyvkCreateXlibSurfaceKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkCreateXlibSurfaceKHR", sizeof(PyvkCreateXlibSurfaceKHR), 0,
        (destructor)PyvkCreateXlibSurfaceKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateXlibSurfaceKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkCreateXlibSurfaceKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkCreateXlibSurfaceKHR_init,0,PyvkCreateXlibSurfaceKHR_new,
    };
    
     #endif 


    
     #ifdef VK_USE_PLATFORM_XLIB_KHR 
        

    typedef struct { PyObject_HEAD PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR pfn; } PyvkGetPhysicalDeviceXlibPresentationSupportKHR;

    static PyObject* PyvkGetPhysicalDeviceXlibPresentationSupportKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkGetPhysicalDeviceXlibPresentationSupportKHR *self;
        self = (PyvkGetPhysicalDeviceXlibPresentationSupportKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkGetPhysicalDeviceXlibPresentationSupportKHR_del(PyvkGetPhysicalDeviceXlibPresentationSupportKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkGetPhysicalDeviceXlibPresentationSupportKHR_init(PyvkGetPhysicalDeviceXlibPresentationSupportKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkGetPhysicalDeviceXlibPresentationSupportKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkPhysicalDevice physicalDevice;
uint32_t queueFamilyIndex;
Display * dpy;
VisualID visualID;

    static char *kwlist[] = {"physicalDevice","queueFamilyIndex","dpy","visualID",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice,pyc_uint32_t_converter,&queueFamilyIndex,pyc_Display_x_converter,&dpy,pyc_VisualID_converter,&visualID))
        return NULL;
    

    

    
        

        
            PyObject* return_value = PyBool_FromLong((*(((PyvkGetPhysicalDeviceXlibPresentationSupportKHR*)self)->pfn))(physicalDevice,queueFamilyIndex,dpy,visualID));
        
    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);
pyc_uint32_t_converter_free(&queueFamilyIndex);
pyc_Display_x_converter_free(&dpy);
pyc_VisualID_converter_free(&visualID);


    return return_value;

    }

    static PyTypeObject PyvkGetPhysicalDeviceXlibPresentationSupportKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkGetPhysicalDeviceXlibPresentationSupportKHR", sizeof(PyvkGetPhysicalDeviceXlibPresentationSupportKHR), 0,
        (destructor)PyvkGetPhysicalDeviceXlibPresentationSupportKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceXlibPresentationSupportKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkGetPhysicalDeviceXlibPresentationSupportKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceXlibPresentationSupportKHR_init,0,PyvkGetPhysicalDeviceXlibPresentationSupportKHR_new,
    };
    
     #endif 


    
     #ifdef VK_USE_PLATFORM_XCB_KHR 
        

    typedef struct { PyObject_HEAD PFN_vkCreateXcbSurfaceKHR pfn; } PyvkCreateXcbSurfaceKHR;

    static PyObject* PyvkCreateXcbSurfaceKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkCreateXcbSurfaceKHR *self;
        self = (PyvkCreateXcbSurfaceKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkCreateXcbSurfaceKHR_del(PyvkCreateXcbSurfaceKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkCreateXcbSurfaceKHR_init(PyvkCreateXcbSurfaceKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkCreateXcbSurfaceKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkCreateXcbSurfaceKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkInstance instance;
VkXcbSurfaceCreateInfoKHR* pCreateInfo;

    static char *kwlist[] = {"instance","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkInstance_converter,&instance,pyc_struct_pointer_VkXcbSurfaceCreateInfoKHR_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkSurfaceKHR *value = malloc(allocate_size * sizeof(VkSurfaceKHR));
        
        
            if (raise((*(((PyvkCreateXcbSurfaceKHR*)self)->pfn))(instance,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkSurfaceKHR", NULL);
            
        

    

    pyc_handle_base_VkInstance_converter_free(&instance);
pyc_struct_pointer_VkXcbSurfaceCreateInfoKHR_converter_free(&pCreateInfo);


    return return_value;

    }

    static PyTypeObject PyvkCreateXcbSurfaceKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkCreateXcbSurfaceKHR", sizeof(PyvkCreateXcbSurfaceKHR), 0,
        (destructor)PyvkCreateXcbSurfaceKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateXcbSurfaceKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkCreateXcbSurfaceKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkCreateXcbSurfaceKHR_init,0,PyvkCreateXcbSurfaceKHR_new,
    };
    
     #endif 


    
     #ifdef VK_USE_PLATFORM_XCB_KHR 
        

    typedef struct { PyObject_HEAD PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR pfn; } PyvkGetPhysicalDeviceXcbPresentationSupportKHR;

    static PyObject* PyvkGetPhysicalDeviceXcbPresentationSupportKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkGetPhysicalDeviceXcbPresentationSupportKHR *self;
        self = (PyvkGetPhysicalDeviceXcbPresentationSupportKHR *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkGetPhysicalDeviceXcbPresentationSupportKHR_del(PyvkGetPhysicalDeviceXcbPresentationSupportKHR* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkGetPhysicalDeviceXcbPresentationSupportKHR_init(PyvkGetPhysicalDeviceXcbPresentationSupportKHR *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkGetPhysicalDeviceXcbPresentationSupportKHR_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkPhysicalDevice physicalDevice;
uint32_t queueFamilyIndex;
xcb_connection_t * connection;
xcb_visualid_t visual_id;

    static char *kwlist[] = {"physicalDevice","queueFamilyIndex","connection","visual_id",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice,pyc_uint32_t_converter,&queueFamilyIndex,pyc_xcb_connection_t_x_converter,&connection,pyc_xcb_visualid_t_converter,&visual_id))
        return NULL;
    

    

    
        

        
            PyObject* return_value = PyBool_FromLong((*(((PyvkGetPhysicalDeviceXcbPresentationSupportKHR*)self)->pfn))(physicalDevice,queueFamilyIndex,connection,visual_id));
        
    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);
pyc_uint32_t_converter_free(&queueFamilyIndex);
pyc_xcb_connection_t_x_converter_free(&connection);
pyc_xcb_visualid_t_converter_free(&visual_id);


    return return_value;

    }

    static PyTypeObject PyvkGetPhysicalDeviceXcbPresentationSupportKHRType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkGetPhysicalDeviceXcbPresentationSupportKHR", sizeof(PyvkGetPhysicalDeviceXcbPresentationSupportKHR), 0,
        (destructor)PyvkGetPhysicalDeviceXcbPresentationSupportKHR_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceXcbPresentationSupportKHR_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkGetPhysicalDeviceXcbPresentationSupportKHR object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceXcbPresentationSupportKHR_init,0,PyvkGetPhysicalDeviceXcbPresentationSupportKHR_new,
    };
    
     #endif 


    
    
        

    typedef struct { PyObject_HEAD PFN_vkCreateDebugReportCallbackEXT pfn; } PyvkCreateDebugReportCallbackEXT;

    static PyObject* PyvkCreateDebugReportCallbackEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkCreateDebugReportCallbackEXT *self;
        self = (PyvkCreateDebugReportCallbackEXT *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkCreateDebugReportCallbackEXT_del(PyvkCreateDebugReportCallbackEXT* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkCreateDebugReportCallbackEXT_init(PyvkCreateDebugReportCallbackEXT *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkCreateDebugReportCallbackEXT) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkCreateDebugReportCallbackEXT_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkInstance instance;
VkDebugReportCallbackCreateInfoEXT* pCreateInfo;

    static char *kwlist[] = {"instance","pCreateInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkInstance_converter,&instance,pyc_struct_pointer_VkDebugReportCallbackCreateInfoEXT_converter,&pCreateInfo))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkDebugReportCallbackEXT *value = malloc(allocate_size * sizeof(VkDebugReportCallbackEXT));
        
        
            if (raise((*(((PyvkCreateDebugReportCallbackEXT*)self)->pfn))(instance,pCreateInfo,NULL,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyCapsule_New(value, "VkDebugReportCallbackEXT", NULL);
            
        

    

    pyc_handle_base_VkInstance_converter_free(&instance);
pyc_struct_pointer_VkDebugReportCallbackCreateInfoEXT_converter_free(&pCreateInfo);


    return return_value;

    }

    static PyTypeObject PyvkCreateDebugReportCallbackEXTType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkCreateDebugReportCallbackEXT", sizeof(PyvkCreateDebugReportCallbackEXT), 0,
        (destructor)PyvkCreateDebugReportCallbackEXT_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateDebugReportCallbackEXT_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkCreateDebugReportCallbackEXT object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkCreateDebugReportCallbackEXT_init,0,PyvkCreateDebugReportCallbackEXT_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkDestroyDebugReportCallbackEXT pfn; } PyvkDestroyDebugReportCallbackEXT;

    static PyObject* PyvkDestroyDebugReportCallbackEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkDestroyDebugReportCallbackEXT *self;
        self = (PyvkDestroyDebugReportCallbackEXT *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkDestroyDebugReportCallbackEXT_del(PyvkDestroyDebugReportCallbackEXT* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkDestroyDebugReportCallbackEXT_init(PyvkDestroyDebugReportCallbackEXT *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkDestroyDebugReportCallbackEXT) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkDestroyDebugReportCallbackEXT_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkInstance instance;
VkDebugReportCallbackEXT callback;

    static char *kwlist[] = {"instance","callback",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkInstance_converter,&instance,pyc_handle_base_VkDebugReportCallbackEXT_converter,&callback))
        return NULL;
    

    

    
        

        
            (*(((PyvkDestroyDebugReportCallbackEXT*)self)->pfn))(instance,callback,NULL);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkInstance_converter_free(&instance);
pyc_handle_base_VkDebugReportCallbackEXT_converter_free(&callback);


    return return_value;

    }

    static PyTypeObject PyvkDestroyDebugReportCallbackEXTType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkDestroyDebugReportCallbackEXT", sizeof(PyvkDestroyDebugReportCallbackEXT), 0,
        (destructor)PyvkDestroyDebugReportCallbackEXT_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkDestroyDebugReportCallbackEXT_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkDestroyDebugReportCallbackEXT object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkDestroyDebugReportCallbackEXT_init,0,PyvkDestroyDebugReportCallbackEXT_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkDebugReportMessageEXT pfn; } PyvkDebugReportMessageEXT;

    static PyObject* PyvkDebugReportMessageEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkDebugReportMessageEXT *self;
        self = (PyvkDebugReportMessageEXT *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkDebugReportMessageEXT_del(PyvkDebugReportMessageEXT* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkDebugReportMessageEXT_init(PyvkDebugReportMessageEXT *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkDebugReportMessageEXT) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkDebugReportMessageEXT_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkInstance instance;
VkDebugReportFlagsEXT flags;
VkDebugReportObjectTypeEXT objectType;
uint64_t object;
size_t location;
int32_t messageCode;
char* pLayerPrefix;
char* pMessage;

    static char *kwlist[] = {"instance","flags","objectType","object","location","messageCode","pLayerPrefix","pMessage",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&O&", kwlist, pyc_handle_base_VkInstance_converter,&instance,pyc_flag_base_VkDebugReportFlagsEXT_converter,&flags,pyc_flag_base_VkDebugReportObjectTypeEXT_converter,&objectType,pyc_uint64_t_converter,&object,pyc_size_t_converter,&location,pyc_int32_t_converter,&messageCode,pyc_string_converter,&pLayerPrefix,pyc_string_converter,&pMessage))
        return NULL;
    

    

    
        

        
            (*(((PyvkDebugReportMessageEXT*)self)->pfn))(instance,flags,objectType,object,location,messageCode,pLayerPrefix,pMessage);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkInstance_converter_free(&instance);
pyc_flag_base_VkDebugReportFlagsEXT_converter_free(&flags);
pyc_flag_base_VkDebugReportObjectTypeEXT_converter_free(&objectType);
pyc_uint64_t_converter_free(&object);
pyc_size_t_converter_free(&location);
pyc_int32_t_converter_free(&messageCode);
pyc_string_converter_free(&pLayerPrefix);
pyc_string_converter_free(&pMessage);


    return return_value;

    }

    static PyTypeObject PyvkDebugReportMessageEXTType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkDebugReportMessageEXT", sizeof(PyvkDebugReportMessageEXT), 0,
        (destructor)PyvkDebugReportMessageEXT_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkDebugReportMessageEXT_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkDebugReportMessageEXT object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkDebugReportMessageEXT_init,0,PyvkDebugReportMessageEXT_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkDebugMarkerSetObjectNameEXT pfn; } PyvkDebugMarkerSetObjectNameEXT;

    static PyObject* PyvkDebugMarkerSetObjectNameEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkDebugMarkerSetObjectNameEXT *self;
        self = (PyvkDebugMarkerSetObjectNameEXT *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkDebugMarkerSetObjectNameEXT_del(PyvkDebugMarkerSetObjectNameEXT* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkDebugMarkerSetObjectNameEXT_init(PyvkDebugMarkerSetObjectNameEXT *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkDebugMarkerSetObjectNameEXT) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkDebugMarkerSetObjectNameEXT_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkDevice device;
VkDebugMarkerObjectNameInfoEXT* pNameInfo;

    static char *kwlist[] = {"device","pNameInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkDebugMarkerObjectNameInfoEXT_converter,&pNameInfo))
        return NULL;
    

    

    
        

        
            (*(((PyvkDebugMarkerSetObjectNameEXT*)self)->pfn))(device,pNameInfo);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkDebugMarkerObjectNameInfoEXT_converter_free(&pNameInfo);


    return return_value;

    }

    static PyTypeObject PyvkDebugMarkerSetObjectNameEXTType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkDebugMarkerSetObjectNameEXT", sizeof(PyvkDebugMarkerSetObjectNameEXT), 0,
        (destructor)PyvkDebugMarkerSetObjectNameEXT_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkDebugMarkerSetObjectNameEXT_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkDebugMarkerSetObjectNameEXT object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkDebugMarkerSetObjectNameEXT_init,0,PyvkDebugMarkerSetObjectNameEXT_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkDebugMarkerSetObjectTagEXT pfn; } PyvkDebugMarkerSetObjectTagEXT;

    static PyObject* PyvkDebugMarkerSetObjectTagEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkDebugMarkerSetObjectTagEXT *self;
        self = (PyvkDebugMarkerSetObjectTagEXT *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkDebugMarkerSetObjectTagEXT_del(PyvkDebugMarkerSetObjectTagEXT* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkDebugMarkerSetObjectTagEXT_init(PyvkDebugMarkerSetObjectTagEXT *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkDebugMarkerSetObjectTagEXT) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkDebugMarkerSetObjectTagEXT_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkDevice device;
VkDebugMarkerObjectTagInfoEXT* pTagInfo;

    static char *kwlist[] = {"device","pTagInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_struct_pointer_VkDebugMarkerObjectTagInfoEXT_converter,&pTagInfo))
        return NULL;
    

    

    
        

        
            (*(((PyvkDebugMarkerSetObjectTagEXT*)self)->pfn))(device,pTagInfo);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_struct_pointer_VkDebugMarkerObjectTagInfoEXT_converter_free(&pTagInfo);


    return return_value;

    }

    static PyTypeObject PyvkDebugMarkerSetObjectTagEXTType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkDebugMarkerSetObjectTagEXT", sizeof(PyvkDebugMarkerSetObjectTagEXT), 0,
        (destructor)PyvkDebugMarkerSetObjectTagEXT_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkDebugMarkerSetObjectTagEXT_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkDebugMarkerSetObjectTagEXT object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkDebugMarkerSetObjectTagEXT_init,0,PyvkDebugMarkerSetObjectTagEXT_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkCmdDebugMarkerBeginEXT pfn; } PyvkCmdDebugMarkerBeginEXT;

    static PyObject* PyvkCmdDebugMarkerBeginEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkCmdDebugMarkerBeginEXT *self;
        self = (PyvkCmdDebugMarkerBeginEXT *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkCmdDebugMarkerBeginEXT_del(PyvkCmdDebugMarkerBeginEXT* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkCmdDebugMarkerBeginEXT_init(PyvkCmdDebugMarkerBeginEXT *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkCmdDebugMarkerBeginEXT) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkCmdDebugMarkerBeginEXT_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkCommandBuffer commandBuffer;
VkDebugMarkerMarkerInfoEXT* pMarkerInfo;

    static char *kwlist[] = {"commandBuffer","pMarkerInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_struct_pointer_VkDebugMarkerMarkerInfoEXT_converter,&pMarkerInfo))
        return NULL;
    

    

    
        

        
            (*(((PyvkCmdDebugMarkerBeginEXT*)self)->pfn))(commandBuffer,pMarkerInfo);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_struct_pointer_VkDebugMarkerMarkerInfoEXT_converter_free(&pMarkerInfo);


    return return_value;

    }

    static PyTypeObject PyvkCmdDebugMarkerBeginEXTType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkCmdDebugMarkerBeginEXT", sizeof(PyvkCmdDebugMarkerBeginEXT), 0,
        (destructor)PyvkCmdDebugMarkerBeginEXT_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCmdDebugMarkerBeginEXT_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkCmdDebugMarkerBeginEXT object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkCmdDebugMarkerBeginEXT_init,0,PyvkCmdDebugMarkerBeginEXT_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkCmdDebugMarkerEndEXT pfn; } PyvkCmdDebugMarkerEndEXT;

    static PyObject* PyvkCmdDebugMarkerEndEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkCmdDebugMarkerEndEXT *self;
        self = (PyvkCmdDebugMarkerEndEXT *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkCmdDebugMarkerEndEXT_del(PyvkCmdDebugMarkerEndEXT* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkCmdDebugMarkerEndEXT_init(PyvkCmdDebugMarkerEndEXT *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkCmdDebugMarkerEndEXT) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkCmdDebugMarkerEndEXT_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkCommandBuffer commandBuffer;

    static char *kwlist[] = {"commandBuffer",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer))
        return NULL;
    

    

    
        

        
            (*(((PyvkCmdDebugMarkerEndEXT*)self)->pfn))(commandBuffer);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);


    return return_value;

    }

    static PyTypeObject PyvkCmdDebugMarkerEndEXTType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkCmdDebugMarkerEndEXT", sizeof(PyvkCmdDebugMarkerEndEXT), 0,
        (destructor)PyvkCmdDebugMarkerEndEXT_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCmdDebugMarkerEndEXT_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkCmdDebugMarkerEndEXT object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkCmdDebugMarkerEndEXT_init,0,PyvkCmdDebugMarkerEndEXT_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkCmdDebugMarkerInsertEXT pfn; } PyvkCmdDebugMarkerInsertEXT;

    static PyObject* PyvkCmdDebugMarkerInsertEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkCmdDebugMarkerInsertEXT *self;
        self = (PyvkCmdDebugMarkerInsertEXT *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkCmdDebugMarkerInsertEXT_del(PyvkCmdDebugMarkerInsertEXT* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkCmdDebugMarkerInsertEXT_init(PyvkCmdDebugMarkerInsertEXT *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkCmdDebugMarkerInsertEXT) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkCmdDebugMarkerInsertEXT_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkCommandBuffer commandBuffer;
VkDebugMarkerMarkerInfoEXT* pMarkerInfo;

    static char *kwlist[] = {"commandBuffer","pMarkerInfo",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_struct_pointer_VkDebugMarkerMarkerInfoEXT_converter,&pMarkerInfo))
        return NULL;
    

    

    
        

        
            (*(((PyvkCmdDebugMarkerInsertEXT*)self)->pfn))(commandBuffer,pMarkerInfo);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_struct_pointer_VkDebugMarkerMarkerInfoEXT_converter_free(&pMarkerInfo);


    return return_value;

    }

    static PyTypeObject PyvkCmdDebugMarkerInsertEXTType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkCmdDebugMarkerInsertEXT", sizeof(PyvkCmdDebugMarkerInsertEXT), 0,
        (destructor)PyvkCmdDebugMarkerInsertEXT_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCmdDebugMarkerInsertEXT_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkCmdDebugMarkerInsertEXT object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkCmdDebugMarkerInsertEXT_init,0,PyvkCmdDebugMarkerInsertEXT_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV pfn; } PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV;

    static PyObject* PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV *self;
        self = (PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV_del(PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV_init(PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkPhysicalDevice physicalDevice;
VkFormat format;
VkImageType type;
VkImageTiling tiling;
VkImageUsageFlags usage;
VkImageCreateFlags flags;
VkExternalMemoryHandleTypeFlagsNV externalHandleType;

    static char *kwlist[] = {"physicalDevice","format","type","tiling","usage","flags","externalHandleType",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&", kwlist, pyc_handle_base_VkPhysicalDevice_converter,&physicalDevice,pyc_flag_base_VkFormat_converter,&format,pyc_flag_base_VkImageType_converter,&type,pyc_flag_base_VkImageTiling_converter,&tiling,pyc_flag_base_VkImageUsageFlags_converter,&usage,pyc_flag_base_VkImageCreateFlags_converter,&flags,pyc_flag_base_VkExternalMemoryHandleTypeFlagsNV_converter,&externalHandleType))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        VkExternalImageFormatPropertiesNV *value = malloc(allocate_size * sizeof(VkExternalImageFormatPropertiesNV));
        
        
            if (raise((*(((PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV*)self)->pfn))(physicalDevice,format,type,tiling,usage,flags,externalHandleType,value)))
                return NULL;
        


        
            
                PyObject* return_value = _PyObject_New(&PyVkExternalImageFormatPropertiesNVType);
                if (!return_value)
                    return NULL;
                ((PyVkExternalImageFormatPropertiesNV*)return_value)->base = value;
            
        

    

    pyc_handle_base_VkPhysicalDevice_converter_free(&physicalDevice);
pyc_flag_base_VkFormat_converter_free(&format);
pyc_flag_base_VkImageType_converter_free(&type);
pyc_flag_base_VkImageTiling_converter_free(&tiling);
pyc_flag_base_VkImageUsageFlags_converter_free(&usage);
pyc_flag_base_VkImageCreateFlags_converter_free(&flags);
pyc_flag_base_VkExternalMemoryHandleTypeFlagsNV_converter_free(&externalHandleType);


    return return_value;

    }

    static PyTypeObject PyvkGetPhysicalDeviceExternalImageFormatPropertiesNVType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkGetPhysicalDeviceExternalImageFormatPropertiesNV", sizeof(PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV), 0,
        (destructor)PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV_init,0,PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV_new,
    };
    
    


    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        

    typedef struct { PyObject_HEAD PFN_vkGetMemoryWin32HandleNV pfn; } PyvkGetMemoryWin32HandleNV;

    static PyObject* PyvkGetMemoryWin32HandleNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkGetMemoryWin32HandleNV *self;
        self = (PyvkGetMemoryWin32HandleNV *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkGetMemoryWin32HandleNV_del(PyvkGetMemoryWin32HandleNV* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkGetMemoryWin32HandleNV_init(PyvkGetMemoryWin32HandleNV *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkGetMemoryWin32HandleNV) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkGetMemoryWin32HandleNV_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkDevice device;
VkDeviceMemory memory;
VkExternalMemoryHandleTypeFlagsNV handleType;

    static char *kwlist[] = {"device","memory","handleType",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&", kwlist, pyc_handle_base_VkDevice_converter,&device,pyc_handle_base_VkDeviceMemory_converter,&memory,pyc_flag_base_VkExternalMemoryHandleTypeFlagsNV_converter,&handleType))
        return NULL;
    

    

    
        int allocate_size = 1;

        

        HANDLE *value = malloc(allocate_size * sizeof(HANDLE));
        
        
            if (raise((*(((PyvkGetMemoryWin32HandleNV*)self)->pfn))(device,memory,handleType,value)))
                return NULL;
        


        
            
                PyObject* return_value = PyLong_FromLong((long) *value);
            
        

    

    pyc_handle_base_VkDevice_converter_free(&device);
pyc_handle_base_VkDeviceMemory_converter_free(&memory);
pyc_flag_base_VkExternalMemoryHandleTypeFlagsNV_converter_free(&handleType);


    return return_value;

    }

    static PyTypeObject PyvkGetMemoryWin32HandleNVType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkGetMemoryWin32HandleNV", sizeof(PyvkGetMemoryWin32HandleNV), 0,
        (destructor)PyvkGetMemoryWin32HandleNV_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetMemoryWin32HandleNV_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkGetMemoryWin32HandleNV object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkGetMemoryWin32HandleNV_init,0,PyvkGetMemoryWin32HandleNV_new,
    };
    
     #endif 


    
    
        

    typedef struct { PyObject_HEAD PFN_vkCmdDrawIndirectCountAMD pfn; } PyvkCmdDrawIndirectCountAMD;

    static PyObject* PyvkCmdDrawIndirectCountAMD_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkCmdDrawIndirectCountAMD *self;
        self = (PyvkCmdDrawIndirectCountAMD *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkCmdDrawIndirectCountAMD_del(PyvkCmdDrawIndirectCountAMD* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkCmdDrawIndirectCountAMD_init(PyvkCmdDrawIndirectCountAMD *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkCmdDrawIndirectCountAMD) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkCmdDrawIndirectCountAMD_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkCommandBuffer commandBuffer;
VkBuffer buffer;
VkDeviceSize offset;
VkBuffer countBuffer;
VkDeviceSize countBufferOffset;
uint32_t maxDrawCount;
uint32_t stride;

    static char *kwlist[] = {"commandBuffer","buffer","offset","countBuffer","countBufferOffset","maxDrawCount","stride",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkBuffer_converter,&buffer,pyc_flag_base_VkDeviceSize_converter,&offset,pyc_handle_base_VkBuffer_converter,&countBuffer,pyc_flag_base_VkDeviceSize_converter,&countBufferOffset,pyc_uint32_t_converter,&maxDrawCount,pyc_uint32_t_converter,&stride))
        return NULL;
    

    

    
        

        
            (*(((PyvkCmdDrawIndirectCountAMD*)self)->pfn))(commandBuffer,buffer,offset,countBuffer,countBufferOffset,maxDrawCount,stride);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkBuffer_converter_free(&buffer);
pyc_flag_base_VkDeviceSize_converter_free(&offset);
pyc_handle_base_VkBuffer_converter_free(&countBuffer);
pyc_flag_base_VkDeviceSize_converter_free(&countBufferOffset);
pyc_uint32_t_converter_free(&maxDrawCount);
pyc_uint32_t_converter_free(&stride);


    return return_value;

    }

    static PyTypeObject PyvkCmdDrawIndirectCountAMDType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkCmdDrawIndirectCountAMD", sizeof(PyvkCmdDrawIndirectCountAMD), 0,
        (destructor)PyvkCmdDrawIndirectCountAMD_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCmdDrawIndirectCountAMD_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkCmdDrawIndirectCountAMD object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkCmdDrawIndirectCountAMD_init,0,PyvkCmdDrawIndirectCountAMD_new,
    };
    
    


    
    
        

    typedef struct { PyObject_HEAD PFN_vkCmdDrawIndexedIndirectCountAMD pfn; } PyvkCmdDrawIndexedIndirectCountAMD;

    static PyObject* PyvkCmdDrawIndexedIndirectCountAMD_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
        PyvkCmdDrawIndexedIndirectCountAMD *self;
        self = (PyvkCmdDrawIndexedIndirectCountAMD *)type->tp_alloc(type, 0);
        return (PyObject *)self;
    }

    static void PyvkCmdDrawIndexedIndirectCountAMD_del(PyvkCmdDrawIndexedIndirectCountAMD* self) {
        Py_TYPE(self)->tp_free((PyObject*)self);
    }

    static int PyvkCmdDrawIndexedIndirectCountAMD_init(PyvkCmdDrawIndexedIndirectCountAMD *self, PyObject *args, PyObject *kwds) {
        PyObject* capsule;
        if (!PyArg_ParseTuple(args, "O", &capsule))
            return -1;
        self->pfn = (PFN_vkCmdDrawIndexedIndirectCountAMD) PyCapsule_GetPointer(capsule, NULL);
        if (self->pfn == NULL)
            return -1;
        return 0;
    }


    static PyObject* PyvkCmdDrawIndexedIndirectCountAMD_call(PyObject *self, PyObject *args, PyObject *kwds) {
        
    
    
        
    

    VkCommandBuffer commandBuffer;
VkBuffer buffer;
VkDeviceSize offset;
VkBuffer countBuffer;
VkDeviceSize countBufferOffset;
uint32_t maxDrawCount;
uint32_t stride;

    static char *kwlist[] = {"commandBuffer","buffer","offset","countBuffer","countBufferOffset","maxDrawCount","stride",NULL};
    
    if( !PyArg_ParseTupleAndKeywords(args, kwds,
        "O&O&O&O&O&O&O&", kwlist, pyc_handle_base_VkCommandBuffer_converter,&commandBuffer,pyc_handle_base_VkBuffer_converter,&buffer,pyc_flag_base_VkDeviceSize_converter,&offset,pyc_handle_base_VkBuffer_converter,&countBuffer,pyc_flag_base_VkDeviceSize_converter,&countBufferOffset,pyc_uint32_t_converter,&maxDrawCount,pyc_uint32_t_converter,&stride))
        return NULL;
    

    

    
        

        
            (*(((PyvkCmdDrawIndexedIndirectCountAMD*)self)->pfn))(commandBuffer,buffer,offset,countBuffer,countBufferOffset,maxDrawCount,stride);
            Py_INCREF(Py_None);
            PyObject* return_value = Py_None;
        
    

    pyc_handle_base_VkCommandBuffer_converter_free(&commandBuffer);
pyc_handle_base_VkBuffer_converter_free(&buffer);
pyc_flag_base_VkDeviceSize_converter_free(&offset);
pyc_handle_base_VkBuffer_converter_free(&countBuffer);
pyc_flag_base_VkDeviceSize_converter_free(&countBufferOffset);
pyc_uint32_t_converter_free(&maxDrawCount);
pyc_uint32_t_converter_free(&stride);


    return return_value;

    }

    static PyTypeObject PyvkCmdDrawIndexedIndirectCountAMDType = {
        PyVarObject_HEAD_INIT(NULL, 0) "vulkan.vkCmdDrawIndexedIndirectCountAMD", sizeof(PyvkCmdDrawIndexedIndirectCountAMD), 0,
        (destructor)PyvkCmdDrawIndexedIndirectCountAMD_del, 0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCmdDrawIndexedIndirectCountAMD_call,
        0,0,0,0,Py_TPFLAGS_DEFAULT, "vkCmdDrawIndexedIndirectCountAMD object",0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,(initproc)PyvkCmdDrawIndexedIndirectCountAMD_init,0,PyvkCmdDrawIndexedIndirectCountAMD_new,
    };
    
    




// ---------------
// CREATE PYTHON CUSTOM FUNCTIONS
// ---------------
static PyObject* PyVK_MAKE_VERSION(PyObject *self, PyObject *args) {
    const int major, minor, patch;
    if (!PyArg_ParseTuple(args, "iii", &major, &minor, &patch))
        return NULL;
    return PyLong_FromLong((((major) << 22) | ((minor) << 12) | (patch)));
}

static PyObject* PyVK_VERSION_MAJOR(PyObject *self, PyObject *args) {
    const int version;
    if (!PyArg_ParseTuple(args, "i", &version))
        return NULL;
    return PyLong_FromLong(((uint32_t)(version) >> 22));
}

static PyObject* PyVK_VERSION_MINOR(PyObject *self, PyObject *args) {
    const int version;
    if (!PyArg_ParseTuple(args, "i", &version))
        return NULL;
    return PyLong_FromLong((((uint32_t)(version) >> 12) & 0x3ff));
}

static PyObject* PyVK_VERSION_PATCH(PyObject *self, PyObject *args) {
    const int version;
    if (!PyArg_ParseTuple(args, "i", &version))
        return NULL;
    return PyLong_FromLong(((uint32_t)(version) & 0xfff));
}


static PyObject* PyvkMapMemory(PyObject *self, PyObject *args, PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* memory = NULL;
    PyObject* offset = NULL;
    PyObject* size = NULL;
    PyObject* flags = NULL;
    static char *kwlist[] = {"device","memory","offset","size","flags",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &device, &memory, &offset, &size, &flags)) return NULL;

    VkDevice* c_device = PyCapsule_GetPointer(device, "VkDevice");
    VkDeviceMemory* c_memory = PyCapsule_GetPointer(memory, "VkDeviceMemory");
    VkDeviceSize c_offset = PyLong_AsLong(offset);
    VkDeviceSize c_size = PyLong_AsLong(size);
    VkMemoryMapFlags c_flags = PyLong_AsLong(flags);

    void* value;
    if (raise(vkMapMemory(*c_device, *c_memory, c_offset, c_size, c_flags, &value)))
        return NULL;

    PyObject* return_value = PyMemoryView_FromMemory(value, c_size, PyBUF_WRITE);

    return return_value;
}


static PyObject* PyvkGetPipelineCacheData(PyObject *self, PyObject *args, PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pipelineCache = NULL;
    PyObject* pDataSize = NULL;
    static char *kwlist[] = {"device","pipelineCache","pDataSize",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &pipelineCache, &pDataSize)) return NULL;

    VkDevice* c_device = PyCapsule_GetPointer(device, "VkDevice");
    VkPipelineCache* c_pipelineCache = PyCapsule_GetPointer(pipelineCache, "VkPipelineCache");

    void* value = NULL;
    size_t* data_size = NULL;
    if (raise(vkGetPipelineCacheData(*c_device, *c_pipelineCache, data_size, value)))
        return NULL;

    PyObject* return_value = PyMemoryView_FromMemory(value, *data_size, PyBUF_WRITE);

    return return_value;
}





static PyObject* PyvkGetInstanceProcAddr(PyObject *self, PyObject *args, PyObject *kwds) {
    PyObject* instance = NULL;
    PyObject* pName = NULL;
    static char *kwlist[] = {"instance", "pName", NULL};

    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &instance, &pName))
          return NULL;

    VkInstance* arg0 = PyCapsule_GetPointer(instance, "VkInstance");
    if(arg0 == NULL) return NULL;

    PyObject* tmp = PyUnicode_AsASCIIString(pName);
    if(tmp == NULL) return NULL;

    char* arg1 = PyBytes_AsString(tmp);
    if(arg1 == NULL) return NULL;

    PFN_vkVoidFunction fun = vkGetInstanceProcAddr(*arg0, arg1);
    if (fun == NULL) {
          PyErr_SetString(PyExc_ImportError, "Can't get address of extension function");
          return NULL;
    }
    PyObject* pointer = PyCapsule_New(fun, NULL, NULL);
    if (pointer == NULL) return NULL;

    PyObject* call_args = Py_BuildValue("(O)", pointer);
    if (call_args == NULL) return NULL;

    PyObject* pyreturn = NULL;

    
        
     #ifdef VK_USE_PLATFORM_ANDROID_KHR 
        
            if (strcmp(arg1, "vkCreateAndroidSurfaceKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateAndroidSurfaceKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
    
        
            if (strcmp(arg1, "vkGetPhysicalDeviceDisplayPropertiesKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceDisplayPropertiesKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceDisplayPlanePropertiesKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetDisplayPlaneSupportedDisplaysKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetDisplayPlaneSupportedDisplaysKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetDisplayModePropertiesKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetDisplayModePropertiesKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkCreateDisplayModeKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateDisplayModeKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetDisplayPlaneCapabilitiesKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetDisplayPlaneCapabilitiesKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkCreateDisplayPlaneSurfaceKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateDisplayPlaneSurfaceKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkCreateSharedSwapchainsKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateSharedSwapchainsKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
     #ifdef VK_USE_PLATFORM_MIR_KHR 
        
            if (strcmp(arg1, "vkCreateMirSurfaceKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateMirSurfaceKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_MIR_KHR 
        
            if (strcmp(arg1, "vkGetPhysicalDeviceMirPresentationSupportKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceMirPresentationSupportKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
    
        
            if (strcmp(arg1, "vkDestroySurfaceKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkDestroySurfaceKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetPhysicalDeviceSurfaceSupportKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceSurfaceSupportKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceSurfaceCapabilitiesKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetPhysicalDeviceSurfaceFormatsKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceSurfaceFormatsKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetPhysicalDeviceSurfacePresentModesKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceSurfacePresentModesKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkCreateSwapchainKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateSwapchainKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkDestroySwapchainKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkDestroySwapchainKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetSwapchainImagesKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetSwapchainImagesKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkAcquireNextImageKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkAcquireNextImageKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkQueuePresentKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkQueuePresentKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
     #ifdef VK_USE_PLATFORM_WAYLAND_KHR 
        
            if (strcmp(arg1, "vkCreateWaylandSurfaceKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateWaylandSurfaceKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_WAYLAND_KHR 
        
            if (strcmp(arg1, "vkGetPhysicalDeviceWaylandPresentationSupportKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceWaylandPresentationSupportKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
            if (strcmp(arg1, "vkCreateWin32SurfaceKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateWin32SurfaceKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
            if (strcmp(arg1, "vkGetPhysicalDeviceWin32PresentationSupportKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceWin32PresentationSupportKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_XLIB_KHR 
        
            if (strcmp(arg1, "vkCreateXlibSurfaceKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateXlibSurfaceKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_XLIB_KHR 
        
            if (strcmp(arg1, "vkGetPhysicalDeviceXlibPresentationSupportKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceXlibPresentationSupportKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_XCB_KHR 
        
            if (strcmp(arg1, "vkCreateXcbSurfaceKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateXcbSurfaceKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_XCB_KHR 
        
            if (strcmp(arg1, "vkGetPhysicalDeviceXcbPresentationSupportKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceXcbPresentationSupportKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
    
        
            if (strcmp(arg1, "vkCreateDebugReportCallbackEXT") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateDebugReportCallbackEXTType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkDestroyDebugReportCallbackEXT") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkDestroyDebugReportCallbackEXTType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkDebugReportMessageEXT") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkDebugReportMessageEXTType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkDebugMarkerSetObjectNameEXT") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkDebugMarkerSetObjectNameEXTType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkDebugMarkerSetObjectTagEXT") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkDebugMarkerSetObjectTagEXTType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkCmdDebugMarkerBeginEXT") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCmdDebugMarkerBeginEXTType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkCmdDebugMarkerEndEXT") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCmdDebugMarkerEndEXTType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkCmdDebugMarkerInsertEXT") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCmdDebugMarkerInsertEXTType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceExternalImageFormatPropertiesNVType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
            if (strcmp(arg1, "vkGetMemoryWin32HandleNV") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetMemoryWin32HandleNVType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
    
        
            if (strcmp(arg1, "vkCmdDrawIndirectCountAMD") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCmdDrawIndirectCountAMDType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkCmdDrawIndexedIndirectCountAMD") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCmdDrawIndexedIndirectCountAMDType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    

    if (pyreturn == NULL) {
        char error[100];
        sprintf(error, "Can't find python object for function %s", arg1);
        PyErr_SetString(PyExc_ImportError, error);
        return NULL;
    }

    Py_DECREF(tmp);
    Py_INCREF(pyreturn);
    return pyreturn;
}


static PyObject* PyvkGetDeviceProcAddr(PyObject *self, PyObject *args, PyObject *kwds) {
    PyObject* instance = NULL;
    PyObject* pName = NULL;
    static char *kwlist[] = {"device", "pName", NULL};

    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &instance, &pName))
          return NULL;

    VkDevice* arg0 = PyCapsule_GetPointer(instance, "VkDevice");
    if(arg0 == NULL) return NULL;

    PyObject* tmp = PyUnicode_AsASCIIString(pName);
    if(tmp == NULL) return NULL;

    char* arg1 = PyBytes_AsString(tmp);
    if(arg1 == NULL) return NULL;

    PFN_vkVoidFunction fun = vkGetDeviceProcAddr(*arg0, arg1);
    if (fun == NULL) {
          PyErr_SetString(PyExc_ImportError, "Can't get address of extension function");
          return NULL;
    }
    PyObject* pointer = PyCapsule_New(fun, NULL, NULL);
    if (pointer == NULL) return NULL;

    PyObject* call_args = Py_BuildValue("(O)", pointer);
    if (call_args == NULL) return NULL;

    PyObject* pyreturn = NULL;

    
        
     #ifdef VK_USE_PLATFORM_ANDROID_KHR 
        
            if (strcmp(arg1, "vkCreateAndroidSurfaceKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateAndroidSurfaceKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
    
        
            if (strcmp(arg1, "vkGetPhysicalDeviceDisplayPropertiesKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceDisplayPropertiesKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceDisplayPlanePropertiesKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetDisplayPlaneSupportedDisplaysKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetDisplayPlaneSupportedDisplaysKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetDisplayModePropertiesKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetDisplayModePropertiesKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkCreateDisplayModeKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateDisplayModeKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetDisplayPlaneCapabilitiesKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetDisplayPlaneCapabilitiesKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkCreateDisplayPlaneSurfaceKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateDisplayPlaneSurfaceKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkCreateSharedSwapchainsKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateSharedSwapchainsKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
     #ifdef VK_USE_PLATFORM_MIR_KHR 
        
            if (strcmp(arg1, "vkCreateMirSurfaceKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateMirSurfaceKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_MIR_KHR 
        
            if (strcmp(arg1, "vkGetPhysicalDeviceMirPresentationSupportKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceMirPresentationSupportKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
    
        
            if (strcmp(arg1, "vkDestroySurfaceKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkDestroySurfaceKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetPhysicalDeviceSurfaceSupportKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceSurfaceSupportKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceSurfaceCapabilitiesKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetPhysicalDeviceSurfaceFormatsKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceSurfaceFormatsKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetPhysicalDeviceSurfacePresentModesKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceSurfacePresentModesKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkCreateSwapchainKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateSwapchainKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkDestroySwapchainKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkDestroySwapchainKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetSwapchainImagesKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetSwapchainImagesKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkAcquireNextImageKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkAcquireNextImageKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkQueuePresentKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkQueuePresentKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
     #ifdef VK_USE_PLATFORM_WAYLAND_KHR 
        
            if (strcmp(arg1, "vkCreateWaylandSurfaceKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateWaylandSurfaceKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_WAYLAND_KHR 
        
            if (strcmp(arg1, "vkGetPhysicalDeviceWaylandPresentationSupportKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceWaylandPresentationSupportKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
            if (strcmp(arg1, "vkCreateWin32SurfaceKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateWin32SurfaceKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
            if (strcmp(arg1, "vkGetPhysicalDeviceWin32PresentationSupportKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceWin32PresentationSupportKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_XLIB_KHR 
        
            if (strcmp(arg1, "vkCreateXlibSurfaceKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateXlibSurfaceKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_XLIB_KHR 
        
            if (strcmp(arg1, "vkGetPhysicalDeviceXlibPresentationSupportKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceXlibPresentationSupportKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_XCB_KHR 
        
            if (strcmp(arg1, "vkCreateXcbSurfaceKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateXcbSurfaceKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
     #ifdef VK_USE_PLATFORM_XCB_KHR 
        
            if (strcmp(arg1, "vkGetPhysicalDeviceXcbPresentationSupportKHR") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceXcbPresentationSupportKHRType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
    
        
            if (strcmp(arg1, "vkCreateDebugReportCallbackEXT") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCreateDebugReportCallbackEXTType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkDestroyDebugReportCallbackEXT") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkDestroyDebugReportCallbackEXTType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkDebugReportMessageEXT") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkDebugReportMessageEXTType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkDebugMarkerSetObjectNameEXT") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkDebugMarkerSetObjectNameEXTType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkDebugMarkerSetObjectTagEXT") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkDebugMarkerSetObjectTagEXTType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkCmdDebugMarkerBeginEXT") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCmdDebugMarkerBeginEXTType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkCmdDebugMarkerEndEXT") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCmdDebugMarkerEndEXTType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkCmdDebugMarkerInsertEXT") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCmdDebugMarkerInsertEXTType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceExternalImageFormatPropertiesNVType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
            if (strcmp(arg1, "vkGetMemoryWin32HandleNV") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkGetMemoryWin32HandleNVType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
     #endif 

    
        
    
        
            if (strcmp(arg1, "vkCmdDrawIndirectCountAMD") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCmdDrawIndirectCountAMDType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    
        
    
        
            if (strcmp(arg1, "vkCmdDrawIndexedIndirectCountAMD") == 0) {
                pyreturn = PyObject_Call((PyObject *)&PyvkCmdDrawIndexedIndirectCountAMDType, call_args, NULL);
                if (pyreturn == NULL)
                    return NULL;
            }
        
    

    

    if (pyreturn == NULL) {
        char error[100];
        sprintf(error, "Can't find python object for function %s", arg1);
        PyErr_SetString(PyExc_ImportError, error);
        return NULL;
    }

    Py_DECREF(tmp);
    Py_INCREF(pyreturn);
    return pyreturn;
}



// ---------------
// REGISTER VULKAN METHOD
// ---------------
static PyMethodDef VulkanMethods[] = {
    
        
    
        
            {"vkCreateInstance", (PyCFunction)PyvkCreateInstance, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroyInstance", (PyCFunction)PyvkDestroyInstance, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkEnumeratePhysicalDevices", (PyCFunction)PyvkEnumeratePhysicalDevices, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkGetPhysicalDeviceProperties", (PyCFunction)PyvkGetPhysicalDeviceProperties, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkGetPhysicalDeviceQueueFamilyProperties", (PyCFunction)PyvkGetPhysicalDeviceQueueFamilyProperties, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkGetPhysicalDeviceMemoryProperties", (PyCFunction)PyvkGetPhysicalDeviceMemoryProperties, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkGetPhysicalDeviceFeatures", (PyCFunction)PyvkGetPhysicalDeviceFeatures, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkGetPhysicalDeviceFormatProperties", (PyCFunction)PyvkGetPhysicalDeviceFormatProperties, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkGetPhysicalDeviceImageFormatProperties", (PyCFunction)PyvkGetPhysicalDeviceImageFormatProperties, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreateDevice", (PyCFunction)PyvkCreateDevice, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroyDevice", (PyCFunction)PyvkDestroyDevice, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkEnumerateInstanceLayerProperties", (PyCFunction)PyvkEnumerateInstanceLayerProperties, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkEnumerateInstanceExtensionProperties", (PyCFunction)PyvkEnumerateInstanceExtensionProperties, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkEnumerateDeviceLayerProperties", (PyCFunction)PyvkEnumerateDeviceLayerProperties, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkEnumerateDeviceExtensionProperties", (PyCFunction)PyvkEnumerateDeviceExtensionProperties, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkGetDeviceQueue", (PyCFunction)PyvkGetDeviceQueue, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkQueueSubmit", (PyCFunction)PyvkQueueSubmit, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkQueueWaitIdle", (PyCFunction)PyvkQueueWaitIdle, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDeviceWaitIdle", (PyCFunction)PyvkDeviceWaitIdle, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkAllocateMemory", (PyCFunction)PyvkAllocateMemory, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkFreeMemory", (PyCFunction)PyvkFreeMemory, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkUnmapMemory", (PyCFunction)PyvkUnmapMemory, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkFlushMappedMemoryRanges", (PyCFunction)PyvkFlushMappedMemoryRanges, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkInvalidateMappedMemoryRanges", (PyCFunction)PyvkInvalidateMappedMemoryRanges, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkGetDeviceMemoryCommitment", (PyCFunction)PyvkGetDeviceMemoryCommitment, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkGetBufferMemoryRequirements", (PyCFunction)PyvkGetBufferMemoryRequirements, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkBindBufferMemory", (PyCFunction)PyvkBindBufferMemory, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkGetImageMemoryRequirements", (PyCFunction)PyvkGetImageMemoryRequirements, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkBindImageMemory", (PyCFunction)PyvkBindImageMemory, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkGetImageSparseMemoryRequirements", (PyCFunction)PyvkGetImageSparseMemoryRequirements, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkGetPhysicalDeviceSparseImageFormatProperties", (PyCFunction)PyvkGetPhysicalDeviceSparseImageFormatProperties, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkQueueBindSparse", (PyCFunction)PyvkQueueBindSparse, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreateFence", (PyCFunction)PyvkCreateFence, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroyFence", (PyCFunction)PyvkDestroyFence, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkResetFences", (PyCFunction)PyvkResetFences, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkGetFenceStatus", (PyCFunction)PyvkGetFenceStatus, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkWaitForFences", (PyCFunction)PyvkWaitForFences, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreateSemaphore", (PyCFunction)PyvkCreateSemaphore, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroySemaphore", (PyCFunction)PyvkDestroySemaphore, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreateEvent", (PyCFunction)PyvkCreateEvent, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroyEvent", (PyCFunction)PyvkDestroyEvent, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkGetEventStatus", (PyCFunction)PyvkGetEventStatus, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkSetEvent", (PyCFunction)PyvkSetEvent, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkResetEvent", (PyCFunction)PyvkResetEvent, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreateQueryPool", (PyCFunction)PyvkCreateQueryPool, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroyQueryPool", (PyCFunction)PyvkDestroyQueryPool, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkGetQueryPoolResults", (PyCFunction)PyvkGetQueryPoolResults, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreateBuffer", (PyCFunction)PyvkCreateBuffer, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroyBuffer", (PyCFunction)PyvkDestroyBuffer, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreateBufferView", (PyCFunction)PyvkCreateBufferView, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroyBufferView", (PyCFunction)PyvkDestroyBufferView, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreateImage", (PyCFunction)PyvkCreateImage, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroyImage", (PyCFunction)PyvkDestroyImage, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkGetImageSubresourceLayout", (PyCFunction)PyvkGetImageSubresourceLayout, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreateImageView", (PyCFunction)PyvkCreateImageView, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroyImageView", (PyCFunction)PyvkDestroyImageView, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreateShaderModule", (PyCFunction)PyvkCreateShaderModule, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroyShaderModule", (PyCFunction)PyvkDestroyShaderModule, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreatePipelineCache", (PyCFunction)PyvkCreatePipelineCache, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroyPipelineCache", (PyCFunction)PyvkDestroyPipelineCache, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkMergePipelineCaches", (PyCFunction)PyvkMergePipelineCaches, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreateGraphicsPipelines", (PyCFunction)PyvkCreateGraphicsPipelines, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreateComputePipelines", (PyCFunction)PyvkCreateComputePipelines, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroyPipeline", (PyCFunction)PyvkDestroyPipeline, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreatePipelineLayout", (PyCFunction)PyvkCreatePipelineLayout, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroyPipelineLayout", (PyCFunction)PyvkDestroyPipelineLayout, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreateSampler", (PyCFunction)PyvkCreateSampler, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroySampler", (PyCFunction)PyvkDestroySampler, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreateDescriptorSetLayout", (PyCFunction)PyvkCreateDescriptorSetLayout, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroyDescriptorSetLayout", (PyCFunction)PyvkDestroyDescriptorSetLayout, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreateDescriptorPool", (PyCFunction)PyvkCreateDescriptorPool, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroyDescriptorPool", (PyCFunction)PyvkDestroyDescriptorPool, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkResetDescriptorPool", (PyCFunction)PyvkResetDescriptorPool, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkAllocateDescriptorSets", (PyCFunction)PyvkAllocateDescriptorSets, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkFreeDescriptorSets", (PyCFunction)PyvkFreeDescriptorSets, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkUpdateDescriptorSets", (PyCFunction)PyvkUpdateDescriptorSets, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreateFramebuffer", (PyCFunction)PyvkCreateFramebuffer, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroyFramebuffer", (PyCFunction)PyvkDestroyFramebuffer, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreateRenderPass", (PyCFunction)PyvkCreateRenderPass, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroyRenderPass", (PyCFunction)PyvkDestroyRenderPass, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkGetRenderAreaGranularity", (PyCFunction)PyvkGetRenderAreaGranularity, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCreateCommandPool", (PyCFunction)PyvkCreateCommandPool, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkDestroyCommandPool", (PyCFunction)PyvkDestroyCommandPool, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkResetCommandPool", (PyCFunction)PyvkResetCommandPool, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkAllocateCommandBuffers", (PyCFunction)PyvkAllocateCommandBuffers, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkFreeCommandBuffers", (PyCFunction)PyvkFreeCommandBuffers, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkBeginCommandBuffer", (PyCFunction)PyvkBeginCommandBuffer, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkEndCommandBuffer", (PyCFunction)PyvkEndCommandBuffer, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkResetCommandBuffer", (PyCFunction)PyvkResetCommandBuffer, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdBindPipeline", (PyCFunction)PyvkCmdBindPipeline, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdSetViewport", (PyCFunction)PyvkCmdSetViewport, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdSetScissor", (PyCFunction)PyvkCmdSetScissor, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdSetLineWidth", (PyCFunction)PyvkCmdSetLineWidth, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdSetDepthBias", (PyCFunction)PyvkCmdSetDepthBias, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdSetBlendConstants", (PyCFunction)PyvkCmdSetBlendConstants, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdSetDepthBounds", (PyCFunction)PyvkCmdSetDepthBounds, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdSetStencilCompareMask", (PyCFunction)PyvkCmdSetStencilCompareMask, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdSetStencilWriteMask", (PyCFunction)PyvkCmdSetStencilWriteMask, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdSetStencilReference", (PyCFunction)PyvkCmdSetStencilReference, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdBindDescriptorSets", (PyCFunction)PyvkCmdBindDescriptorSets, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdBindIndexBuffer", (PyCFunction)PyvkCmdBindIndexBuffer, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdBindVertexBuffers", (PyCFunction)PyvkCmdBindVertexBuffers, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdDraw", (PyCFunction)PyvkCmdDraw, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdDrawIndexed", (PyCFunction)PyvkCmdDrawIndexed, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdDrawIndirect", (PyCFunction)PyvkCmdDrawIndirect, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdDrawIndexedIndirect", (PyCFunction)PyvkCmdDrawIndexedIndirect, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdDispatch", (PyCFunction)PyvkCmdDispatch, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdDispatchIndirect", (PyCFunction)PyvkCmdDispatchIndirect, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdCopyBuffer", (PyCFunction)PyvkCmdCopyBuffer, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdCopyImage", (PyCFunction)PyvkCmdCopyImage, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdBlitImage", (PyCFunction)PyvkCmdBlitImage, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdCopyBufferToImage", (PyCFunction)PyvkCmdCopyBufferToImage, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdCopyImageToBuffer", (PyCFunction)PyvkCmdCopyImageToBuffer, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdUpdateBuffer", (PyCFunction)PyvkCmdUpdateBuffer, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdFillBuffer", (PyCFunction)PyvkCmdFillBuffer, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdClearColorImage", (PyCFunction)PyvkCmdClearColorImage, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdClearDepthStencilImage", (PyCFunction)PyvkCmdClearDepthStencilImage, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdClearAttachments", (PyCFunction)PyvkCmdClearAttachments, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdResolveImage", (PyCFunction)PyvkCmdResolveImage, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdSetEvent", (PyCFunction)PyvkCmdSetEvent, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdResetEvent", (PyCFunction)PyvkCmdResetEvent, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdWaitEvents", (PyCFunction)PyvkCmdWaitEvents, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdPipelineBarrier", (PyCFunction)PyvkCmdPipelineBarrier, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdBeginQuery", (PyCFunction)PyvkCmdBeginQuery, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdEndQuery", (PyCFunction)PyvkCmdEndQuery, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdResetQueryPool", (PyCFunction)PyvkCmdResetQueryPool, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdWriteTimestamp", (PyCFunction)PyvkCmdWriteTimestamp, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdCopyQueryPoolResults", (PyCFunction)PyvkCmdCopyQueryPoolResults, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdPushConstants", (PyCFunction)PyvkCmdPushConstants, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdBeginRenderPass", (PyCFunction)PyvkCmdBeginRenderPass, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdNextSubpass", (PyCFunction)PyvkCmdNextSubpass, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdEndRenderPass", (PyCFunction)PyvkCmdEndRenderPass, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    
        
    
        
            {"vkCmdExecuteCommands", (PyCFunction)PyvkCmdExecuteCommands, METH_VARARGS | METH_KEYWORDS, ""},
        
    

    

    
        {"vkGetInstanceProcAddr", (PyCFunction)PyvkGetInstanceProcAddr, METH_VARARGS, ""},
    
        {"vkGetDeviceProcAddr", (PyCFunction)PyvkGetDeviceProcAddr, METH_VARARGS, ""},
    
        {"vkMapMemory", (PyCFunction)PyvkMapMemory, METH_VARARGS, ""},
    
        {"vkGetPipelineCacheData", (PyCFunction)PyvkGetPipelineCacheData, METH_VARARGS, ""},
    

    
        {"VK_MAKE_VERSION", (PyCFunction)PyVK_MAKE_VERSION, METH_VARARGS, ""},
    
        {"VK_VERSION_MAJOR", (PyCFunction)PyVK_VERSION_MAJOR, METH_VARARGS, ""},
    
        {"VK_VERSION_MINOR", (PyCFunction)PyVK_VERSION_MINOR, METH_VARARGS, ""},
    
        {"VK_VERSION_PATCH", (PyCFunction)PyVK_VERSION_PATCH, METH_VARARGS, ""},
    

    {NULL, NULL, 0, NULL}
};


// ---------------
// CREATE PYTHON MODULE
// ---------------
static struct PyModuleDef vulkanmodule = {
    PyModuleDef_HEAD_INIT, "vulkan", "Vulkan Module", -1, VulkanMethods
};


// ---------------
// PYTHON ENTRY POINT
// ---------------
PyMODINIT_FUNC PyInit_vulkan(void) {
    PyObject* module = PyModule_Create(&vulkanmodule);
    if (module == NULL)
        return NULL;

    if (!init_import_sdk())
        return NULL;


    // ----------
    // CONSTANTS
    // ----------
    
        
            PyModule_AddIntConstant(module, "VK_MAX_PHYSICAL_DEVICE_NAME_SIZE", 256);
        
    
        
            PyModule_AddIntConstant(module, "VK_UUID_SIZE", 16);
        
    
        
            PyModule_AddIntConstant(module, "VK_MAX_EXTENSION_NAME_SIZE", 256);
        
    
        
            PyModule_AddIntConstant(module, "VK_MAX_DESCRIPTION_SIZE", 256);
        
    
        
            PyModule_AddIntConstant(module, "VK_MAX_MEMORY_TYPES", 32);
        
    
        
            PyModule_AddIntConstant(module, "VK_MAX_MEMORY_HEAPS", 16);
        
    
        
            PyModule_AddIntConstant(module, "VK_LOD_CLAMP_NONE", 1000.0f);
        
    
        
            PyModule_AddIntConstant(module, "VK_REMAINING_MIP_LEVELS", (~0U));
        
    
        
            PyModule_AddIntConstant(module, "VK_REMAINING_ARRAY_LAYERS", (~0U));
        
    
        
            PyModule_AddIntConstant(module, "VK_WHOLE_SIZE", (~0ULL));
        
    
        
            PyModule_AddIntConstant(module, "VK_ATTACHMENT_UNUSED", (~0U));
        
    
        
            PyModule_AddIntConstant(module, "VK_TRUE", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_FALSE", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUEUE_FAMILY_IGNORED", (~0U));
        
    
        
            PyModule_AddIntConstant(module, "VK_SUBPASS_EXTERNAL", (~0U));
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_UNDEFINED", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_GENERAL", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL", 5);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL", 6);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL", 7);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_PREINITIALIZED", 8);
        
    
        
            PyModule_AddIntConstant(module, "VK_ATTACHMENT_LOAD_OP_LOAD", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_ATTACHMENT_LOAD_OP_CLEAR", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_ATTACHMENT_LOAD_OP_DONT_CARE", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_ATTACHMENT_STORE_OP_STORE", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_ATTACHMENT_STORE_OP_DONT_CARE", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_TYPE_1D", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_TYPE_2D", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_TYPE_3D", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_TILING_OPTIMAL", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_TILING_LINEAR", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_1D", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_2D", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_3D", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_CUBE", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_1D_ARRAY", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_2D_ARRAY", 5);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", 6);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_LEVEL_PRIMARY", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_LEVEL_SECONDARY", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_IDENTITY", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_ZERO", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_ONE", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_R", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_G", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_B", 5);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_A", 6);
        
    
        
            PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_SAMPLER", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER", 5);
        
    
        
            PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER", 6);
        
    
        
            PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER", 7);
        
    
        
            PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC", 8);
        
    
        
            PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC", 9);
        
    
        
            PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT", 10);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUERY_TYPE_OCCLUSION", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUERY_TYPE_PIPELINE_STATISTICS", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUERY_TYPE_TIMESTAMP", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_BORDER_COLOR_INT_OPAQUE_BLACK", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_BORDER_COLOR_INT_OPAQUE_WHITE", 5);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_BIND_POINT_GRAPHICS", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_BIND_POINT_COMPUTE", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_CACHE_HEADER_VERSION_ONE", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_POINT_LIST", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_LINE_LIST", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN", 5);
        
    
        
            PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY", 6);
        
    
        
            PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY", 7);
        
    
        
            PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY", 8);
        
    
        
            PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY", 9);
        
    
        
            PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST", 10);
        
    
        
            PyModule_AddIntConstant(module, "VK_SHARING_MODE_EXCLUSIVE", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_SHARING_MODE_CONCURRENT", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_INDEX_TYPE_UINT16", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_INDEX_TYPE_UINT32", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_FILTER_NEAREST", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_FILTER_LINEAR", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_SAMPLER_MIPMAP_MODE_NEAREST", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_SAMPLER_MIPMAP_MODE_LINEAR", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_SAMPLER_ADDRESS_MODE_REPEAT", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMPARE_OP_NEVER", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMPARE_OP_LESS", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMPARE_OP_EQUAL", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMPARE_OP_LESS_OR_EQUAL", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMPARE_OP_GREATER", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMPARE_OP_NOT_EQUAL", 5);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMPARE_OP_GREATER_OR_EQUAL", 6);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMPARE_OP_ALWAYS", 7);
        
    
        
            PyModule_AddIntConstant(module, "VK_POLYGON_MODE_FILL", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_POLYGON_MODE_LINE", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_POLYGON_MODE_POINT", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_CULL_MODE_NONE", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_CULL_MODE_FRONT_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_CULL_MODE_BACK_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_CULL_MODE_FRONT_AND_BACK", 0x00000003);
        
    
        
            PyModule_AddIntConstant(module, "VK_FRONT_FACE_COUNTER_CLOCKWISE", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_FRONT_FACE_CLOCKWISE", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ZERO", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC_COLOR", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_DST_COLOR", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR", 5);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC_ALPHA", 6);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA", 7);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_DST_ALPHA", 8);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA", 9);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_CONSTANT_COLOR", 10);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR", 11);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_CONSTANT_ALPHA", 12);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA", 13);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE", 14);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC1_COLOR", 15);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR", 16);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC1_ALPHA", 17);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA", 18);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_OP_ADD", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_OP_SUBTRACT", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_OP_REVERSE_SUBTRACT", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_OP_MIN", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_BLEND_OP_MAX", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_STENCIL_OP_KEEP", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_STENCIL_OP_ZERO", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_STENCIL_OP_REPLACE", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_STENCIL_OP_INCREMENT_AND_CLAMP", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_STENCIL_OP_DECREMENT_AND_CLAMP", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_STENCIL_OP_INVERT", 5);
        
    
        
            PyModule_AddIntConstant(module, "VK_STENCIL_OP_INCREMENT_AND_WRAP", 6);
        
    
        
            PyModule_AddIntConstant(module, "VK_STENCIL_OP_DECREMENT_AND_WRAP", 7);
        
    
        
            PyModule_AddIntConstant(module, "VK_LOGIC_OP_CLEAR", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_LOGIC_OP_AND", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_LOGIC_OP_AND_REVERSE", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_LOGIC_OP_COPY", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_LOGIC_OP_AND_INVERTED", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_LOGIC_OP_NO_OP", 5);
        
    
        
            PyModule_AddIntConstant(module, "VK_LOGIC_OP_XOR", 6);
        
    
        
            PyModule_AddIntConstant(module, "VK_LOGIC_OP_OR", 7);
        
    
        
            PyModule_AddIntConstant(module, "VK_LOGIC_OP_NOR", 8);
        
    
        
            PyModule_AddIntConstant(module, "VK_LOGIC_OP_EQUIVALENT", 9);
        
    
        
            PyModule_AddIntConstant(module, "VK_LOGIC_OP_INVERT", 10);
        
    
        
            PyModule_AddIntConstant(module, "VK_LOGIC_OP_OR_REVERSE", 11);
        
    
        
            PyModule_AddIntConstant(module, "VK_LOGIC_OP_COPY_INVERTED", 12);
        
    
        
            PyModule_AddIntConstant(module, "VK_LOGIC_OP_OR_INVERTED", 13);
        
    
        
            PyModule_AddIntConstant(module, "VK_LOGIC_OP_NAND", 14);
        
    
        
            PyModule_AddIntConstant(module, "VK_LOGIC_OP_SET", 15);
        
    
        
            PyModule_AddIntConstant(module, "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_CACHE", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_OTHER", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_CPU", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_VERTEX_INPUT_RATE_VERTEX", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_VERTEX_INPUT_RATE_INSTANCE", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_UNDEFINED", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R4G4_UNORM_PACK8", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R4G4B4A4_UNORM_PACK16", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_B4G4R4A4_UNORM_PACK16", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R5G6B5_UNORM_PACK16", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_B5G6R5_UNORM_PACK16", 5);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R5G5B5A1_UNORM_PACK16", 6);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_B5G5R5A1_UNORM_PACK16", 7);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A1R5G5B5_UNORM_PACK16", 8);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8_UNORM", 9);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8_SNORM", 10);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8_USCALED", 11);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8_SSCALED", 12);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8_UINT", 13);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8_SINT", 14);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8_SRGB", 15);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_UNORM", 16);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_SNORM", 17);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_USCALED", 18);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_SSCALED", 19);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_UINT", 20);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_SINT", 21);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_SRGB", 22);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_UNORM", 23);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_SNORM", 24);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_USCALED", 25);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_SSCALED", 26);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_UINT", 27);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_SINT", 28);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_SRGB", 29);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_UNORM", 30);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_SNORM", 31);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_USCALED", 32);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_SSCALED", 33);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_UINT", 34);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_SINT", 35);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_SRGB", 36);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_UNORM", 37);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_SNORM", 38);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_USCALED", 39);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_SSCALED", 40);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_UINT", 41);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_SINT", 42);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_SRGB", 43);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_UNORM", 44);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_SNORM", 45);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_USCALED", 46);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_SSCALED", 47);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_UINT", 48);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_SINT", 49);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_SRGB", 50);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_UNORM_PACK32", 51);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_SNORM_PACK32", 52);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_USCALED_PACK32", 53);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_SSCALED_PACK32", 54);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_UINT_PACK32", 55);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_SINT_PACK32", 56);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_SRGB_PACK32", 57);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_UNORM_PACK32", 58);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_SNORM_PACK32", 59);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_USCALED_PACK32", 60);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_SSCALED_PACK32", 61);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_UINT_PACK32", 62);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_SINT_PACK32", 63);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_UNORM_PACK32", 64);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_SNORM_PACK32", 65);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_USCALED_PACK32", 66);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_SSCALED_PACK32", 67);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_UINT_PACK32", 68);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_SINT_PACK32", 69);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16_UNORM", 70);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16_SNORM", 71);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16_USCALED", 72);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16_SSCALED", 73);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16_UINT", 74);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16_SINT", 75);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16_SFLOAT", 76);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_UNORM", 77);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_SNORM", 78);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_USCALED", 79);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_SSCALED", 80);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_UINT", 81);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_SINT", 82);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_SFLOAT", 83);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_UNORM", 84);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_SNORM", 85);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_USCALED", 86);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_SSCALED", 87);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_UINT", 88);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_SINT", 89);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_SFLOAT", 90);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_UNORM", 91);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_SNORM", 92);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_USCALED", 93);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_SSCALED", 94);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_UINT", 95);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_SINT", 96);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_SFLOAT", 97);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R32_UINT", 98);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R32_SINT", 99);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R32_SFLOAT", 100);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R32G32_UINT", 101);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R32G32_SINT", 102);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R32G32_SFLOAT", 103);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32_UINT", 104);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32_SINT", 105);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32_SFLOAT", 106);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32A32_UINT", 107);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32A32_SINT", 108);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32A32_SFLOAT", 109);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R64_UINT", 110);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R64_SINT", 111);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R64_SFLOAT", 112);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R64G64_UINT", 113);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R64G64_SINT", 114);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R64G64_SFLOAT", 115);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64_UINT", 116);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64_SINT", 117);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64_SFLOAT", 118);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64A64_UINT", 119);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64A64_SINT", 120);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64A64_SFLOAT", 121);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_B10G11R11_UFLOAT_PACK32", 122);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32", 123);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_D16_UNORM", 124);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_X8_D24_UNORM_PACK32", 125);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_D32_SFLOAT", 126);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_S8_UINT", 127);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_D16_UNORM_S8_UINT", 128);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_D24_UNORM_S8_UINT", 129);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_D32_SFLOAT_S8_UINT", 130);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_BC1_RGB_UNORM_BLOCK", 131);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_BC1_RGB_SRGB_BLOCK", 132);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_BC1_RGBA_UNORM_BLOCK", 133);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_BC1_RGBA_SRGB_BLOCK", 134);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_BC2_UNORM_BLOCK", 135);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_BC2_SRGB_BLOCK", 136);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_BC3_UNORM_BLOCK", 137);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_BC3_SRGB_BLOCK", 138);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_BC4_UNORM_BLOCK", 139);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_BC4_SNORM_BLOCK", 140);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_BC5_UNORM_BLOCK", 141);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_BC5_SNORM_BLOCK", 142);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_BC6H_UFLOAT_BLOCK", 143);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_BC6H_SFLOAT_BLOCK", 144);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_BC7_UNORM_BLOCK", 145);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_BC7_SRGB_BLOCK", 146);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK", 147);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK", 148);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK", 149);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK", 150);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK", 151);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK", 152);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_EAC_R11_UNORM_BLOCK", 153);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_EAC_R11_SNORM_BLOCK", 154);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_EAC_R11G11_UNORM_BLOCK", 155);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_EAC_R11G11_SNORM_BLOCK", 156);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_4x4_UNORM_BLOCK", 157);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_4x4_SRGB_BLOCK", 158);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_5x4_UNORM_BLOCK", 159);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_5x4_SRGB_BLOCK", 160);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_5x5_UNORM_BLOCK", 161);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_5x5_SRGB_BLOCK", 162);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_6x5_UNORM_BLOCK", 163);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_6x5_SRGB_BLOCK", 164);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_6x6_UNORM_BLOCK", 165);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_6x6_SRGB_BLOCK", 166);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x5_UNORM_BLOCK", 167);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x5_SRGB_BLOCK", 168);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x6_UNORM_BLOCK", 169);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x6_SRGB_BLOCK", 170);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x8_UNORM_BLOCK", 171);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x8_SRGB_BLOCK", 172);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x5_UNORM_BLOCK", 173);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x5_SRGB_BLOCK", 174);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x6_UNORM_BLOCK", 175);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x6_SRGB_BLOCK", 176);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x8_UNORM_BLOCK", 177);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x8_SRGB_BLOCK", 178);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x10_UNORM_BLOCK", 179);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x10_SRGB_BLOCK", 180);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_12x10_UNORM_BLOCK", 181);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_12x10_SRGB_BLOCK", 182);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_12x12_UNORM_BLOCK", 183);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_12x12_SRGB_BLOCK", 184);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_APPLICATION_INFO", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_SUBMIT_INFO", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO", 5);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE", 6);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO", 7);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO", 8);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO", 9);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO", 10);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO", 11);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO", 12);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO", 13);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO", 14);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO", 15);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO", 16);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO", 17);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO", 18);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO", 19);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO", 20);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO", 21);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO", 22);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO", 23);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO", 24);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO", 25);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO", 26);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO", 27);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO", 28);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO", 29);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO", 30);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO", 31);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO", 32);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO", 33);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO", 34);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET", 35);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET", 36);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO", 37);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO", 38);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO", 39);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO", 40);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO", 41);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO", 42);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO", 43);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER", 44);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER", 45);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_MEMORY_BARRIER", 46);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO", 47);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO", 48);
        
    
        
            PyModule_AddIntConstant(module, "VK_SUBPASS_CONTENTS_INLINE", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_SUCCESS", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_NOT_READY", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_TIMEOUT", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_EVENT_SET", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_EVENT_RESET", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_INCOMPLETE", 5);
        
    
        
            PyModule_AddIntConstant(module, "VK_ERROR_OUT_OF_HOST_MEMORY", -1);
        
    
        
            PyModule_AddIntConstant(module, "VK_ERROR_OUT_OF_DEVICE_MEMORY", -2);
        
    
        
            PyModule_AddIntConstant(module, "VK_ERROR_INITIALIZATION_FAILED", -3);
        
    
        
            PyModule_AddIntConstant(module, "VK_ERROR_DEVICE_LOST", -4);
        
    
        
            PyModule_AddIntConstant(module, "VK_ERROR_MEMORY_MAP_FAILED", -5);
        
    
        
            PyModule_AddIntConstant(module, "VK_ERROR_LAYER_NOT_PRESENT", -6);
        
    
        
            PyModule_AddIntConstant(module, "VK_ERROR_EXTENSION_NOT_PRESENT", -7);
        
    
        
            PyModule_AddIntConstant(module, "VK_ERROR_FEATURE_NOT_PRESENT", -8);
        
    
        
            PyModule_AddIntConstant(module, "VK_ERROR_INCOMPATIBLE_DRIVER", -9);
        
    
        
            PyModule_AddIntConstant(module, "VK_ERROR_TOO_MANY_OBJECTS", -10);
        
    
        
            PyModule_AddIntConstant(module, "VK_ERROR_FORMAT_NOT_SUPPORTED", -11);
        
    
        
            PyModule_AddIntConstant(module, "VK_ERROR_FRAGMENTED_POOL", -12);
        
    
        
            PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_VIEWPORT", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_SCISSOR", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_LINE_WIDTH", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_DEPTH_BIAS", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_BLEND_CONSTANTS", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_DEPTH_BOUNDS", 5);
        
    
        
            PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK", 6);
        
    
        
            PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK", 7);
        
    
        
            PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_STENCIL_REFERENCE", 8);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUEUE_GRAPHICS_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUEUE_COMPUTE_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUEUE_TRANSFER_BIT", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUEUE_SPARSE_BINDING_BIT", 0x00000008);
        
    
        
            PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_HOST_CACHED_BIT", 0x00000008);
        
    
        
            PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT", 0x00000010);
        
    
        
            PyModule_AddIntConstant(module, "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_ACCESS_INDIRECT_COMMAND_READ_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_ACCESS_INDEX_READ_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_ACCESS_UNIFORM_READ_BIT", 0x00000008);
        
    
        
            PyModule_AddIntConstant(module, "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT", 0x00000010);
        
    
        
            PyModule_AddIntConstant(module, "VK_ACCESS_SHADER_READ_BIT", 0x00000020);
        
    
        
            PyModule_AddIntConstant(module, "VK_ACCESS_SHADER_WRITE_BIT", 0x00000040);
        
    
        
            PyModule_AddIntConstant(module, "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT", 0x00000080);
        
    
        
            PyModule_AddIntConstant(module, "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT", 0x00000100);
        
    
        
            PyModule_AddIntConstant(module, "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT", 0x00000200);
        
    
        
            PyModule_AddIntConstant(module, "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT", 0x00000400);
        
    
        
            PyModule_AddIntConstant(module, "VK_ACCESS_TRANSFER_READ_BIT", 0x00000800);
        
    
        
            PyModule_AddIntConstant(module, "VK_ACCESS_TRANSFER_WRITE_BIT", 0x00001000);
        
    
        
            PyModule_AddIntConstant(module, "VK_ACCESS_HOST_READ_BIT", 0x00002000);
        
    
        
            PyModule_AddIntConstant(module, "VK_ACCESS_HOST_WRITE_BIT", 0x00004000);
        
    
        
            PyModule_AddIntConstant(module, "VK_ACCESS_MEMORY_READ_BIT", 0x00008000);
        
    
        
            PyModule_AddIntConstant(module, "VK_ACCESS_MEMORY_WRITE_BIT", 0x00010000);
        
    
        
            PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_TRANSFER_SRC_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_TRANSFER_DST_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT", 0x00000008);
        
    
        
            PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT", 0x00000010);
        
    
        
            PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT", 0x00000020);
        
    
        
            PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_INDEX_BUFFER_BIT", 0x00000040);
        
    
        
            PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT", 0x00000080);
        
    
        
            PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT", 0x00000100);
        
    
        
            PyModule_AddIntConstant(module, "VK_BUFFER_CREATE_SPARSE_BINDING_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_SHADER_STAGE_VERTEX_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_SHADER_STAGE_GEOMETRY_BIT", 0x00000008);
        
    
        
            PyModule_AddIntConstant(module, "VK_SHADER_STAGE_FRAGMENT_BIT", 0x00000010);
        
    
        
            PyModule_AddIntConstant(module, "VK_SHADER_STAGE_COMPUTE_BIT", 0x00000020);
        
    
        
            PyModule_AddIntConstant(module, "VK_SHADER_STAGE_ALL_GRAPHICS", 0x0000001F);
        
    
        
            PyModule_AddIntConstant(module, "VK_SHADER_STAGE_ALL", 0x7FFFFFFF);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_TRANSFER_SRC_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_TRANSFER_DST_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_SAMPLED_BIT", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_STORAGE_BIT", 0x00000008);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT", 0x00000010);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", 0x00000020);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT", 0x00000040);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT", 0x00000080);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_SPARSE_BINDING_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT", 0x00000008);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT", 0x00000010);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_CREATE_DERIVATIVE_BIT", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_COLOR_COMPONENT_R_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_COLOR_COMPONENT_G_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_COLOR_COMPONENT_B_BIT", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_COLOR_COMPONENT_A_BIT", 0x00000008);
        
    
        
            PyModule_AddIntConstant(module, "VK_FENCE_CREATE_SIGNALED_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT", 0x00000008);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT", 0x00000010);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT", 0x00000020);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT", 0x00000040);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT", 0x00000080);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", 0x00000100);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT", 0x00000200);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_BLIT_SRC_BIT", 0x00000400);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_BLIT_DST_BIT", 0x00000800);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", 0x00001000);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUERY_CONTROL_PRECISE_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUERY_RESULT_64_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUERY_RESULT_WAIT_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUERY_RESULT_PARTIAL_BIT", 0x00000008);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT", 0x00000008);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT", 0x00000010);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT", 0x00000020);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT", 0x00000040);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT", 0x00000080);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT", 0x00000100);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT", 0x00000200);
        
    
        
            PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT", 0x00000400);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_ASPECT_COLOR_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_ASPECT_DEPTH_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_ASPECT_STENCIL_BIT", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_ASPECT_METADATA_BIT", 0x00000008);
        
    
        
            PyModule_AddIntConstant(module, "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_SPARSE_MEMORY_BIND_METADATA_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT", 0x00000008);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT", 0x00000010);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT", 0x00000020);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", 0x00000040);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT", 0x00000080);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT", 0x00000100);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT", 0x00000200);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT", 0x00000400);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT", 0x00000800);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_TRANSFER_BIT", 0x00001000);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT", 0x00002000);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_HOST_BIT", 0x00004000);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT", 0x00008000);
        
    
        
            PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT", 0x00010000);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_1_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_2_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_4_BIT", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_8_BIT", 0x00000008);
        
    
        
            PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_16_BIT", 0x00000010);
        
    
        
            PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_32_BIT", 0x00000020);
        
    
        
            PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_64_BIT", 0x00000040);
        
    
        
            PyModule_AddIntConstant(module, "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_STENCIL_FACE_FRONT_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_STENCIL_FACE_BACK_BIT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_STENCIL_FRONT_AND_BACK", 0x00000003);
        
    
        
            PyModule_AddIntConstant(module, "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEPENDENCY_BY_REGION_BIT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_PRESENT_MODE_IMMEDIATE_KHR", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_PRESENT_MODE_MAILBOX_KHR", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_PRESENT_MODE_FIFO_KHR", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_PRESENT_MODE_FIFO_RELAXED_KHR", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR", 0x00000008);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR", 0x00000008);
        
    
        
            PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR", 0x00000008);
        
    
        
            PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR", 0x00000010);
        
    
        
            PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR", 0x00000020);
        
    
        
            PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR", 0x00000040);
        
    
        
            PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR", 0x00000080);
        
    
        
            PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR", 0x00000100);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_INFORMATION_BIT_EXT", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_WARNING_BIT_EXT", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_ERROR_BIT_EXT", 0x00000008);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_DEBUG_BIT_EXT", 0x00000010);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT", 2);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT", 3);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT", 5);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT", 6);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT", 7);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT", 8);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT", 9);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT", 10);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT", 11);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT", 12);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT", 13);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT", 14);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT", 15);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT", 16);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT", 17);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT", 18);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT", 19);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT", 20);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT", 21);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT", 22);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT", 23);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT", 24);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT", 25);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT", 26);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT", 27);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT", 28);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_ERROR_NONE_EXT", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_RASTERIZATION_ORDER_STRICT_AMD", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_RASTERIZATION_ORDER_RELAXED_AMD", 1);
        
    
        
            PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV", 0x00000008);
        
    
        
            PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV", 0x00000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV", 0x00000002);
        
    
        
            PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV", 0x00000004);
        
    
        
            PyModule_AddIntConstant(module, "VK_VALIDATION_CHECK_ALL_EXT", 0);
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_SURFACE_SPEC_VERSION", 25);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_ERROR_SURFACE_LOST_KHR", 1000000000);
        
    
        
            PyModule_AddIntConstant(module, "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR", 1000000001);
        
    
        
            PyModule_AddIntConstant(module, "VK_COLORSPACE_SRGB_NONLINEAR_KHR", VK_COLOR_SPACE_SRGB_NONLINEAR_KHR);
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_SWAPCHAIN_SPEC_VERSION", 68);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR", 1000001000);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR", 1000001001);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR", 1000001002);
        
    
        
            PyModule_AddIntConstant(module, "VK_SUBOPTIMAL_KHR", 1000001003);
        
    
        
            PyModule_AddIntConstant(module, "VK_ERROR_OUT_OF_DATE_KHR", 1000001004);
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_DISPLAY_SPEC_VERSION", 21);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR", 1000002000);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR", 1000002001);
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION", 9);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR", 1000003000);
        
    
        
            PyModule_AddIntConstant(module, "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR", 1000003001);
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_XLIB_SURFACE_SPEC_VERSION", 6);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR", 1000004000);
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_XCB_SURFACE_SPEC_VERSION", 6);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR", 1000005000);
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_WAYLAND_SURFACE_SPEC_VERSION", 5);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR", 1000006000);
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_MIR_SURFACE_SPEC_VERSION", 4);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR", 1000007000);
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_ANDROID_SURFACE_SPEC_VERSION", 6);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR", 1000008000);
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_WIN32_SURFACE_SPEC_VERSION", 5);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR", 1000009000);
        
    
        
            PyModule_AddIntConstant(module, "VK_ANDROID_NATIVE_BUFFER_SPEC_VERSION", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_ANDROID_NATIVE_BUFFER_NUMBER", 11);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_EXT_DEBUG_REPORT_SPEC_VERSION", 3);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT", 1000011000);
        
    
        
            PyModule_AddIntConstant(module, "VK_ERROR_VALIDATION_FAILED_EXT", 1000011001);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT", VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT);
        
    
        
            PyModule_AddIntConstant(module, "VK_NV_GLSL_SHADER_SPEC_VERSION", 1);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_ERROR_INVALID_SHADER_NV", 1000012000);
        
    
        
            PyModule_AddIntConstant(module, "VK_NV_EXTENSION_1_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_NV_EXTENSION_1_ERROR", 1000013000);
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION", 1);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE", 4);
        
    
        
            PyModule_AddIntConstant(module, "VK_IMG_FILTER_CUBIC_SPEC_VERSION", 1);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_FILTER_CUBIC_IMG", 1000015000);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG", 0x00002000);
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_EXTENSION_17_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_EXTENSION_18_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION", 1);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD", 1000018000);
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_EXTENSION_20_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION", 1);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION", 1);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_EXT_DEBUG_MARKER_SPEC_VERSION", 3);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT", 1000022000);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT", 1000022001);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT", 1000022002);
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_EXTENSION_24_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_EXTENSION_25_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_GCN_SHADER_SPEC_VERSION", 1);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION", 1);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV", 1000026000);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV", 1000026001);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV", 1000026002);
        
    
        
            PyModule_AddIntConstant(module, "VK_EXT_EXTENSION_28_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_NVX_EXTENSION_29_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_NVX_EXTENSION_30_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_NVX_EXTENSION_31_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_EXTENSION_32_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_EXTENSION_33_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION", 1);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_EXTENSION_35_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION", 1);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION", 1);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_SHADER_BALLOT_SPEC_VERSION", 1);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_EXTENSION_39_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_EXTENSION_40_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_EXTENSION_41_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_EXTENSION_42_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_EXTENSION_43_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_EXTENSION_44_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_EXTENSION_45_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_EXTENSION_46_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_AMD_EXTENSION_47_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_NVX_EXTENSION_48_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_GOOGLE_EXTENSION_49_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_GOOGLE_EXTENSION_50_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_NVX_EXTENSION_51_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_NVX_EXTENSION_52_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_NV_EXTENSION_53_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_NV_EXTENSION_54_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_IMG_FORMAT_PVRTC_SPEC_VERSION", 1);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG", 1000054000);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG", 1000054001);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG", 1000054002);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG", 1000054003);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG", 1000054004);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG", 1000054005);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG", 1000054006);
        
    
        
            PyModule_AddIntConstant(module, "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG", 1000054007);
        
    
        
            PyModule_AddIntConstant(module, "VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION", 1);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_NV_EXTERNAL_MEMORY_SPEC_VERSION", 1);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV", 1000056000);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV", 1000056001);
        
    
        
            PyModule_AddIntConstant(module, "VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION", 1);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV", 1000057000);
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV", 1000057001);
        
    
        
            PyModule_AddIntConstant(module, "VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION", 1);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV", 1000058000);
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_EXTENSION_60_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_EXTENSION_61_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_EXT_VALIDATION_FLAGS_SPEC_VERSION", 1);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT", 1000061000);
        
    
        
            PyModule_AddIntConstant(module, "VK_NV_EXTENSION_63_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_EXTENSION_64_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_NV_EXTENSION_65_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_NV_EXTENSION_66_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_ARM_EXTENSION_01_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_ARM_EXTENSION_02_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_IMG_EXTENSION_69_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_EXTENSION_70_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_EXTENSION_71_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_EXTENSION_72_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_EXTENSION_73_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_EXTENSION_74_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_EXTENSION_75_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_EXTENSION_76_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_EXTENSION_77_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_EXTENSION_78_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_EXTENSION_79_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_EXTENSION_80_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_EXTENSION_81_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_EXTENSION_82_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_EXTENSION_83_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_KHR_EXTENSION_84_SPEC_VERSION", 0);
        
    
        
    
        
            PyModule_AddIntConstant(module, "VK_API_VERSION_1_0", VK_API_VERSION_1_0);
        
    


    // ----------
    // TYPES
    // ----------
    init_pytype_objects();
    
    
    
        
        if (PyType_Ready(&PyVkOffset2DType) < 0)
            return NULL;
        Py_INCREF(&PyVkOffset2DType);
        PyModule_AddObject(module, "VkOffset2D", (PyObject *)&PyVkOffset2DType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkOffset3DType) < 0)
            return NULL;
        Py_INCREF(&PyVkOffset3DType);
        PyModule_AddObject(module, "VkOffset3D", (PyObject *)&PyVkOffset3DType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkExtent2DType) < 0)
            return NULL;
        Py_INCREF(&PyVkExtent2DType);
        PyModule_AddObject(module, "VkExtent2D", (PyObject *)&PyVkExtent2DType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkExtent3DType) < 0)
            return NULL;
        Py_INCREF(&PyVkExtent3DType);
        PyModule_AddObject(module, "VkExtent3D", (PyObject *)&PyVkExtent3DType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkViewportType) < 0)
            return NULL;
        Py_INCREF(&PyVkViewportType);
        PyModule_AddObject(module, "VkViewport", (PyObject *)&PyVkViewportType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkRect2DType) < 0)
            return NULL;
        Py_INCREF(&PyVkRect2DType);
        PyModule_AddObject(module, "VkRect2D", (PyObject *)&PyVkRect2DType);
    
    

    
    
     #ifdef hackdefine 
        
        if (PyType_Ready(&PyVkRect3DType) < 0)
            return NULL;
        Py_INCREF(&PyVkRect3DType);
        PyModule_AddObject(module, "VkRect3D", (PyObject *)&PyVkRect3DType);
    
     #endif 

    
    
    
        
        if (PyType_Ready(&PyVkClearRectType) < 0)
            return NULL;
        Py_INCREF(&PyVkClearRectType);
        PyModule_AddObject(module, "VkClearRect", (PyObject *)&PyVkClearRectType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkComponentMappingType) < 0)
            return NULL;
        Py_INCREF(&PyVkComponentMappingType);
        PyModule_AddObject(module, "VkComponentMapping", (PyObject *)&PyVkComponentMappingType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPhysicalDevicePropertiesType) < 0)
            return NULL;
        Py_INCREF(&PyVkPhysicalDevicePropertiesType);
        PyModule_AddObject(module, "VkPhysicalDeviceProperties", (PyObject *)&PyVkPhysicalDevicePropertiesType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkExtensionPropertiesType) < 0)
            return NULL;
        Py_INCREF(&PyVkExtensionPropertiesType);
        PyModule_AddObject(module, "VkExtensionProperties", (PyObject *)&PyVkExtensionPropertiesType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkLayerPropertiesType) < 0)
            return NULL;
        Py_INCREF(&PyVkLayerPropertiesType);
        PyModule_AddObject(module, "VkLayerProperties", (PyObject *)&PyVkLayerPropertiesType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkApplicationInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkApplicationInfoType);
        PyModule_AddObject(module, "VkApplicationInfo", (PyObject *)&PyVkApplicationInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkAllocationCallbacksType) < 0)
            return NULL;
        Py_INCREF(&PyVkAllocationCallbacksType);
        PyModule_AddObject(module, "VkAllocationCallbacks", (PyObject *)&PyVkAllocationCallbacksType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDeviceQueueCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkDeviceQueueCreateInfoType);
        PyModule_AddObject(module, "VkDeviceQueueCreateInfo", (PyObject *)&PyVkDeviceQueueCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDeviceCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkDeviceCreateInfoType);
        PyModule_AddObject(module, "VkDeviceCreateInfo", (PyObject *)&PyVkDeviceCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkInstanceCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkInstanceCreateInfoType);
        PyModule_AddObject(module, "VkInstanceCreateInfo", (PyObject *)&PyVkInstanceCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkQueueFamilyPropertiesType) < 0)
            return NULL;
        Py_INCREF(&PyVkQueueFamilyPropertiesType);
        PyModule_AddObject(module, "VkQueueFamilyProperties", (PyObject *)&PyVkQueueFamilyPropertiesType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPhysicalDeviceMemoryPropertiesType) < 0)
            return NULL;
        Py_INCREF(&PyVkPhysicalDeviceMemoryPropertiesType);
        PyModule_AddObject(module, "VkPhysicalDeviceMemoryProperties", (PyObject *)&PyVkPhysicalDeviceMemoryPropertiesType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkMemoryAllocateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkMemoryAllocateInfoType);
        PyModule_AddObject(module, "VkMemoryAllocateInfo", (PyObject *)&PyVkMemoryAllocateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkMemoryRequirementsType) < 0)
            return NULL;
        Py_INCREF(&PyVkMemoryRequirementsType);
        PyModule_AddObject(module, "VkMemoryRequirements", (PyObject *)&PyVkMemoryRequirementsType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkSparseImageFormatPropertiesType) < 0)
            return NULL;
        Py_INCREF(&PyVkSparseImageFormatPropertiesType);
        PyModule_AddObject(module, "VkSparseImageFormatProperties", (PyObject *)&PyVkSparseImageFormatPropertiesType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkSparseImageMemoryRequirementsType) < 0)
            return NULL;
        Py_INCREF(&PyVkSparseImageMemoryRequirementsType);
        PyModule_AddObject(module, "VkSparseImageMemoryRequirements", (PyObject *)&PyVkSparseImageMemoryRequirementsType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkMemoryTypeType) < 0)
            return NULL;
        Py_INCREF(&PyVkMemoryTypeType);
        PyModule_AddObject(module, "VkMemoryType", (PyObject *)&PyVkMemoryTypeType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkMemoryHeapType) < 0)
            return NULL;
        Py_INCREF(&PyVkMemoryHeapType);
        PyModule_AddObject(module, "VkMemoryHeap", (PyObject *)&PyVkMemoryHeapType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkMappedMemoryRangeType) < 0)
            return NULL;
        Py_INCREF(&PyVkMappedMemoryRangeType);
        PyModule_AddObject(module, "VkMappedMemoryRange", (PyObject *)&PyVkMappedMemoryRangeType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkFormatPropertiesType) < 0)
            return NULL;
        Py_INCREF(&PyVkFormatPropertiesType);
        PyModule_AddObject(module, "VkFormatProperties", (PyObject *)&PyVkFormatPropertiesType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkImageFormatPropertiesType) < 0)
            return NULL;
        Py_INCREF(&PyVkImageFormatPropertiesType);
        PyModule_AddObject(module, "VkImageFormatProperties", (PyObject *)&PyVkImageFormatPropertiesType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDescriptorBufferInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkDescriptorBufferInfoType);
        PyModule_AddObject(module, "VkDescriptorBufferInfo", (PyObject *)&PyVkDescriptorBufferInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDescriptorImageInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkDescriptorImageInfoType);
        PyModule_AddObject(module, "VkDescriptorImageInfo", (PyObject *)&PyVkDescriptorImageInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkWriteDescriptorSetType) < 0)
            return NULL;
        Py_INCREF(&PyVkWriteDescriptorSetType);
        PyModule_AddObject(module, "VkWriteDescriptorSet", (PyObject *)&PyVkWriteDescriptorSetType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkCopyDescriptorSetType) < 0)
            return NULL;
        Py_INCREF(&PyVkCopyDescriptorSetType);
        PyModule_AddObject(module, "VkCopyDescriptorSet", (PyObject *)&PyVkCopyDescriptorSetType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkBufferCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkBufferCreateInfoType);
        PyModule_AddObject(module, "VkBufferCreateInfo", (PyObject *)&PyVkBufferCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkBufferViewCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkBufferViewCreateInfoType);
        PyModule_AddObject(module, "VkBufferViewCreateInfo", (PyObject *)&PyVkBufferViewCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkImageSubresourceType) < 0)
            return NULL;
        Py_INCREF(&PyVkImageSubresourceType);
        PyModule_AddObject(module, "VkImageSubresource", (PyObject *)&PyVkImageSubresourceType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkImageSubresourceLayersType) < 0)
            return NULL;
        Py_INCREF(&PyVkImageSubresourceLayersType);
        PyModule_AddObject(module, "VkImageSubresourceLayers", (PyObject *)&PyVkImageSubresourceLayersType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkImageSubresourceRangeType) < 0)
            return NULL;
        Py_INCREF(&PyVkImageSubresourceRangeType);
        PyModule_AddObject(module, "VkImageSubresourceRange", (PyObject *)&PyVkImageSubresourceRangeType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkMemoryBarrierType) < 0)
            return NULL;
        Py_INCREF(&PyVkMemoryBarrierType);
        PyModule_AddObject(module, "VkMemoryBarrier", (PyObject *)&PyVkMemoryBarrierType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkBufferMemoryBarrierType) < 0)
            return NULL;
        Py_INCREF(&PyVkBufferMemoryBarrierType);
        PyModule_AddObject(module, "VkBufferMemoryBarrier", (PyObject *)&PyVkBufferMemoryBarrierType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkImageMemoryBarrierType) < 0)
            return NULL;
        Py_INCREF(&PyVkImageMemoryBarrierType);
        PyModule_AddObject(module, "VkImageMemoryBarrier", (PyObject *)&PyVkImageMemoryBarrierType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkImageCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkImageCreateInfoType);
        PyModule_AddObject(module, "VkImageCreateInfo", (PyObject *)&PyVkImageCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkSubresourceLayoutType) < 0)
            return NULL;
        Py_INCREF(&PyVkSubresourceLayoutType);
        PyModule_AddObject(module, "VkSubresourceLayout", (PyObject *)&PyVkSubresourceLayoutType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkImageViewCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkImageViewCreateInfoType);
        PyModule_AddObject(module, "VkImageViewCreateInfo", (PyObject *)&PyVkImageViewCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkBufferCopyType) < 0)
            return NULL;
        Py_INCREF(&PyVkBufferCopyType);
        PyModule_AddObject(module, "VkBufferCopy", (PyObject *)&PyVkBufferCopyType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkSparseMemoryBindType) < 0)
            return NULL;
        Py_INCREF(&PyVkSparseMemoryBindType);
        PyModule_AddObject(module, "VkSparseMemoryBind", (PyObject *)&PyVkSparseMemoryBindType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkSparseImageMemoryBindType) < 0)
            return NULL;
        Py_INCREF(&PyVkSparseImageMemoryBindType);
        PyModule_AddObject(module, "VkSparseImageMemoryBind", (PyObject *)&PyVkSparseImageMemoryBindType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkSparseBufferMemoryBindInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkSparseBufferMemoryBindInfoType);
        PyModule_AddObject(module, "VkSparseBufferMemoryBindInfo", (PyObject *)&PyVkSparseBufferMemoryBindInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkSparseImageOpaqueMemoryBindInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkSparseImageOpaqueMemoryBindInfoType);
        PyModule_AddObject(module, "VkSparseImageOpaqueMemoryBindInfo", (PyObject *)&PyVkSparseImageOpaqueMemoryBindInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkSparseImageMemoryBindInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkSparseImageMemoryBindInfoType);
        PyModule_AddObject(module, "VkSparseImageMemoryBindInfo", (PyObject *)&PyVkSparseImageMemoryBindInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkBindSparseInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkBindSparseInfoType);
        PyModule_AddObject(module, "VkBindSparseInfo", (PyObject *)&PyVkBindSparseInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkImageCopyType) < 0)
            return NULL;
        Py_INCREF(&PyVkImageCopyType);
        PyModule_AddObject(module, "VkImageCopy", (PyObject *)&PyVkImageCopyType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkImageBlitType) < 0)
            return NULL;
        Py_INCREF(&PyVkImageBlitType);
        PyModule_AddObject(module, "VkImageBlit", (PyObject *)&PyVkImageBlitType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkBufferImageCopyType) < 0)
            return NULL;
        Py_INCREF(&PyVkBufferImageCopyType);
        PyModule_AddObject(module, "VkBufferImageCopy", (PyObject *)&PyVkBufferImageCopyType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkImageResolveType) < 0)
            return NULL;
        Py_INCREF(&PyVkImageResolveType);
        PyModule_AddObject(module, "VkImageResolve", (PyObject *)&PyVkImageResolveType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkShaderModuleCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkShaderModuleCreateInfoType);
        PyModule_AddObject(module, "VkShaderModuleCreateInfo", (PyObject *)&PyVkShaderModuleCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDescriptorSetLayoutBindingType) < 0)
            return NULL;
        Py_INCREF(&PyVkDescriptorSetLayoutBindingType);
        PyModule_AddObject(module, "VkDescriptorSetLayoutBinding", (PyObject *)&PyVkDescriptorSetLayoutBindingType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDescriptorSetLayoutCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkDescriptorSetLayoutCreateInfoType);
        PyModule_AddObject(module, "VkDescriptorSetLayoutCreateInfo", (PyObject *)&PyVkDescriptorSetLayoutCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDescriptorPoolSizeType) < 0)
            return NULL;
        Py_INCREF(&PyVkDescriptorPoolSizeType);
        PyModule_AddObject(module, "VkDescriptorPoolSize", (PyObject *)&PyVkDescriptorPoolSizeType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDescriptorPoolCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkDescriptorPoolCreateInfoType);
        PyModule_AddObject(module, "VkDescriptorPoolCreateInfo", (PyObject *)&PyVkDescriptorPoolCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDescriptorSetAllocateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkDescriptorSetAllocateInfoType);
        PyModule_AddObject(module, "VkDescriptorSetAllocateInfo", (PyObject *)&PyVkDescriptorSetAllocateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkSpecializationMapEntryType) < 0)
            return NULL;
        Py_INCREF(&PyVkSpecializationMapEntryType);
        PyModule_AddObject(module, "VkSpecializationMapEntry", (PyObject *)&PyVkSpecializationMapEntryType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkSpecializationInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkSpecializationInfoType);
        PyModule_AddObject(module, "VkSpecializationInfo", (PyObject *)&PyVkSpecializationInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPipelineShaderStageCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkPipelineShaderStageCreateInfoType);
        PyModule_AddObject(module, "VkPipelineShaderStageCreateInfo", (PyObject *)&PyVkPipelineShaderStageCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkComputePipelineCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkComputePipelineCreateInfoType);
        PyModule_AddObject(module, "VkComputePipelineCreateInfo", (PyObject *)&PyVkComputePipelineCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkVertexInputBindingDescriptionType) < 0)
            return NULL;
        Py_INCREF(&PyVkVertexInputBindingDescriptionType);
        PyModule_AddObject(module, "VkVertexInputBindingDescription", (PyObject *)&PyVkVertexInputBindingDescriptionType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkVertexInputAttributeDescriptionType) < 0)
            return NULL;
        Py_INCREF(&PyVkVertexInputAttributeDescriptionType);
        PyModule_AddObject(module, "VkVertexInputAttributeDescription", (PyObject *)&PyVkVertexInputAttributeDescriptionType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPipelineVertexInputStateCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkPipelineVertexInputStateCreateInfoType);
        PyModule_AddObject(module, "VkPipelineVertexInputStateCreateInfo", (PyObject *)&PyVkPipelineVertexInputStateCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPipelineInputAssemblyStateCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkPipelineInputAssemblyStateCreateInfoType);
        PyModule_AddObject(module, "VkPipelineInputAssemblyStateCreateInfo", (PyObject *)&PyVkPipelineInputAssemblyStateCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPipelineTessellationStateCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkPipelineTessellationStateCreateInfoType);
        PyModule_AddObject(module, "VkPipelineTessellationStateCreateInfo", (PyObject *)&PyVkPipelineTessellationStateCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPipelineViewportStateCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkPipelineViewportStateCreateInfoType);
        PyModule_AddObject(module, "VkPipelineViewportStateCreateInfo", (PyObject *)&PyVkPipelineViewportStateCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPipelineRasterizationStateCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkPipelineRasterizationStateCreateInfoType);
        PyModule_AddObject(module, "VkPipelineRasterizationStateCreateInfo", (PyObject *)&PyVkPipelineRasterizationStateCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPipelineMultisampleStateCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkPipelineMultisampleStateCreateInfoType);
        PyModule_AddObject(module, "VkPipelineMultisampleStateCreateInfo", (PyObject *)&PyVkPipelineMultisampleStateCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPipelineColorBlendAttachmentStateType) < 0)
            return NULL;
        Py_INCREF(&PyVkPipelineColorBlendAttachmentStateType);
        PyModule_AddObject(module, "VkPipelineColorBlendAttachmentState", (PyObject *)&PyVkPipelineColorBlendAttachmentStateType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPipelineColorBlendStateCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkPipelineColorBlendStateCreateInfoType);
        PyModule_AddObject(module, "VkPipelineColorBlendStateCreateInfo", (PyObject *)&PyVkPipelineColorBlendStateCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPipelineDynamicStateCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkPipelineDynamicStateCreateInfoType);
        PyModule_AddObject(module, "VkPipelineDynamicStateCreateInfo", (PyObject *)&PyVkPipelineDynamicStateCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkStencilOpStateType) < 0)
            return NULL;
        Py_INCREF(&PyVkStencilOpStateType);
        PyModule_AddObject(module, "VkStencilOpState", (PyObject *)&PyVkStencilOpStateType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPipelineDepthStencilStateCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkPipelineDepthStencilStateCreateInfoType);
        PyModule_AddObject(module, "VkPipelineDepthStencilStateCreateInfo", (PyObject *)&PyVkPipelineDepthStencilStateCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkGraphicsPipelineCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkGraphicsPipelineCreateInfoType);
        PyModule_AddObject(module, "VkGraphicsPipelineCreateInfo", (PyObject *)&PyVkGraphicsPipelineCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPipelineCacheCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkPipelineCacheCreateInfoType);
        PyModule_AddObject(module, "VkPipelineCacheCreateInfo", (PyObject *)&PyVkPipelineCacheCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPushConstantRangeType) < 0)
            return NULL;
        Py_INCREF(&PyVkPushConstantRangeType);
        PyModule_AddObject(module, "VkPushConstantRange", (PyObject *)&PyVkPushConstantRangeType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPipelineLayoutCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkPipelineLayoutCreateInfoType);
        PyModule_AddObject(module, "VkPipelineLayoutCreateInfo", (PyObject *)&PyVkPipelineLayoutCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkSamplerCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkSamplerCreateInfoType);
        PyModule_AddObject(module, "VkSamplerCreateInfo", (PyObject *)&PyVkSamplerCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkCommandPoolCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkCommandPoolCreateInfoType);
        PyModule_AddObject(module, "VkCommandPoolCreateInfo", (PyObject *)&PyVkCommandPoolCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkCommandBufferAllocateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkCommandBufferAllocateInfoType);
        PyModule_AddObject(module, "VkCommandBufferAllocateInfo", (PyObject *)&PyVkCommandBufferAllocateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkCommandBufferInheritanceInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkCommandBufferInheritanceInfoType);
        PyModule_AddObject(module, "VkCommandBufferInheritanceInfo", (PyObject *)&PyVkCommandBufferInheritanceInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkCommandBufferBeginInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkCommandBufferBeginInfoType);
        PyModule_AddObject(module, "VkCommandBufferBeginInfo", (PyObject *)&PyVkCommandBufferBeginInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkRenderPassBeginInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkRenderPassBeginInfoType);
        PyModule_AddObject(module, "VkRenderPassBeginInfo", (PyObject *)&PyVkRenderPassBeginInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkClearDepthStencilValueType) < 0)
            return NULL;
        Py_INCREF(&PyVkClearDepthStencilValueType);
        PyModule_AddObject(module, "VkClearDepthStencilValue", (PyObject *)&PyVkClearDepthStencilValueType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkClearAttachmentType) < 0)
            return NULL;
        Py_INCREF(&PyVkClearAttachmentType);
        PyModule_AddObject(module, "VkClearAttachment", (PyObject *)&PyVkClearAttachmentType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkAttachmentDescriptionType) < 0)
            return NULL;
        Py_INCREF(&PyVkAttachmentDescriptionType);
        PyModule_AddObject(module, "VkAttachmentDescription", (PyObject *)&PyVkAttachmentDescriptionType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkAttachmentReferenceType) < 0)
            return NULL;
        Py_INCREF(&PyVkAttachmentReferenceType);
        PyModule_AddObject(module, "VkAttachmentReference", (PyObject *)&PyVkAttachmentReferenceType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkSubpassDescriptionType) < 0)
            return NULL;
        Py_INCREF(&PyVkSubpassDescriptionType);
        PyModule_AddObject(module, "VkSubpassDescription", (PyObject *)&PyVkSubpassDescriptionType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkSubpassDependencyType) < 0)
            return NULL;
        Py_INCREF(&PyVkSubpassDependencyType);
        PyModule_AddObject(module, "VkSubpassDependency", (PyObject *)&PyVkSubpassDependencyType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkRenderPassCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkRenderPassCreateInfoType);
        PyModule_AddObject(module, "VkRenderPassCreateInfo", (PyObject *)&PyVkRenderPassCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkEventCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkEventCreateInfoType);
        PyModule_AddObject(module, "VkEventCreateInfo", (PyObject *)&PyVkEventCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkFenceCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkFenceCreateInfoType);
        PyModule_AddObject(module, "VkFenceCreateInfo", (PyObject *)&PyVkFenceCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPhysicalDeviceFeaturesType) < 0)
            return NULL;
        Py_INCREF(&PyVkPhysicalDeviceFeaturesType);
        PyModule_AddObject(module, "VkPhysicalDeviceFeatures", (PyObject *)&PyVkPhysicalDeviceFeaturesType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPhysicalDeviceSparsePropertiesType) < 0)
            return NULL;
        Py_INCREF(&PyVkPhysicalDeviceSparsePropertiesType);
        PyModule_AddObject(module, "VkPhysicalDeviceSparseProperties", (PyObject *)&PyVkPhysicalDeviceSparsePropertiesType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPhysicalDeviceLimitsType) < 0)
            return NULL;
        Py_INCREF(&PyVkPhysicalDeviceLimitsType);
        PyModule_AddObject(module, "VkPhysicalDeviceLimits", (PyObject *)&PyVkPhysicalDeviceLimitsType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkSemaphoreCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkSemaphoreCreateInfoType);
        PyModule_AddObject(module, "VkSemaphoreCreateInfo", (PyObject *)&PyVkSemaphoreCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkQueryPoolCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkQueryPoolCreateInfoType);
        PyModule_AddObject(module, "VkQueryPoolCreateInfo", (PyObject *)&PyVkQueryPoolCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkFramebufferCreateInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkFramebufferCreateInfoType);
        PyModule_AddObject(module, "VkFramebufferCreateInfo", (PyObject *)&PyVkFramebufferCreateInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDrawIndirectCommandType) < 0)
            return NULL;
        Py_INCREF(&PyVkDrawIndirectCommandType);
        PyModule_AddObject(module, "VkDrawIndirectCommand", (PyObject *)&PyVkDrawIndirectCommandType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDrawIndexedIndirectCommandType) < 0)
            return NULL;
        Py_INCREF(&PyVkDrawIndexedIndirectCommandType);
        PyModule_AddObject(module, "VkDrawIndexedIndirectCommand", (PyObject *)&PyVkDrawIndexedIndirectCommandType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDispatchIndirectCommandType) < 0)
            return NULL;
        Py_INCREF(&PyVkDispatchIndirectCommandType);
        PyModule_AddObject(module, "VkDispatchIndirectCommand", (PyObject *)&PyVkDispatchIndirectCommandType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkSubmitInfoType) < 0)
            return NULL;
        Py_INCREF(&PyVkSubmitInfoType);
        PyModule_AddObject(module, "VkSubmitInfo", (PyObject *)&PyVkSubmitInfoType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDisplayPropertiesKHRType) < 0)
            return NULL;
        Py_INCREF(&PyVkDisplayPropertiesKHRType);
        PyModule_AddObject(module, "VkDisplayPropertiesKHR", (PyObject *)&PyVkDisplayPropertiesKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDisplayPlanePropertiesKHRType) < 0)
            return NULL;
        Py_INCREF(&PyVkDisplayPlanePropertiesKHRType);
        PyModule_AddObject(module, "VkDisplayPlanePropertiesKHR", (PyObject *)&PyVkDisplayPlanePropertiesKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDisplayModeParametersKHRType) < 0)
            return NULL;
        Py_INCREF(&PyVkDisplayModeParametersKHRType);
        PyModule_AddObject(module, "VkDisplayModeParametersKHR", (PyObject *)&PyVkDisplayModeParametersKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDisplayModePropertiesKHRType) < 0)
            return NULL;
        Py_INCREF(&PyVkDisplayModePropertiesKHRType);
        PyModule_AddObject(module, "VkDisplayModePropertiesKHR", (PyObject *)&PyVkDisplayModePropertiesKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDisplayModeCreateInfoKHRType) < 0)
            return NULL;
        Py_INCREF(&PyVkDisplayModeCreateInfoKHRType);
        PyModule_AddObject(module, "VkDisplayModeCreateInfoKHR", (PyObject *)&PyVkDisplayModeCreateInfoKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDisplayPlaneCapabilitiesKHRType) < 0)
            return NULL;
        Py_INCREF(&PyVkDisplayPlaneCapabilitiesKHRType);
        PyModule_AddObject(module, "VkDisplayPlaneCapabilitiesKHR", (PyObject *)&PyVkDisplayPlaneCapabilitiesKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDisplaySurfaceCreateInfoKHRType) < 0)
            return NULL;
        Py_INCREF(&PyVkDisplaySurfaceCreateInfoKHRType);
        PyModule_AddObject(module, "VkDisplaySurfaceCreateInfoKHR", (PyObject *)&PyVkDisplaySurfaceCreateInfoKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDisplayPresentInfoKHRType) < 0)
            return NULL;
        Py_INCREF(&PyVkDisplayPresentInfoKHRType);
        PyModule_AddObject(module, "VkDisplayPresentInfoKHR", (PyObject *)&PyVkDisplayPresentInfoKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkSurfaceCapabilitiesKHRType) < 0)
            return NULL;
        Py_INCREF(&PyVkSurfaceCapabilitiesKHRType);
        PyModule_AddObject(module, "VkSurfaceCapabilitiesKHR", (PyObject *)&PyVkSurfaceCapabilitiesKHRType);
    
    

    
    
     #ifdef VK_USE_PLATFORM_ANDROID_KHR 
        
        if (PyType_Ready(&PyVkAndroidSurfaceCreateInfoKHRType) < 0)
            return NULL;
        Py_INCREF(&PyVkAndroidSurfaceCreateInfoKHRType);
        PyModule_AddObject(module, "VkAndroidSurfaceCreateInfoKHR", (PyObject *)&PyVkAndroidSurfaceCreateInfoKHRType);
    
     #endif 

    
    
     #ifdef VK_USE_PLATFORM_MIR_KHR 
        
        if (PyType_Ready(&PyVkMirSurfaceCreateInfoKHRType) < 0)
            return NULL;
        Py_INCREF(&PyVkMirSurfaceCreateInfoKHRType);
        PyModule_AddObject(module, "VkMirSurfaceCreateInfoKHR", (PyObject *)&PyVkMirSurfaceCreateInfoKHRType);
    
     #endif 

    
    
     #ifdef VK_USE_PLATFORM_WAYLAND_KHR 
        
        if (PyType_Ready(&PyVkWaylandSurfaceCreateInfoKHRType) < 0)
            return NULL;
        Py_INCREF(&PyVkWaylandSurfaceCreateInfoKHRType);
        PyModule_AddObject(module, "VkWaylandSurfaceCreateInfoKHR", (PyObject *)&PyVkWaylandSurfaceCreateInfoKHRType);
    
     #endif 

    
    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
        if (PyType_Ready(&PyVkWin32SurfaceCreateInfoKHRType) < 0)
            return NULL;
        Py_INCREF(&PyVkWin32SurfaceCreateInfoKHRType);
        PyModule_AddObject(module, "VkWin32SurfaceCreateInfoKHR", (PyObject *)&PyVkWin32SurfaceCreateInfoKHRType);
    
     #endif 

    
    
     #ifdef VK_USE_PLATFORM_XLIB_KHR 
        
        if (PyType_Ready(&PyVkXlibSurfaceCreateInfoKHRType) < 0)
            return NULL;
        Py_INCREF(&PyVkXlibSurfaceCreateInfoKHRType);
        PyModule_AddObject(module, "VkXlibSurfaceCreateInfoKHR", (PyObject *)&PyVkXlibSurfaceCreateInfoKHRType);
    
     #endif 

    
    
     #ifdef VK_USE_PLATFORM_XCB_KHR 
        
        if (PyType_Ready(&PyVkXcbSurfaceCreateInfoKHRType) < 0)
            return NULL;
        Py_INCREF(&PyVkXcbSurfaceCreateInfoKHRType);
        PyModule_AddObject(module, "VkXcbSurfaceCreateInfoKHR", (PyObject *)&PyVkXcbSurfaceCreateInfoKHRType);
    
     #endif 

    
    
    
        
        if (PyType_Ready(&PyVkSurfaceFormatKHRType) < 0)
            return NULL;
        Py_INCREF(&PyVkSurfaceFormatKHRType);
        PyModule_AddObject(module, "VkSurfaceFormatKHR", (PyObject *)&PyVkSurfaceFormatKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkSwapchainCreateInfoKHRType) < 0)
            return NULL;
        Py_INCREF(&PyVkSwapchainCreateInfoKHRType);
        PyModule_AddObject(module, "VkSwapchainCreateInfoKHR", (PyObject *)&PyVkSwapchainCreateInfoKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPresentInfoKHRType) < 0)
            return NULL;
        Py_INCREF(&PyVkPresentInfoKHRType);
        PyModule_AddObject(module, "VkPresentInfoKHR", (PyObject *)&PyVkPresentInfoKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkValidationFlagsEXTType) < 0)
            return NULL;
        Py_INCREF(&PyVkValidationFlagsEXTType);
        PyModule_AddObject(module, "VkValidationFlagsEXT", (PyObject *)&PyVkValidationFlagsEXTType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkPipelineRasterizationStateRasterizationOrderAMDType) < 0)
            return NULL;
        Py_INCREF(&PyVkPipelineRasterizationStateRasterizationOrderAMDType);
        PyModule_AddObject(module, "VkPipelineRasterizationStateRasterizationOrderAMD", (PyObject *)&PyVkPipelineRasterizationStateRasterizationOrderAMDType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDebugMarkerObjectNameInfoEXTType) < 0)
            return NULL;
        Py_INCREF(&PyVkDebugMarkerObjectNameInfoEXTType);
        PyModule_AddObject(module, "VkDebugMarkerObjectNameInfoEXT", (PyObject *)&PyVkDebugMarkerObjectNameInfoEXTType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDebugMarkerObjectTagInfoEXTType) < 0)
            return NULL;
        Py_INCREF(&PyVkDebugMarkerObjectTagInfoEXTType);
        PyModule_AddObject(module, "VkDebugMarkerObjectTagInfoEXT", (PyObject *)&PyVkDebugMarkerObjectTagInfoEXTType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDebugMarkerMarkerInfoEXTType) < 0)
            return NULL;
        Py_INCREF(&PyVkDebugMarkerMarkerInfoEXTType);
        PyModule_AddObject(module, "VkDebugMarkerMarkerInfoEXT", (PyObject *)&PyVkDebugMarkerMarkerInfoEXTType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDedicatedAllocationImageCreateInfoNVType) < 0)
            return NULL;
        Py_INCREF(&PyVkDedicatedAllocationImageCreateInfoNVType);
        PyModule_AddObject(module, "VkDedicatedAllocationImageCreateInfoNV", (PyObject *)&PyVkDedicatedAllocationImageCreateInfoNVType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDedicatedAllocationBufferCreateInfoNVType) < 0)
            return NULL;
        Py_INCREF(&PyVkDedicatedAllocationBufferCreateInfoNVType);
        PyModule_AddObject(module, "VkDedicatedAllocationBufferCreateInfoNV", (PyObject *)&PyVkDedicatedAllocationBufferCreateInfoNVType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkDedicatedAllocationMemoryAllocateInfoNVType) < 0)
            return NULL;
        Py_INCREF(&PyVkDedicatedAllocationMemoryAllocateInfoNVType);
        PyModule_AddObject(module, "VkDedicatedAllocationMemoryAllocateInfoNV", (PyObject *)&PyVkDedicatedAllocationMemoryAllocateInfoNVType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkExternalImageFormatPropertiesNVType) < 0)
            return NULL;
        Py_INCREF(&PyVkExternalImageFormatPropertiesNVType);
        PyModule_AddObject(module, "VkExternalImageFormatPropertiesNV", (PyObject *)&PyVkExternalImageFormatPropertiesNVType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkExternalMemoryImageCreateInfoNVType) < 0)
            return NULL;
        Py_INCREF(&PyVkExternalMemoryImageCreateInfoNVType);
        PyModule_AddObject(module, "VkExternalMemoryImageCreateInfoNV", (PyObject *)&PyVkExternalMemoryImageCreateInfoNVType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkExportMemoryAllocateInfoNVType) < 0)
            return NULL;
        Py_INCREF(&PyVkExportMemoryAllocateInfoNVType);
        PyModule_AddObject(module, "VkExportMemoryAllocateInfoNV", (PyObject *)&PyVkExportMemoryAllocateInfoNVType);
    
    

    
    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
        if (PyType_Ready(&PyVkImportMemoryWin32HandleInfoNVType) < 0)
            return NULL;
        Py_INCREF(&PyVkImportMemoryWin32HandleInfoNVType);
        PyModule_AddObject(module, "VkImportMemoryWin32HandleInfoNV", (PyObject *)&PyVkImportMemoryWin32HandleInfoNVType);
    
     #endif 

    
    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
        if (PyType_Ready(&PyVkExportMemoryWin32HandleInfoNVType) < 0)
            return NULL;
        Py_INCREF(&PyVkExportMemoryWin32HandleInfoNVType);
        PyModule_AddObject(module, "VkExportMemoryWin32HandleInfoNV", (PyObject *)&PyVkExportMemoryWin32HandleInfoNVType);
    
     #endif 

    
    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
        if (PyType_Ready(&PyVkWin32KeyedMutexAcquireReleaseInfoNVType) < 0)
            return NULL;
        Py_INCREF(&PyVkWin32KeyedMutexAcquireReleaseInfoNVType);
        PyModule_AddObject(module, "VkWin32KeyedMutexAcquireReleaseInfoNV", (PyObject *)&PyVkWin32KeyedMutexAcquireReleaseInfoNVType);
    
     #endif 

    
    
    
        
        if (PyType_Ready(&PyVkClearColorValueType) < 0)
            return NULL;
        Py_INCREF(&PyVkClearColorValueType);
        PyModule_AddObject(module, "VkClearColorValue", (PyObject *)&PyVkClearColorValueType);
    
    

    
    
    
        
        if (PyType_Ready(&PyVkClearValueType) < 0)
            return NULL;
        Py_INCREF(&PyVkClearValueType);
        PyModule_AddObject(module, "VkClearValue", (PyObject *)&PyVkClearValueType);
    
    

    


    // ----------
    // TYPES FOR CUSTOM STRUCTS
    // ----------
    
        if (PyType_Ready(&PyVkDebugReportCallbackCreateInfoEXTType) < 0)
            return NULL;
        Py_INCREF(&PyVkDebugReportCallbackCreateInfoEXTType);
        PyModule_AddObject(module, "VkDebugReportCallbackCreateInfoEXT", (PyObject *)&PyVkDebugReportCallbackCreateInfoEXTType);
    

    // ----------
    // TYPES FOR EXTENSION FUNCTIONS
    // ----------
    
    
     #ifdef VK_USE_PLATFORM_ANDROID_KHR 
        
        if (PyType_Ready(&PyvkCreateAndroidSurfaceKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkCreateAndroidSurfaceKHRType);
    
     #endif 

    
    
    
        
        if (PyType_Ready(&PyvkGetPhysicalDeviceDisplayPropertiesKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkGetPhysicalDeviceDisplayPropertiesKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkGetPhysicalDeviceDisplayPlanePropertiesKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkGetPhysicalDeviceDisplayPlanePropertiesKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkGetDisplayPlaneSupportedDisplaysKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkGetDisplayPlaneSupportedDisplaysKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkGetDisplayModePropertiesKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkGetDisplayModePropertiesKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkCreateDisplayModeKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkCreateDisplayModeKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkGetDisplayPlaneCapabilitiesKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkGetDisplayPlaneCapabilitiesKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkCreateDisplayPlaneSurfaceKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkCreateDisplayPlaneSurfaceKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkCreateSharedSwapchainsKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkCreateSharedSwapchainsKHRType);
    
    

    
    
     #ifdef VK_USE_PLATFORM_MIR_KHR 
        
        if (PyType_Ready(&PyvkCreateMirSurfaceKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkCreateMirSurfaceKHRType);
    
     #endif 

    
    
     #ifdef VK_USE_PLATFORM_MIR_KHR 
        
        if (PyType_Ready(&PyvkGetPhysicalDeviceMirPresentationSupportKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkGetPhysicalDeviceMirPresentationSupportKHRType);
    
     #endif 

    
    
    
        
        if (PyType_Ready(&PyvkDestroySurfaceKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkDestroySurfaceKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkGetPhysicalDeviceSurfaceSupportKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkGetPhysicalDeviceSurfaceSupportKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkGetPhysicalDeviceSurfaceCapabilitiesKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkGetPhysicalDeviceSurfaceCapabilitiesKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkGetPhysicalDeviceSurfaceFormatsKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkGetPhysicalDeviceSurfaceFormatsKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkGetPhysicalDeviceSurfacePresentModesKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkGetPhysicalDeviceSurfacePresentModesKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkCreateSwapchainKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkCreateSwapchainKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkDestroySwapchainKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkDestroySwapchainKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkGetSwapchainImagesKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkGetSwapchainImagesKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkAcquireNextImageKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkAcquireNextImageKHRType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkQueuePresentKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkQueuePresentKHRType);
    
    

    
    
     #ifdef VK_USE_PLATFORM_WAYLAND_KHR 
        
        if (PyType_Ready(&PyvkCreateWaylandSurfaceKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkCreateWaylandSurfaceKHRType);
    
     #endif 

    
    
     #ifdef VK_USE_PLATFORM_WAYLAND_KHR 
        
        if (PyType_Ready(&PyvkGetPhysicalDeviceWaylandPresentationSupportKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkGetPhysicalDeviceWaylandPresentationSupportKHRType);
    
     #endif 

    
    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
        if (PyType_Ready(&PyvkCreateWin32SurfaceKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkCreateWin32SurfaceKHRType);
    
     #endif 

    
    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
        if (PyType_Ready(&PyvkGetPhysicalDeviceWin32PresentationSupportKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkGetPhysicalDeviceWin32PresentationSupportKHRType);
    
     #endif 

    
    
     #ifdef VK_USE_PLATFORM_XLIB_KHR 
        
        if (PyType_Ready(&PyvkCreateXlibSurfaceKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkCreateXlibSurfaceKHRType);
    
     #endif 

    
    
     #ifdef VK_USE_PLATFORM_XLIB_KHR 
        
        if (PyType_Ready(&PyvkGetPhysicalDeviceXlibPresentationSupportKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkGetPhysicalDeviceXlibPresentationSupportKHRType);
    
     #endif 

    
    
     #ifdef VK_USE_PLATFORM_XCB_KHR 
        
        if (PyType_Ready(&PyvkCreateXcbSurfaceKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkCreateXcbSurfaceKHRType);
    
     #endif 

    
    
     #ifdef VK_USE_PLATFORM_XCB_KHR 
        
        if (PyType_Ready(&PyvkGetPhysicalDeviceXcbPresentationSupportKHRType) < 0)
            return NULL;
        Py_INCREF(&PyvkGetPhysicalDeviceXcbPresentationSupportKHRType);
    
     #endif 

    
    
    
        
        if (PyType_Ready(&PyvkCreateDebugReportCallbackEXTType) < 0)
            return NULL;
        Py_INCREF(&PyvkCreateDebugReportCallbackEXTType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkDestroyDebugReportCallbackEXTType) < 0)
            return NULL;
        Py_INCREF(&PyvkDestroyDebugReportCallbackEXTType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkDebugReportMessageEXTType) < 0)
            return NULL;
        Py_INCREF(&PyvkDebugReportMessageEXTType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkDebugMarkerSetObjectNameEXTType) < 0)
            return NULL;
        Py_INCREF(&PyvkDebugMarkerSetObjectNameEXTType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkDebugMarkerSetObjectTagEXTType) < 0)
            return NULL;
        Py_INCREF(&PyvkDebugMarkerSetObjectTagEXTType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkCmdDebugMarkerBeginEXTType) < 0)
            return NULL;
        Py_INCREF(&PyvkCmdDebugMarkerBeginEXTType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkCmdDebugMarkerEndEXTType) < 0)
            return NULL;
        Py_INCREF(&PyvkCmdDebugMarkerEndEXTType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkCmdDebugMarkerInsertEXTType) < 0)
            return NULL;
        Py_INCREF(&PyvkCmdDebugMarkerInsertEXTType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkGetPhysicalDeviceExternalImageFormatPropertiesNVType) < 0)
            return NULL;
        Py_INCREF(&PyvkGetPhysicalDeviceExternalImageFormatPropertiesNVType);
    
    

    
    
     #ifdef VK_USE_PLATFORM_WIN32_KHR 
        
        if (PyType_Ready(&PyvkGetMemoryWin32HandleNVType) < 0)
            return NULL;
        Py_INCREF(&PyvkGetMemoryWin32HandleNVType);
    
     #endif 

    
    
    
        
        if (PyType_Ready(&PyvkCmdDrawIndirectCountAMDType) < 0)
            return NULL;
        Py_INCREF(&PyvkCmdDrawIndirectCountAMDType);
    
    

    
    
    
        
        if (PyType_Ready(&PyvkCmdDrawIndexedIndirectCountAMDType) < 0)
            return NULL;
        Py_INCREF(&PyvkCmdDrawIndexedIndirectCountAMDType);
    
    

    


    // ----------
    // EXCEPTIONS
    // ----------
    VulkanError = PyErr_NewException("vulkan.VulkanError", NULL, NULL);
    Py_INCREF(VulkanError);
    PyModule_AddObject(module, "VulkanError", VulkanError);

    
        VkTimeout = PyErr_NewException("vulkan.VkTimeout", VulkanError, NULL);
        Py_INCREF(VkTimeout);
        PyModule_AddObject(module, "VkTimeout", VkTimeout);
    
        VkErrorInitializationFailed = PyErr_NewException("vulkan.VkErrorInitializationFailed", VulkanError, NULL);
        Py_INCREF(VkErrorInitializationFailed);
        PyModule_AddObject(module, "VkErrorInitializationFailed", VkErrorInitializationFailed);
    
        VkEventSet = PyErr_NewException("vulkan.VkEventSet", VulkanError, NULL);
        Py_INCREF(VkEventSet);
        PyModule_AddObject(module, "VkEventSet", VkEventSet);
    
        VkErrorFragmentedPool = PyErr_NewException("vulkan.VkErrorFragmentedPool", VulkanError, NULL);
        Py_INCREF(VkErrorFragmentedPool);
        PyModule_AddObject(module, "VkErrorFragmentedPool", VkErrorFragmentedPool);
    
        VkEventReset = PyErr_NewException("vulkan.VkEventReset", VulkanError, NULL);
        Py_INCREF(VkEventReset);
        PyModule_AddObject(module, "VkEventReset", VkEventReset);
    
        VkErrorIncompatibleDriver = PyErr_NewException("vulkan.VkErrorIncompatibleDriver", VulkanError, NULL);
        Py_INCREF(VkErrorIncompatibleDriver);
        PyModule_AddObject(module, "VkErrorIncompatibleDriver", VkErrorIncompatibleDriver);
    
        VkErrorOutOfDeviceMemory = PyErr_NewException("vulkan.VkErrorOutOfDeviceMemory", VulkanError, NULL);
        Py_INCREF(VkErrorOutOfDeviceMemory);
        PyModule_AddObject(module, "VkErrorOutOfDeviceMemory", VkErrorOutOfDeviceMemory);
    
        VkIncomplete = PyErr_NewException("vulkan.VkIncomplete", VulkanError, NULL);
        Py_INCREF(VkIncomplete);
        PyModule_AddObject(module, "VkIncomplete", VkIncomplete);
    
        VkErrorExtensionNotPresent = PyErr_NewException("vulkan.VkErrorExtensionNotPresent", VulkanError, NULL);
        Py_INCREF(VkErrorExtensionNotPresent);
        PyModule_AddObject(module, "VkErrorExtensionNotPresent", VkErrorExtensionNotPresent);
    
        VkErrorMemoryMapFailed = PyErr_NewException("vulkan.VkErrorMemoryMapFailed", VulkanError, NULL);
        Py_INCREF(VkErrorMemoryMapFailed);
        PyModule_AddObject(module, "VkErrorMemoryMapFailed", VkErrorMemoryMapFailed);
    
        VkErrorDeviceLost = PyErr_NewException("vulkan.VkErrorDeviceLost", VulkanError, NULL);
        Py_INCREF(VkErrorDeviceLost);
        PyModule_AddObject(module, "VkErrorDeviceLost", VkErrorDeviceLost);
    
        VkErrorFormatNotSupported = PyErr_NewException("vulkan.VkErrorFormatNotSupported", VulkanError, NULL);
        Py_INCREF(VkErrorFormatNotSupported);
        PyModule_AddObject(module, "VkErrorFormatNotSupported", VkErrorFormatNotSupported);
    
        VkNotReady = PyErr_NewException("vulkan.VkNotReady", VulkanError, NULL);
        Py_INCREF(VkNotReady);
        PyModule_AddObject(module, "VkNotReady", VkNotReady);
    
        VkErrorLayerNotPresent = PyErr_NewException("vulkan.VkErrorLayerNotPresent", VulkanError, NULL);
        Py_INCREF(VkErrorLayerNotPresent);
        PyModule_AddObject(module, "VkErrorLayerNotPresent", VkErrorLayerNotPresent);
    
        VkErrorFeatureNotPresent = PyErr_NewException("vulkan.VkErrorFeatureNotPresent", VulkanError, NULL);
        Py_INCREF(VkErrorFeatureNotPresent);
        PyModule_AddObject(module, "VkErrorFeatureNotPresent", VkErrorFeatureNotPresent);
    
        VkErrorTooManyObjects = PyErr_NewException("vulkan.VkErrorTooManyObjects", VulkanError, NULL);
        Py_INCREF(VkErrorTooManyObjects);
        PyModule_AddObject(module, "VkErrorTooManyObjects", VkErrorTooManyObjects);
    
        VkErrorOutOfHostMemory = PyErr_NewException("vulkan.VkErrorOutOfHostMemory", VulkanError, NULL);
        Py_INCREF(VkErrorOutOfHostMemory);
        PyModule_AddObject(module, "VkErrorOutOfHostMemory", VkErrorOutOfHostMemory);
    


    return module;
}
