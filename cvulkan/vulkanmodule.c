
#include <Python.h>
#include <dlfcn.h>

#define VK_NO_PROTOTYPES

#if defined(ANDROID) || defined (__ANDROID__)
#define VK_USE_PLATFORM_ANDROID_KHR 1
#elif defined(_WIN32)
#define VK_USE_PLATFORM_WIN32_KHR 1
#elif defined(__linux__)
#define VK_USE_PLATFORM_XLIB_KHR 1
#endif

#ifdef __unix__

#define LOAD_SDK() dlopen("libvulkan.so", RTLD_NOW);

#elif defined(_WIN32) || defined(WIN32)

#define LOAD_SDK() LoadLibrary("vulkan-1.dll");
#define dlsym GetProcAddress

#endif

// BEGIN VULKAN PLATEFORM
//
// File: vk_platform.h
//
/*
** Copyright (c) 2014-2015 The Khronos Group Inc.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/


#ifndef VK_PLATFORM_H_
#define VK_PLATFORM_H_

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

    /*
    ***************************************************************************************************
    *   Platform-specific directives and type declarations
    ***************************************************************************************************
    */

    /* Platform-specific calling convention macros.
     *
     * Platforms should define these so that Vulkan clients call Vulkan commands
     * with the same calling conventions that the Vulkan implementation expects.
     *
     * VKAPI_ATTR - Placed before the return type in function declarations.
     *              Useful for C++11 and GCC/Clang-style function attribute syntax.
     * VKAPI_CALL - Placed after the return type in function declarations.
     *              Useful for MSVC-style calling convention syntax.
     * VKAPI_PTR  - Placed between the '(' and '*' in function pointer types.
     *
     * Function declaration:  VKAPI_ATTR void VKAPI_CALL vkCommand(void);
     * Function pointer type: typedef void (VKAPI_PTR *PFN_vkCommand)(void);
     */
#if defined(_WIN32)
    // On Windows, Vulkan commands use the stdcall convention
#define VKAPI_ATTR
#define VKAPI_CALL __stdcall
#define VKAPI_PTR  VKAPI_CALL
#elif defined(__ANDROID__) && defined(__ARM_ARCH) && __ARM_ARCH < 7
#error "Vulkan isn't supported for the 'armeabi' NDK ABI"
#elif defined(__ANDROID__) && defined(__ARM_ARCH) && __ARM_ARCH >= 7 && __ARM_32BIT_STATE
    // On Android 32-bit ARM targets, Vulkan functions use the "hardfloat"
    // calling convention, i.e. float parameters are passed in registers. This
    // is true even if the rest of the application passes floats on the stack,
    // as it does by default when compiling for the armeabi-v7a NDK ABI.
#define VKAPI_ATTR __attribute__((pcs("aapcs-vfp")))
#define VKAPI_CALL
#define VKAPI_PTR  VKAPI_ATTR
#else
    // On other platforms, use the default calling convention
#define VKAPI_ATTR
#define VKAPI_CALL
#define VKAPI_PTR
#endif

#include <stddef.h>

#if !defined(VK_NO_STDINT_H)
#if defined(_MSC_VER) && (_MSC_VER < 1600)
    typedef signed   __int8  int8_t;
    typedef unsigned __int8  uint8_t;
    typedef signed   __int16 int16_t;
    typedef unsigned __int16 uint16_t;
    typedef signed   __int32 int32_t;
    typedef unsigned __int32 uint32_t;
    typedef signed   __int64 int64_t;
    typedef unsigned __int64 uint64_t;
#else
#include <stdint.h>
#endif
#endif // !defined(VK_NO_STDINT_H)

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

// Platform-specific headers required by platform window system extensions.
// These are enabled prior to #including "vulkan.h". The same enable then
// controls inclusion of the extension interfaces in vulkan.h.

#ifdef VK_USE_PLATFORM_ANDROID_KHR
#include <android/native_window.h>
#endif

#ifdef VK_USE_PLATFORM_MIR_KHR
#include <mir_toolkit/client_types.h>
#endif

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
#include <wayland-client.h>
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
#include <windows.h>
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR
#include <X11/Xlib.h>
#endif

#ifdef VK_USE_PLATFORM_XCB_KHR
#include <xcb/xcb.h>
#endif

#endif
// END VULKAN PLATEFORM
// BEGIN VULKAN H
#ifndef VULKAN_H_
#define VULKAN_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

    /*
    ** Copyright (c) 2015-2016 The Khronos Group Inc.
    **
    ** Licensed under the Apache License, Version 2.0 (the "License");
    ** you may not use this file except in compliance with the License.
    ** You may obtain a copy of the License at
    **
    **     http://www.apache.org/licenses/LICENSE-2.0
    **
    ** Unless required by applicable law or agreed to in writing, software
    ** distributed under the License is distributed on an "AS IS" BASIS,
    ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    ** See the License for the specific language governing permissions and
    ** limitations under the License.
    */

    /*
    ** This header is generated from the Khronos Vulkan XML API Registry.
    **
    */


#define VK_VERSION_1_0 1

#define VK_MAKE_VERSION(major, minor, patch) \
    (((major) << 22) | ((minor) << 12) | (patch))

// DEPRECATED: This define has been removed. Specific version defines (e.g. VK_API_VERSION_1_0), or the VK_MAKE_VERSION macro, should be used instead.
//#define VK_API_VERSION VK_MAKE_VERSION(1, 0, 0)

// Vulkan 1.0 version number
#define VK_API_VERSION_1_0 VK_MAKE_VERSION(1, 0, 0)

#define VK_VERSION_MAJOR(version) ((uint32_t)(version) >> 22)
#define VK_VERSION_MINOR(version) (((uint32_t)(version) >> 12) & 0x3ff)
#define VK_VERSION_PATCH(version) ((uint32_t)(version) & 0xfff)
// Version of this file
#define VK_HEADER_VERSION 26


#define VK_NULL_HANDLE 0



#define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;


#if !defined(VK_DEFINE_NON_DISPATCHABLE_HANDLE)
#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
#define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
#else
#define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
#endif
#endif



    typedef uint32_t VkFlags;
    typedef uint32_t VkBool32;
    typedef uint64_t VkDeviceSize;
    typedef uint32_t VkSampleMask;

    VK_DEFINE_HANDLE(VkInstance)
    VK_DEFINE_HANDLE(VkPhysicalDevice)
    VK_DEFINE_HANDLE(VkDevice)
    VK_DEFINE_HANDLE(VkQueue)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSemaphore)
    VK_DEFINE_HANDLE(VkCommandBuffer)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFence)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDeviceMemory)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBuffer)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImage)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkEvent)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkQueryPool)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBufferView)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImageView)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkShaderModule)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineCache)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineLayout)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkRenderPass)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipeline)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSetLayout)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSampler)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorPool)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSet)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFramebuffer)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCommandPool)

#define VK_LOD_CLAMP_NONE                 1000.0f
#define VK_REMAINING_MIP_LEVELS           (~0U)
#define VK_REMAINING_ARRAY_LAYERS         (~0U)
#define VK_WHOLE_SIZE                     (~0ULL)
#define VK_ATTACHMENT_UNUSED              (~0U)
#define VK_TRUE                           1
#define VK_FALSE                          0
#define VK_QUEUE_FAMILY_IGNORED           (~0U)
#define VK_SUBPASS_EXTERNAL               (~0U)
#define VK_MAX_PHYSICAL_DEVICE_NAME_SIZE  256
#define VK_UUID_SIZE                      16
#define VK_MAX_MEMORY_TYPES               32
#define VK_MAX_MEMORY_HEAPS               16
#define VK_MAX_EXTENSION_NAME_SIZE        256
#define VK_MAX_DESCRIPTION_SIZE           256


    typedef enum VkPipelineCacheHeaderVersion {
        VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
        VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
        VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
        VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE = (VK_PIPELINE_CACHE_HEADER_VERSION_ONE - VK_PIPELINE_CACHE_HEADER_VERSION_ONE + 1),
        VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 0x7FFFFFFF
    } VkPipelineCacheHeaderVersion;

    typedef enum VkResult {
        VK_SUCCESS = 0,
        VK_NOT_READY = 1,
        VK_TIMEOUT = 2,
        VK_EVENT_SET = 3,
        VK_EVENT_RESET = 4,
        VK_INCOMPLETE = 5,
        VK_ERROR_OUT_OF_HOST_MEMORY = -1,
        VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
        VK_ERROR_INITIALIZATION_FAILED = -3,
        VK_ERROR_DEVICE_LOST = -4,
        VK_ERROR_MEMORY_MAP_FAILED = -5,
        VK_ERROR_LAYER_NOT_PRESENT = -6,
        VK_ERROR_EXTENSION_NOT_PRESENT = -7,
        VK_ERROR_FEATURE_NOT_PRESENT = -8,
        VK_ERROR_INCOMPATIBLE_DRIVER = -9,
        VK_ERROR_TOO_MANY_OBJECTS = -10,
        VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
        VK_ERROR_FRAGMENTED_POOL = -12,
        VK_ERROR_SURFACE_LOST_KHR = -1000000000,
        VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
        VK_SUBOPTIMAL_KHR = 1000001003,
        VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
        VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
        VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
        VK_ERROR_INVALID_SHADER_NV = -1000012000,
        VK_RESULT_BEGIN_RANGE = VK_ERROR_FRAGMENTED_POOL,
        VK_RESULT_END_RANGE = VK_INCOMPLETE,
        VK_RESULT_RANGE_SIZE = (VK_INCOMPLETE - VK_ERROR_FRAGMENTED_POOL + 1),
        VK_RESULT_MAX_ENUM = 0x7FFFFFFF
    } VkResult;

    typedef enum VkStructureType {
        VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
        VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
        VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
        VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
        VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
        VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
        VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
        VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
        VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
        VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
        VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
        VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
        VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
        VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
        VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
        VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
        VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
        VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
        VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
        VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
        VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
        VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
        VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
        VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
        VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
        VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
        VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
        VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
        VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
        VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
        VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
        VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
        VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
        VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
        VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
        VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
        VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
        VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
        VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
        VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
        VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
        VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
        VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
        VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
        VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
        VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
        VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
        VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
        VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
        VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
        VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
        VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = 1000007000,
        VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
        VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
        VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
        VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
        VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
        VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
        VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
        VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
        VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
        VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
        VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
        VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
        VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
        VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
        VK_STRUCTURE_TYPE_BEGIN_RANGE = VK_STRUCTURE_TYPE_APPLICATION_INFO,
        VK_STRUCTURE_TYPE_END_RANGE = VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
        VK_STRUCTURE_TYPE_RANGE_SIZE = (VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO - VK_STRUCTURE_TYPE_APPLICATION_INFO + 1),
        VK_STRUCTURE_TYPE_MAX_ENUM = 0x7FFFFFFF
    } VkStructureType;

    typedef enum VkSystemAllocationScope {
        VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
        VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
        VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
        VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
        VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
        VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
        VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
        VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE = (VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE - VK_SYSTEM_ALLOCATION_SCOPE_COMMAND + 1),
        VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 0x7FFFFFFF
    } VkSystemAllocationScope;

    typedef enum VkInternalAllocationType {
        VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
        VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
        VK_INTERNAL_ALLOCATION_TYPE_END_RANGE = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
        VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE = (VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE - VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE + 1),
        VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 0x7FFFFFFF
    } VkInternalAllocationType;

    typedef enum VkFormat {
        VK_FORMAT_UNDEFINED = 0,
        VK_FORMAT_R4G4_UNORM_PACK8 = 1,
        VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
        VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
        VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
        VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
        VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
        VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
        VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
        VK_FORMAT_R8_UNORM = 9,
        VK_FORMAT_R8_SNORM = 10,
        VK_FORMAT_R8_USCALED = 11,
        VK_FORMAT_R8_SSCALED = 12,
        VK_FORMAT_R8_UINT = 13,
        VK_FORMAT_R8_SINT = 14,
        VK_FORMAT_R8_SRGB = 15,
        VK_FORMAT_R8G8_UNORM = 16,
        VK_FORMAT_R8G8_SNORM = 17,
        VK_FORMAT_R8G8_USCALED = 18,
        VK_FORMAT_R8G8_SSCALED = 19,
        VK_FORMAT_R8G8_UINT = 20,
        VK_FORMAT_R8G8_SINT = 21,
        VK_FORMAT_R8G8_SRGB = 22,
        VK_FORMAT_R8G8B8_UNORM = 23,
        VK_FORMAT_R8G8B8_SNORM = 24,
        VK_FORMAT_R8G8B8_USCALED = 25,
        VK_FORMAT_R8G8B8_SSCALED = 26,
        VK_FORMAT_R8G8B8_UINT = 27,
        VK_FORMAT_R8G8B8_SINT = 28,
        VK_FORMAT_R8G8B8_SRGB = 29,
        VK_FORMAT_B8G8R8_UNORM = 30,
        VK_FORMAT_B8G8R8_SNORM = 31,
        VK_FORMAT_B8G8R8_USCALED = 32,
        VK_FORMAT_B8G8R8_SSCALED = 33,
        VK_FORMAT_B8G8R8_UINT = 34,
        VK_FORMAT_B8G8R8_SINT = 35,
        VK_FORMAT_B8G8R8_SRGB = 36,
        VK_FORMAT_R8G8B8A8_UNORM = 37,
        VK_FORMAT_R8G8B8A8_SNORM = 38,
        VK_FORMAT_R8G8B8A8_USCALED = 39,
        VK_FORMAT_R8G8B8A8_SSCALED = 40,
        VK_FORMAT_R8G8B8A8_UINT = 41,
        VK_FORMAT_R8G8B8A8_SINT = 42,
        VK_FORMAT_R8G8B8A8_SRGB = 43,
        VK_FORMAT_B8G8R8A8_UNORM = 44,
        VK_FORMAT_B8G8R8A8_SNORM = 45,
        VK_FORMAT_B8G8R8A8_USCALED = 46,
        VK_FORMAT_B8G8R8A8_SSCALED = 47,
        VK_FORMAT_B8G8R8A8_UINT = 48,
        VK_FORMAT_B8G8R8A8_SINT = 49,
        VK_FORMAT_B8G8R8A8_SRGB = 50,
        VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
        VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
        VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
        VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
        VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
        VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
        VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
        VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
        VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
        VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
        VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
        VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
        VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
        VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
        VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
        VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
        VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
        VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
        VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
        VK_FORMAT_R16_UNORM = 70,
        VK_FORMAT_R16_SNORM = 71,
        VK_FORMAT_R16_USCALED = 72,
        VK_FORMAT_R16_SSCALED = 73,
        VK_FORMAT_R16_UINT = 74,
        VK_FORMAT_R16_SINT = 75,
        VK_FORMAT_R16_SFLOAT = 76,
        VK_FORMAT_R16G16_UNORM = 77,
        VK_FORMAT_R16G16_SNORM = 78,
        VK_FORMAT_R16G16_USCALED = 79,
        VK_FORMAT_R16G16_SSCALED = 80,
        VK_FORMAT_R16G16_UINT = 81,
        VK_FORMAT_R16G16_SINT = 82,
        VK_FORMAT_R16G16_SFLOAT = 83,
        VK_FORMAT_R16G16B16_UNORM = 84,
        VK_FORMAT_R16G16B16_SNORM = 85,
        VK_FORMAT_R16G16B16_USCALED = 86,
        VK_FORMAT_R16G16B16_SSCALED = 87,
        VK_FORMAT_R16G16B16_UINT = 88,
        VK_FORMAT_R16G16B16_SINT = 89,
        VK_FORMAT_R16G16B16_SFLOAT = 90,
        VK_FORMAT_R16G16B16A16_UNORM = 91,
        VK_FORMAT_R16G16B16A16_SNORM = 92,
        VK_FORMAT_R16G16B16A16_USCALED = 93,
        VK_FORMAT_R16G16B16A16_SSCALED = 94,
        VK_FORMAT_R16G16B16A16_UINT = 95,
        VK_FORMAT_R16G16B16A16_SINT = 96,
        VK_FORMAT_R16G16B16A16_SFLOAT = 97,
        VK_FORMAT_R32_UINT = 98,
        VK_FORMAT_R32_SINT = 99,
        VK_FORMAT_R32_SFLOAT = 100,
        VK_FORMAT_R32G32_UINT = 101,
        VK_FORMAT_R32G32_SINT = 102,
        VK_FORMAT_R32G32_SFLOAT = 103,
        VK_FORMAT_R32G32B32_UINT = 104,
        VK_FORMAT_R32G32B32_SINT = 105,
        VK_FORMAT_R32G32B32_SFLOAT = 106,
        VK_FORMAT_R32G32B32A32_UINT = 107,
        VK_FORMAT_R32G32B32A32_SINT = 108,
        VK_FORMAT_R32G32B32A32_SFLOAT = 109,
        VK_FORMAT_R64_UINT = 110,
        VK_FORMAT_R64_SINT = 111,
        VK_FORMAT_R64_SFLOAT = 112,
        VK_FORMAT_R64G64_UINT = 113,
        VK_FORMAT_R64G64_SINT = 114,
        VK_FORMAT_R64G64_SFLOAT = 115,
        VK_FORMAT_R64G64B64_UINT = 116,
        VK_FORMAT_R64G64B64_SINT = 117,
        VK_FORMAT_R64G64B64_SFLOAT = 118,
        VK_FORMAT_R64G64B64A64_UINT = 119,
        VK_FORMAT_R64G64B64A64_SINT = 120,
        VK_FORMAT_R64G64B64A64_SFLOAT = 121,
        VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
        VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
        VK_FORMAT_D16_UNORM = 124,
        VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
        VK_FORMAT_D32_SFLOAT = 126,
        VK_FORMAT_S8_UINT = 127,
        VK_FORMAT_D16_UNORM_S8_UINT = 128,
        VK_FORMAT_D24_UNORM_S8_UINT = 129,
        VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
        VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
        VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
        VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
        VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
        VK_FORMAT_BC2_UNORM_BLOCK = 135,
        VK_FORMAT_BC2_SRGB_BLOCK = 136,
        VK_FORMAT_BC3_UNORM_BLOCK = 137,
        VK_FORMAT_BC3_SRGB_BLOCK = 138,
        VK_FORMAT_BC4_UNORM_BLOCK = 139,
        VK_FORMAT_BC4_SNORM_BLOCK = 140,
        VK_FORMAT_BC5_UNORM_BLOCK = 141,
        VK_FORMAT_BC5_SNORM_BLOCK = 142,
        VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
        VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
        VK_FORMAT_BC7_UNORM_BLOCK = 145,
        VK_FORMAT_BC7_SRGB_BLOCK = 146,
        VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
        VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
        VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
        VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
        VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
        VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
        VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
        VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
        VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
        VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
        VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
        VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
        VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
        VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
        VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
        VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
        VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
        VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
        VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
        VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
        VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
        VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
        VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
        VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
        VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
        VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
        VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
        VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
        VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
        VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
        VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
        VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
        VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
        VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
        VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
        VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
        VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
        VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
        VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
        VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
        VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
        VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
        VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
        VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
        VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
        VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
        VK_FORMAT_BEGIN_RANGE = VK_FORMAT_UNDEFINED,
        VK_FORMAT_END_RANGE = VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
        VK_FORMAT_RANGE_SIZE = (VK_FORMAT_ASTC_12x12_SRGB_BLOCK - VK_FORMAT_UNDEFINED + 1),
        VK_FORMAT_MAX_ENUM = 0x7FFFFFFF
    } VkFormat;

    typedef enum VkImageType {
        VK_IMAGE_TYPE_1D = 0,
        VK_IMAGE_TYPE_2D = 1,
        VK_IMAGE_TYPE_3D = 2,
        VK_IMAGE_TYPE_BEGIN_RANGE = VK_IMAGE_TYPE_1D,
        VK_IMAGE_TYPE_END_RANGE = VK_IMAGE_TYPE_3D,
        VK_IMAGE_TYPE_RANGE_SIZE = (VK_IMAGE_TYPE_3D - VK_IMAGE_TYPE_1D + 1),
        VK_IMAGE_TYPE_MAX_ENUM = 0x7FFFFFFF
    } VkImageType;

    typedef enum VkImageTiling {
        VK_IMAGE_TILING_OPTIMAL = 0,
        VK_IMAGE_TILING_LINEAR = 1,
        VK_IMAGE_TILING_BEGIN_RANGE = VK_IMAGE_TILING_OPTIMAL,
        VK_IMAGE_TILING_END_RANGE = VK_IMAGE_TILING_LINEAR,
        VK_IMAGE_TILING_RANGE_SIZE = (VK_IMAGE_TILING_LINEAR - VK_IMAGE_TILING_OPTIMAL + 1),
        VK_IMAGE_TILING_MAX_ENUM = 0x7FFFFFFF
    } VkImageTiling;

    typedef enum VkPhysicalDeviceType {
        VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
        VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
        VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
        VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
        VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
        VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE = VK_PHYSICAL_DEVICE_TYPE_OTHER,
        VK_PHYSICAL_DEVICE_TYPE_END_RANGE = VK_PHYSICAL_DEVICE_TYPE_CPU,
        VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE = (VK_PHYSICAL_DEVICE_TYPE_CPU - VK_PHYSICAL_DEVICE_TYPE_OTHER + 1),
        VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 0x7FFFFFFF
    } VkPhysicalDeviceType;

    typedef enum VkQueryType {
        VK_QUERY_TYPE_OCCLUSION = 0,
        VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
        VK_QUERY_TYPE_TIMESTAMP = 2,
        VK_QUERY_TYPE_BEGIN_RANGE = VK_QUERY_TYPE_OCCLUSION,
        VK_QUERY_TYPE_END_RANGE = VK_QUERY_TYPE_TIMESTAMP,
        VK_QUERY_TYPE_RANGE_SIZE = (VK_QUERY_TYPE_TIMESTAMP - VK_QUERY_TYPE_OCCLUSION + 1),
        VK_QUERY_TYPE_MAX_ENUM = 0x7FFFFFFF
    } VkQueryType;

    typedef enum VkSharingMode {
        VK_SHARING_MODE_EXCLUSIVE = 0,
        VK_SHARING_MODE_CONCURRENT = 1,
        VK_SHARING_MODE_BEGIN_RANGE = VK_SHARING_MODE_EXCLUSIVE,
        VK_SHARING_MODE_END_RANGE = VK_SHARING_MODE_CONCURRENT,
        VK_SHARING_MODE_RANGE_SIZE = (VK_SHARING_MODE_CONCURRENT - VK_SHARING_MODE_EXCLUSIVE + 1),
        VK_SHARING_MODE_MAX_ENUM = 0x7FFFFFFF
    } VkSharingMode;

    typedef enum VkImageLayout {
        VK_IMAGE_LAYOUT_UNDEFINED = 0,
        VK_IMAGE_LAYOUT_GENERAL = 1,
        VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
        VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
        VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
        VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
        VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
        VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
        VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
        VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
        VK_IMAGE_LAYOUT_BEGIN_RANGE = VK_IMAGE_LAYOUT_UNDEFINED,
        VK_IMAGE_LAYOUT_END_RANGE = VK_IMAGE_LAYOUT_PREINITIALIZED,
        VK_IMAGE_LAYOUT_RANGE_SIZE = (VK_IMAGE_LAYOUT_PREINITIALIZED - VK_IMAGE_LAYOUT_UNDEFINED + 1),
        VK_IMAGE_LAYOUT_MAX_ENUM = 0x7FFFFFFF
    } VkImageLayout;

    typedef enum VkImageViewType {
        VK_IMAGE_VIEW_TYPE_1D = 0,
        VK_IMAGE_VIEW_TYPE_2D = 1,
        VK_IMAGE_VIEW_TYPE_3D = 2,
        VK_IMAGE_VIEW_TYPE_CUBE = 3,
        VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
        VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
        VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
        VK_IMAGE_VIEW_TYPE_BEGIN_RANGE = VK_IMAGE_VIEW_TYPE_1D,
        VK_IMAGE_VIEW_TYPE_END_RANGE = VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
        VK_IMAGE_VIEW_TYPE_RANGE_SIZE = (VK_IMAGE_VIEW_TYPE_CUBE_ARRAY - VK_IMAGE_VIEW_TYPE_1D + 1),
        VK_IMAGE_VIEW_TYPE_MAX_ENUM = 0x7FFFFFFF
    } VkImageViewType;

    typedef enum VkComponentSwizzle {
        VK_COMPONENT_SWIZZLE_IDENTITY = 0,
        VK_COMPONENT_SWIZZLE_ZERO = 1,
        VK_COMPONENT_SWIZZLE_ONE = 2,
        VK_COMPONENT_SWIZZLE_R = 3,
        VK_COMPONENT_SWIZZLE_G = 4,
        VK_COMPONENT_SWIZZLE_B = 5,
        VK_COMPONENT_SWIZZLE_A = 6,
        VK_COMPONENT_SWIZZLE_BEGIN_RANGE = VK_COMPONENT_SWIZZLE_IDENTITY,
        VK_COMPONENT_SWIZZLE_END_RANGE = VK_COMPONENT_SWIZZLE_A,
        VK_COMPONENT_SWIZZLE_RANGE_SIZE = (VK_COMPONENT_SWIZZLE_A - VK_COMPONENT_SWIZZLE_IDENTITY + 1),
        VK_COMPONENT_SWIZZLE_MAX_ENUM = 0x7FFFFFFF
    } VkComponentSwizzle;

    typedef enum VkVertexInputRate {
        VK_VERTEX_INPUT_RATE_VERTEX = 0,
        VK_VERTEX_INPUT_RATE_INSTANCE = 1,
        VK_VERTEX_INPUT_RATE_BEGIN_RANGE = VK_VERTEX_INPUT_RATE_VERTEX,
        VK_VERTEX_INPUT_RATE_END_RANGE = VK_VERTEX_INPUT_RATE_INSTANCE,
        VK_VERTEX_INPUT_RATE_RANGE_SIZE = (VK_VERTEX_INPUT_RATE_INSTANCE - VK_VERTEX_INPUT_RATE_VERTEX + 1),
        VK_VERTEX_INPUT_RATE_MAX_ENUM = 0x7FFFFFFF
    } VkVertexInputRate;

    typedef enum VkPrimitiveTopology {
        VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
        VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
        VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
        VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
        VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
        VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
        VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE = VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
        VK_PRIMITIVE_TOPOLOGY_END_RANGE = VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
        VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE = (VK_PRIMITIVE_TOPOLOGY_PATCH_LIST - VK_PRIMITIVE_TOPOLOGY_POINT_LIST + 1),
        VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = 0x7FFFFFFF
    } VkPrimitiveTopology;

    typedef enum VkPolygonMode {
        VK_POLYGON_MODE_FILL = 0,
        VK_POLYGON_MODE_LINE = 1,
        VK_POLYGON_MODE_POINT = 2,
        VK_POLYGON_MODE_BEGIN_RANGE = VK_POLYGON_MODE_FILL,
        VK_POLYGON_MODE_END_RANGE = VK_POLYGON_MODE_POINT,
        VK_POLYGON_MODE_RANGE_SIZE = (VK_POLYGON_MODE_POINT - VK_POLYGON_MODE_FILL + 1),
        VK_POLYGON_MODE_MAX_ENUM = 0x7FFFFFFF
    } VkPolygonMode;

    typedef enum VkFrontFace {
        VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
        VK_FRONT_FACE_CLOCKWISE = 1,
        VK_FRONT_FACE_BEGIN_RANGE = VK_FRONT_FACE_COUNTER_CLOCKWISE,
        VK_FRONT_FACE_END_RANGE = VK_FRONT_FACE_CLOCKWISE,
        VK_FRONT_FACE_RANGE_SIZE = (VK_FRONT_FACE_CLOCKWISE - VK_FRONT_FACE_COUNTER_CLOCKWISE + 1),
        VK_FRONT_FACE_MAX_ENUM = 0x7FFFFFFF
    } VkFrontFace;

    typedef enum VkCompareOp {
        VK_COMPARE_OP_NEVER = 0,
        VK_COMPARE_OP_LESS = 1,
        VK_COMPARE_OP_EQUAL = 2,
        VK_COMPARE_OP_LESS_OR_EQUAL = 3,
        VK_COMPARE_OP_GREATER = 4,
        VK_COMPARE_OP_NOT_EQUAL = 5,
        VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
        VK_COMPARE_OP_ALWAYS = 7,
        VK_COMPARE_OP_BEGIN_RANGE = VK_COMPARE_OP_NEVER,
        VK_COMPARE_OP_END_RANGE = VK_COMPARE_OP_ALWAYS,
        VK_COMPARE_OP_RANGE_SIZE = (VK_COMPARE_OP_ALWAYS - VK_COMPARE_OP_NEVER + 1),
        VK_COMPARE_OP_MAX_ENUM = 0x7FFFFFFF
    } VkCompareOp;

    typedef enum VkStencilOp {
        VK_STENCIL_OP_KEEP = 0,
        VK_STENCIL_OP_ZERO = 1,
        VK_STENCIL_OP_REPLACE = 2,
        VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
        VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
        VK_STENCIL_OP_INVERT = 5,
        VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
        VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
        VK_STENCIL_OP_BEGIN_RANGE = VK_STENCIL_OP_KEEP,
        VK_STENCIL_OP_END_RANGE = VK_STENCIL_OP_DECREMENT_AND_WRAP,
        VK_STENCIL_OP_RANGE_SIZE = (VK_STENCIL_OP_DECREMENT_AND_WRAP - VK_STENCIL_OP_KEEP + 1),
        VK_STENCIL_OP_MAX_ENUM = 0x7FFFFFFF
    } VkStencilOp;

    typedef enum VkLogicOp {
        VK_LOGIC_OP_CLEAR = 0,
        VK_LOGIC_OP_AND = 1,
        VK_LOGIC_OP_AND_REVERSE = 2,
        VK_LOGIC_OP_COPY = 3,
        VK_LOGIC_OP_AND_INVERTED = 4,
        VK_LOGIC_OP_NO_OP = 5,
        VK_LOGIC_OP_XOR = 6,
        VK_LOGIC_OP_OR = 7,
        VK_LOGIC_OP_NOR = 8,
        VK_LOGIC_OP_EQUIVALENT = 9,
        VK_LOGIC_OP_INVERT = 10,
        VK_LOGIC_OP_OR_REVERSE = 11,
        VK_LOGIC_OP_COPY_INVERTED = 12,
        VK_LOGIC_OP_OR_INVERTED = 13,
        VK_LOGIC_OP_NAND = 14,
        VK_LOGIC_OP_SET = 15,
        VK_LOGIC_OP_BEGIN_RANGE = VK_LOGIC_OP_CLEAR,
        VK_LOGIC_OP_END_RANGE = VK_LOGIC_OP_SET,
        VK_LOGIC_OP_RANGE_SIZE = (VK_LOGIC_OP_SET - VK_LOGIC_OP_CLEAR + 1),
        VK_LOGIC_OP_MAX_ENUM = 0x7FFFFFFF
    } VkLogicOp;

    typedef enum VkBlendFactor {
        VK_BLEND_FACTOR_ZERO = 0,
        VK_BLEND_FACTOR_ONE = 1,
        VK_BLEND_FACTOR_SRC_COLOR = 2,
        VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
        VK_BLEND_FACTOR_DST_COLOR = 4,
        VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
        VK_BLEND_FACTOR_SRC_ALPHA = 6,
        VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
        VK_BLEND_FACTOR_DST_ALPHA = 8,
        VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
        VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
        VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
        VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
        VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
        VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
        VK_BLEND_FACTOR_SRC1_COLOR = 15,
        VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
        VK_BLEND_FACTOR_SRC1_ALPHA = 17,
        VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
        VK_BLEND_FACTOR_BEGIN_RANGE = VK_BLEND_FACTOR_ZERO,
        VK_BLEND_FACTOR_END_RANGE = VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
        VK_BLEND_FACTOR_RANGE_SIZE = (VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA - VK_BLEND_FACTOR_ZERO + 1),
        VK_BLEND_FACTOR_MAX_ENUM = 0x7FFFFFFF
    } VkBlendFactor;

    typedef enum VkBlendOp {
        VK_BLEND_OP_ADD = 0,
        VK_BLEND_OP_SUBTRACT = 1,
        VK_BLEND_OP_REVERSE_SUBTRACT = 2,
        VK_BLEND_OP_MIN = 3,
        VK_BLEND_OP_MAX = 4,
        VK_BLEND_OP_BEGIN_RANGE = VK_BLEND_OP_ADD,
        VK_BLEND_OP_END_RANGE = VK_BLEND_OP_MAX,
        VK_BLEND_OP_RANGE_SIZE = (VK_BLEND_OP_MAX - VK_BLEND_OP_ADD + 1),
        VK_BLEND_OP_MAX_ENUM = 0x7FFFFFFF
    } VkBlendOp;

    typedef enum VkDynamicState {
        VK_DYNAMIC_STATE_VIEWPORT = 0,
        VK_DYNAMIC_STATE_SCISSOR = 1,
        VK_DYNAMIC_STATE_LINE_WIDTH = 2,
        VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
        VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
        VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
        VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
        VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
        VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
        VK_DYNAMIC_STATE_BEGIN_RANGE = VK_DYNAMIC_STATE_VIEWPORT,
        VK_DYNAMIC_STATE_END_RANGE = VK_DYNAMIC_STATE_STENCIL_REFERENCE,
        VK_DYNAMIC_STATE_RANGE_SIZE = (VK_DYNAMIC_STATE_STENCIL_REFERENCE - VK_DYNAMIC_STATE_VIEWPORT + 1),
        VK_DYNAMIC_STATE_MAX_ENUM = 0x7FFFFFFF
    } VkDynamicState;

    typedef enum VkFilter {
        VK_FILTER_NEAREST = 0,
        VK_FILTER_LINEAR = 1,
        VK_FILTER_CUBIC_IMG = 1000015000,
        VK_FILTER_BEGIN_RANGE = VK_FILTER_NEAREST,
        VK_FILTER_END_RANGE = VK_FILTER_LINEAR,
        VK_FILTER_RANGE_SIZE = (VK_FILTER_LINEAR - VK_FILTER_NEAREST + 1),
        VK_FILTER_MAX_ENUM = 0x7FFFFFFF
    } VkFilter;

    typedef enum VkSamplerMipmapMode {
        VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
        VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
        VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE = VK_SAMPLER_MIPMAP_MODE_NEAREST,
        VK_SAMPLER_MIPMAP_MODE_END_RANGE = VK_SAMPLER_MIPMAP_MODE_LINEAR,
        VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE = (VK_SAMPLER_MIPMAP_MODE_LINEAR - VK_SAMPLER_MIPMAP_MODE_NEAREST + 1),
        VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = 0x7FFFFFFF
    } VkSamplerMipmapMode;

    typedef enum VkSamplerAddressMode {
        VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
        VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
        VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
        VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
        VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
        VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE = VK_SAMPLER_ADDRESS_MODE_REPEAT,
        VK_SAMPLER_ADDRESS_MODE_END_RANGE = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
        VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE = (VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER - VK_SAMPLER_ADDRESS_MODE_REPEAT + 1),
        VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = 0x7FFFFFFF
    } VkSamplerAddressMode;

    typedef enum VkBorderColor {
        VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
        VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
        VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
        VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
        VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
        VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
        VK_BORDER_COLOR_BEGIN_RANGE = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
        VK_BORDER_COLOR_END_RANGE = VK_BORDER_COLOR_INT_OPAQUE_WHITE,
        VK_BORDER_COLOR_RANGE_SIZE = (VK_BORDER_COLOR_INT_OPAQUE_WHITE - VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK + 1),
        VK_BORDER_COLOR_MAX_ENUM = 0x7FFFFFFF
    } VkBorderColor;

    typedef enum VkDescriptorType {
        VK_DESCRIPTOR_TYPE_SAMPLER = 0,
        VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
        VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
        VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
        VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
        VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
        VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
        VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
        VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
        VK_DESCRIPTOR_TYPE_BEGIN_RANGE = VK_DESCRIPTOR_TYPE_SAMPLER,
        VK_DESCRIPTOR_TYPE_END_RANGE = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
        VK_DESCRIPTOR_TYPE_RANGE_SIZE = (VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT - VK_DESCRIPTOR_TYPE_SAMPLER + 1),
        VK_DESCRIPTOR_TYPE_MAX_ENUM = 0x7FFFFFFF
    } VkDescriptorType;

    typedef enum VkAttachmentLoadOp {
        VK_ATTACHMENT_LOAD_OP_LOAD = 0,
        VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
        VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
        VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE = VK_ATTACHMENT_LOAD_OP_LOAD,
        VK_ATTACHMENT_LOAD_OP_END_RANGE = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
        VK_ATTACHMENT_LOAD_OP_RANGE_SIZE = (VK_ATTACHMENT_LOAD_OP_DONT_CARE - VK_ATTACHMENT_LOAD_OP_LOAD + 1),
        VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 0x7FFFFFFF
    } VkAttachmentLoadOp;

    typedef enum VkAttachmentStoreOp {
        VK_ATTACHMENT_STORE_OP_STORE = 0,
        VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
        VK_ATTACHMENT_STORE_OP_BEGIN_RANGE = VK_ATTACHMENT_STORE_OP_STORE,
        VK_ATTACHMENT_STORE_OP_END_RANGE = VK_ATTACHMENT_STORE_OP_DONT_CARE,
        VK_ATTACHMENT_STORE_OP_RANGE_SIZE = (VK_ATTACHMENT_STORE_OP_DONT_CARE - VK_ATTACHMENT_STORE_OP_STORE + 1),
        VK_ATTACHMENT_STORE_OP_MAX_ENUM = 0x7FFFFFFF
    } VkAttachmentStoreOp;

    typedef enum VkPipelineBindPoint {
        VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
        VK_PIPELINE_BIND_POINT_COMPUTE = 1,
        VK_PIPELINE_BIND_POINT_BEGIN_RANGE = VK_PIPELINE_BIND_POINT_GRAPHICS,
        VK_PIPELINE_BIND_POINT_END_RANGE = VK_PIPELINE_BIND_POINT_COMPUTE,
        VK_PIPELINE_BIND_POINT_RANGE_SIZE = (VK_PIPELINE_BIND_POINT_COMPUTE - VK_PIPELINE_BIND_POINT_GRAPHICS + 1),
        VK_PIPELINE_BIND_POINT_MAX_ENUM = 0x7FFFFFFF
    } VkPipelineBindPoint;

    typedef enum VkCommandBufferLevel {
        VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
        VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
        VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
        VK_COMMAND_BUFFER_LEVEL_END_RANGE = VK_COMMAND_BUFFER_LEVEL_SECONDARY,
        VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE = (VK_COMMAND_BUFFER_LEVEL_SECONDARY - VK_COMMAND_BUFFER_LEVEL_PRIMARY + 1),
        VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 0x7FFFFFFF
    } VkCommandBufferLevel;

    typedef enum VkIndexType {
        VK_INDEX_TYPE_UINT16 = 0,
        VK_INDEX_TYPE_UINT32 = 1,
        VK_INDEX_TYPE_BEGIN_RANGE = VK_INDEX_TYPE_UINT16,
        VK_INDEX_TYPE_END_RANGE = VK_INDEX_TYPE_UINT32,
        VK_INDEX_TYPE_RANGE_SIZE = (VK_INDEX_TYPE_UINT32 - VK_INDEX_TYPE_UINT16 + 1),
        VK_INDEX_TYPE_MAX_ENUM = 0x7FFFFFFF
    } VkIndexType;

    typedef enum VkSubpassContents {
        VK_SUBPASS_CONTENTS_INLINE = 0,
        VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
        VK_SUBPASS_CONTENTS_BEGIN_RANGE = VK_SUBPASS_CONTENTS_INLINE,
        VK_SUBPASS_CONTENTS_END_RANGE = VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
        VK_SUBPASS_CONTENTS_RANGE_SIZE = (VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS - VK_SUBPASS_CONTENTS_INLINE + 1),
        VK_SUBPASS_CONTENTS_MAX_ENUM = 0x7FFFFFFF
    } VkSubpassContents;

    typedef VkFlags VkInstanceCreateFlags;

    typedef enum VkFormatFeatureFlagBits {
        VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001,
        VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002,
        VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004,
        VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008,
        VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010,
        VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020,
        VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040,
        VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080,
        VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100,
        VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200,
        VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400,
        VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800,
        VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000,
        VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 0x00002000,
        VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkFormatFeatureFlagBits;
    typedef VkFlags VkFormatFeatureFlags;

    typedef enum VkImageUsageFlagBits {
        VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001,
        VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002,
        VK_IMAGE_USAGE_SAMPLED_BIT = 0x00000004,
        VK_IMAGE_USAGE_STORAGE_BIT = 0x00000008,
        VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010,
        VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
        VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040,
        VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080,
        VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkImageUsageFlagBits;
    typedef VkFlags VkImageUsageFlags;

    typedef enum VkImageCreateFlagBits {
        VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001,
        VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
        VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
        VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008,
        VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010,
        VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkImageCreateFlagBits;
    typedef VkFlags VkImageCreateFlags;

    typedef enum VkSampleCountFlagBits {
        VK_SAMPLE_COUNT_1_BIT = 0x00000001,
        VK_SAMPLE_COUNT_2_BIT = 0x00000002,
        VK_SAMPLE_COUNT_4_BIT = 0x00000004,
        VK_SAMPLE_COUNT_8_BIT = 0x00000008,
        VK_SAMPLE_COUNT_16_BIT = 0x00000010,
        VK_SAMPLE_COUNT_32_BIT = 0x00000020,
        VK_SAMPLE_COUNT_64_BIT = 0x00000040,
        VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkSampleCountFlagBits;
    typedef VkFlags VkSampleCountFlags;

    typedef enum VkQueueFlagBits {
        VK_QUEUE_GRAPHICS_BIT = 0x00000001,
        VK_QUEUE_COMPUTE_BIT = 0x00000002,
        VK_QUEUE_TRANSFER_BIT = 0x00000004,
        VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
        VK_QUEUE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkQueueFlagBits;
    typedef VkFlags VkQueueFlags;

    typedef enum VkMemoryPropertyFlagBits {
        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
        VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
        VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
        VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
        VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
        VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkMemoryPropertyFlagBits;
    typedef VkFlags VkMemoryPropertyFlags;

    typedef enum VkMemoryHeapFlagBits {
        VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
        VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkMemoryHeapFlagBits;
    typedef VkFlags VkMemoryHeapFlags;
    typedef VkFlags VkDeviceCreateFlags;
    typedef VkFlags VkDeviceQueueCreateFlags;

    typedef enum VkPipelineStageFlagBits {
        VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001,
        VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002,
        VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004,
        VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008,
        VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010,
        VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020,
        VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040,
        VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080,
        VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100,
        VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200,
        VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400,
        VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800,
        VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000,
        VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000,
        VK_PIPELINE_STAGE_HOST_BIT = 0x00004000,
        VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000,
        VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000,
        VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkPipelineStageFlagBits;
    typedef VkFlags VkPipelineStageFlags;
    typedef VkFlags VkMemoryMapFlags;

    typedef enum VkImageAspectFlagBits {
        VK_IMAGE_ASPECT_COLOR_BIT = 0x00000001,
        VK_IMAGE_ASPECT_DEPTH_BIT = 0x00000002,
        VK_IMAGE_ASPECT_STENCIL_BIT = 0x00000004,
        VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
        VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkImageAspectFlagBits;
    typedef VkFlags VkImageAspectFlags;

    typedef enum VkSparseImageFormatFlagBits {
        VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001,
        VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002,
        VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
        VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkSparseImageFormatFlagBits;
    typedef VkFlags VkSparseImageFormatFlags;

    typedef enum VkSparseMemoryBindFlagBits {
        VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
        VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkSparseMemoryBindFlagBits;
    typedef VkFlags VkSparseMemoryBindFlags;

    typedef enum VkFenceCreateFlagBits {
        VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
        VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkFenceCreateFlagBits;
    typedef VkFlags VkFenceCreateFlags;
    typedef VkFlags VkSemaphoreCreateFlags;
    typedef VkFlags VkEventCreateFlags;
    typedef VkFlags VkQueryPoolCreateFlags;

    typedef enum VkQueryPipelineStatisticFlagBits {
        VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001,
        VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002,
        VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004,
        VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008,
        VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010,
        VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020,
        VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040,
        VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080,
        VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100,
        VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200,
        VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400,
        VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkQueryPipelineStatisticFlagBits;
    typedef VkFlags VkQueryPipelineStatisticFlags;

    typedef enum VkQueryResultFlagBits {
        VK_QUERY_RESULT_64_BIT = 0x00000001,
        VK_QUERY_RESULT_WAIT_BIT = 0x00000002,
        VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004,
        VK_QUERY_RESULT_PARTIAL_BIT = 0x00000008,
        VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkQueryResultFlagBits;
    typedef VkFlags VkQueryResultFlags;

    typedef enum VkBufferCreateFlagBits {
        VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001,
        VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
        VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
        VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkBufferCreateFlagBits;
    typedef VkFlags VkBufferCreateFlags;

    typedef enum VkBufferUsageFlagBits {
        VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001,
        VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002,
        VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,
        VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008,
        VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010,
        VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020,
        VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040,
        VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080,
        VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100,
        VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkBufferUsageFlagBits;
    typedef VkFlags VkBufferUsageFlags;
    typedef VkFlags VkBufferViewCreateFlags;
    typedef VkFlags VkImageViewCreateFlags;
    typedef VkFlags VkShaderModuleCreateFlags;
    typedef VkFlags VkPipelineCacheCreateFlags;

    typedef enum VkPipelineCreateFlagBits {
        VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
        VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002,
        VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004,
        VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkPipelineCreateFlagBits;
    typedef VkFlags VkPipelineCreateFlags;
    typedef VkFlags VkPipelineShaderStageCreateFlags;

    typedef enum VkShaderStageFlagBits {
        VK_SHADER_STAGE_VERTEX_BIT = 0x00000001,
        VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002,
        VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
        VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008,
        VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010,
        VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020,
        VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F,
        VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
        VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkShaderStageFlagBits;
    typedef VkFlags VkPipelineVertexInputStateCreateFlags;
    typedef VkFlags VkPipelineInputAssemblyStateCreateFlags;
    typedef VkFlags VkPipelineTessellationStateCreateFlags;
    typedef VkFlags VkPipelineViewportStateCreateFlags;
    typedef VkFlags VkPipelineRasterizationStateCreateFlags;

    typedef enum VkCullModeFlagBits {
        VK_CULL_MODE_NONE = 0,
        VK_CULL_MODE_FRONT_BIT = 0x00000001,
        VK_CULL_MODE_BACK_BIT = 0x00000002,
        VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
        VK_CULL_MODE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkCullModeFlagBits;
    typedef VkFlags VkCullModeFlags;
    typedef VkFlags VkPipelineMultisampleStateCreateFlags;
    typedef VkFlags VkPipelineDepthStencilStateCreateFlags;
    typedef VkFlags VkPipelineColorBlendStateCreateFlags;

    typedef enum VkColorComponentFlagBits {
        VK_COLOR_COMPONENT_R_BIT = 0x00000001,
        VK_COLOR_COMPONENT_G_BIT = 0x00000002,
        VK_COLOR_COMPONENT_B_BIT = 0x00000004,
        VK_COLOR_COMPONENT_A_BIT = 0x00000008,
        VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkColorComponentFlagBits;
    typedef VkFlags VkColorComponentFlags;
    typedef VkFlags VkPipelineDynamicStateCreateFlags;
    typedef VkFlags VkPipelineLayoutCreateFlags;
    typedef VkFlags VkShaderStageFlags;
    typedef VkFlags VkSamplerCreateFlags;
    typedef VkFlags VkDescriptorSetLayoutCreateFlags;

    typedef enum VkDescriptorPoolCreateFlagBits {
        VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
        VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkDescriptorPoolCreateFlagBits;
    typedef VkFlags VkDescriptorPoolCreateFlags;
    typedef VkFlags VkDescriptorPoolResetFlags;
    typedef VkFlags VkFramebufferCreateFlags;
    typedef VkFlags VkRenderPassCreateFlags;

    typedef enum VkAttachmentDescriptionFlagBits {
        VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001,
        VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkAttachmentDescriptionFlagBits;
    typedef VkFlags VkAttachmentDescriptionFlags;
    typedef VkFlags VkSubpassDescriptionFlags;

    typedef enum VkAccessFlagBits {
        VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001,
        VK_ACCESS_INDEX_READ_BIT = 0x00000002,
        VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004,
        VK_ACCESS_UNIFORM_READ_BIT = 0x00000008,
        VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010,
        VK_ACCESS_SHADER_READ_BIT = 0x00000020,
        VK_ACCESS_SHADER_WRITE_BIT = 0x00000040,
        VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080,
        VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100,
        VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200,
        VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
        VK_ACCESS_TRANSFER_READ_BIT = 0x00000800,
        VK_ACCESS_TRANSFER_WRITE_BIT = 0x00001000,
        VK_ACCESS_HOST_READ_BIT = 0x00002000,
        VK_ACCESS_HOST_WRITE_BIT = 0x00004000,
        VK_ACCESS_MEMORY_READ_BIT = 0x00008000,
        VK_ACCESS_MEMORY_WRITE_BIT = 0x00010000,
        VK_ACCESS_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkAccessFlagBits;
    typedef VkFlags VkAccessFlags;

    typedef enum VkDependencyFlagBits {
        VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
        VK_DEPENDENCY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkDependencyFlagBits;
    typedef VkFlags VkDependencyFlags;

    typedef enum VkCommandPoolCreateFlagBits {
        VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001,
        VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002,
        VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkCommandPoolCreateFlagBits;
    typedef VkFlags VkCommandPoolCreateFlags;

    typedef enum VkCommandPoolResetFlagBits {
        VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
        VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkCommandPoolResetFlagBits;
    typedef VkFlags VkCommandPoolResetFlags;

    typedef enum VkCommandBufferUsageFlagBits {
        VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001,
        VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
        VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004,
        VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkCommandBufferUsageFlagBits;
    typedef VkFlags VkCommandBufferUsageFlags;

    typedef enum VkQueryControlFlagBits {
        VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
        VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkQueryControlFlagBits;
    typedef VkFlags VkQueryControlFlags;

    typedef enum VkCommandBufferResetFlagBits {
        VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
        VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkCommandBufferResetFlagBits;
    typedef VkFlags VkCommandBufferResetFlags;

    typedef enum VkStencilFaceFlagBits {
        VK_STENCIL_FACE_FRONT_BIT = 0x00000001,
        VK_STENCIL_FACE_BACK_BIT = 0x00000002,
        VK_STENCIL_FRONT_AND_BACK = 0x00000003,
        VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
    } VkStencilFaceFlagBits;
    typedef VkFlags VkStencilFaceFlags;

    typedef void* (VKAPI_PTR *PFN_vkAllocationFunction)(
        void*                                       pUserData,
        size_t                                      size,
        size_t                                      alignment,
        VkSystemAllocationScope                     allocationScope);

    typedef void* (VKAPI_PTR *PFN_vkReallocationFunction)(
        void*                                       pUserData,
        void*                                       pOriginal,
        size_t                                      size,
        size_t                                      alignment,
        VkSystemAllocationScope                     allocationScope);

    typedef void (VKAPI_PTR *PFN_vkFreeFunction)(
        void*                                       pUserData,
        void*                                       pMemory);

    typedef void (VKAPI_PTR *PFN_vkInternalAllocationNotification)(
        void*                                       pUserData,
        size_t                                      size,
        VkInternalAllocationType                    allocationType,
        VkSystemAllocationScope                     allocationScope);

    typedef void (VKAPI_PTR *PFN_vkInternalFreeNotification)(
        void*                                       pUserData,
        size_t                                      size,
        VkInternalAllocationType                    allocationType,
        VkSystemAllocationScope                     allocationScope);

    typedef void (VKAPI_PTR *PFN_vkVoidFunction)(void);

    typedef struct VkApplicationInfo {
        VkStructureType    sType;
        void*        pNext;
        char*        pApplicationName;
        uint32_t           applicationVersion;
        char*        pEngineName;
        uint32_t           engineVersion;
        uint32_t           apiVersion;
    } VkApplicationInfo;

    typedef struct VkInstanceCreateInfo {
        VkStructureType             sType;
        void*                 pNext;
        VkInstanceCreateFlags       flags;
        VkApplicationInfo*    pApplicationInfo;
        uint32_t                    enabledLayerCount;
        char* *         ppEnabledLayerNames;
        uint32_t                    enabledExtensionCount;
        char* *         ppEnabledExtensionNames;
    } VkInstanceCreateInfo;

    typedef struct VkAllocationCallbacks {
        void*                                   pUserData;
        PFN_vkAllocationFunction                pfnAllocation;
        PFN_vkReallocationFunction              pfnReallocation;
        PFN_vkFreeFunction                      pfnFree;
        PFN_vkInternalAllocationNotification    pfnInternalAllocation;
        PFN_vkInternalFreeNotification          pfnInternalFree;
    } VkAllocationCallbacks;

    typedef struct VkPhysicalDeviceFeatures {
        VkBool32    robustBufferAccess;
        VkBool32    fullDrawIndexUint32;
        VkBool32    imageCubeArray;
        VkBool32    independentBlend;
        VkBool32    geometryShader;
        VkBool32    tessellationShader;
        VkBool32    sampleRateShading;
        VkBool32    dualSrcBlend;
        VkBool32    logicOp;
        VkBool32    multiDrawIndirect;
        VkBool32    drawIndirectFirstInstance;
        VkBool32    depthClamp;
        VkBool32    depthBiasClamp;
        VkBool32    fillModeNonSolid;
        VkBool32    depthBounds;
        VkBool32    wideLines;
        VkBool32    largePoints;
        VkBool32    alphaToOne;
        VkBool32    multiViewport;
        VkBool32    samplerAnisotropy;
        VkBool32    textureCompressionETC2;
        VkBool32    textureCompressionASTC_LDR;
        VkBool32    textureCompressionBC;
        VkBool32    occlusionQueryPrecise;
        VkBool32    pipelineStatisticsQuery;
        VkBool32    vertexPipelineStoresAndAtomics;
        VkBool32    fragmentStoresAndAtomics;
        VkBool32    shaderTessellationAndGeometryPointSize;
        VkBool32    shaderImageGatherExtended;
        VkBool32    shaderStorageImageExtendedFormats;
        VkBool32    shaderStorageImageMultisample;
        VkBool32    shaderStorageImageReadWithoutFormat;
        VkBool32    shaderStorageImageWriteWithoutFormat;
        VkBool32    shaderUniformBufferArrayDynamicIndexing;
        VkBool32    shaderSampledImageArrayDynamicIndexing;
        VkBool32    shaderStorageBufferArrayDynamicIndexing;
        VkBool32    shaderStorageImageArrayDynamicIndexing;
        VkBool32    shaderClipDistance;
        VkBool32    shaderCullDistance;
        VkBool32    shaderFloat64;
        VkBool32    shaderInt64;
        VkBool32    shaderInt16;
        VkBool32    shaderResourceResidency;
        VkBool32    shaderResourceMinLod;
        VkBool32    sparseBinding;
        VkBool32    sparseResidencyBuffer;
        VkBool32    sparseResidencyImage2D;
        VkBool32    sparseResidencyImage3D;
        VkBool32    sparseResidency2Samples;
        VkBool32    sparseResidency4Samples;
        VkBool32    sparseResidency8Samples;
        VkBool32    sparseResidency16Samples;
        VkBool32    sparseResidencyAliased;
        VkBool32    variableMultisampleRate;
        VkBool32    inheritedQueries;
    } VkPhysicalDeviceFeatures;

    typedef struct VkFormatProperties {
        VkFormatFeatureFlags    linearTilingFeatures;
        VkFormatFeatureFlags    optimalTilingFeatures;
        VkFormatFeatureFlags    bufferFeatures;
    } VkFormatProperties;

    typedef struct VkExtent3D {
        uint32_t    width;
        uint32_t    height;
        uint32_t    depth;
    } VkExtent3D;

    typedef struct VkImageFormatProperties {
        VkExtent3D            maxExtent;
        uint32_t              maxMipLevels;
        uint32_t              maxArrayLayers;
        VkSampleCountFlags    sampleCounts;
        VkDeviceSize          maxResourceSize;
    } VkImageFormatProperties;

    typedef struct VkPhysicalDeviceLimits {
        uint32_t              maxImageDimension1D;
        uint32_t              maxImageDimension2D;
        uint32_t              maxImageDimension3D;
        uint32_t              maxImageDimensionCube;
        uint32_t              maxImageArrayLayers;
        uint32_t              maxTexelBufferElements;
        uint32_t              maxUniformBufferRange;
        uint32_t              maxStorageBufferRange;
        uint32_t              maxPushConstantsSize;
        uint32_t              maxMemoryAllocationCount;
        uint32_t              maxSamplerAllocationCount;
        VkDeviceSize          bufferImageGranularity;
        VkDeviceSize          sparseAddressSpaceSize;
        uint32_t              maxBoundDescriptorSets;
        uint32_t              maxPerStageDescriptorSamplers;
        uint32_t              maxPerStageDescriptorUniformBuffers;
        uint32_t              maxPerStageDescriptorStorageBuffers;
        uint32_t              maxPerStageDescriptorSampledImages;
        uint32_t              maxPerStageDescriptorStorageImages;
        uint32_t              maxPerStageDescriptorInputAttachments;
        uint32_t              maxPerStageResources;
        uint32_t              maxDescriptorSetSamplers;
        uint32_t              maxDescriptorSetUniformBuffers;
        uint32_t              maxDescriptorSetUniformBuffersDynamic;
        uint32_t              maxDescriptorSetStorageBuffers;
        uint32_t              maxDescriptorSetStorageBuffersDynamic;
        uint32_t              maxDescriptorSetSampledImages;
        uint32_t              maxDescriptorSetStorageImages;
        uint32_t              maxDescriptorSetInputAttachments;
        uint32_t              maxVertexInputAttributes;
        uint32_t              maxVertexInputBindings;
        uint32_t              maxVertexInputAttributeOffset;
        uint32_t              maxVertexInputBindingStride;
        uint32_t              maxVertexOutputComponents;
        uint32_t              maxTessellationGenerationLevel;
        uint32_t              maxTessellationPatchSize;
        uint32_t              maxTessellationControlPerVertexInputComponents;
        uint32_t              maxTessellationControlPerVertexOutputComponents;
        uint32_t              maxTessellationControlPerPatchOutputComponents;
        uint32_t              maxTessellationControlTotalOutputComponents;
        uint32_t              maxTessellationEvaluationInputComponents;
        uint32_t              maxTessellationEvaluationOutputComponents;
        uint32_t              maxGeometryShaderInvocations;
        uint32_t              maxGeometryInputComponents;
        uint32_t              maxGeometryOutputComponents;
        uint32_t              maxGeometryOutputVertices;
        uint32_t              maxGeometryTotalOutputComponents;
        uint32_t              maxFragmentInputComponents;
        uint32_t              maxFragmentOutputAttachments;
        uint32_t              maxFragmentDualSrcAttachments;
        uint32_t              maxFragmentCombinedOutputResources;
        uint32_t              maxComputeSharedMemorySize;
        uint32_t              maxComputeWorkGroupCount[3];
        uint32_t              maxComputeWorkGroupInvocations;
        uint32_t              maxComputeWorkGroupSize[3];
        uint32_t              subPixelPrecisionBits;
        uint32_t              subTexelPrecisionBits;
        uint32_t              mipmapPrecisionBits;
        uint32_t              maxDrawIndexedIndexValue;
        uint32_t              maxDrawIndirectCount;
        float                 maxSamplerLodBias;
        float                 maxSamplerAnisotropy;
        uint32_t              maxViewports;
        uint32_t              maxViewportDimensions[2];
        float                 viewportBoundsRange[2];
        uint32_t              viewportSubPixelBits;
        size_t                minMemoryMapAlignment;
        VkDeviceSize          minTexelBufferOffsetAlignment;
        VkDeviceSize          minUniformBufferOffsetAlignment;
        VkDeviceSize          minStorageBufferOffsetAlignment;
        int32_t               minTexelOffset;
        uint32_t              maxTexelOffset;
        int32_t               minTexelGatherOffset;
        uint32_t              maxTexelGatherOffset;
        float                 minInterpolationOffset;
        float                 maxInterpolationOffset;
        uint32_t              subPixelInterpolationOffsetBits;
        uint32_t              maxFramebufferWidth;
        uint32_t              maxFramebufferHeight;
        uint32_t              maxFramebufferLayers;
        VkSampleCountFlags    framebufferColorSampleCounts;
        VkSampleCountFlags    framebufferDepthSampleCounts;
        VkSampleCountFlags    framebufferStencilSampleCounts;
        VkSampleCountFlags    framebufferNoAttachmentsSampleCounts;
        uint32_t              maxColorAttachments;
        VkSampleCountFlags    sampledImageColorSampleCounts;
        VkSampleCountFlags    sampledImageIntegerSampleCounts;
        VkSampleCountFlags    sampledImageDepthSampleCounts;
        VkSampleCountFlags    sampledImageStencilSampleCounts;
        VkSampleCountFlags    storageImageSampleCounts;
        uint32_t              maxSampleMaskWords;
        VkBool32              timestampComputeAndGraphics;
        float                 timestampPeriod;
        uint32_t              maxClipDistances;
        uint32_t              maxCullDistances;
        uint32_t              maxCombinedClipAndCullDistances;
        uint32_t              discreteQueuePriorities;
        float                 pointSizeRange[2];
        float                 lineWidthRange[2];
        float                 pointSizeGranularity;
        float                 lineWidthGranularity;
        VkBool32              strictLines;
        VkBool32              standardSampleLocations;
        VkDeviceSize          optimalBufferCopyOffsetAlignment;
        VkDeviceSize          optimalBufferCopyRowPitchAlignment;
        VkDeviceSize          nonCoherentAtomSize;
    } VkPhysicalDeviceLimits;

    typedef struct VkPhysicalDeviceSparseProperties {
        VkBool32    residencyStandard2DBlockShape;
        VkBool32    residencyStandard2DMultisampleBlockShape;
        VkBool32    residencyStandard3DBlockShape;
        VkBool32    residencyAlignedMipSize;
        VkBool32    residencyNonResidentStrict;
    } VkPhysicalDeviceSparseProperties;

    typedef struct VkPhysicalDeviceProperties {
        uint32_t                            apiVersion;
        uint32_t                            driverVersion;
        uint32_t                            vendorID;
        uint32_t                            deviceID;
        VkPhysicalDeviceType                deviceType;
        char                                deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
        uint8_t                             pipelineCacheUUID[VK_UUID_SIZE];
        VkPhysicalDeviceLimits              limits;
        VkPhysicalDeviceSparseProperties    sparseProperties;
    } VkPhysicalDeviceProperties;

    typedef struct VkQueueFamilyProperties {
        VkQueueFlags    queueFlags;
        uint32_t        queueCount;
        uint32_t        timestampValidBits;
        VkExtent3D      minImageTransferGranularity;
    } VkQueueFamilyProperties;

    typedef struct VkMemoryType {
        VkMemoryPropertyFlags    propertyFlags;
        uint32_t                 heapIndex;
    } VkMemoryType;

    typedef struct VkMemoryHeap {
        VkDeviceSize         size;
        VkMemoryHeapFlags    flags;
    } VkMemoryHeap;

    typedef struct VkPhysicalDeviceMemoryProperties {
        uint32_t        memoryTypeCount;
        VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];
        uint32_t        memoryHeapCount;
        VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];
    } VkPhysicalDeviceMemoryProperties;

    typedef struct VkDeviceQueueCreateInfo {
        VkStructureType             sType;
        void*                 pNext;
        VkDeviceQueueCreateFlags    flags;
        uint32_t                    queueFamilyIndex;
        uint32_t                    queueCount;
        float*                pQueuePriorities;
    } VkDeviceQueueCreateInfo;

    typedef struct VkDeviceCreateInfo {
        VkStructureType                    sType;
        void*                        pNext;
        VkDeviceCreateFlags                flags;
        uint32_t                           queueCreateInfoCount;
        VkDeviceQueueCreateInfo*     pQueueCreateInfos;
        uint32_t                           enabledLayerCount;
        char* *                ppEnabledLayerNames;
        uint32_t                           enabledExtensionCount;
        char* *                ppEnabledExtensionNames;
        VkPhysicalDeviceFeatures*    pEnabledFeatures;
    } VkDeviceCreateInfo;

    typedef struct VkExtensionProperties {
        char        extensionName[VK_MAX_EXTENSION_NAME_SIZE];
        uint32_t    specVersion;
    } VkExtensionProperties;

    typedef struct VkLayerProperties {
        char        layerName[VK_MAX_EXTENSION_NAME_SIZE];
        uint32_t    specVersion;
        uint32_t    implementationVersion;
        char        description[VK_MAX_DESCRIPTION_SIZE];
    } VkLayerProperties;

    typedef struct VkSubmitInfo {
        VkStructureType                sType;
        void*                    pNext;
        uint32_t                       waitSemaphoreCount;
        VkSemaphore*             pWaitSemaphores;
        VkPipelineStageFlags*    pWaitDstStageMask;
        uint32_t                       commandBufferCount;
        VkCommandBuffer*         pCommandBuffers;
        uint32_t                       signalSemaphoreCount;
        VkSemaphore*             pSignalSemaphores;
    } VkSubmitInfo;

    typedef struct VkMemoryAllocateInfo {
        VkStructureType    sType;
        void*        pNext;
        VkDeviceSize       allocationSize;
        uint32_t           memoryTypeIndex;
    } VkMemoryAllocateInfo;

    typedef struct VkMappedMemoryRange {
        VkStructureType    sType;
        void*        pNext;
        VkDeviceMemory     memory;
        VkDeviceSize       offset;
        VkDeviceSize       size;
    } VkMappedMemoryRange;

    typedef struct VkMemoryRequirements {
        VkDeviceSize    size;
        VkDeviceSize    alignment;
        uint32_t        memoryTypeBits;
    } VkMemoryRequirements;

    typedef struct VkSparseImageFormatProperties {
        VkImageAspectFlags          aspectMask;
        VkExtent3D                  imageGranularity;
        VkSparseImageFormatFlags    flags;
    } VkSparseImageFormatProperties;

    typedef struct VkSparseImageMemoryRequirements {
        VkSparseImageFormatProperties    formatProperties;
        uint32_t                         imageMipTailFirstLod;
        VkDeviceSize                     imageMipTailSize;
        VkDeviceSize                     imageMipTailOffset;
        VkDeviceSize                     imageMipTailStride;
    } VkSparseImageMemoryRequirements;

    typedef struct VkSparseMemoryBind {
        VkDeviceSize               resourceOffset;
        VkDeviceSize               size;
        VkDeviceMemory             memory;
        VkDeviceSize               memoryOffset;
        VkSparseMemoryBindFlags    flags;
    } VkSparseMemoryBind;

    typedef struct VkSparseBufferMemoryBindInfo {
        VkBuffer                     buffer;
        uint32_t                     bindCount;
        VkSparseMemoryBind*    pBinds;
    } VkSparseBufferMemoryBindInfo;

    typedef struct VkSparseImageOpaqueMemoryBindInfo {
        VkImage                      image;
        uint32_t                     bindCount;
        VkSparseMemoryBind*    pBinds;
    } VkSparseImageOpaqueMemoryBindInfo;

    typedef struct VkImageSubresource {
        VkImageAspectFlags    aspectMask;
        uint32_t              mipLevel;
        uint32_t              arrayLayer;
    } VkImageSubresource;

    typedef struct VkOffset3D {
        int32_t    x;
        int32_t    y;
        int32_t    z;
    } VkOffset3D;

    typedef struct VkSparseImageMemoryBind {
        VkImageSubresource         subresource;
        VkOffset3D                 offset;
        VkExtent3D                 extent;
        VkDeviceMemory             memory;
        VkDeviceSize               memoryOffset;
        VkSparseMemoryBindFlags    flags;
    } VkSparseImageMemoryBind;

    typedef struct VkSparseImageMemoryBindInfo {
        VkImage                           image;
        uint32_t                          bindCount;
        VkSparseImageMemoryBind*    pBinds;
    } VkSparseImageMemoryBindInfo;

    typedef struct VkBindSparseInfo {
        VkStructureType                             sType;
        void*                                 pNext;
        uint32_t                                    waitSemaphoreCount;
        VkSemaphore*                          pWaitSemaphores;
        uint32_t                                    bufferBindCount;
        VkSparseBufferMemoryBindInfo*         pBufferBinds;
        uint32_t                                    imageOpaqueBindCount;
        VkSparseImageOpaqueMemoryBindInfo*    pImageOpaqueBinds;
        uint32_t                                    imageBindCount;
        VkSparseImageMemoryBindInfo*          pImageBinds;
        uint32_t                                    signalSemaphoreCount;
        VkSemaphore*                          pSignalSemaphores;
    } VkBindSparseInfo;

    typedef struct VkFenceCreateInfo {
        VkStructureType       sType;
        void*           pNext;
        VkFenceCreateFlags    flags;
    } VkFenceCreateInfo;

    typedef struct VkSemaphoreCreateInfo {
        VkStructureType           sType;
        void*               pNext;
        VkSemaphoreCreateFlags    flags;
    } VkSemaphoreCreateInfo;

    typedef struct VkEventCreateInfo {
        VkStructureType       sType;
        void*           pNext;
        VkEventCreateFlags    flags;
    } VkEventCreateInfo;

    typedef struct VkQueryPoolCreateInfo {
        VkStructureType                  sType;
        void*                      pNext;
        VkQueryPoolCreateFlags           flags;
        VkQueryType                      queryType;
        uint32_t                         queryCount;
        VkQueryPipelineStatisticFlags    pipelineStatistics;
    } VkQueryPoolCreateInfo;

    typedef struct VkBufferCreateInfo {
        VkStructureType        sType;
        void*            pNext;
        VkBufferCreateFlags    flags;
        VkDeviceSize           size;
        VkBufferUsageFlags     usage;
        VkSharingMode          sharingMode;
        uint32_t               queueFamilyIndexCount;
        uint32_t*        pQueueFamilyIndices;
    } VkBufferCreateInfo;

    typedef struct VkBufferViewCreateInfo {
        VkStructureType            sType;
        void*                pNext;
        VkBufferViewCreateFlags    flags;
        VkBuffer                   buffer;
        VkFormat                   format;
        VkDeviceSize               offset;
        VkDeviceSize               range;
    } VkBufferViewCreateInfo;

    typedef struct VkImageCreateInfo {
        VkStructureType          sType;
        void*              pNext;
        VkImageCreateFlags       flags;
        VkImageType              imageType;
        VkFormat                 format;
        VkExtent3D               extent;
        uint32_t                 mipLevels;
        uint32_t                 arrayLayers;
        VkSampleCountFlagBits    samples;
        VkImageTiling            tiling;
        VkImageUsageFlags        usage;
        VkSharingMode            sharingMode;
        uint32_t                 queueFamilyIndexCount;
        uint32_t*          pQueueFamilyIndices;
        VkImageLayout            initialLayout;
    } VkImageCreateInfo;

    typedef struct VkSubresourceLayout {
        VkDeviceSize    offset;
        VkDeviceSize    size;
        VkDeviceSize    rowPitch;
        VkDeviceSize    arrayPitch;
        VkDeviceSize    depthPitch;
    } VkSubresourceLayout;

    typedef struct VkComponentMapping {
        VkComponentSwizzle    r;
        VkComponentSwizzle    g;
        VkComponentSwizzle    b;
        VkComponentSwizzle    a;
    } VkComponentMapping;

    typedef struct VkImageSubresourceRange {
        VkImageAspectFlags    aspectMask;
        uint32_t              baseMipLevel;
        uint32_t              levelCount;
        uint32_t              baseArrayLayer;
        uint32_t              layerCount;
    } VkImageSubresourceRange;

    typedef struct VkImageViewCreateInfo {
        VkStructureType            sType;
        void*                pNext;
        VkImageViewCreateFlags     flags;
        VkImage                    image;
        VkImageViewType            viewType;
        VkFormat                   format;
        VkComponentMapping         components;
        VkImageSubresourceRange    subresourceRange;
    } VkImageViewCreateInfo;

    typedef struct VkShaderModuleCreateInfo {
        VkStructureType              sType;
        void*                  pNext;
        VkShaderModuleCreateFlags    flags;
        size_t                       codeSize;
        uint32_t*              pCode;
    } VkShaderModuleCreateInfo;

    typedef struct VkPipelineCacheCreateInfo {
        VkStructureType               sType;
        void*                   pNext;
        VkPipelineCacheCreateFlags    flags;
        size_t                        initialDataSize;
        void*                   pInitialData;
    } VkPipelineCacheCreateInfo;

    typedef struct VkSpecializationMapEntry {
        uint32_t    constantID;
        uint32_t    offset;
        size_t      size;
    } VkSpecializationMapEntry;

    typedef struct VkSpecializationInfo {
        uint32_t                           mapEntryCount;
        VkSpecializationMapEntry*    pMapEntries;
        size_t                             dataSize;
        void*                        pData;
    } VkSpecializationInfo;

    typedef struct VkPipelineShaderStageCreateInfo {
        VkStructureType                     sType;
        void*                         pNext;
        VkPipelineShaderStageCreateFlags    flags;
        VkShaderStageFlagBits               stage;
        VkShaderModule                      module;
        char*                         pName;
        VkSpecializationInfo*         pSpecializationInfo;
    } VkPipelineShaderStageCreateInfo;

    typedef struct VkVertexInputBindingDescription {
        uint32_t             binding;
        uint32_t             stride;
        VkVertexInputRate    inputRate;
    } VkVertexInputBindingDescription;

    typedef struct VkVertexInputAttributeDescription {
        uint32_t    location;
        uint32_t    binding;
        VkFormat    format;
        uint32_t    offset;
    } VkVertexInputAttributeDescription;

    typedef struct VkPipelineVertexInputStateCreateInfo {
        VkStructureType                             sType;
        void*                                 pNext;
        VkPipelineVertexInputStateCreateFlags       flags;
        uint32_t                                    vertexBindingDescriptionCount;
        VkVertexInputBindingDescription*      pVertexBindingDescriptions;
        uint32_t                                    vertexAttributeDescriptionCount;
        VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;
    } VkPipelineVertexInputStateCreateInfo;

    typedef struct VkPipelineInputAssemblyStateCreateInfo {
        VkStructureType                            sType;
        void*                                pNext;
        VkPipelineInputAssemblyStateCreateFlags    flags;
        VkPrimitiveTopology                        topology;
        VkBool32                                   primitiveRestartEnable;
    } VkPipelineInputAssemblyStateCreateInfo;

    typedef struct VkPipelineTessellationStateCreateInfo {
        VkStructureType                           sType;
        void*                               pNext;
        VkPipelineTessellationStateCreateFlags    flags;
        uint32_t                                  patchControlPoints;
    } VkPipelineTessellationStateCreateInfo;

    typedef struct VkViewport {
        float    x;
        float    y;
        float    width;
        float    height;
        float    minDepth;
        float    maxDepth;
    } VkViewport;

    typedef struct VkOffset2D {
        int32_t    x;
        int32_t    y;
    } VkOffset2D;

    typedef struct VkExtent2D {
        uint32_t    width;
        uint32_t    height;
    } VkExtent2D;

    typedef struct VkRect2D {
        VkOffset2D    offset;
        VkExtent2D    extent;
    } VkRect2D;

    typedef struct VkPipelineViewportStateCreateInfo {
        VkStructureType                       sType;
        void*                           pNext;
        VkPipelineViewportStateCreateFlags    flags;
        uint32_t                              viewportCount;
        VkViewport*                     pViewports;
        uint32_t                              scissorCount;
        VkRect2D*                       pScissors;
    } VkPipelineViewportStateCreateInfo;

    typedef struct VkPipelineRasterizationStateCreateInfo {
        VkStructureType                            sType;
        void*                                pNext;
        VkPipelineRasterizationStateCreateFlags    flags;
        VkBool32                                   depthClampEnable;
        VkBool32                                   rasterizerDiscardEnable;
        VkPolygonMode                              polygonMode;
        VkCullModeFlags                            cullMode;
        VkFrontFace                                frontFace;
        VkBool32                                   depthBiasEnable;
        float                                      depthBiasConstantFactor;
        float                                      depthBiasClamp;
        float                                      depthBiasSlopeFactor;
        float                                      lineWidth;
    } VkPipelineRasterizationStateCreateInfo;

    typedef struct VkPipelineMultisampleStateCreateInfo {
        VkStructureType                          sType;
        void*                              pNext;
        VkPipelineMultisampleStateCreateFlags    flags;
        VkSampleCountFlagBits                    rasterizationSamples;
        VkBool32                                 sampleShadingEnable;
        float                                    minSampleShading;
        VkSampleMask*                      pSampleMask;
        VkBool32                                 alphaToCoverageEnable;
        VkBool32                                 alphaToOneEnable;
    } VkPipelineMultisampleStateCreateInfo;

    typedef struct VkStencilOpState {
        VkStencilOp    failOp;
        VkStencilOp    passOp;
        VkStencilOp    depthFailOp;
        VkCompareOp    compareOp;
        uint32_t       compareMask;
        uint32_t       writeMask;
        uint32_t       reference;
    } VkStencilOpState;

    typedef struct VkPipelineDepthStencilStateCreateInfo {
        VkStructureType                           sType;
        void*                               pNext;
        VkPipelineDepthStencilStateCreateFlags    flags;
        VkBool32                                  depthTestEnable;
        VkBool32                                  depthWriteEnable;
        VkCompareOp                               depthCompareOp;
        VkBool32                                  depthBoundsTestEnable;
        VkBool32                                  stencilTestEnable;
        VkStencilOpState                          front;
        VkStencilOpState                          back;
        float                                     minDepthBounds;
        float                                     maxDepthBounds;
    } VkPipelineDepthStencilStateCreateInfo;

    typedef struct VkPipelineColorBlendAttachmentState {
        VkBool32                 blendEnable;
        VkBlendFactor            srcColorBlendFactor;
        VkBlendFactor            dstColorBlendFactor;
        VkBlendOp                colorBlendOp;
        VkBlendFactor            srcAlphaBlendFactor;
        VkBlendFactor            dstAlphaBlendFactor;
        VkBlendOp                alphaBlendOp;
        VkColorComponentFlags    colorWriteMask;
    } VkPipelineColorBlendAttachmentState;

    typedef struct VkPipelineColorBlendStateCreateInfo {
        VkStructureType                               sType;
        void*                                   pNext;
        VkPipelineColorBlendStateCreateFlags          flags;
        VkBool32                                      logicOpEnable;
        VkLogicOp                                     logicOp;
        uint32_t                                      attachmentCount;
        VkPipelineColorBlendAttachmentState*    pAttachments;
        float                                         blendConstants[4];
    } VkPipelineColorBlendStateCreateInfo;

    typedef struct VkPipelineDynamicStateCreateInfo {
        VkStructureType                      sType;
        void*                          pNext;
        VkPipelineDynamicStateCreateFlags    flags;
        uint32_t                             dynamicStateCount;
        VkDynamicState*                pDynamicStates;
    } VkPipelineDynamicStateCreateInfo;

    typedef struct VkGraphicsPipelineCreateInfo {
        VkStructureType                                  sType;
        void*                                      pNext;
        VkPipelineCreateFlags                            flags;
        uint32_t                                         stageCount;
        VkPipelineShaderStageCreateInfo*           pStages;
        VkPipelineVertexInputStateCreateInfo*      pVertexInputState;
        VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;
        VkPipelineTessellationStateCreateInfo*     pTessellationState;
        VkPipelineViewportStateCreateInfo*         pViewportState;
        VkPipelineRasterizationStateCreateInfo*    pRasterizationState;
        VkPipelineMultisampleStateCreateInfo*      pMultisampleState;
        VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;
        VkPipelineColorBlendStateCreateInfo*       pColorBlendState;
        VkPipelineDynamicStateCreateInfo*          pDynamicState;
        VkPipelineLayout                                 layout;
        VkRenderPass                                     renderPass;
        uint32_t                                         subpass;
        VkPipeline                                       basePipelineHandle;
        int32_t                                          basePipelineIndex;
    } VkGraphicsPipelineCreateInfo;

    typedef struct VkComputePipelineCreateInfo {
        VkStructureType                    sType;
        void*                        pNext;
        VkPipelineCreateFlags              flags;
        VkPipelineShaderStageCreateInfo    stage;
        VkPipelineLayout                   layout;
        VkPipeline                         basePipelineHandle;
        int32_t                            basePipelineIndex;
    } VkComputePipelineCreateInfo;

    typedef struct VkPushConstantRange {
        VkShaderStageFlags    stageFlags;
        uint32_t              offset;
        uint32_t              size;
    } VkPushConstantRange;

    typedef struct VkPipelineLayoutCreateInfo {
        VkStructureType                 sType;
        void*                     pNext;
        VkPipelineLayoutCreateFlags     flags;
        uint32_t                        setLayoutCount;
        VkDescriptorSetLayout*    pSetLayouts;
        uint32_t                        pushConstantRangeCount;
        VkPushConstantRange*      pPushConstantRanges;
    } VkPipelineLayoutCreateInfo;

    typedef struct VkSamplerCreateInfo {
        VkStructureType         sType;
        void*             pNext;
        VkSamplerCreateFlags    flags;
        VkFilter                magFilter;
        VkFilter                minFilter;
        VkSamplerMipmapMode     mipmapMode;
        VkSamplerAddressMode    addressModeU;
        VkSamplerAddressMode    addressModeV;
        VkSamplerAddressMode    addressModeW;
        float                   mipLodBias;
        VkBool32                anisotropyEnable;
        float                   maxAnisotropy;
        VkBool32                compareEnable;
        VkCompareOp             compareOp;
        float                   minLod;
        float                   maxLod;
        VkBorderColor           borderColor;
        VkBool32                unnormalizedCoordinates;
    } VkSamplerCreateInfo;

    typedef struct VkDescriptorSetLayoutBinding {
        uint32_t              binding;
        VkDescriptorType      descriptorType;
        uint32_t              descriptorCount;
        VkShaderStageFlags    stageFlags;
        VkSampler*      pImmutableSamplers;
    } VkDescriptorSetLayoutBinding;

    typedef struct VkDescriptorSetLayoutCreateInfo {
        VkStructureType                        sType;
        void*                            pNext;
        VkDescriptorSetLayoutCreateFlags       flags;
        uint32_t                               bindingCount;
        VkDescriptorSetLayoutBinding*    pBindings;
    } VkDescriptorSetLayoutCreateInfo;

    typedef struct VkDescriptorPoolSize {
        VkDescriptorType    type;
        uint32_t            descriptorCount;
    } VkDescriptorPoolSize;

    typedef struct VkDescriptorPoolCreateInfo {
        VkStructureType                sType;
        void*                    pNext;
        VkDescriptorPoolCreateFlags    flags;
        uint32_t                       maxSets;
        uint32_t                       poolSizeCount;
        VkDescriptorPoolSize*    pPoolSizes;
    } VkDescriptorPoolCreateInfo;

    typedef struct VkDescriptorSetAllocateInfo {
        VkStructureType                 sType;
        void*                     pNext;
        VkDescriptorPool                descriptorPool;
        uint32_t                        descriptorSetCount;
        VkDescriptorSetLayout*    pSetLayouts;
    } VkDescriptorSetAllocateInfo;

    typedef struct VkDescriptorImageInfo {
        VkSampler        sampler;
        VkImageView      imageView;
        VkImageLayout    imageLayout;
    } VkDescriptorImageInfo;

    typedef struct VkDescriptorBufferInfo {
        VkBuffer        buffer;
        VkDeviceSize    offset;
        VkDeviceSize    range;
    } VkDescriptorBufferInfo;

    typedef struct VkWriteDescriptorSet {
        VkStructureType                  sType;
        void*                      pNext;
        VkDescriptorSet                  dstSet;
        uint32_t                         dstBinding;
        uint32_t                         dstArrayElement;
        uint32_t                         descriptorCount;
        VkDescriptorType                 descriptorType;
        VkDescriptorImageInfo*     pImageInfo;
        VkDescriptorBufferInfo*    pBufferInfo;
        VkBufferView*              pTexelBufferView;
    } VkWriteDescriptorSet;

    typedef struct VkCopyDescriptorSet {
        VkStructureType    sType;
        void*        pNext;
        VkDescriptorSet    srcSet;
        uint32_t           srcBinding;
        uint32_t           srcArrayElement;
        VkDescriptorSet    dstSet;
        uint32_t           dstBinding;
        uint32_t           dstArrayElement;
        uint32_t           descriptorCount;
    } VkCopyDescriptorSet;

    typedef struct VkFramebufferCreateInfo {
        VkStructureType             sType;
        void*                 pNext;
        VkFramebufferCreateFlags    flags;
        VkRenderPass                renderPass;
        uint32_t                    attachmentCount;
        VkImageView*          pAttachments;
        uint32_t                    width;
        uint32_t                    height;
        uint32_t                    layers;
    } VkFramebufferCreateInfo;

    typedef struct VkAttachmentDescription {
        VkAttachmentDescriptionFlags    flags;
        VkFormat                        format;
        VkSampleCountFlagBits           samples;
        VkAttachmentLoadOp              loadOp;
        VkAttachmentStoreOp             storeOp;
        VkAttachmentLoadOp              stencilLoadOp;
        VkAttachmentStoreOp             stencilStoreOp;
        VkImageLayout                   initialLayout;
        VkImageLayout                   finalLayout;
    } VkAttachmentDescription;

    typedef struct VkAttachmentReference {
        uint32_t         attachment;
        VkImageLayout    layout;
    } VkAttachmentReference;

    typedef struct VkSubpassDescription {
        VkSubpassDescriptionFlags       flags;
        VkPipelineBindPoint             pipelineBindPoint;
        uint32_t                        inputAttachmentCount;
        VkAttachmentReference*    pInputAttachments;
        uint32_t                        colorAttachmentCount;
        VkAttachmentReference*    pColorAttachments;
        VkAttachmentReference*    pResolveAttachments;
        VkAttachmentReference*    pDepthStencilAttachment;
        uint32_t                        preserveAttachmentCount;
        uint32_t*                 pPreserveAttachments;
    } VkSubpassDescription;

    typedef struct VkSubpassDependency {
        uint32_t                srcSubpass;
        uint32_t                dstSubpass;
        VkPipelineStageFlags    srcStageMask;
        VkPipelineStageFlags    dstStageMask;
        VkAccessFlags           srcAccessMask;
        VkAccessFlags           dstAccessMask;
        VkDependencyFlags       dependencyFlags;
    } VkSubpassDependency;

    typedef struct VkRenderPassCreateInfo {
        VkStructureType                   sType;
        void*                       pNext;
        VkRenderPassCreateFlags           flags;
        uint32_t                          attachmentCount;
        VkAttachmentDescription*    pAttachments;
        uint32_t                          subpassCount;
        VkSubpassDescription*       pSubpasses;
        uint32_t                          dependencyCount;
        VkSubpassDependency*        pDependencies;
    } VkRenderPassCreateInfo;

    typedef struct VkCommandPoolCreateInfo {
        VkStructureType             sType;
        void*                 pNext;
        VkCommandPoolCreateFlags    flags;
        uint32_t                    queueFamilyIndex;
    } VkCommandPoolCreateInfo;

    typedef struct VkCommandBufferAllocateInfo {
        VkStructureType         sType;
        void*             pNext;
        VkCommandPool           commandPool;
        VkCommandBufferLevel    level;
        uint32_t                commandBufferCount;
    } VkCommandBufferAllocateInfo;

    typedef struct VkCommandBufferInheritanceInfo {
        VkStructureType                  sType;
        void*                      pNext;
        VkRenderPass                     renderPass;
        uint32_t                         subpass;
        VkFramebuffer                    framebuffer;
        VkBool32                         occlusionQueryEnable;
        VkQueryControlFlags              queryFlags;
        VkQueryPipelineStatisticFlags    pipelineStatistics;
    } VkCommandBufferInheritanceInfo;

    typedef struct VkCommandBufferBeginInfo {
        VkStructureType                          sType;
        void*                              pNext;
        VkCommandBufferUsageFlags                flags;
        VkCommandBufferInheritanceInfo*    pInheritanceInfo;
    } VkCommandBufferBeginInfo;

    typedef struct VkBufferCopy {
        VkDeviceSize    srcOffset;
        VkDeviceSize    dstOffset;
        VkDeviceSize    size;
    } VkBufferCopy;

    typedef struct VkImageSubresourceLayers {
        VkImageAspectFlags    aspectMask;
        uint32_t              mipLevel;
        uint32_t              baseArrayLayer;
        uint32_t              layerCount;
    } VkImageSubresourceLayers;

    typedef struct VkImageCopy {
        VkImageSubresourceLayers    srcSubresource;
        VkOffset3D                  srcOffset;
        VkImageSubresourceLayers    dstSubresource;
        VkOffset3D                  dstOffset;
        VkExtent3D                  extent;
    } VkImageCopy;

    typedef struct VkImageBlit {
        VkImageSubresourceLayers    srcSubresource;
        VkOffset3D                  srcOffsets[2];
        VkImageSubresourceLayers    dstSubresource;
        VkOffset3D                  dstOffsets[2];
    } VkImageBlit;

    typedef struct VkBufferImageCopy {
        VkDeviceSize                bufferOffset;
        uint32_t                    bufferRowLength;
        uint32_t                    bufferImageHeight;
        VkImageSubresourceLayers    imageSubresource;
        VkOffset3D                  imageOffset;
        VkExtent3D                  imageExtent;
    } VkBufferImageCopy;

    typedef union VkClearColorValue {
        float       float32[4];
        int32_t     int32[4];
        uint32_t    uint32[4];
    } VkClearColorValue;

    typedef struct VkClearDepthStencilValue {
        float       depth;
        uint32_t    stencil;
    } VkClearDepthStencilValue;

    typedef union VkClearValue {
        VkClearColorValue           color;
        VkClearDepthStencilValue    depthStencil;
    } VkClearValue;

    typedef struct VkClearAttachment {
        VkImageAspectFlags    aspectMask;
        uint32_t              colorAttachment;
        VkClearValue          clearValue;
    } VkClearAttachment;

    typedef struct VkClearRect {
        VkRect2D    rect;
        uint32_t    baseArrayLayer;
        uint32_t    layerCount;
    } VkClearRect;

    typedef struct VkImageResolve {
        VkImageSubresourceLayers    srcSubresource;
        VkOffset3D                  srcOffset;
        VkImageSubresourceLayers    dstSubresource;
        VkOffset3D                  dstOffset;
        VkExtent3D                  extent;
    } VkImageResolve;

    typedef struct VkMemoryBarrier {
        VkStructureType    sType;
        void*        pNext;
        VkAccessFlags      srcAccessMask;
        VkAccessFlags      dstAccessMask;
    } VkMemoryBarrier;

    typedef struct VkBufferMemoryBarrier {
        VkStructureType    sType;
        void*        pNext;
        VkAccessFlags      srcAccessMask;
        VkAccessFlags      dstAccessMask;
        uint32_t           srcQueueFamilyIndex;
        uint32_t           dstQueueFamilyIndex;
        VkBuffer           buffer;
        VkDeviceSize       offset;
        VkDeviceSize       size;
    } VkBufferMemoryBarrier;

    typedef struct VkImageMemoryBarrier {
        VkStructureType            sType;
        void*                pNext;
        VkAccessFlags              srcAccessMask;
        VkAccessFlags              dstAccessMask;
        VkImageLayout              oldLayout;
        VkImageLayout              newLayout;
        uint32_t                   srcQueueFamilyIndex;
        uint32_t                   dstQueueFamilyIndex;
        VkImage                    image;
        VkImageSubresourceRange    subresourceRange;
    } VkImageMemoryBarrier;

    typedef struct VkRenderPassBeginInfo {
        VkStructureType        sType;
        void*            pNext;
        VkRenderPass           renderPass;
        VkFramebuffer          framebuffer;
        VkRect2D               renderArea;
        uint32_t               clearValueCount;
        VkClearValue*    pClearValues;
    } VkRenderPassBeginInfo;

    typedef struct VkDispatchIndirectCommand {
        uint32_t    x;
        uint32_t    y;
        uint32_t    z;
    } VkDispatchIndirectCommand;

    typedef struct VkDrawIndexedIndirectCommand {
        uint32_t    indexCount;
        uint32_t    instanceCount;
        uint32_t    firstIndex;
        int32_t     vertexOffset;
        uint32_t    firstInstance;
    } VkDrawIndexedIndirectCommand;

    typedef struct VkDrawIndirectCommand {
        uint32_t    vertexCount;
        uint32_t    instanceCount;
        uint32_t    firstVertex;
        uint32_t    firstInstance;
    } VkDrawIndirectCommand;


    typedef VkResult (VKAPI_PTR *PFN_vkCreateInstance)(const VkInstanceCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkInstance* pInstance);
    typedef void (VKAPI_PTR *PFN_vkDestroyInstance)(VkInstance instance, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkEnumeratePhysicalDevices)(VkInstance instance, uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices);
    typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFeatures)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures);
    typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties);
    typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties);
    typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties);
    typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceQueueFamilyProperties)(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties);
    typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceMemoryProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties);
    typedef PFN_vkVoidFunction (VKAPI_PTR *PFN_vkGetInstanceProcAddr)(VkInstance instance, char* pName);
    typedef PFN_vkVoidFunction (VKAPI_PTR *PFN_vkGetDeviceProcAddr)(VkDevice device, char* pName);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateDevice)(VkPhysicalDevice physicalDevice, VkDeviceCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDevice* pDevice);
    typedef void (VKAPI_PTR *PFN_vkDestroyDevice)(VkDevice device, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkEnumerateInstanceExtensionProperties)(const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties);
    typedef VkResult (VKAPI_PTR *PFN_vkEnumerateDeviceExtensionProperties)(VkPhysicalDevice physicalDevice, char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties);
    typedef VkResult (VKAPI_PTR *PFN_vkEnumerateInstanceLayerProperties)(uint32_t* pPropertyCount, VkLayerProperties* pProperties);
    typedef VkResult (VKAPI_PTR *PFN_vkEnumerateDeviceLayerProperties)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkLayerProperties* pProperties);
    typedef void (VKAPI_PTR *PFN_vkGetDeviceQueue)(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue);
    typedef VkResult (VKAPI_PTR *PFN_vkQueueSubmit)(VkQueue queue, uint32_t submitCount, VkSubmitInfo* pSubmits, VkFence fence);
    typedef VkResult (VKAPI_PTR *PFN_vkQueueWaitIdle)(VkQueue queue);
    typedef VkResult (VKAPI_PTR *PFN_vkDeviceWaitIdle)(VkDevice device);
    typedef VkResult (VKAPI_PTR *PFN_vkAllocateMemory)(VkDevice device, VkMemoryAllocateInfo* pAllocateInfo, VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory);
    typedef void (VKAPI_PTR *PFN_vkFreeMemory)(VkDevice device, VkDeviceMemory memory, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkMapMemory)(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void** ppData);
    typedef void (VKAPI_PTR *PFN_vkUnmapMemory)(VkDevice device, VkDeviceMemory memory);
    typedef VkResult (VKAPI_PTR *PFN_vkFlushMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, VkMappedMemoryRange* pMemoryRanges);
    typedef VkResult (VKAPI_PTR *PFN_vkInvalidateMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, VkMappedMemoryRange* pMemoryRanges);
    typedef void (VKAPI_PTR *PFN_vkGetDeviceMemoryCommitment)(VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes);
    typedef VkResult (VKAPI_PTR *PFN_vkBindBufferMemory)(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset);
    typedef VkResult (VKAPI_PTR *PFN_vkBindImageMemory)(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset);
    typedef void (VKAPI_PTR *PFN_vkGetBufferMemoryRequirements)(VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements);
    typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements)(VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements);
    typedef void (VKAPI_PTR *PFN_vkGetImageSparseMemoryRequirements)(VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements);
    typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceSparseImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties);
    typedef VkResult (VKAPI_PTR *PFN_vkQueueBindSparse)(VkQueue queue, uint32_t bindInfoCount, VkBindSparseInfo* pBindInfo, VkFence fence);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateFence)(VkDevice device, VkFenceCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkFence* pFence);
    typedef void (VKAPI_PTR *PFN_vkDestroyFence)(VkDevice device, VkFence fence, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkResetFences)(VkDevice device, uint32_t fenceCount, VkFence* pFences);
    typedef VkResult (VKAPI_PTR *PFN_vkGetFenceStatus)(VkDevice device, VkFence fence);
    typedef VkResult (VKAPI_PTR *PFN_vkWaitForFences)(VkDevice device, uint32_t fenceCount, VkFence* pFences, VkBool32 waitAll, uint64_t timeout);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateSemaphore)(VkDevice device, VkSemaphoreCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore);
    typedef void (VKAPI_PTR *PFN_vkDestroySemaphore)(VkDevice device, VkSemaphore semaphore, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateEvent)(VkDevice device, VkEventCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkEvent* pEvent);
    typedef void (VKAPI_PTR *PFN_vkDestroyEvent)(VkDevice device, VkEvent event, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkGetEventStatus)(VkDevice device, VkEvent event);
    typedef VkResult (VKAPI_PTR *PFN_vkSetEvent)(VkDevice device, VkEvent event);
    typedef VkResult (VKAPI_PTR *PFN_vkResetEvent)(VkDevice device, VkEvent event);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateQueryPool)(VkDevice device, VkQueryPoolCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool);
    typedef void (VKAPI_PTR *PFN_vkDestroyQueryPool)(VkDevice device, VkQueryPool queryPool, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkGetQueryPoolResults)(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateBuffer)(VkDevice device, VkBufferCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer);
    typedef void (VKAPI_PTR *PFN_vkDestroyBuffer)(VkDevice device, VkBuffer buffer, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateBufferView)(VkDevice device, VkBufferViewCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkBufferView* pView);
    typedef void (VKAPI_PTR *PFN_vkDestroyBufferView)(VkDevice device, VkBufferView bufferView, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateImage)(VkDevice device, VkImageCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkImage* pImage);
    typedef void (VKAPI_PTR *PFN_vkDestroyImage)(VkDevice device, VkImage image, VkAllocationCallbacks* pAllocator);
    typedef void (VKAPI_PTR *PFN_vkGetImageSubresourceLayout)(VkDevice device, VkImage image, VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateImageView)(VkDevice device, VkImageViewCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkImageView* pView);
    typedef void (VKAPI_PTR *PFN_vkDestroyImageView)(VkDevice device, VkImageView imageView, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateShaderModule)(VkDevice device, VkShaderModuleCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule);
    typedef void (VKAPI_PTR *PFN_vkDestroyShaderModule)(VkDevice device, VkShaderModule shaderModule, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkCreatePipelineCache)(VkDevice device, VkPipelineCacheCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache);
    typedef void (VKAPI_PTR *PFN_vkDestroyPipelineCache)(VkDevice device, VkPipelineCache pipelineCache, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkGetPipelineCacheData)(VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData);
    typedef VkResult (VKAPI_PTR *PFN_vkMergePipelineCaches)(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, VkPipelineCache* pSrcCaches);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateGraphicsPipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, VkGraphicsPipelineCreateInfo* pCreateInfos, VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateComputePipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, VkComputePipelineCreateInfo* pCreateInfos, VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
    typedef void (VKAPI_PTR *PFN_vkDestroyPipeline)(VkDevice device, VkPipeline pipeline, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkCreatePipelineLayout)(VkDevice device, VkPipelineLayoutCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout);
    typedef void (VKAPI_PTR *PFN_vkDestroyPipelineLayout)(VkDevice device, VkPipelineLayout pipelineLayout, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateSampler)(VkDevice device, VkSamplerCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSampler* pSampler);
    typedef void (VKAPI_PTR *PFN_vkDestroySampler)(VkDevice device, VkSampler sampler, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorSetLayout)(VkDevice device, VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout);
    typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorSetLayout)(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorPool)(VkDevice device, VkDescriptorPoolCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool);
    typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkResetDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags);
    typedef VkResult (VKAPI_PTR *PFN_vkAllocateDescriptorSets)(VkDevice device, VkDescriptorSetAllocateInfo* pAllocateInfo, VkDescriptorSet* pDescriptorSets);
    typedef VkResult (VKAPI_PTR *PFN_vkFreeDescriptorSets)(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, VkDescriptorSet* pDescriptorSets);
    typedef void (VKAPI_PTR *PFN_vkUpdateDescriptorSets)(VkDevice device, uint32_t descriptorWriteCount, VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, VkCopyDescriptorSet* pDescriptorCopies);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateFramebuffer)(VkDevice device, VkFramebufferCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer);
    typedef void (VKAPI_PTR *PFN_vkDestroyFramebuffer)(VkDevice device, VkFramebuffer framebuffer, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateRenderPass)(VkDevice device, VkRenderPassCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass);
    typedef void (VKAPI_PTR *PFN_vkDestroyRenderPass)(VkDevice device, VkRenderPass renderPass, VkAllocationCallbacks* pAllocator);
    typedef void (VKAPI_PTR *PFN_vkGetRenderAreaGranularity)(VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateCommandPool)(VkDevice device, VkCommandPoolCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool);
    typedef void (VKAPI_PTR *PFN_vkDestroyCommandPool)(VkDevice device, VkCommandPool commandPool, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkResetCommandPool)(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags);
    typedef VkResult (VKAPI_PTR *PFN_vkAllocateCommandBuffers)(VkDevice device, VkCommandBufferAllocateInfo* pAllocateInfo, VkCommandBuffer* pCommandBuffers);
    typedef void (VKAPI_PTR *PFN_vkFreeCommandBuffers)(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, VkCommandBuffer* pCommandBuffers);
    typedef VkResult (VKAPI_PTR *PFN_vkBeginCommandBuffer)(VkCommandBuffer commandBuffer, VkCommandBufferBeginInfo* pBeginInfo);
    typedef VkResult (VKAPI_PTR *PFN_vkEndCommandBuffer)(VkCommandBuffer commandBuffer);
    typedef VkResult (VKAPI_PTR *PFN_vkResetCommandBuffer)(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags);
    typedef void (VKAPI_PTR *PFN_vkCmdBindPipeline)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline);
    typedef void (VKAPI_PTR *PFN_vkCmdSetViewport)(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, VkViewport* pViewports);
    typedef void (VKAPI_PTR *PFN_vkCmdSetScissor)(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, VkRect2D* pScissors);
    typedef void (VKAPI_PTR *PFN_vkCmdSetLineWidth)(VkCommandBuffer commandBuffer, float lineWidth);
    typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBias)(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor);
    typedef void (VKAPI_PTR *PFN_vkCmdSetBlendConstants)(VkCommandBuffer commandBuffer, float blendConstants[4]);
    typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBounds)(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds);
    typedef void (VKAPI_PTR *PFN_vkCmdSetStencilCompareMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask);
    typedef void (VKAPI_PTR *PFN_vkCmdSetStencilWriteMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask);
    typedef void (VKAPI_PTR *PFN_vkCmdSetStencilReference)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference);
    typedef void (VKAPI_PTR *PFN_vkCmdBindDescriptorSets)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, uint32_t* pDynamicOffsets);
    typedef void (VKAPI_PTR *PFN_vkCmdBindIndexBuffer)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType);
    typedef void (VKAPI_PTR *PFN_vkCmdBindVertexBuffers)(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, VkBuffer* pBuffers, VkDeviceSize* pOffsets);
    typedef void (VKAPI_PTR *PFN_vkCmdDraw)(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);
    typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexed)(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance);
    typedef void (VKAPI_PTR *PFN_vkCmdDrawIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
    typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexedIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
    typedef void (VKAPI_PTR *PFN_vkCmdDispatch)(VkCommandBuffer commandBuffer, uint32_t x, uint32_t y, uint32_t z);
    typedef void (VKAPI_PTR *PFN_vkCmdDispatchIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset);
    typedef void (VKAPI_PTR *PFN_vkCmdCopyBuffer)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, VkBufferCopy* pRegions);
    typedef void (VKAPI_PTR *PFN_vkCmdCopyImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageCopy* pRegions);
    typedef void (VKAPI_PTR *PFN_vkCmdBlitImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageBlit* pRegions, VkFilter filter);
    typedef void (VKAPI_PTR *PFN_vkCmdCopyBufferToImage)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkBufferImageCopy* pRegions);
    typedef void (VKAPI_PTR *PFN_vkCmdCopyImageToBuffer)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, VkBufferImageCopy* pRegions);
    typedef void (VKAPI_PTR *PFN_vkCmdUpdateBuffer)(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, void* pData);
    typedef void (VKAPI_PTR *PFN_vkCmdFillBuffer)(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data);
    typedef void (VKAPI_PTR *PFN_vkCmdClearColorImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, VkClearColorValue* pColor, uint32_t rangeCount, VkImageSubresourceRange* pRanges);
    typedef void (VKAPI_PTR *PFN_vkCmdClearDepthStencilImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, VkImageSubresourceRange* pRanges);
    typedef void (VKAPI_PTR *PFN_vkCmdClearAttachments)(VkCommandBuffer commandBuffer, uint32_t attachmentCount, VkClearAttachment* pAttachments, uint32_t rectCount, VkClearRect* pRects);
    typedef void (VKAPI_PTR *PFN_vkCmdResolveImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageResolve* pRegions);
    typedef void (VKAPI_PTR *PFN_vkCmdSetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
    typedef void (VKAPI_PTR *PFN_vkCmdResetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
    typedef void (VKAPI_PTR *PFN_vkCmdWaitEvents)(VkCommandBuffer commandBuffer, uint32_t eventCount, VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, VkImageMemoryBarrier* pImageMemoryBarriers);
    typedef void (VKAPI_PTR *PFN_vkCmdPipelineBarrier)(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, VkImageMemoryBarrier* pImageMemoryBarriers);
    typedef void (VKAPI_PTR *PFN_vkCmdBeginQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags);
    typedef void (VKAPI_PTR *PFN_vkCmdEndQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query);
    typedef void (VKAPI_PTR *PFN_vkCmdResetQueryPool)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);
    typedef void (VKAPI_PTR *PFN_vkCmdWriteTimestamp)(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query);
    typedef void (VKAPI_PTR *PFN_vkCmdCopyQueryPoolResults)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags);
    typedef void (VKAPI_PTR *PFN_vkCmdPushConstants)(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, void* pValues);
    typedef void (VKAPI_PTR *PFN_vkCmdBeginRenderPass)(VkCommandBuffer commandBuffer, VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents);
    typedef void (VKAPI_PTR *PFN_vkCmdNextSubpass)(VkCommandBuffer commandBuffer, VkSubpassContents contents);
    typedef void (VKAPI_PTR *PFN_vkCmdEndRenderPass)(VkCommandBuffer commandBuffer);
    typedef void (VKAPI_PTR *PFN_vkCmdExecuteCommands)(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, VkCommandBuffer* pCommandBuffers);

#ifndef VK_NO_PROTOTYPES
    VKAPI_ATTR VkResult VKAPI_CALL vkCreateInstance(
        VkInstanceCreateInfo*                 pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkInstance*                                 pInstance);

    VKAPI_ATTR void VKAPI_CALL vkDestroyInstance(
        VkInstance                                  instance,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkEnumeratePhysicalDevices(
        VkInstance                                  instance,
        uint32_t*                                   pPhysicalDeviceCount,
        VkPhysicalDevice*                           pPhysicalDevices);

    VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceFeatures(
        VkPhysicalDevice                            physicalDevice,
        VkPhysicalDeviceFeatures*                   pFeatures);

    VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceFormatProperties(
        VkPhysicalDevice                            physicalDevice,
        VkFormat                                    format,
        VkFormatProperties*                         pFormatProperties);

    VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceImageFormatProperties(
        VkPhysicalDevice                            physicalDevice,
        VkFormat                                    format,
        VkImageType                                 type,
        VkImageTiling                               tiling,
        VkImageUsageFlags                           usage,
        VkImageCreateFlags                          flags,
        VkImageFormatProperties*                    pImageFormatProperties);

    VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceProperties(
        VkPhysicalDevice                            physicalDevice,
        VkPhysicalDeviceProperties*                 pProperties);

    VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceQueueFamilyProperties(
        VkPhysicalDevice                            physicalDevice,
        uint32_t*                                   pQueueFamilyPropertyCount,
        VkQueueFamilyProperties*                    pQueueFamilyProperties);

    VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceMemoryProperties(
        VkPhysicalDevice                            physicalDevice,
        VkPhysicalDeviceMemoryProperties*           pMemoryProperties);

    VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL vkGetInstanceProcAddr(
        VkInstance                                  instance,
        char*                                 pName);

    VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL vkGetDeviceProcAddr(
        VkDevice                                    device,
        char*                                 pName);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateDevice(
        VkPhysicalDevice                            physicalDevice,
        VkDeviceCreateInfo*                   pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkDevice*                                   pDevice);

    VKAPI_ATTR void VKAPI_CALL vkDestroyDevice(
        VkDevice                                    device,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkEnumerateInstanceExtensionProperties(
        char*                                 pLayerName,
        uint32_t*                                   pPropertyCount,
        VkExtensionProperties*                      pProperties);

    VKAPI_ATTR VkResult VKAPI_CALL vkEnumerateDeviceExtensionProperties(
        VkPhysicalDevice                            physicalDevice,
        char*                                 pLayerName,
        uint32_t*                                   pPropertyCount,
        VkExtensionProperties*                      pProperties);

    VKAPI_ATTR VkResult VKAPI_CALL vkEnumerateInstanceLayerProperties(
        uint32_t*                                   pPropertyCount,
        VkLayerProperties*                          pProperties);

    VKAPI_ATTR VkResult VKAPI_CALL vkEnumerateDeviceLayerProperties(
        VkPhysicalDevice                            physicalDevice,
        uint32_t*                                   pPropertyCount,
        VkLayerProperties*                          pProperties);

    VKAPI_ATTR void VKAPI_CALL vkGetDeviceQueue(
        VkDevice                                    device,
        uint32_t                                    queueFamilyIndex,
        uint32_t                                    queueIndex,
        VkQueue*                                    pQueue);

    VKAPI_ATTR VkResult VKAPI_CALL vkQueueSubmit(
        VkQueue                                     queue,
        uint32_t                                    submitCount,
        VkSubmitInfo*                         pSubmits,
        VkFence                                     fence);

    VKAPI_ATTR VkResult VKAPI_CALL vkQueueWaitIdle(
        VkQueue                                     queue);

    VKAPI_ATTR VkResult VKAPI_CALL vkDeviceWaitIdle(
        VkDevice                                    device);

    VKAPI_ATTR VkResult VKAPI_CALL vkAllocateMemory(
        VkDevice                                    device,
        VkMemoryAllocateInfo*                 pAllocateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkDeviceMemory*                             pMemory);

    VKAPI_ATTR void VKAPI_CALL vkFreeMemory(
        VkDevice                                    device,
        VkDeviceMemory                              memory,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkMapMemory(
        VkDevice                                    device,
        VkDeviceMemory                              memory,
        VkDeviceSize                                offset,
        VkDeviceSize                                size,
        VkMemoryMapFlags                            flags,
        void**                                      ppData);

    VKAPI_ATTR void VKAPI_CALL vkUnmapMemory(
        VkDevice                                    device,
        VkDeviceMemory                              memory);

    VKAPI_ATTR VkResult VKAPI_CALL vkFlushMappedMemoryRanges(
        VkDevice                                    device,
        uint32_t                                    memoryRangeCount,
        VkMappedMemoryRange*                  pMemoryRanges);

    VKAPI_ATTR VkResult VKAPI_CALL vkInvalidateMappedMemoryRanges(
        VkDevice                                    device,
        uint32_t                                    memoryRangeCount,
        VkMappedMemoryRange*                  pMemoryRanges);

    VKAPI_ATTR void VKAPI_CALL vkGetDeviceMemoryCommitment(
        VkDevice                                    device,
        VkDeviceMemory                              memory,
        VkDeviceSize*                               pCommittedMemoryInBytes);

    VKAPI_ATTR VkResult VKAPI_CALL vkBindBufferMemory(
        VkDevice                                    device,
        VkBuffer                                    buffer,
        VkDeviceMemory                              memory,
        VkDeviceSize                                memoryOffset);

    VKAPI_ATTR VkResult VKAPI_CALL vkBindImageMemory(
        VkDevice                                    device,
        VkImage                                     image,
        VkDeviceMemory                              memory,
        VkDeviceSize                                memoryOffset);

    VKAPI_ATTR void VKAPI_CALL vkGetBufferMemoryRequirements(
        VkDevice                                    device,
        VkBuffer                                    buffer,
        VkMemoryRequirements*                       pMemoryRequirements);

    VKAPI_ATTR void VKAPI_CALL vkGetImageMemoryRequirements(
        VkDevice                                    device,
        VkImage                                     image,
        VkMemoryRequirements*                       pMemoryRequirements);

    VKAPI_ATTR void VKAPI_CALL vkGetImageSparseMemoryRequirements(
        VkDevice                                    device,
        VkImage                                     image,
        uint32_t*                                   pSparseMemoryRequirementCount,
        VkSparseImageMemoryRequirements*            pSparseMemoryRequirements);

    VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceSparseImageFormatProperties(
        VkPhysicalDevice                            physicalDevice,
        VkFormat                                    format,
        VkImageType                                 type,
        VkSampleCountFlagBits                       samples,
        VkImageUsageFlags                           usage,
        VkImageTiling                               tiling,
        uint32_t*                                   pPropertyCount,
        VkSparseImageFormatProperties*              pProperties);

    VKAPI_ATTR VkResult VKAPI_CALL vkQueueBindSparse(
        VkQueue                                     queue,
        uint32_t                                    bindInfoCount,
        VkBindSparseInfo*                     pBindInfo,
        VkFence                                     fence);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateFence(
        VkDevice                                    device,
        VkFenceCreateInfo*                    pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkFence*                                    pFence);

    VKAPI_ATTR void VKAPI_CALL vkDestroyFence(
        VkDevice                                    device,
        VkFence                                     fence,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkResetFences(
        VkDevice                                    device,
        uint32_t                                    fenceCount,
        VkFence*                              pFences);

    VKAPI_ATTR VkResult VKAPI_CALL vkGetFenceStatus(
        VkDevice                                    device,
        VkFence                                     fence);

    VKAPI_ATTR VkResult VKAPI_CALL vkWaitForFences(
        VkDevice                                    device,
        uint32_t                                    fenceCount,
        VkFence*                              pFences,
        VkBool32                                    waitAll,
        uint64_t                                    timeout);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateSemaphore(
        VkDevice                                    device,
        VkSemaphoreCreateInfo*                pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkSemaphore*                                pSemaphore);

    VKAPI_ATTR void VKAPI_CALL vkDestroySemaphore(
        VkDevice                                    device,
        VkSemaphore                                 semaphore,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateEvent(
        VkDevice                                    device,
        VkEventCreateInfo*                    pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkEvent*                                    pEvent);

    VKAPI_ATTR void VKAPI_CALL vkDestroyEvent(
        VkDevice                                    device,
        VkEvent                                     event,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkGetEventStatus(
        VkDevice                                    device,
        VkEvent                                     event);

    VKAPI_ATTR VkResult VKAPI_CALL vkSetEvent(
        VkDevice                                    device,
        VkEvent                                     event);

    VKAPI_ATTR VkResult VKAPI_CALL vkResetEvent(
        VkDevice                                    device,
        VkEvent                                     event);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateQueryPool(
        VkDevice                                    device,
        VkQueryPoolCreateInfo*                pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkQueryPool*                                pQueryPool);

    VKAPI_ATTR void VKAPI_CALL vkDestroyQueryPool(
        VkDevice                                    device,
        VkQueryPool                                 queryPool,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkGetQueryPoolResults(
        VkDevice                                    device,
        VkQueryPool                                 queryPool,
        uint32_t                                    firstQuery,
        uint32_t                                    queryCount,
        size_t                                      dataSize,
        void*                                       pData,
        VkDeviceSize                                stride,
        VkQueryResultFlags                          flags);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateBuffer(
        VkDevice                                    device,
        VkBufferCreateInfo*                   pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkBuffer*                                   pBuffer);

    VKAPI_ATTR void VKAPI_CALL vkDestroyBuffer(
        VkDevice                                    device,
        VkBuffer                                    buffer,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateBufferView(
        VkDevice                                    device,
        VkBufferViewCreateInfo*               pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkBufferView*                               pView);

    VKAPI_ATTR void VKAPI_CALL vkDestroyBufferView(
        VkDevice                                    device,
        VkBufferView                                bufferView,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateImage(
        VkDevice                                    device,
        VkImageCreateInfo*                    pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkImage*                                    pImage);

    VKAPI_ATTR void VKAPI_CALL vkDestroyImage(
        VkDevice                                    device,
        VkImage                                     image,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR void VKAPI_CALL vkGetImageSubresourceLayout(
        VkDevice                                    device,
        VkImage                                     image,
        VkImageSubresource*                   pSubresource,
        VkSubresourceLayout*                        pLayout);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateImageView(
        VkDevice                                    device,
        VkImageViewCreateInfo*                pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkImageView*                                pView);

    VKAPI_ATTR void VKAPI_CALL vkDestroyImageView(
        VkDevice                                    device,
        VkImageView                                 imageView,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateShaderModule(
        VkDevice                                    device,
        VkShaderModuleCreateInfo*             pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkShaderModule*                             pShaderModule);

    VKAPI_ATTR void VKAPI_CALL vkDestroyShaderModule(
        VkDevice                                    device,
        VkShaderModule                              shaderModule,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreatePipelineCache(
        VkDevice                                    device,
        VkPipelineCacheCreateInfo*            pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkPipelineCache*                            pPipelineCache);

    VKAPI_ATTR void VKAPI_CALL vkDestroyPipelineCache(
        VkDevice                                    device,
        VkPipelineCache                             pipelineCache,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkGetPipelineCacheData(
        VkDevice                                    device,
        VkPipelineCache                             pipelineCache,
        size_t*                                     pDataSize,
        void*                                       pData);

    VKAPI_ATTR VkResult VKAPI_CALL vkMergePipelineCaches(
        VkDevice                                    device,
        VkPipelineCache                             dstCache,
        uint32_t                                    srcCacheCount,
        VkPipelineCache*                      pSrcCaches);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateGraphicsPipelines(
        VkDevice                                    device,
        VkPipelineCache                             pipelineCache,
        uint32_t                                    createInfoCount,
        VkGraphicsPipelineCreateInfo*         pCreateInfos,
        VkAllocationCallbacks*                pAllocator,
        VkPipeline*                                 pPipelines);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateComputePipelines(
        VkDevice                                    device,
        VkPipelineCache                             pipelineCache,
        uint32_t                                    createInfoCount,
        VkComputePipelineCreateInfo*          pCreateInfos,
        VkAllocationCallbacks*                pAllocator,
        VkPipeline*                                 pPipelines);

    VKAPI_ATTR void VKAPI_CALL vkDestroyPipeline(
        VkDevice                                    device,
        VkPipeline                                  pipeline,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreatePipelineLayout(
        VkDevice                                    device,
        VkPipelineLayoutCreateInfo*           pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkPipelineLayout*                           pPipelineLayout);

    VKAPI_ATTR void VKAPI_CALL vkDestroyPipelineLayout(
        VkDevice                                    device,
        VkPipelineLayout                            pipelineLayout,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateSampler(
        VkDevice                                    device,
        VkSamplerCreateInfo*                  pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkSampler*                                  pSampler);

    VKAPI_ATTR void VKAPI_CALL vkDestroySampler(
        VkDevice                                    device,
        VkSampler                                   sampler,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateDescriptorSetLayout(
        VkDevice                                    device,
        VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkDescriptorSetLayout*                      pSetLayout);

    VKAPI_ATTR void VKAPI_CALL vkDestroyDescriptorSetLayout(
        VkDevice                                    device,
        VkDescriptorSetLayout                       descriptorSetLayout,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateDescriptorPool(
        VkDevice                                    device,
        VkDescriptorPoolCreateInfo*           pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkDescriptorPool*                           pDescriptorPool);

    VKAPI_ATTR void VKAPI_CALL vkDestroyDescriptorPool(
        VkDevice                                    device,
        VkDescriptorPool                            descriptorPool,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkResetDescriptorPool(
        VkDevice                                    device,
        VkDescriptorPool                            descriptorPool,
        VkDescriptorPoolResetFlags                  flags);

    VKAPI_ATTR VkResult VKAPI_CALL vkAllocateDescriptorSets(
        VkDevice                                    device,
        VkDescriptorSetAllocateInfo*          pAllocateInfo,
        VkDescriptorSet*                            pDescriptorSets);

    VKAPI_ATTR VkResult VKAPI_CALL vkFreeDescriptorSets(
        VkDevice                                    device,
        VkDescriptorPool                            descriptorPool,
        uint32_t                                    descriptorSetCount,
        VkDescriptorSet*                      pDescriptorSets);

    VKAPI_ATTR void VKAPI_CALL vkUpdateDescriptorSets(
        VkDevice                                    device,
        uint32_t                                    descriptorWriteCount,
        VkWriteDescriptorSet*                 pDescriptorWrites,
        uint32_t                                    descriptorCopyCount,
        VkCopyDescriptorSet*                  pDescriptorCopies);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateFramebuffer(
        VkDevice                                    device,
        VkFramebufferCreateInfo*              pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkFramebuffer*                              pFramebuffer);

    VKAPI_ATTR void VKAPI_CALL vkDestroyFramebuffer(
        VkDevice                                    device,
        VkFramebuffer                               framebuffer,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateRenderPass(
        VkDevice                                    device,
        VkRenderPassCreateInfo*               pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkRenderPass*                               pRenderPass);

    VKAPI_ATTR void VKAPI_CALL vkDestroyRenderPass(
        VkDevice                                    device,
        VkRenderPass                                renderPass,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR void VKAPI_CALL vkGetRenderAreaGranularity(
        VkDevice                                    device,
        VkRenderPass                                renderPass,
        VkExtent2D*                                 pGranularity);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateCommandPool(
        VkDevice                                    device,
        VkCommandPoolCreateInfo*              pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkCommandPool*                              pCommandPool);

    VKAPI_ATTR void VKAPI_CALL vkDestroyCommandPool(
        VkDevice                                    device,
        VkCommandPool                               commandPool,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkResetCommandPool(
        VkDevice                                    device,
        VkCommandPool                               commandPool,
        VkCommandPoolResetFlags                     flags);

    VKAPI_ATTR VkResult VKAPI_CALL vkAllocateCommandBuffers(
        VkDevice                                    device,
        VkCommandBufferAllocateInfo*          pAllocateInfo,
        VkCommandBuffer*                            pCommandBuffers);

    VKAPI_ATTR void VKAPI_CALL vkFreeCommandBuffers(
        VkDevice                                    device,
        VkCommandPool                               commandPool,
        uint32_t                                    commandBufferCount,
        VkCommandBuffer*                      pCommandBuffers);

    VKAPI_ATTR VkResult VKAPI_CALL vkBeginCommandBuffer(
        VkCommandBuffer                             commandBuffer,
        VkCommandBufferBeginInfo*             pBeginInfo);

    VKAPI_ATTR VkResult VKAPI_CALL vkEndCommandBuffer(
        VkCommandBuffer                             commandBuffer);

    VKAPI_ATTR VkResult VKAPI_CALL vkResetCommandBuffer(
        VkCommandBuffer                             commandBuffer,
        VkCommandBufferResetFlags                   flags);

    VKAPI_ATTR void VKAPI_CALL vkCmdBindPipeline(
        VkCommandBuffer                             commandBuffer,
        VkPipelineBindPoint                         pipelineBindPoint,
        VkPipeline                                  pipeline);

    VKAPI_ATTR void VKAPI_CALL vkCmdSetViewport(
        VkCommandBuffer                             commandBuffer,
        uint32_t                                    firstViewport,
        uint32_t                                    viewportCount,
        VkViewport*                           pViewports);

    VKAPI_ATTR void VKAPI_CALL vkCmdSetScissor(
        VkCommandBuffer                             commandBuffer,
        uint32_t                                    firstScissor,
        uint32_t                                    scissorCount,
        VkRect2D*                             pScissors);

    VKAPI_ATTR void VKAPI_CALL vkCmdSetLineWidth(
        VkCommandBuffer                             commandBuffer,
        float                                       lineWidth);

    VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthBias(
        VkCommandBuffer                             commandBuffer,
        float                                       depthBiasConstantFactor,
        float                                       depthBiasClamp,
        float                                       depthBiasSlopeFactor);

    VKAPI_ATTR void VKAPI_CALL vkCmdSetBlendConstants(
        VkCommandBuffer                             commandBuffer,
        float                                 blendConstants[4]);

    VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthBounds(
        VkCommandBuffer                             commandBuffer,
        float                                       minDepthBounds,
        float                                       maxDepthBounds);

    VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilCompareMask(
        VkCommandBuffer                             commandBuffer,
        VkStencilFaceFlags                          faceMask,
        uint32_t                                    compareMask);

    VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilWriteMask(
        VkCommandBuffer                             commandBuffer,
        VkStencilFaceFlags                          faceMask,
        uint32_t                                    writeMask);

    VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilReference(
        VkCommandBuffer                             commandBuffer,
        VkStencilFaceFlags                          faceMask,
        uint32_t                                    reference);

    VKAPI_ATTR void VKAPI_CALL vkCmdBindDescriptorSets(
        VkCommandBuffer                             commandBuffer,
        VkPipelineBindPoint                         pipelineBindPoint,
        VkPipelineLayout                            layout,
        uint32_t                                    firstSet,
        uint32_t                                    descriptorSetCount,
        VkDescriptorSet*                      pDescriptorSets,
        uint32_t                                    dynamicOffsetCount,
        uint32_t*                             pDynamicOffsets);

    VKAPI_ATTR void VKAPI_CALL vkCmdBindIndexBuffer(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    buffer,
        VkDeviceSize                                offset,
        VkIndexType                                 indexType);

    VKAPI_ATTR void VKAPI_CALL vkCmdBindVertexBuffers(
        VkCommandBuffer                             commandBuffer,
        uint32_t                                    firstBinding,
        uint32_t                                    bindingCount,
        VkBuffer*                             pBuffers,
        VkDeviceSize*                         pOffsets);

    VKAPI_ATTR void VKAPI_CALL vkCmdDraw(
        VkCommandBuffer                             commandBuffer,
        uint32_t                                    vertexCount,
        uint32_t                                    instanceCount,
        uint32_t                                    firstVertex,
        uint32_t                                    firstInstance);

    VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexed(
        VkCommandBuffer                             commandBuffer,
        uint32_t                                    indexCount,
        uint32_t                                    instanceCount,
        uint32_t                                    firstIndex,
        int32_t                                     vertexOffset,
        uint32_t                                    firstInstance);

    VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndirect(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    buffer,
        VkDeviceSize                                offset,
        uint32_t                                    drawCount,
        uint32_t                                    stride);

    VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexedIndirect(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    buffer,
        VkDeviceSize                                offset,
        uint32_t                                    drawCount,
        uint32_t                                    stride);

    VKAPI_ATTR void VKAPI_CALL vkCmdDispatch(
        VkCommandBuffer                             commandBuffer,
        uint32_t                                    x,
        uint32_t                                    y,
        uint32_t                                    z);

    VKAPI_ATTR void VKAPI_CALL vkCmdDispatchIndirect(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    buffer,
        VkDeviceSize                                offset);

    VKAPI_ATTR void VKAPI_CALL vkCmdCopyBuffer(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    srcBuffer,
        VkBuffer                                    dstBuffer,
        uint32_t                                    regionCount,
        VkBufferCopy*                         pRegions);

    VKAPI_ATTR void VKAPI_CALL vkCmdCopyImage(
        VkCommandBuffer                             commandBuffer,
        VkImage                                     srcImage,
        VkImageLayout                               srcImageLayout,
        VkImage                                     dstImage,
        VkImageLayout                               dstImageLayout,
        uint32_t                                    regionCount,
        VkImageCopy*                          pRegions);

    VKAPI_ATTR void VKAPI_CALL vkCmdBlitImage(
        VkCommandBuffer                             commandBuffer,
        VkImage                                     srcImage,
        VkImageLayout                               srcImageLayout,
        VkImage                                     dstImage,
        VkImageLayout                               dstImageLayout,
        uint32_t                                    regionCount,
        VkImageBlit*                          pRegions,
        VkFilter                                    filter);

    VKAPI_ATTR void VKAPI_CALL vkCmdCopyBufferToImage(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    srcBuffer,
        VkImage                                     dstImage,
        VkImageLayout                               dstImageLayout,
        uint32_t                                    regionCount,
        VkBufferImageCopy*                    pRegions);

    VKAPI_ATTR void VKAPI_CALL vkCmdCopyImageToBuffer(
        VkCommandBuffer                             commandBuffer,
        VkImage                                     srcImage,
        VkImageLayout                               srcImageLayout,
        VkBuffer                                    dstBuffer,
        uint32_t                                    regionCount,
        VkBufferImageCopy*                    pRegions);

    VKAPI_ATTR void VKAPI_CALL vkCmdUpdateBuffer(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    dstBuffer,
        VkDeviceSize                                dstOffset,
        VkDeviceSize                                dataSize,
        void*                                 pData);

    VKAPI_ATTR void VKAPI_CALL vkCmdFillBuffer(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    dstBuffer,
        VkDeviceSize                                dstOffset,
        VkDeviceSize                                size,
        uint32_t                                    data);

    VKAPI_ATTR void VKAPI_CALL vkCmdClearColorImage(
        VkCommandBuffer                             commandBuffer,
        VkImage                                     image,
        VkImageLayout                               imageLayout,
        VkClearColorValue*                    pColor,
        uint32_t                                    rangeCount,
        VkImageSubresourceRange*              pRanges);

    VKAPI_ATTR void VKAPI_CALL vkCmdClearDepthStencilImage(
        VkCommandBuffer                             commandBuffer,
        VkImage                                     image,
        VkImageLayout                               imageLayout,
        VkClearDepthStencilValue*             pDepthStencil,
        uint32_t                                    rangeCount,
        VkImageSubresourceRange*              pRanges);

    VKAPI_ATTR void VKAPI_CALL vkCmdClearAttachments(
        VkCommandBuffer                             commandBuffer,
        uint32_t                                    attachmentCount,
        VkClearAttachment*                    pAttachments,
        uint32_t                                    rectCount,
        VkClearRect*                          pRects);

    VKAPI_ATTR void VKAPI_CALL vkCmdResolveImage(
        VkCommandBuffer                             commandBuffer,
        VkImage                                     srcImage,
        VkImageLayout                               srcImageLayout,
        VkImage                                     dstImage,
        VkImageLayout                               dstImageLayout,
        uint32_t                                    regionCount,
        VkImageResolve*                       pRegions);

    VKAPI_ATTR void VKAPI_CALL vkCmdSetEvent(
        VkCommandBuffer                             commandBuffer,
        VkEvent                                     event,
        VkPipelineStageFlags                        stageMask);

    VKAPI_ATTR void VKAPI_CALL vkCmdResetEvent(
        VkCommandBuffer                             commandBuffer,
        VkEvent                                     event,
        VkPipelineStageFlags                        stageMask);

    VKAPI_ATTR void VKAPI_CALL vkCmdWaitEvents(
        VkCommandBuffer                             commandBuffer,
        uint32_t                                    eventCount,
        VkEvent*                              pEvents,
        VkPipelineStageFlags                        srcStageMask,
        VkPipelineStageFlags                        dstStageMask,
        uint32_t                                    memoryBarrierCount,
        VkMemoryBarrier*                      pMemoryBarriers,
        uint32_t                                    bufferMemoryBarrierCount,
        VkBufferMemoryBarrier*                pBufferMemoryBarriers,
        uint32_t                                    imageMemoryBarrierCount,
        VkImageMemoryBarrier*                 pImageMemoryBarriers);

    VKAPI_ATTR void VKAPI_CALL vkCmdPipelineBarrier(
        VkCommandBuffer                             commandBuffer,
        VkPipelineStageFlags                        srcStageMask,
        VkPipelineStageFlags                        dstStageMask,
        VkDependencyFlags                           dependencyFlags,
        uint32_t                                    memoryBarrierCount,
        VkMemoryBarrier*                      pMemoryBarriers,
        uint32_t                                    bufferMemoryBarrierCount,
        VkBufferMemoryBarrier*                pBufferMemoryBarriers,
        uint32_t                                    imageMemoryBarrierCount,
        VkImageMemoryBarrier*                 pImageMemoryBarriers);

    VKAPI_ATTR void VKAPI_CALL vkCmdBeginQuery(
        VkCommandBuffer                             commandBuffer,
        VkQueryPool                                 queryPool,
        uint32_t                                    query,
        VkQueryControlFlags                         flags);

    VKAPI_ATTR void VKAPI_CALL vkCmdEndQuery(
        VkCommandBuffer                             commandBuffer,
        VkQueryPool                                 queryPool,
        uint32_t                                    query);

    VKAPI_ATTR void VKAPI_CALL vkCmdResetQueryPool(
        VkCommandBuffer                             commandBuffer,
        VkQueryPool                                 queryPool,
        uint32_t                                    firstQuery,
        uint32_t                                    queryCount);

    VKAPI_ATTR void VKAPI_CALL vkCmdWriteTimestamp(
        VkCommandBuffer                             commandBuffer,
        VkPipelineStageFlagBits                     pipelineStage,
        VkQueryPool                                 queryPool,
        uint32_t                                    query);

    VKAPI_ATTR void VKAPI_CALL vkCmdCopyQueryPoolResults(
        VkCommandBuffer                             commandBuffer,
        VkQueryPool                                 queryPool,
        uint32_t                                    firstQuery,
        uint32_t                                    queryCount,
        VkBuffer                                    dstBuffer,
        VkDeviceSize                                dstOffset,
        VkDeviceSize                                stride,
        VkQueryResultFlags                          flags);

    VKAPI_ATTR void VKAPI_CALL vkCmdPushConstants(
        VkCommandBuffer                             commandBuffer,
        VkPipelineLayout                            layout,
        VkShaderStageFlags                          stageFlags,
        uint32_t                                    offset,
        uint32_t                                    size,
        void*                                 pValues);

    VKAPI_ATTR void VKAPI_CALL vkCmdBeginRenderPass(
        VkCommandBuffer                             commandBuffer,
        VkRenderPassBeginInfo*                pRenderPassBegin,
        VkSubpassContents                           contents);

    VKAPI_ATTR void VKAPI_CALL vkCmdNextSubpass(
        VkCommandBuffer                             commandBuffer,
        VkSubpassContents                           contents);

    VKAPI_ATTR void VKAPI_CALL vkCmdEndRenderPass(
        VkCommandBuffer                             commandBuffer);

    VKAPI_ATTR void VKAPI_CALL vkCmdExecuteCommands(
        VkCommandBuffer                             commandBuffer,
        uint32_t                                    commandBufferCount,
        VkCommandBuffer*                      pCommandBuffers);
#endif

#define VK_KHR_surface 1
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSurfaceKHR)

#define VK_KHR_SURFACE_SPEC_VERSION       25
#define VK_KHR_SURFACE_EXTENSION_NAME     "VK_KHR_surface"
#define VK_COLORSPACE_SRGB_NONLINEAR_KHR  VK_COLOR_SPACE_SRGB_NONLINEAR_KHR


    typedef enum VkColorSpaceKHR {
        VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
        VK_COLOR_SPACE_BEGIN_RANGE_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
        VK_COLOR_SPACE_END_RANGE_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
        VK_COLOR_SPACE_RANGE_SIZE_KHR = (VK_COLOR_SPACE_SRGB_NONLINEAR_KHR - VK_COLOR_SPACE_SRGB_NONLINEAR_KHR + 1),
        VK_COLOR_SPACE_MAX_ENUM_KHR = 0x7FFFFFFF
    } VkColorSpaceKHR;

    typedef enum VkPresentModeKHR {
        VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
        VK_PRESENT_MODE_MAILBOX_KHR = 1,
        VK_PRESENT_MODE_FIFO_KHR = 2,
        VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
        VK_PRESENT_MODE_BEGIN_RANGE_KHR = VK_PRESENT_MODE_IMMEDIATE_KHR,
        VK_PRESENT_MODE_END_RANGE_KHR = VK_PRESENT_MODE_FIFO_RELAXED_KHR,
        VK_PRESENT_MODE_RANGE_SIZE_KHR = (VK_PRESENT_MODE_FIFO_RELAXED_KHR - VK_PRESENT_MODE_IMMEDIATE_KHR + 1),
        VK_PRESENT_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
    } VkPresentModeKHR;


    typedef enum VkSurfaceTransformFlagBitsKHR {
        VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x00000001,
        VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x00000002,
        VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x00000004,
        VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x00000008,
        VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x00000010,
        VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x00000020,
        VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
        VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080,
        VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x00000100,
        VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
    } VkSurfaceTransformFlagBitsKHR;
    typedef VkFlags VkSurfaceTransformFlagsKHR;

    typedef enum VkCompositeAlphaFlagBitsKHR {
        VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
        VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0x00000002,
        VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x00000004,
        VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0x00000008,
        VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
    } VkCompositeAlphaFlagBitsKHR;
    typedef VkFlags VkCompositeAlphaFlagsKHR;

    typedef struct VkSurfaceCapabilitiesKHR {
        uint32_t                         minImageCount;
        uint32_t                         maxImageCount;
        VkExtent2D                       currentExtent;
        VkExtent2D                       minImageExtent;
        VkExtent2D                       maxImageExtent;
        uint32_t                         maxImageArrayLayers;
        VkSurfaceTransformFlagsKHR       supportedTransforms;
        VkSurfaceTransformFlagBitsKHR    currentTransform;
        VkCompositeAlphaFlagsKHR         supportedCompositeAlpha;
        VkImageUsageFlags                supportedUsageFlags;
    } VkSurfaceCapabilitiesKHR;

    typedef struct VkSurfaceFormatKHR {
        VkFormat           format;
        VkColorSpaceKHR    colorSpace;
    } VkSurfaceFormatKHR;


    typedef void (VKAPI_PTR *PFN_vkDestroySurfaceKHR)(VkInstance instance, VkSurfaceKHR surface, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported);
    typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities);
    typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats);
    typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes);

#ifndef VK_NO_PROTOTYPES
    VKAPI_ATTR void VKAPI_CALL vkDestroySurfaceKHR(
        VkInstance                                  instance,
        VkSurfaceKHR                                surface,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceSupportKHR(
        VkPhysicalDevice                            physicalDevice,
        uint32_t                                    queueFamilyIndex,
        VkSurfaceKHR                                surface,
        VkBool32*                                   pSupported);

    VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
        VkPhysicalDevice                            physicalDevice,
        VkSurfaceKHR                                surface,
        VkSurfaceCapabilitiesKHR*                   pSurfaceCapabilities);

    VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceFormatsKHR(
        VkPhysicalDevice                            physicalDevice,
        VkSurfaceKHR                                surface,
        uint32_t*                                   pSurfaceFormatCount,
        VkSurfaceFormatKHR*                         pSurfaceFormats);

    VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfacePresentModesKHR(
        VkPhysicalDevice                            physicalDevice,
        VkSurfaceKHR                                surface,
        uint32_t*                                   pPresentModeCount,
        VkPresentModeKHR*                           pPresentModes);
#endif

#define VK_KHR_swapchain 1
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSwapchainKHR)

#define VK_KHR_SWAPCHAIN_SPEC_VERSION     68
#define VK_KHR_SWAPCHAIN_EXTENSION_NAME   "VK_KHR_swapchain"

    typedef VkFlags VkSwapchainCreateFlagsKHR;

    typedef struct VkSwapchainCreateInfoKHR {
        VkStructureType                  sType;
        void*                      pNext;
        VkSwapchainCreateFlagsKHR        flags;
        VkSurfaceKHR                     surface;
        uint32_t                         minImageCount;
        VkFormat                         imageFormat;
        VkColorSpaceKHR                  imageColorSpace;
        VkExtent2D                       imageExtent;
        uint32_t                         imageArrayLayers;
        VkImageUsageFlags                imageUsage;
        VkSharingMode                    imageSharingMode;
        uint32_t                         queueFamilyIndexCount;
        uint32_t*                  pQueueFamilyIndices;
        VkSurfaceTransformFlagBitsKHR    preTransform;
        VkCompositeAlphaFlagBitsKHR      compositeAlpha;
        VkPresentModeKHR                 presentMode;
        VkBool32                         clipped;
        VkSwapchainKHR                   oldSwapchain;
    } VkSwapchainCreateInfoKHR;

    typedef struct VkPresentInfoKHR {
        VkStructureType          sType;
        void*              pNext;
        uint32_t                 waitSemaphoreCount;
        VkSemaphore*       pWaitSemaphores;
        uint32_t                 swapchainCount;
        VkSwapchainKHR*    pSwapchains;
        uint32_t*          pImageIndices;
        VkResult*                pResults;
    } VkPresentInfoKHR;


    typedef VkResult (VKAPI_PTR *PFN_vkCreateSwapchainKHR)(VkDevice device, VkSwapchainCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain);
    typedef void (VKAPI_PTR *PFN_vkDestroySwapchainKHR)(VkDevice device, VkSwapchainKHR swapchain, VkAllocationCallbacks* pAllocator);
    typedef VkResult (VKAPI_PTR *PFN_vkGetSwapchainImagesKHR)(VkDevice device, VkSwapchainKHR swapchain, uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages);
    typedef VkResult (VKAPI_PTR *PFN_vkAcquireNextImageKHR)(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex);
    typedef VkResult (VKAPI_PTR *PFN_vkQueuePresentKHR)(VkQueue queue, VkPresentInfoKHR* pPresentInfo);

#ifndef VK_NO_PROTOTYPES
    VKAPI_ATTR VkResult VKAPI_CALL vkCreateSwapchainKHR(
        VkDevice                                    device,
        VkSwapchainCreateInfoKHR*             pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkSwapchainKHR*                             pSwapchain);

    VKAPI_ATTR void VKAPI_CALL vkDestroySwapchainKHR(
        VkDevice                                    device,
        VkSwapchainKHR                              swapchain,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR VkResult VKAPI_CALL vkGetSwapchainImagesKHR(
        VkDevice                                    device,
        VkSwapchainKHR                              swapchain,
        uint32_t*                                   pSwapchainImageCount,
        VkImage*                                    pSwapchainImages);

    VKAPI_ATTR VkResult VKAPI_CALL vkAcquireNextImageKHR(
        VkDevice                                    device,
        VkSwapchainKHR                              swapchain,
        uint64_t                                    timeout,
        VkSemaphore                                 semaphore,
        VkFence                                     fence,
        uint32_t*                                   pImageIndex);

    VKAPI_ATTR VkResult VKAPI_CALL vkQueuePresentKHR(
        VkQueue                                     queue,
        VkPresentInfoKHR*                     pPresentInfo);
#endif

#define VK_KHR_display 1
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayKHR)
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayModeKHR)

#define VK_KHR_DISPLAY_SPEC_VERSION       21
#define VK_KHR_DISPLAY_EXTENSION_NAME     "VK_KHR_display"


    typedef enum VkDisplayPlaneAlphaFlagBitsKHR {
        VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
        VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x00000002,
        VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x00000004,
        VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008,
        VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
    } VkDisplayPlaneAlphaFlagBitsKHR;
    typedef VkFlags VkDisplayPlaneAlphaFlagsKHR;
    typedef VkFlags VkDisplayModeCreateFlagsKHR;
    typedef VkFlags VkDisplaySurfaceCreateFlagsKHR;

    typedef struct VkDisplayPropertiesKHR {
        VkDisplayKHR                  display;
        char*                   displayName;
        VkExtent2D                    physicalDimensions;
        VkExtent2D                    physicalResolution;
        VkSurfaceTransformFlagsKHR    supportedTransforms;
        VkBool32                      planeReorderPossible;
        VkBool32                      persistentContent;
    } VkDisplayPropertiesKHR;

    typedef struct VkDisplayModeParametersKHR {
        VkExtent2D    visibleRegion;
        uint32_t      refreshRate;
    } VkDisplayModeParametersKHR;

    typedef struct VkDisplayModePropertiesKHR {
        VkDisplayModeKHR              displayMode;
        VkDisplayModeParametersKHR    parameters;
    } VkDisplayModePropertiesKHR;

    typedef struct VkDisplayModeCreateInfoKHR {
        VkStructureType                sType;
        void*                    pNext;
        VkDisplayModeCreateFlagsKHR    flags;
        VkDisplayModeParametersKHR     parameters;
    } VkDisplayModeCreateInfoKHR;

    typedef struct VkDisplayPlaneCapabilitiesKHR {
        VkDisplayPlaneAlphaFlagsKHR    supportedAlpha;
        VkOffset2D                     minSrcPosition;
        VkOffset2D                     maxSrcPosition;
        VkExtent2D                     minSrcExtent;
        VkExtent2D                     maxSrcExtent;
        VkOffset2D                     minDstPosition;
        VkOffset2D                     maxDstPosition;
        VkExtent2D                     minDstExtent;
        VkExtent2D                     maxDstExtent;
    } VkDisplayPlaneCapabilitiesKHR;

    typedef struct VkDisplayPlanePropertiesKHR {
        VkDisplayKHR    currentDisplay;
        uint32_t        currentStackIndex;
    } VkDisplayPlanePropertiesKHR;

    typedef struct VkDisplaySurfaceCreateInfoKHR {
        VkStructureType                   sType;
        void*                       pNext;
        VkDisplaySurfaceCreateFlagsKHR    flags;
        VkDisplayModeKHR                  displayMode;
        uint32_t                          planeIndex;
        uint32_t                          planeStackIndex;
        VkSurfaceTransformFlagBitsKHR     transform;
        float                             globalAlpha;
        VkDisplayPlaneAlphaFlagBitsKHR    alphaMode;
        VkExtent2D                        imageExtent;
    } VkDisplaySurfaceCreateInfoKHR;


    typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPropertiesKHR* pProperties);
    typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties);
    typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayPlaneSupportedDisplaysKHR)(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t* pDisplayCount, VkDisplayKHR* pDisplays);
    typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayModePropertiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModePropertiesKHR* pProperties);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateDisplayModeKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, VkDisplayModeCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode);
    typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayPlaneCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities);
    typedef VkResult (VKAPI_PTR *PFN_vkCreateDisplayPlaneSurfaceKHR)(VkInstance instance, VkDisplaySurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);

#ifndef VK_NO_PROTOTYPES
    VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceDisplayPropertiesKHR(
        VkPhysicalDevice                            physicalDevice,
        uint32_t*                                   pPropertyCount,
        VkDisplayPropertiesKHR*                     pProperties);

    VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
        VkPhysicalDevice                            physicalDevice,
        uint32_t*                                   pPropertyCount,
        VkDisplayPlanePropertiesKHR*                pProperties);

    VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayPlaneSupportedDisplaysKHR(
        VkPhysicalDevice                            physicalDevice,
        uint32_t                                    planeIndex,
        uint32_t*                                   pDisplayCount,
        VkDisplayKHR*                               pDisplays);

    VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayModePropertiesKHR(
        VkPhysicalDevice                            physicalDevice,
        VkDisplayKHR                                display,
        uint32_t*                                   pPropertyCount,
        VkDisplayModePropertiesKHR*                 pProperties);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateDisplayModeKHR(
        VkPhysicalDevice                            physicalDevice,
        VkDisplayKHR                                display,
        VkDisplayModeCreateInfoKHR*           pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkDisplayModeKHR*                           pMode);

    VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayPlaneCapabilitiesKHR(
        VkPhysicalDevice                            physicalDevice,
        VkDisplayModeKHR                            mode,
        uint32_t                                    planeIndex,
        VkDisplayPlaneCapabilitiesKHR*              pCapabilities);

    VKAPI_ATTR VkResult VKAPI_CALL vkCreateDisplayPlaneSurfaceKHR(
        VkInstance                                  instance,
        VkDisplaySurfaceCreateInfoKHR*        pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkSurfaceKHR*                               pSurface);
#endif

#define VK_KHR_display_swapchain 1
#define VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION 9
#define VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME "VK_KHR_display_swapchain"

    typedef struct VkDisplayPresentInfoKHR {
        VkStructureType    sType;
        void*        pNext;
        VkRect2D           srcRect;
        VkRect2D           dstRect;
        VkBool32           persistent;
    } VkDisplayPresentInfoKHR;


    typedef VkResult (VKAPI_PTR *PFN_vkCreateSharedSwapchainsKHR)(VkDevice device, uint32_t swapchainCount, VkSwapchainCreateInfoKHR* pCreateInfos, VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains);

#ifndef VK_NO_PROTOTYPES
    VKAPI_ATTR VkResult VKAPI_CALL vkCreateSharedSwapchainsKHR(
        VkDevice                                    device,
        uint32_t                                    swapchainCount,
        VkSwapchainCreateInfoKHR*             pCreateInfos,
        VkAllocationCallbacks*                pAllocator,
        VkSwapchainKHR*                             pSwapchains);
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR
#define VK_KHR_xlib_surface 1
#include <X11/Xlib.h>

#define VK_KHR_XLIB_SURFACE_SPEC_VERSION  6
#define VK_KHR_XLIB_SURFACE_EXTENSION_NAME "VK_KHR_xlib_surface"

    typedef VkFlags VkXlibSurfaceCreateFlagsKHR;

    typedef struct VkXlibSurfaceCreateInfoKHR {
        VkStructureType                sType;
        void*                    pNext;
        VkXlibSurfaceCreateFlagsKHR    flags;
        Display*                       dpy;
        Window                         window;
    } VkXlibSurfaceCreateInfoKHR;


    typedef VkResult (VKAPI_PTR *PFN_vkCreateXlibSurfaceKHR)(VkInstance instance, VkXlibSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
    typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display* dpy, VisualID visualID);

#ifndef VK_NO_PROTOTYPES
    VKAPI_ATTR VkResult VKAPI_CALL vkCreateXlibSurfaceKHR(
        VkInstance                                  instance,
        VkXlibSurfaceCreateInfoKHR*           pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkSurfaceKHR*                               pSurface);

    VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceXlibPresentationSupportKHR(
        VkPhysicalDevice                            physicalDevice,
        uint32_t                                    queueFamilyIndex,
        Display*                                    dpy,
        VisualID                                    visualID);
#endif
#endif /* VK_USE_PLATFORM_XLIB_KHR */

#ifdef VK_USE_PLATFORM_XCB_KHR
#define VK_KHR_xcb_surface 1
#include <xcb/xcb.h>

#define VK_KHR_XCB_SURFACE_SPEC_VERSION   6
#define VK_KHR_XCB_SURFACE_EXTENSION_NAME "VK_KHR_xcb_surface"

    typedef VkFlags VkXcbSurfaceCreateFlagsKHR;

    typedef struct VkXcbSurfaceCreateInfoKHR {
        VkStructureType               sType;
        void*                   pNext;
        VkXcbSurfaceCreateFlagsKHR    flags;
        xcb_connection_t*             connection;
        xcb_window_t                  window;
    } VkXcbSurfaceCreateInfoKHR;


    typedef VkResult (VKAPI_PTR *PFN_vkCreateXcbSurfaceKHR)(VkInstance instance, VkXcbSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
    typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id);

#ifndef VK_NO_PROTOTYPES
    VKAPI_ATTR VkResult VKAPI_CALL vkCreateXcbSurfaceKHR(
        VkInstance                                  instance,
        VkXcbSurfaceCreateInfoKHR*            pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkSurfaceKHR*                               pSurface);

    VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceXcbPresentationSupportKHR(
        VkPhysicalDevice                            physicalDevice,
        uint32_t                                    queueFamilyIndex,
        xcb_connection_t*                           connection,
        xcb_visualid_t                              visual_id);
#endif
#endif /* VK_USE_PLATFORM_XCB_KHR */

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
#define VK_KHR_wayland_surface 1
#include <wayland-client.h>

#define VK_KHR_WAYLAND_SURFACE_SPEC_VERSION 5
#define VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME "VK_KHR_wayland_surface"

    typedef VkFlags VkWaylandSurfaceCreateFlagsKHR;

    typedef struct VkWaylandSurfaceCreateInfoKHR {
        VkStructureType                   sType;
        void*                       pNext;
        VkWaylandSurfaceCreateFlagsKHR    flags;
        struct wl_display*                display;
        struct wl_surface*                surface;
    } VkWaylandSurfaceCreateInfoKHR;


    typedef VkResult (VKAPI_PTR *PFN_vkCreateWaylandSurfaceKHR)(VkInstance instance, VkWaylandSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
    typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display* display);

#ifndef VK_NO_PROTOTYPES
    VKAPI_ATTR VkResult VKAPI_CALL vkCreateWaylandSurfaceKHR(
        VkInstance                                  instance,
        VkWaylandSurfaceCreateInfoKHR*        pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkSurfaceKHR*                               pSurface);

    VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceWaylandPresentationSupportKHR(
        VkPhysicalDevice                            physicalDevice,
        uint32_t                                    queueFamilyIndex,
        struct wl_display*                          display);
#endif
#endif /* VK_USE_PLATFORM_WAYLAND_KHR */

#ifdef VK_USE_PLATFORM_MIR_KHR
#define VK_KHR_mir_surface 1
#include <mir_toolkit/client_types.h>

#define VK_KHR_MIR_SURFACE_SPEC_VERSION   4
#define VK_KHR_MIR_SURFACE_EXTENSION_NAME "VK_KHR_mir_surface"

    typedef VkFlags VkMirSurfaceCreateFlagsKHR;

    typedef struct VkMirSurfaceCreateInfoKHR {
        VkStructureType               sType;
        void*                   pNext;
        VkMirSurfaceCreateFlagsKHR    flags;
        MirConnection*                connection;
        MirSurface*                   mirSurface;
    } VkMirSurfaceCreateInfoKHR;


    typedef VkResult (VKAPI_PTR *PFN_vkCreateMirSurfaceKHR)(VkInstance instance, VkMirSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
    typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceMirPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, MirConnection* connection);

#ifndef VK_NO_PROTOTYPES
    VKAPI_ATTR VkResult VKAPI_CALL vkCreateMirSurfaceKHR(
        VkInstance                                  instance,
        VkMirSurfaceCreateInfoKHR*            pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkSurfaceKHR*                               pSurface);

    VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceMirPresentationSupportKHR(
        VkPhysicalDevice                            physicalDevice,
        uint32_t                                    queueFamilyIndex,
        MirConnection*                              connection);
#endif
#endif /* VK_USE_PLATFORM_MIR_KHR */

#ifdef VK_USE_PLATFORM_ANDROID_KHR
#define VK_KHR_android_surface 1
#include <android/native_window.h>

#define VK_KHR_ANDROID_SURFACE_SPEC_VERSION 6
#define VK_KHR_ANDROID_SURFACE_EXTENSION_NAME "VK_KHR_android_surface"

    typedef VkFlags VkAndroidSurfaceCreateFlagsKHR;

    typedef struct VkAndroidSurfaceCreateInfoKHR {
        VkStructureType                   sType;
        void*                       pNext;
        VkAndroidSurfaceCreateFlagsKHR    flags;
        ANativeWindow*                    window;
    } VkAndroidSurfaceCreateInfoKHR;


    typedef VkResult (VKAPI_PTR *PFN_vkCreateAndroidSurfaceKHR)(VkInstance instance, VkAndroidSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);

#ifndef VK_NO_PROTOTYPES
    VKAPI_ATTR VkResult VKAPI_CALL vkCreateAndroidSurfaceKHR(
        VkInstance                                  instance,
        VkAndroidSurfaceCreateInfoKHR*        pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkSurfaceKHR*                               pSurface);
#endif
#endif /* VK_USE_PLATFORM_ANDROID_KHR */

#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_KHR_win32_surface 1
#include <windows.h>

#define VK_KHR_WIN32_SURFACE_SPEC_VERSION 5
#define VK_KHR_WIN32_SURFACE_EXTENSION_NAME "VK_KHR_win32_surface"

    typedef VkFlags VkWin32SurfaceCreateFlagsKHR;

    typedef struct VkWin32SurfaceCreateInfoKHR {
        VkStructureType                 sType;
        void*                     pNext;
        VkWin32SurfaceCreateFlagsKHR    flags;
        HINSTANCE                       hinstance;
        HWND                            hwnd;
    } VkWin32SurfaceCreateInfoKHR;


    typedef VkResult (VKAPI_PTR *PFN_vkCreateWin32SurfaceKHR)(VkInstance instance, VkWin32SurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
    typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex);

#ifndef VK_NO_PROTOTYPES
    VKAPI_ATTR VkResult VKAPI_CALL vkCreateWin32SurfaceKHR(
        VkInstance                                  instance,
        VkWin32SurfaceCreateInfoKHR*          pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkSurfaceKHR*                               pSurface);

    VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceWin32PresentationSupportKHR(
        VkPhysicalDevice                            physicalDevice,
        uint32_t                                    queueFamilyIndex);
#endif
#endif /* VK_USE_PLATFORM_WIN32_KHR */

#define VK_KHR_sampler_mirror_clamp_to_edge 1
#define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION 1
#define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME "VK_KHR_sampler_mirror_clamp_to_edge"


#define VK_EXT_debug_report 1
    VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDebugReportCallbackEXT)

#define VK_EXT_DEBUG_REPORT_SPEC_VERSION  3
#define VK_EXT_DEBUG_REPORT_EXTENSION_NAME "VK_EXT_debug_report"
#define VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT


    typedef enum VkDebugReportObjectTypeEXT {
        VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
        VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
        VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
        VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
        VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
        VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
        VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
        VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
        VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
        VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
        VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
        VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
        VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
        VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
        VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
        VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
        VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
        VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
        VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
        VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
        VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
        VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
        VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
        VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
        VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
        VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
        VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
        VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
        VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = 28,
        VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
        VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT,
        VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT = (VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT - VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT + 1),
        VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
    } VkDebugReportObjectTypeEXT;

    typedef enum VkDebugReportErrorEXT {
        VK_DEBUG_REPORT_ERROR_NONE_EXT = 0,
        VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT = 1,
        VK_DEBUG_REPORT_ERROR_BEGIN_RANGE_EXT = VK_DEBUG_REPORT_ERROR_NONE_EXT,
        VK_DEBUG_REPORT_ERROR_END_RANGE_EXT = VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT,
        VK_DEBUG_REPORT_ERROR_RANGE_SIZE_EXT = (VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT - VK_DEBUG_REPORT_ERROR_NONE_EXT + 1),
        VK_DEBUG_REPORT_ERROR_MAX_ENUM_EXT = 0x7FFFFFFF
    } VkDebugReportErrorEXT;


    typedef enum VkDebugReportFlagBitsEXT {
        VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0x00000001,
        VK_DEBUG_REPORT_WARNING_BIT_EXT = 0x00000002,
        VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004,
        VK_DEBUG_REPORT_ERROR_BIT_EXT = 0x00000008,
        VK_DEBUG_REPORT_DEBUG_BIT_EXT = 0x00000010,
        VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
    } VkDebugReportFlagBitsEXT;
    typedef VkFlags VkDebugReportFlagsEXT;

    typedef VkBool32 (VKAPI_PTR *PFN_vkDebugReportCallbackEXT)(
        VkDebugReportFlagsEXT                       flags,
        VkDebugReportObjectTypeEXT                  objectType,
        uint64_t                                    object,
        size_t                                      location,
        int32_t                                     messageCode,
        char*                                 pLayerPrefix,
        char*                                 pMessage,
        void*                                       pUserData);


    typedef struct VkDebugReportCallbackCreateInfoEXT {
        VkStructureType                 sType;
        void*                     pNext;
        VkDebugReportFlagsEXT           flags;
        PFN_vkDebugReportCallbackEXT    pfnCallback;
        void*                           pUserData;
    } VkDebugReportCallbackCreateInfoEXT;


    typedef VkResult (VKAPI_PTR *PFN_vkCreateDebugReportCallbackEXT)(VkInstance instance, VkDebugReportCallbackCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDebugReportCallbackEXT* pCallback);
    typedef void (VKAPI_PTR *PFN_vkDestroyDebugReportCallbackEXT)(VkInstance instance, VkDebugReportCallbackEXT callback, VkAllocationCallbacks* pAllocator);
    typedef void (VKAPI_PTR *PFN_vkDebugReportMessageEXT)(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, char* pLayerPrefix, char* pMessage);

#ifndef VK_NO_PROTOTYPES
    VKAPI_ATTR VkResult VKAPI_CALL vkCreateDebugReportCallbackEXT(
        VkInstance                                  instance,
        VkDebugReportCallbackCreateInfoEXT*   pCreateInfo,
        VkAllocationCallbacks*                pAllocator,
        VkDebugReportCallbackEXT*                   pCallback);

    VKAPI_ATTR void VKAPI_CALL vkDestroyDebugReportCallbackEXT(
        VkInstance                                  instance,
        VkDebugReportCallbackEXT                    callback,
        VkAllocationCallbacks*                pAllocator);

    VKAPI_ATTR void VKAPI_CALL vkDebugReportMessageEXT(
        VkInstance                                  instance,
        VkDebugReportFlagsEXT                       flags,
        VkDebugReportObjectTypeEXT                  objectType,
        uint64_t                                    object,
        size_t                                      location,
        int32_t                                     messageCode,
        char*                                 pLayerPrefix,
        char*                                 pMessage);
#endif

#define VK_NV_glsl_shader 1
#define VK_NV_GLSL_SHADER_SPEC_VERSION    1
#define VK_NV_GLSL_SHADER_EXTENSION_NAME  "VK_NV_glsl_shader"


#define VK_IMG_filter_cubic 1
#define VK_IMG_FILTER_CUBIC_SPEC_VERSION  1
#define VK_IMG_FILTER_CUBIC_EXTENSION_NAME "VK_IMG_filter_cubic"


#define VK_AMD_rasterization_order 1
#define VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION 1
#define VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME "VK_AMD_rasterization_order"


    typedef enum VkRasterizationOrderAMD {
        VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
        VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
        VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD = VK_RASTERIZATION_ORDER_STRICT_AMD,
        VK_RASTERIZATION_ORDER_END_RANGE_AMD = VK_RASTERIZATION_ORDER_RELAXED_AMD,
        VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD = (VK_RASTERIZATION_ORDER_RELAXED_AMD - VK_RASTERIZATION_ORDER_STRICT_AMD + 1),
        VK_RASTERIZATION_ORDER_MAX_ENUM_AMD = 0x7FFFFFFF
    } VkRasterizationOrderAMD;

    typedef struct VkPipelineRasterizationStateRasterizationOrderAMD {
        VkStructureType            sType;
        void*                pNext;
        VkRasterizationOrderAMD    rasterizationOrder;
    } VkPipelineRasterizationStateRasterizationOrderAMD;



#define VK_AMD_shader_trinary_minmax 1
#define VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION 1
#define VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME "VK_AMD_shader_trinary_minmax"


#define VK_AMD_shader_explicit_vertex_parameter 1
#define VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION 1
#define VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME "VK_AMD_shader_explicit_vertex_parameter"


#define VK_EXT_debug_marker 1
#define VK_EXT_DEBUG_MARKER_SPEC_VERSION  3
#define VK_EXT_DEBUG_MARKER_EXTENSION_NAME "VK_EXT_debug_marker"

    typedef struct VkDebugMarkerObjectNameInfoEXT {
        VkStructureType               sType;
        void*                   pNext;
        VkDebugReportObjectTypeEXT    objectType;
        uint64_t                      object;
        char*                   pObjectName;
    } VkDebugMarkerObjectNameInfoEXT;

    typedef struct VkDebugMarkerObjectTagInfoEXT {
        VkStructureType               sType;
        void*                   pNext;
        VkDebugReportObjectTypeEXT    objectType;
        uint64_t                      object;
        uint64_t                      tagName;
        size_t                        tagSize;
        void*                   pTag;
    } VkDebugMarkerObjectTagInfoEXT;

    typedef struct VkDebugMarkerMarkerInfoEXT {
        VkStructureType    sType;
        void*        pNext;
        char*        pMarkerName;
        float              color[4];
    } VkDebugMarkerMarkerInfoEXT;


    typedef VkResult (VKAPI_PTR *PFN_vkDebugMarkerSetObjectTagEXT)(VkDevice device, VkDebugMarkerObjectTagInfoEXT* pTagInfo);
    typedef VkResult (VKAPI_PTR *PFN_vkDebugMarkerSetObjectNameEXT)(VkDevice device, VkDebugMarkerObjectNameInfoEXT* pNameInfo);
    typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerBeginEXT)(VkCommandBuffer commandBuffer, VkDebugMarkerMarkerInfoEXT* pMarkerInfo);
    typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerEndEXT)(VkCommandBuffer commandBuffer);
    typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerInsertEXT)(VkCommandBuffer commandBuffer, VkDebugMarkerMarkerInfoEXT* pMarkerInfo);

#ifndef VK_NO_PROTOTYPES
    VKAPI_ATTR VkResult VKAPI_CALL vkDebugMarkerSetObjectTagEXT(
        VkDevice                                    device,
        VkDebugMarkerObjectTagInfoEXT*              pTagInfo);

    VKAPI_ATTR VkResult VKAPI_CALL vkDebugMarkerSetObjectNameEXT(
        VkDevice                                    device,
        VkDebugMarkerObjectNameInfoEXT*             pNameInfo);

    VKAPI_ATTR void VKAPI_CALL vkCmdDebugMarkerBeginEXT(
        VkCommandBuffer                             commandBuffer,
        VkDebugMarkerMarkerInfoEXT*                 pMarkerInfo);

    VKAPI_ATTR void VKAPI_CALL vkCmdDebugMarkerEndEXT(
        VkCommandBuffer                             commandBuffer);

    VKAPI_ATTR void VKAPI_CALL vkCmdDebugMarkerInsertEXT(
        VkCommandBuffer                             commandBuffer,
        VkDebugMarkerMarkerInfoEXT*                 pMarkerInfo);
#endif

#define VK_AMD_gcn_shader 1
#define VK_AMD_GCN_SHADER_SPEC_VERSION    1
#define VK_AMD_GCN_SHADER_EXTENSION_NAME  "VK_AMD_gcn_shader"


#define VK_NV_dedicated_allocation 1
#define VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION 1
#define VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME "VK_NV_dedicated_allocation"

    typedef struct VkDedicatedAllocationImageCreateInfoNV {
        VkStructureType    sType;
        void*        pNext;
        VkBool32           dedicatedAllocation;
    } VkDedicatedAllocationImageCreateInfoNV;

    typedef struct VkDedicatedAllocationBufferCreateInfoNV {
        VkStructureType    sType;
        void*        pNext;
        VkBool32           dedicatedAllocation;
    } VkDedicatedAllocationBufferCreateInfoNV;

    typedef struct VkDedicatedAllocationMemoryAllocateInfoNV {
        VkStructureType    sType;
        void*        pNext;
        VkImage            image;
        VkBuffer           buffer;
    } VkDedicatedAllocationMemoryAllocateInfoNV;



#define VK_AMD_draw_indirect_count 1
#define VK_AMD_EXTENSION_DRAW_INDIRECT_COUNT_SPEC_VERSION 1
#define VK_AMD_EXTENSION_DRAW_INDIRECT_COUNT_EXTENSION_NAME "VK_AMD_draw_indirect_count"

    typedef void (VKAPI_PTR *PFN_vkCmdDrawIndirectCountAMD)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
    typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexedIndirectCountAMD)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);

#ifndef VK_NO_PROTOTYPES
    VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndirectCountAMD(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    buffer,
        VkDeviceSize                                offset,
        VkBuffer                                    countBuffer,
        VkDeviceSize                                countBufferOffset,
        uint32_t                                    maxDrawCount,
        uint32_t                                    stride);

    VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexedIndirectCountAMD(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    buffer,
        VkDeviceSize                                offset,
        VkBuffer                                    countBuffer,
        VkDeviceSize                                countBufferOffset,
        uint32_t                                    maxDrawCount,
        uint32_t                                    stride);
#endif

#define VK_IMG_format_pvrtc 1
#define VK_IMG_FORMAT_PVRTC_SPEC_VERSION  1
#define VK_IMG_FORMAT_PVRTC_EXTENSION_NAME "VK_IMG_format_pvrtc"


#define VK_NV_external_memory_capabilities 1
#define VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION 1
#define VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME "VK_NV_external_memory_capabilities"


    typedef enum VkExternalMemoryHandleTypeFlagBitsNV {
        VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 0x00000001,
        VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x00000002,
        VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 0x00000004,
        VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 0x00000008,
        VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
    } VkExternalMemoryHandleTypeFlagBitsNV;
    typedef VkFlags VkExternalMemoryHandleTypeFlagsNV;

    typedef enum VkExternalMemoryFeatureFlagBitsNV {
        VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 0x00000001,
        VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 0x00000002,
        VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 0x00000004,
        VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
    } VkExternalMemoryFeatureFlagBitsNV;
    typedef VkFlags VkExternalMemoryFeatureFlagsNV;

    typedef struct VkExternalImageFormatPropertiesNV {
        VkImageFormatProperties              imageFormatProperties;
        VkExternalMemoryFeatureFlagsNV       externalMemoryFeatures;
        VkExternalMemoryHandleTypeFlagsNV    exportFromImportedHandleTypes;
        VkExternalMemoryHandleTypeFlagsNV    compatibleHandleTypes;
    } VkExternalImageFormatPropertiesNV;


    typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties);

#ifndef VK_NO_PROTOTYPES
    VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
        VkPhysicalDevice                            physicalDevice,
        VkFormat                                    format,
        VkImageType                                 type,
        VkImageTiling                               tiling,
        VkImageUsageFlags                           usage,
        VkImageCreateFlags                          flags,
        VkExternalMemoryHandleTypeFlagsNV           externalHandleType,
        VkExternalImageFormatPropertiesNV*          pExternalImageFormatProperties);
#endif

#define VK_NV_external_memory 1
#define VK_NV_EXTERNAL_MEMORY_SPEC_VERSION 1
#define VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME "VK_NV_external_memory"

    typedef struct VkExternalMemoryImageCreateInfoNV {
        VkStructureType                      sType;
        void*                          pNext;
        VkExternalMemoryHandleTypeFlagsNV    handleTypes;
    } VkExternalMemoryImageCreateInfoNV;

    typedef struct VkExportMemoryAllocateInfoNV {
        VkStructureType                      sType;
        void*                          pNext;
        VkExternalMemoryHandleTypeFlagsNV    handleTypes;
    } VkExportMemoryAllocateInfoNV;



#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_NV_external_memory_win32 1
#define VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION 1
#define VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME "VK_NV_external_memory_win32"

    typedef struct VkImportMemoryWin32HandleInfoNV {
        VkStructureType                      sType;
        void*                          pNext;
        VkExternalMemoryHandleTypeFlagsNV    handleType;
        HANDLE                               handle;
    } VkImportMemoryWin32HandleInfoNV;

    typedef struct VkExportMemoryWin32HandleInfoNV {
        VkStructureType               sType;
        void*                   pNext;
        SECURITY_ATTRIBUTES*    pAttributes;
        DWORD                         dwAccess;
    } VkExportMemoryWin32HandleInfoNV;


    typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandleNV)(VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle);

#ifndef VK_NO_PROTOTYPES
    VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryWin32HandleNV(
        VkDevice                                    device,
        VkDeviceMemory                              memory,
        VkExternalMemoryHandleTypeFlagsNV           handleType,
        HANDLE*                                     pHandle);
#endif
#endif /* VK_USE_PLATFORM_WIN32_KHR */

#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_NV_win32_keyed_mutex 1
#define VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION 1
#define VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME "VK_NV_win32_keyed_mutex"

    typedef struct VkWin32KeyedMutexAcquireReleaseInfoNV {
        VkStructureType          sType;
        void*              pNext;
        uint32_t                 acquireCount;
        VkDeviceMemory*    pAcquireSyncs;
        uint64_t*          pAcquireKeys;
        uint32_t*          pAcquireTimeoutMilliseconds;
        uint32_t                 releaseCount;
        VkDeviceMemory*    pReleaseSyncs;
        uint64_t*          pReleaseKeys;
    } VkWin32KeyedMutexAcquireReleaseInfoNV;


#endif /* VK_USE_PLATFORM_WIN32_KHR */

#ifdef __cplusplus
}
#endif

#endif
// END VULKAN H

static PyObject *VulkanError;
static PyObject *VkErrorTooManyObjects;
static PyObject *VkErrorOutOfHostMemory;
static PyObject *VkErrorIncompatibleDriver;
static PyObject *VkIncomplete;
static PyObject *VkEventSet;
static PyObject *VkTimeout;
static PyObject *VkEventReset;
static PyObject *VkErrorLayerNotPresent;
static PyObject *VkErrorExtensionNotPresent;
static PyObject *VkNotReady;
static PyObject *VkErrorFeatureNotPresent;
static PyObject *VkErrorInitializationFailed;
static PyObject *VkErrorOutOfDeviceMemory;
static PyObject *VkErrorFragmentedPool;
static PyObject *VkErrorMemoryMapFailed;
static PyObject *VkErrorFormatNotSupported;
static PyObject *VkErrorDeviceLost;
int raise(int value) {
    switch(value) {

    case -10:
        PyErr_SetString(VkErrorTooManyObjects, "");
        return 1;

    case -1:
        PyErr_SetString(VkErrorOutOfHostMemory, "");
        return 1;

    case -9:
        PyErr_SetString(VkErrorIncompatibleDriver, "");
        return 1;

    case 5:
        PyErr_SetString(VkIncomplete, "");
        return 1;

    case 3:
        PyErr_SetString(VkEventSet, "");
        return 1;

    case 2:
        PyErr_SetString(VkTimeout, "");
        return 1;

    case 4:
        PyErr_SetString(VkEventReset, "");
        return 1;

    case -6:
        PyErr_SetString(VkErrorLayerNotPresent, "");
        return 1;

    case -7:
        PyErr_SetString(VkErrorExtensionNotPresent, "");
        return 1;

    case 1:
        PyErr_SetString(VkNotReady, "");
        return 1;

    case -8:
        PyErr_SetString(VkErrorFeatureNotPresent, "");
        return 1;

    case -3:
        PyErr_SetString(VkErrorInitializationFailed, "");
        return 1;

    case -2:
        PyErr_SetString(VkErrorOutOfDeviceMemory, "");
        return 1;

    case -12:
        PyErr_SetString(VkErrorFragmentedPool, "");
        return 1;

    case -5:
        PyErr_SetString(VkErrorMemoryMapFailed, "");
        return 1;

    case -11:
        PyErr_SetString(VkErrorFormatNotSupported, "");
        return 1;

    case -4:
        PyErr_SetString(VkErrorDeviceLost, "");
        return 1;
    }
    return 0;
}

static PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV vkGetPhysicalDeviceExternalImageFormatPropertiesNV;

static PFN_vkCmdSetScissor vkCmdSetScissor;

static PFN_vkFreeCommandBuffers vkFreeCommandBuffers;

static PFN_vkCmdDebugMarkerBeginEXT vkCmdDebugMarkerBeginEXT;

static PFN_vkCmdBeginQuery vkCmdBeginQuery;

static PFN_vkCmdSetStencilWriteMask vkCmdSetStencilWriteMask;

static PFN_vkGetPhysicalDeviceProperties vkGetPhysicalDeviceProperties;

static PFN_vkCreateFramebuffer vkCreateFramebuffer;

static PFN_vkGetPhysicalDeviceSurfaceFormatsKHR vkGetPhysicalDeviceSurfaceFormatsKHR;

static PFN_vkDeviceWaitIdle vkDeviceWaitIdle;

static PFN_vkFlushMappedMemoryRanges vkFlushMappedMemoryRanges;

static PFN_vkCreateCommandPool vkCreateCommandPool;

static PFN_vkCreateSampler vkCreateSampler;

static PFN_vkAllocateCommandBuffers vkAllocateCommandBuffers;

static PFN_vkCmdSetViewport vkCmdSetViewport;

static PFN_vkCreateBufferView vkCreateBufferView;

static PFN_vkGetFenceStatus vkGetFenceStatus;

static PFN_vkCmdDrawIndexed vkCmdDrawIndexed;

static PFN_vkCmdResolveImage vkCmdResolveImage;

static PFN_vkDestroyPipelineCache vkDestroyPipelineCache;

static PFN_vkCmdSetDepthBias vkCmdSetDepthBias;

static PFN_vkCmdEndRenderPass vkCmdEndRenderPass;

static PFN_vkCmdDispatchIndirect vkCmdDispatchIndirect;

static PFN_vkCreatePipelineLayout vkCreatePipelineLayout;

static PFN_vkResetCommandPool vkResetCommandPool;

static PFN_vkDestroyShaderModule vkDestroyShaderModule;

static PFN_vkEndCommandBuffer vkEndCommandBuffer;

static PFN_vkDestroyImage vkDestroyImage;

static PFN_vkDestroyFramebuffer vkDestroyFramebuffer;

static PFN_vkDestroySemaphore vkDestroySemaphore;

#ifdef VK_USE_PLATFORM_XLIB_KHR

static PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR vkGetPhysicalDeviceXlibPresentationSupportKHR;

#endif

static PFN_vkCmdNextSubpass vkCmdNextSubpass;

static PFN_vkDestroyPipelineLayout vkDestroyPipelineLayout;

static PFN_vkCreateQueryPool vkCreateQueryPool;

static PFN_vkCreateFence vkCreateFence;

#ifdef VK_USE_PLATFORM_XCB_KHR

static PFN_vkCreateXcbSurfaceKHR vkCreateXcbSurfaceKHR;

#endif

static PFN_vkDestroySurfaceKHR vkDestroySurfaceKHR;

static PFN_vkGetPipelineCacheData vkGetPipelineCacheData;

static PFN_vkDestroyDescriptorSetLayout vkDestroyDescriptorSetLayout;

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

static PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR vkGetPhysicalDeviceWaylandPresentationSupportKHR;

#endif

static PFN_vkGetBufferMemoryRequirements vkGetBufferMemoryRequirements;

static PFN_vkCmdResetEvent vkCmdResetEvent;

static PFN_vkQueueWaitIdle vkQueueWaitIdle;

static PFN_vkSetEvent vkSetEvent;

static PFN_vkDestroySwapchainKHR vkDestroySwapchainKHR;

static PFN_vkDebugMarkerSetObjectNameEXT vkDebugMarkerSetObjectNameEXT;

static PFN_vkGetDeviceQueue vkGetDeviceQueue;

static PFN_vkEnumerateDeviceLayerProperties vkEnumerateDeviceLayerProperties;

static PFN_vkCreateBuffer vkCreateBuffer;

static PFN_vkAcquireNextImageKHR vkAcquireNextImageKHR;

static PFN_vkCreateSemaphore vkCreateSemaphore;

#ifdef VK_USE_PLATFORM_XLIB_KHR

static PFN_vkCreateXlibSurfaceKHR vkCreateXlibSurfaceKHR;

#endif

static PFN_vkCmdPushConstants vkCmdPushConstants;

static PFN_vkGetPhysicalDeviceFeatures vkGetPhysicalDeviceFeatures;

static PFN_vkCreateRenderPass vkCreateRenderPass;

#ifdef VK_USE_PLATFORM_WIN32_KHR

static PFN_vkCreateWin32SurfaceKHR vkCreateWin32SurfaceKHR;

#endif

static PFN_vkCmdBindPipeline vkCmdBindPipeline;

#ifdef VK_USE_PLATFORM_WIN32_KHR

static PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR vkGetPhysicalDeviceWin32PresentationSupportKHR;

#endif

static PFN_vkCmdWaitEvents vkCmdWaitEvents;

static PFN_vkBindImageMemory vkBindImageMemory;

static PFN_vkGetPhysicalDeviceSurfaceSupportKHR vkGetPhysicalDeviceSurfaceSupportKHR;

static PFN_vkCmdWriteTimestamp vkCmdWriteTimestamp;

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

static PFN_vkCreateWaylandSurfaceKHR vkCreateWaylandSurfaceKHR;

#endif

static PFN_vkCmdPipelineBarrier vkCmdPipelineBarrier;

static PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR vkGetPhysicalDeviceDisplayPlanePropertiesKHR;

static PFN_vkCmdDebugMarkerInsertEXT vkCmdDebugMarkerInsertEXT;

static PFN_vkGetDisplayModePropertiesKHR vkGetDisplayModePropertiesKHR;

static PFN_vkDestroyRenderPass vkDestroyRenderPass;

static PFN_vkCmdCopyBuffer vkCmdCopyBuffer;

static PFN_vkCreateDescriptorPool vkCreateDescriptorPool;

static PFN_vkEnumeratePhysicalDevices vkEnumeratePhysicalDevices;

static PFN_vkCmdResetQueryPool vkCmdResetQueryPool;

static PFN_vkGetPhysicalDeviceQueueFamilyProperties vkGetPhysicalDeviceQueueFamilyProperties;

static PFN_vkGetPhysicalDeviceFormatProperties vkGetPhysicalDeviceFormatProperties;

static PFN_vkCreateGraphicsPipelines vkCreateGraphicsPipelines;

static PFN_vkCmdSetStencilReference vkCmdSetStencilReference;

static PFN_vkGetImageSubresourceLayout vkGetImageSubresourceLayout;

static PFN_vkCmdSetLineWidth vkCmdSetLineWidth;

#ifdef VK_USE_PLATFORM_MIR_KHR

static PFN_vkGetPhysicalDeviceMirPresentationSupportKHR vkGetPhysicalDeviceMirPresentationSupportKHR;

#endif

static PFN_vkCreateDisplayModeKHR vkCreateDisplayModeKHR;

static PFN_vkCmdCopyBufferToImage vkCmdCopyBufferToImage;

#ifdef VK_USE_PLATFORM_MIR_KHR

static PFN_vkCreateMirSurfaceKHR vkCreateMirSurfaceKHR;

#endif

static PFN_vkCmdDraw vkCmdDraw;

static PFN_vkFreeMemory vkFreeMemory;

static PFN_vkDebugReportMessageEXT vkDebugReportMessageEXT;

static PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr;

static PFN_vkDestroyBuffer vkDestroyBuffer;

static PFN_vkEnumerateInstanceExtensionProperties vkEnumerateInstanceExtensionProperties;

static PFN_vkCmdBindDescriptorSets vkCmdBindDescriptorSets;

static PFN_vkCmdBlitImage vkCmdBlitImage;

static PFN_vkCmdExecuteCommands vkCmdExecuteCommands;

static PFN_vkGetRenderAreaGranularity vkGetRenderAreaGranularity;

static PFN_vkDestroyCommandPool vkDestroyCommandPool;

static PFN_vkUpdateDescriptorSets vkUpdateDescriptorSets;

static PFN_vkCreateEvent vkCreateEvent;

static PFN_vkGetPhysicalDeviceMemoryProperties vkGetPhysicalDeviceMemoryProperties;

static PFN_vkCreateSwapchainKHR vkCreateSwapchainKHR;

static PFN_vkMergePipelineCaches vkMergePipelineCaches;

static PFN_vkBeginCommandBuffer vkBeginCommandBuffer;

static PFN_vkAllocateMemory vkAllocateMemory;

static PFN_vkCreateDisplayPlaneSurfaceKHR vkCreateDisplayPlaneSurfaceKHR;

static PFN_vkGetDeviceProcAddr vkGetDeviceProcAddr;

static PFN_vkDestroyDebugReportCallbackEXT vkDestroyDebugReportCallbackEXT;

static PFN_vkCreateDevice vkCreateDevice;

static PFN_vkCmdBindVertexBuffers vkCmdBindVertexBuffers;

static PFN_vkCmdDispatch vkCmdDispatch;

static PFN_vkResetDescriptorPool vkResetDescriptorPool;

static PFN_vkCreateImageView vkCreateImageView;

static PFN_vkWaitForFences vkWaitForFences;

static PFN_vkCmdSetDepthBounds vkCmdSetDepthBounds;

static PFN_vkCreateComputePipelines vkCreateComputePipelines;

static PFN_vkCmdCopyImageToBuffer vkCmdCopyImageToBuffer;

static PFN_vkCmdCopyQueryPoolResults vkCmdCopyQueryPoolResults;

static PFN_vkFreeDescriptorSets vkFreeDescriptorSets;

static PFN_vkUnmapMemory vkUnmapMemory;

static PFN_vkGetPhysicalDeviceImageFormatProperties vkGetPhysicalDeviceImageFormatProperties;

static PFN_vkInvalidateMappedMemoryRanges vkInvalidateMappedMemoryRanges;

static PFN_vkResetEvent vkResetEvent;

static PFN_vkGetDisplayPlaneCapabilitiesKHR vkGetDisplayPlaneCapabilitiesKHR;

static PFN_vkGetSwapchainImagesKHR vkGetSwapchainImagesKHR;

static PFN_vkQueuePresentKHR vkQueuePresentKHR;

static PFN_vkCmdBindIndexBuffer vkCmdBindIndexBuffer;

static PFN_vkCmdSetStencilCompareMask vkCmdSetStencilCompareMask;

static PFN_vkCreateInstance vkCreateInstance;

static PFN_vkGetEventStatus vkGetEventStatus;

static PFN_vkGetImageMemoryRequirements vkGetImageMemoryRequirements;

#ifdef VK_USE_PLATFORM_XCB_KHR

static PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR vkGetPhysicalDeviceXcbPresentationSupportKHR;

#endif

static PFN_vkCmdSetEvent vkCmdSetEvent;

static PFN_vkCmdBeginRenderPass vkCmdBeginRenderPass;

static PFN_vkDestroySampler vkDestroySampler;

static PFN_vkCmdClearColorImage vkCmdClearColorImage;

static PFN_vkCmdDrawIndexedIndirect vkCmdDrawIndexedIndirect;

static PFN_vkGetQueryPoolResults vkGetQueryPoolResults;

static PFN_vkCreateSharedSwapchainsKHR vkCreateSharedSwapchainsKHR;

static PFN_vkCmdDrawIndexedIndirectCountAMD vkCmdDrawIndexedIndirectCountAMD;

static PFN_vkBindBufferMemory vkBindBufferMemory;

static PFN_vkDestroyDescriptorPool vkDestroyDescriptorPool;

static PFN_vkCmdUpdateBuffer vkCmdUpdateBuffer;

static PFN_vkCreateShaderModule vkCreateShaderModule;

static PFN_vkEnumerateDeviceExtensionProperties vkEnumerateDeviceExtensionProperties;

static PFN_vkDestroyQueryPool vkDestroyQueryPool;

static PFN_vkDestroyBufferView vkDestroyBufferView;

static PFN_vkGetPhysicalDeviceDisplayPropertiesKHR vkGetPhysicalDeviceDisplayPropertiesKHR;

static PFN_vkAllocateDescriptorSets vkAllocateDescriptorSets;

static PFN_vkCreatePipelineCache vkCreatePipelineCache;

static PFN_vkCmdEndQuery vkCmdEndQuery;

static PFN_vkMapMemory vkMapMemory;

static PFN_vkGetPhysicalDeviceSurfacePresentModesKHR vkGetPhysicalDeviceSurfacePresentModesKHR;

static PFN_vkCmdDebugMarkerEndEXT vkCmdDebugMarkerEndEXT;

static PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR vkGetPhysicalDeviceSurfaceCapabilitiesKHR;

static PFN_vkCmdFillBuffer vkCmdFillBuffer;

static PFN_vkDestroyImageView vkDestroyImageView;

static PFN_vkEnumerateInstanceLayerProperties vkEnumerateInstanceLayerProperties;

static PFN_vkGetDisplayPlaneSupportedDisplaysKHR vkGetDisplayPlaneSupportedDisplaysKHR;

static PFN_vkCmdCopyImage vkCmdCopyImage;

static PFN_vkCmdDrawIndirect vkCmdDrawIndirect;

static PFN_vkDestroyInstance vkDestroyInstance;

static PFN_vkDestroyPipeline vkDestroyPipeline;

static PFN_vkQueueBindSparse vkQueueBindSparse;

static PFN_vkDebugMarkerSetObjectTagEXT vkDebugMarkerSetObjectTagEXT;

static PFN_vkDestroyEvent vkDestroyEvent;

static PFN_vkCmdDrawIndirectCountAMD vkCmdDrawIndirectCountAMD;

static PFN_vkDestroyFence vkDestroyFence;

#ifdef VK_USE_PLATFORM_ANDROID_KHR

static PFN_vkCreateAndroidSurfaceKHR vkCreateAndroidSurfaceKHR;

#endif

static PFN_vkResetFences vkResetFences;

#ifdef VK_USE_PLATFORM_WIN32_KHR

static PFN_vkGetMemoryWin32HandleNV vkGetMemoryWin32HandleNV;

#endif

static PFN_vkCmdSetBlendConstants vkCmdSetBlendConstants;

static PFN_vkCreateImage vkCreateImage;

static PFN_vkCreateDescriptorSetLayout vkCreateDescriptorSetLayout;

static PFN_vkGetImageSparseMemoryRequirements vkGetImageSparseMemoryRequirements;

static PFN_vkGetPhysicalDeviceSparseImageFormatProperties vkGetPhysicalDeviceSparseImageFormatProperties;

static PFN_vkDestroyDevice vkDestroyDevice;

static PFN_vkCmdClearDepthStencilImage vkCmdClearDepthStencilImage;

static PFN_vkResetCommandBuffer vkResetCommandBuffer;

static PFN_vkCmdClearAttachments vkCmdClearAttachments;

static PFN_vkGetDeviceMemoryCommitment vkGetDeviceMemoryCommitment;

static PFN_vkCreateDebugReportCallbackEXT vkCreateDebugReportCallbackEXT;

static PFN_vkQueueSubmit vkQueueSubmit;

static PyObject * load_sdk(PyObject *self, PyObject *args) {
    void* vk_sdk = LOAD_SDK();
    if (vk_sdk == NULL) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't find vulkan sdk");
        return NULL;
    }


    vkCmdSetScissor = (PFN_vkCmdSetScissor)dlsym(vk_sdk, "vkCmdSetScissor");
    if( vkCmdSetScissor == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdSetScissor in sdk");
        return NULL;
    }


    vkFreeCommandBuffers = (PFN_vkFreeCommandBuffers)dlsym(vk_sdk, "vkFreeCommandBuffers");
    if( vkFreeCommandBuffers == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkFreeCommandBuffers in sdk");
        return NULL;
    }


    vkCmdBeginQuery = (PFN_vkCmdBeginQuery)dlsym(vk_sdk, "vkCmdBeginQuery");
    if( vkCmdBeginQuery == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdBeginQuery in sdk");
        return NULL;
    }


    vkCmdSetStencilWriteMask = (PFN_vkCmdSetStencilWriteMask)dlsym(vk_sdk, "vkCmdSetStencilWriteMask");
    if( vkCmdSetStencilWriteMask == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdSetStencilWriteMask in sdk");
        return NULL;
    }


    vkGetPhysicalDeviceProperties = (PFN_vkGetPhysicalDeviceProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceProperties");
    if( vkGetPhysicalDeviceProperties == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetPhysicalDeviceProperties in sdk");
        return NULL;
    }


    vkCreateFramebuffer = (PFN_vkCreateFramebuffer)dlsym(vk_sdk, "vkCreateFramebuffer");
    if( vkCreateFramebuffer == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreateFramebuffer in sdk");
        return NULL;
    }


    vkDeviceWaitIdle = (PFN_vkDeviceWaitIdle)dlsym(vk_sdk, "vkDeviceWaitIdle");
    if( vkDeviceWaitIdle == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDeviceWaitIdle in sdk");
        return NULL;
    }


    vkFlushMappedMemoryRanges = (PFN_vkFlushMappedMemoryRanges)dlsym(vk_sdk, "vkFlushMappedMemoryRanges");
    if( vkFlushMappedMemoryRanges == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkFlushMappedMemoryRanges in sdk");
        return NULL;
    }


    vkCreateCommandPool = (PFN_vkCreateCommandPool)dlsym(vk_sdk, "vkCreateCommandPool");
    if( vkCreateCommandPool == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreateCommandPool in sdk");
        return NULL;
    }


    vkCreateSampler = (PFN_vkCreateSampler)dlsym(vk_sdk, "vkCreateSampler");
    if( vkCreateSampler == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreateSampler in sdk");
        return NULL;
    }


    vkAllocateCommandBuffers = (PFN_vkAllocateCommandBuffers)dlsym(vk_sdk, "vkAllocateCommandBuffers");
    if( vkAllocateCommandBuffers == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkAllocateCommandBuffers in sdk");
        return NULL;
    }


    vkCmdSetViewport = (PFN_vkCmdSetViewport)dlsym(vk_sdk, "vkCmdSetViewport");
    if( vkCmdSetViewport == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdSetViewport in sdk");
        return NULL;
    }


    vkCreateBufferView = (PFN_vkCreateBufferView)dlsym(vk_sdk, "vkCreateBufferView");
    if( vkCreateBufferView == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreateBufferView in sdk");
        return NULL;
    }


    vkGetFenceStatus = (PFN_vkGetFenceStatus)dlsym(vk_sdk, "vkGetFenceStatus");
    if( vkGetFenceStatus == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetFenceStatus in sdk");
        return NULL;
    }


    vkCmdDrawIndexed = (PFN_vkCmdDrawIndexed)dlsym(vk_sdk, "vkCmdDrawIndexed");
    if( vkCmdDrawIndexed == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdDrawIndexed in sdk");
        return NULL;
    }


    vkCmdResolveImage = (PFN_vkCmdResolveImage)dlsym(vk_sdk, "vkCmdResolveImage");
    if( vkCmdResolveImage == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdResolveImage in sdk");
        return NULL;
    }


    vkDestroyPipelineCache = (PFN_vkDestroyPipelineCache)dlsym(vk_sdk, "vkDestroyPipelineCache");
    if( vkDestroyPipelineCache == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroyPipelineCache in sdk");
        return NULL;
    }


    vkCmdSetDepthBias = (PFN_vkCmdSetDepthBias)dlsym(vk_sdk, "vkCmdSetDepthBias");
    if( vkCmdSetDepthBias == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdSetDepthBias in sdk");
        return NULL;
    }


    vkCmdEndRenderPass = (PFN_vkCmdEndRenderPass)dlsym(vk_sdk, "vkCmdEndRenderPass");
    if( vkCmdEndRenderPass == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdEndRenderPass in sdk");
        return NULL;
    }


    vkCmdDispatchIndirect = (PFN_vkCmdDispatchIndirect)dlsym(vk_sdk, "vkCmdDispatchIndirect");
    if( vkCmdDispatchIndirect == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdDispatchIndirect in sdk");
        return NULL;
    }


    vkCreatePipelineLayout = (PFN_vkCreatePipelineLayout)dlsym(vk_sdk, "vkCreatePipelineLayout");
    if( vkCreatePipelineLayout == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreatePipelineLayout in sdk");
        return NULL;
    }


    vkResetCommandPool = (PFN_vkResetCommandPool)dlsym(vk_sdk, "vkResetCommandPool");
    if( vkResetCommandPool == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkResetCommandPool in sdk");
        return NULL;
    }


    vkDestroyShaderModule = (PFN_vkDestroyShaderModule)dlsym(vk_sdk, "vkDestroyShaderModule");
    if( vkDestroyShaderModule == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroyShaderModule in sdk");
        return NULL;
    }


    vkEndCommandBuffer = (PFN_vkEndCommandBuffer)dlsym(vk_sdk, "vkEndCommandBuffer");
    if( vkEndCommandBuffer == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkEndCommandBuffer in sdk");
        return NULL;
    }


    vkDestroyImage = (PFN_vkDestroyImage)dlsym(vk_sdk, "vkDestroyImage");
    if( vkDestroyImage == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroyImage in sdk");
        return NULL;
    }


    vkDestroyFramebuffer = (PFN_vkDestroyFramebuffer)dlsym(vk_sdk, "vkDestroyFramebuffer");
    if( vkDestroyFramebuffer == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroyFramebuffer in sdk");
        return NULL;
    }


    vkDestroySemaphore = (PFN_vkDestroySemaphore)dlsym(vk_sdk, "vkDestroySemaphore");
    if( vkDestroySemaphore == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroySemaphore in sdk");
        return NULL;
    }


    vkCmdNextSubpass = (PFN_vkCmdNextSubpass)dlsym(vk_sdk, "vkCmdNextSubpass");
    if( vkCmdNextSubpass == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdNextSubpass in sdk");
        return NULL;
    }


    vkDestroyPipelineLayout = (PFN_vkDestroyPipelineLayout)dlsym(vk_sdk, "vkDestroyPipelineLayout");
    if( vkDestroyPipelineLayout == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroyPipelineLayout in sdk");
        return NULL;
    }


    vkCreateQueryPool = (PFN_vkCreateQueryPool)dlsym(vk_sdk, "vkCreateQueryPool");
    if( vkCreateQueryPool == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreateQueryPool in sdk");
        return NULL;
    }


    vkCreateFence = (PFN_vkCreateFence)dlsym(vk_sdk, "vkCreateFence");
    if( vkCreateFence == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreateFence in sdk");
        return NULL;
    }


    vkGetPipelineCacheData = (PFN_vkGetPipelineCacheData)dlsym(vk_sdk, "vkGetPipelineCacheData");
    if( vkGetPipelineCacheData == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetPipelineCacheData in sdk");
        return NULL;
    }


    vkDestroyDescriptorSetLayout = (PFN_vkDestroyDescriptorSetLayout)dlsym(vk_sdk, "vkDestroyDescriptorSetLayout");
    if( vkDestroyDescriptorSetLayout == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroyDescriptorSetLayout in sdk");
        return NULL;
    }


    vkGetBufferMemoryRequirements = (PFN_vkGetBufferMemoryRequirements)dlsym(vk_sdk, "vkGetBufferMemoryRequirements");
    if( vkGetBufferMemoryRequirements == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetBufferMemoryRequirements in sdk");
        return NULL;
    }


    vkCmdResetEvent = (PFN_vkCmdResetEvent)dlsym(vk_sdk, "vkCmdResetEvent");
    if( vkCmdResetEvent == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdResetEvent in sdk");
        return NULL;
    }


    vkQueueWaitIdle = (PFN_vkQueueWaitIdle)dlsym(vk_sdk, "vkQueueWaitIdle");
    if( vkQueueWaitIdle == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkQueueWaitIdle in sdk");
        return NULL;
    }


    vkSetEvent = (PFN_vkSetEvent)dlsym(vk_sdk, "vkSetEvent");
    if( vkSetEvent == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkSetEvent in sdk");
        return NULL;
    }


    vkGetDeviceQueue = (PFN_vkGetDeviceQueue)dlsym(vk_sdk, "vkGetDeviceQueue");
    if( vkGetDeviceQueue == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetDeviceQueue in sdk");
        return NULL;
    }


    vkEnumerateDeviceLayerProperties = (PFN_vkEnumerateDeviceLayerProperties)dlsym(vk_sdk, "vkEnumerateDeviceLayerProperties");
    if( vkEnumerateDeviceLayerProperties == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkEnumerateDeviceLayerProperties in sdk");
        return NULL;
    }


    vkCreateBuffer = (PFN_vkCreateBuffer)dlsym(vk_sdk, "vkCreateBuffer");
    if( vkCreateBuffer == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreateBuffer in sdk");
        return NULL;
    }


    vkCreateSemaphore = (PFN_vkCreateSemaphore)dlsym(vk_sdk, "vkCreateSemaphore");
    if( vkCreateSemaphore == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreateSemaphore in sdk");
        return NULL;
    }


    vkCmdPushConstants = (PFN_vkCmdPushConstants)dlsym(vk_sdk, "vkCmdPushConstants");
    if( vkCmdPushConstants == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdPushConstants in sdk");
        return NULL;
    }


    vkGetPhysicalDeviceFeatures = (PFN_vkGetPhysicalDeviceFeatures)dlsym(vk_sdk, "vkGetPhysicalDeviceFeatures");
    if( vkGetPhysicalDeviceFeatures == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetPhysicalDeviceFeatures in sdk");
        return NULL;
    }


    vkCreateRenderPass = (PFN_vkCreateRenderPass)dlsym(vk_sdk, "vkCreateRenderPass");
    if( vkCreateRenderPass == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreateRenderPass in sdk");
        return NULL;
    }


    vkCmdBindPipeline = (PFN_vkCmdBindPipeline)dlsym(vk_sdk, "vkCmdBindPipeline");
    if( vkCmdBindPipeline == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdBindPipeline in sdk");
        return NULL;
    }


    vkCmdWaitEvents = (PFN_vkCmdWaitEvents)dlsym(vk_sdk, "vkCmdWaitEvents");
    if( vkCmdWaitEvents == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdWaitEvents in sdk");
        return NULL;
    }


    vkBindImageMemory = (PFN_vkBindImageMemory)dlsym(vk_sdk, "vkBindImageMemory");
    if( vkBindImageMemory == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkBindImageMemory in sdk");
        return NULL;
    }


    vkCmdWriteTimestamp = (PFN_vkCmdWriteTimestamp)dlsym(vk_sdk, "vkCmdWriteTimestamp");
    if( vkCmdWriteTimestamp == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdWriteTimestamp in sdk");
        return NULL;
    }


    vkCmdPipelineBarrier = (PFN_vkCmdPipelineBarrier)dlsym(vk_sdk, "vkCmdPipelineBarrier");
    if( vkCmdPipelineBarrier == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdPipelineBarrier in sdk");
        return NULL;
    }


    vkDestroyRenderPass = (PFN_vkDestroyRenderPass)dlsym(vk_sdk, "vkDestroyRenderPass");
    if( vkDestroyRenderPass == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroyRenderPass in sdk");
        return NULL;
    }


    vkCmdCopyBuffer = (PFN_vkCmdCopyBuffer)dlsym(vk_sdk, "vkCmdCopyBuffer");
    if( vkCmdCopyBuffer == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdCopyBuffer in sdk");
        return NULL;
    }


    vkCreateDescriptorPool = (PFN_vkCreateDescriptorPool)dlsym(vk_sdk, "vkCreateDescriptorPool");
    if( vkCreateDescriptorPool == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreateDescriptorPool in sdk");
        return NULL;
    }


    vkEnumeratePhysicalDevices = (PFN_vkEnumeratePhysicalDevices)dlsym(vk_sdk, "vkEnumeratePhysicalDevices");
    if( vkEnumeratePhysicalDevices == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkEnumeratePhysicalDevices in sdk");
        return NULL;
    }


    vkCmdResetQueryPool = (PFN_vkCmdResetQueryPool)dlsym(vk_sdk, "vkCmdResetQueryPool");
    if( vkCmdResetQueryPool == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdResetQueryPool in sdk");
        return NULL;
    }


    vkGetPhysicalDeviceQueueFamilyProperties = (PFN_vkGetPhysicalDeviceQueueFamilyProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceQueueFamilyProperties");
    if( vkGetPhysicalDeviceQueueFamilyProperties == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetPhysicalDeviceQueueFamilyProperties in sdk");
        return NULL;
    }


    vkGetPhysicalDeviceFormatProperties = (PFN_vkGetPhysicalDeviceFormatProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceFormatProperties");
    if( vkGetPhysicalDeviceFormatProperties == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetPhysicalDeviceFormatProperties in sdk");
        return NULL;
    }


    vkCreateGraphicsPipelines = (PFN_vkCreateGraphicsPipelines)dlsym(vk_sdk, "vkCreateGraphicsPipelines");
    if( vkCreateGraphicsPipelines == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreateGraphicsPipelines in sdk");
        return NULL;
    }


    vkCmdSetStencilReference = (PFN_vkCmdSetStencilReference)dlsym(vk_sdk, "vkCmdSetStencilReference");
    if( vkCmdSetStencilReference == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdSetStencilReference in sdk");
        return NULL;
    }


    vkGetImageSubresourceLayout = (PFN_vkGetImageSubresourceLayout)dlsym(vk_sdk, "vkGetImageSubresourceLayout");
    if( vkGetImageSubresourceLayout == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetImageSubresourceLayout in sdk");
        return NULL;
    }


    vkCmdSetLineWidth = (PFN_vkCmdSetLineWidth)dlsym(vk_sdk, "vkCmdSetLineWidth");
    if( vkCmdSetLineWidth == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdSetLineWidth in sdk");
        return NULL;
    }


    vkCmdCopyBufferToImage = (PFN_vkCmdCopyBufferToImage)dlsym(vk_sdk, "vkCmdCopyBufferToImage");
    if( vkCmdCopyBufferToImage == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdCopyBufferToImage in sdk");
        return NULL;
    }


    vkCmdDraw = (PFN_vkCmdDraw)dlsym(vk_sdk, "vkCmdDraw");
    if( vkCmdDraw == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdDraw in sdk");
        return NULL;
    }


    vkFreeMemory = (PFN_vkFreeMemory)dlsym(vk_sdk, "vkFreeMemory");
    if( vkFreeMemory == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkFreeMemory in sdk");
        return NULL;
    }


    vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)dlsym(vk_sdk, "vkGetInstanceProcAddr");
    if( vkGetInstanceProcAddr == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetInstanceProcAddr in sdk");
        return NULL;
    }


    vkDestroyBuffer = (PFN_vkDestroyBuffer)dlsym(vk_sdk, "vkDestroyBuffer");
    if( vkDestroyBuffer == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroyBuffer in sdk");
        return NULL;
    }


    vkEnumerateInstanceExtensionProperties = (PFN_vkEnumerateInstanceExtensionProperties)dlsym(vk_sdk, "vkEnumerateInstanceExtensionProperties");
    if( vkEnumerateInstanceExtensionProperties == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkEnumerateInstanceExtensionProperties in sdk");
        return NULL;
    }


    vkCmdBindDescriptorSets = (PFN_vkCmdBindDescriptorSets)dlsym(vk_sdk, "vkCmdBindDescriptorSets");
    if( vkCmdBindDescriptorSets == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdBindDescriptorSets in sdk");
        return NULL;
    }


    vkCmdBlitImage = (PFN_vkCmdBlitImage)dlsym(vk_sdk, "vkCmdBlitImage");
    if( vkCmdBlitImage == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdBlitImage in sdk");
        return NULL;
    }


    vkCmdExecuteCommands = (PFN_vkCmdExecuteCommands)dlsym(vk_sdk, "vkCmdExecuteCommands");
    if( vkCmdExecuteCommands == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdExecuteCommands in sdk");
        return NULL;
    }


    vkGetRenderAreaGranularity = (PFN_vkGetRenderAreaGranularity)dlsym(vk_sdk, "vkGetRenderAreaGranularity");
    if( vkGetRenderAreaGranularity == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetRenderAreaGranularity in sdk");
        return NULL;
    }


    vkDestroyCommandPool = (PFN_vkDestroyCommandPool)dlsym(vk_sdk, "vkDestroyCommandPool");
    if( vkDestroyCommandPool == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroyCommandPool in sdk");
        return NULL;
    }


    vkUpdateDescriptorSets = (PFN_vkUpdateDescriptorSets)dlsym(vk_sdk, "vkUpdateDescriptorSets");
    if( vkUpdateDescriptorSets == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkUpdateDescriptorSets in sdk");
        return NULL;
    }


    vkCreateEvent = (PFN_vkCreateEvent)dlsym(vk_sdk, "vkCreateEvent");
    if( vkCreateEvent == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreateEvent in sdk");
        return NULL;
    }


    vkGetPhysicalDeviceMemoryProperties = (PFN_vkGetPhysicalDeviceMemoryProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceMemoryProperties");
    if( vkGetPhysicalDeviceMemoryProperties == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetPhysicalDeviceMemoryProperties in sdk");
        return NULL;
    }


    vkMergePipelineCaches = (PFN_vkMergePipelineCaches)dlsym(vk_sdk, "vkMergePipelineCaches");
    if( vkMergePipelineCaches == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkMergePipelineCaches in sdk");
        return NULL;
    }


    vkBeginCommandBuffer = (PFN_vkBeginCommandBuffer)dlsym(vk_sdk, "vkBeginCommandBuffer");
    if( vkBeginCommandBuffer == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkBeginCommandBuffer in sdk");
        return NULL;
    }


    vkAllocateMemory = (PFN_vkAllocateMemory)dlsym(vk_sdk, "vkAllocateMemory");
    if( vkAllocateMemory == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkAllocateMemory in sdk");
        return NULL;
    }


    vkGetDeviceProcAddr = (PFN_vkGetDeviceProcAddr)dlsym(vk_sdk, "vkGetDeviceProcAddr");
    if( vkGetDeviceProcAddr == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetDeviceProcAddr in sdk");
        return NULL;
    }


    vkCreateDevice = (PFN_vkCreateDevice)dlsym(vk_sdk, "vkCreateDevice");
    if( vkCreateDevice == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreateDevice in sdk");
        return NULL;
    }


    vkCmdBindVertexBuffers = (PFN_vkCmdBindVertexBuffers)dlsym(vk_sdk, "vkCmdBindVertexBuffers");
    if( vkCmdBindVertexBuffers == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdBindVertexBuffers in sdk");
        return NULL;
    }


    vkCmdDispatch = (PFN_vkCmdDispatch)dlsym(vk_sdk, "vkCmdDispatch");
    if( vkCmdDispatch == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdDispatch in sdk");
        return NULL;
    }


    vkResetDescriptorPool = (PFN_vkResetDescriptorPool)dlsym(vk_sdk, "vkResetDescriptorPool");
    if( vkResetDescriptorPool == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkResetDescriptorPool in sdk");
        return NULL;
    }


    vkCreateImageView = (PFN_vkCreateImageView)dlsym(vk_sdk, "vkCreateImageView");
    if( vkCreateImageView == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreateImageView in sdk");
        return NULL;
    }


    vkWaitForFences = (PFN_vkWaitForFences)dlsym(vk_sdk, "vkWaitForFences");
    if( vkWaitForFences == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkWaitForFences in sdk");
        return NULL;
    }


    vkCmdSetDepthBounds = (PFN_vkCmdSetDepthBounds)dlsym(vk_sdk, "vkCmdSetDepthBounds");
    if( vkCmdSetDepthBounds == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdSetDepthBounds in sdk");
        return NULL;
    }


    vkCreateComputePipelines = (PFN_vkCreateComputePipelines)dlsym(vk_sdk, "vkCreateComputePipelines");
    if( vkCreateComputePipelines == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreateComputePipelines in sdk");
        return NULL;
    }


    vkCmdCopyImageToBuffer = (PFN_vkCmdCopyImageToBuffer)dlsym(vk_sdk, "vkCmdCopyImageToBuffer");
    if( vkCmdCopyImageToBuffer == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdCopyImageToBuffer in sdk");
        return NULL;
    }


    vkCmdCopyQueryPoolResults = (PFN_vkCmdCopyQueryPoolResults)dlsym(vk_sdk, "vkCmdCopyQueryPoolResults");
    if( vkCmdCopyQueryPoolResults == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdCopyQueryPoolResults in sdk");
        return NULL;
    }


    vkFreeDescriptorSets = (PFN_vkFreeDescriptorSets)dlsym(vk_sdk, "vkFreeDescriptorSets");
    if( vkFreeDescriptorSets == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkFreeDescriptorSets in sdk");
        return NULL;
    }


    vkUnmapMemory = (PFN_vkUnmapMemory)dlsym(vk_sdk, "vkUnmapMemory");
    if( vkUnmapMemory == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkUnmapMemory in sdk");
        return NULL;
    }


    vkGetPhysicalDeviceImageFormatProperties = (PFN_vkGetPhysicalDeviceImageFormatProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceImageFormatProperties");
    if( vkGetPhysicalDeviceImageFormatProperties == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetPhysicalDeviceImageFormatProperties in sdk");
        return NULL;
    }


    vkInvalidateMappedMemoryRanges = (PFN_vkInvalidateMappedMemoryRanges)dlsym(vk_sdk, "vkInvalidateMappedMemoryRanges");
    if( vkInvalidateMappedMemoryRanges == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkInvalidateMappedMemoryRanges in sdk");
        return NULL;
    }


    vkResetEvent = (PFN_vkResetEvent)dlsym(vk_sdk, "vkResetEvent");
    if( vkResetEvent == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkResetEvent in sdk");
        return NULL;
    }


    vkCmdBindIndexBuffer = (PFN_vkCmdBindIndexBuffer)dlsym(vk_sdk, "vkCmdBindIndexBuffer");
    if( vkCmdBindIndexBuffer == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdBindIndexBuffer in sdk");
        return NULL;
    }


    vkCmdSetStencilCompareMask = (PFN_vkCmdSetStencilCompareMask)dlsym(vk_sdk, "vkCmdSetStencilCompareMask");
    if( vkCmdSetStencilCompareMask == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdSetStencilCompareMask in sdk");
        return NULL;
    }


    vkCreateInstance = (PFN_vkCreateInstance)dlsym(vk_sdk, "vkCreateInstance");
    if( vkCreateInstance == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreateInstance in sdk");
        return NULL;
    }


    vkGetEventStatus = (PFN_vkGetEventStatus)dlsym(vk_sdk, "vkGetEventStatus");
    if( vkGetEventStatus == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetEventStatus in sdk");
        return NULL;
    }


    vkGetImageMemoryRequirements = (PFN_vkGetImageMemoryRequirements)dlsym(vk_sdk, "vkGetImageMemoryRequirements");
    if( vkGetImageMemoryRequirements == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetImageMemoryRequirements in sdk");
        return NULL;
    }


    vkCmdSetEvent = (PFN_vkCmdSetEvent)dlsym(vk_sdk, "vkCmdSetEvent");
    if( vkCmdSetEvent == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdSetEvent in sdk");
        return NULL;
    }


    vkCmdBeginRenderPass = (PFN_vkCmdBeginRenderPass)dlsym(vk_sdk, "vkCmdBeginRenderPass");
    if( vkCmdBeginRenderPass == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdBeginRenderPass in sdk");
        return NULL;
    }


    vkDestroySampler = (PFN_vkDestroySampler)dlsym(vk_sdk, "vkDestroySampler");
    if( vkDestroySampler == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroySampler in sdk");
        return NULL;
    }


    vkCmdClearColorImage = (PFN_vkCmdClearColorImage)dlsym(vk_sdk, "vkCmdClearColorImage");
    if( vkCmdClearColorImage == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdClearColorImage in sdk");
        return NULL;
    }


    vkCmdDrawIndexedIndirect = (PFN_vkCmdDrawIndexedIndirect)dlsym(vk_sdk, "vkCmdDrawIndexedIndirect");
    if( vkCmdDrawIndexedIndirect == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdDrawIndexedIndirect in sdk");
        return NULL;
    }


    vkGetQueryPoolResults = (PFN_vkGetQueryPoolResults)dlsym(vk_sdk, "vkGetQueryPoolResults");
    if( vkGetQueryPoolResults == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetQueryPoolResults in sdk");
        return NULL;
    }


    vkBindBufferMemory = (PFN_vkBindBufferMemory)dlsym(vk_sdk, "vkBindBufferMemory");
    if( vkBindBufferMemory == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkBindBufferMemory in sdk");
        return NULL;
    }


    vkDestroyDescriptorPool = (PFN_vkDestroyDescriptorPool)dlsym(vk_sdk, "vkDestroyDescriptorPool");
    if( vkDestroyDescriptorPool == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroyDescriptorPool in sdk");
        return NULL;
    }


    vkCmdUpdateBuffer = (PFN_vkCmdUpdateBuffer)dlsym(vk_sdk, "vkCmdUpdateBuffer");
    if( vkCmdUpdateBuffer == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdUpdateBuffer in sdk");
        return NULL;
    }


    vkCreateShaderModule = (PFN_vkCreateShaderModule)dlsym(vk_sdk, "vkCreateShaderModule");
    if( vkCreateShaderModule == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreateShaderModule in sdk");
        return NULL;
    }


    vkEnumerateDeviceExtensionProperties = (PFN_vkEnumerateDeviceExtensionProperties)dlsym(vk_sdk, "vkEnumerateDeviceExtensionProperties");
    if( vkEnumerateDeviceExtensionProperties == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkEnumerateDeviceExtensionProperties in sdk");
        return NULL;
    }


    vkDestroyQueryPool = (PFN_vkDestroyQueryPool)dlsym(vk_sdk, "vkDestroyQueryPool");
    if( vkDestroyQueryPool == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroyQueryPool in sdk");
        return NULL;
    }


    vkDestroyBufferView = (PFN_vkDestroyBufferView)dlsym(vk_sdk, "vkDestroyBufferView");
    if( vkDestroyBufferView == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroyBufferView in sdk");
        return NULL;
    }


    vkAllocateDescriptorSets = (PFN_vkAllocateDescriptorSets)dlsym(vk_sdk, "vkAllocateDescriptorSets");
    if( vkAllocateDescriptorSets == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkAllocateDescriptorSets in sdk");
        return NULL;
    }


    vkCreatePipelineCache = (PFN_vkCreatePipelineCache)dlsym(vk_sdk, "vkCreatePipelineCache");
    if( vkCreatePipelineCache == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreatePipelineCache in sdk");
        return NULL;
    }


    vkCmdEndQuery = (PFN_vkCmdEndQuery)dlsym(vk_sdk, "vkCmdEndQuery");
    if( vkCmdEndQuery == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdEndQuery in sdk");
        return NULL;
    }


    vkMapMemory = (PFN_vkMapMemory)dlsym(vk_sdk, "vkMapMemory");
    if( vkMapMemory == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkMapMemory in sdk");
        return NULL;
    }


    vkCmdFillBuffer = (PFN_vkCmdFillBuffer)dlsym(vk_sdk, "vkCmdFillBuffer");
    if( vkCmdFillBuffer == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdFillBuffer in sdk");
        return NULL;
    }


    vkDestroyImageView = (PFN_vkDestroyImageView)dlsym(vk_sdk, "vkDestroyImageView");
    if( vkDestroyImageView == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroyImageView in sdk");
        return NULL;
    }


    vkEnumerateInstanceLayerProperties = (PFN_vkEnumerateInstanceLayerProperties)dlsym(vk_sdk, "vkEnumerateInstanceLayerProperties");
    if( vkEnumerateInstanceLayerProperties == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkEnumerateInstanceLayerProperties in sdk");
        return NULL;
    }


    vkCmdCopyImage = (PFN_vkCmdCopyImage)dlsym(vk_sdk, "vkCmdCopyImage");
    if( vkCmdCopyImage == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdCopyImage in sdk");
        return NULL;
    }


    vkCmdDrawIndirect = (PFN_vkCmdDrawIndirect)dlsym(vk_sdk, "vkCmdDrawIndirect");
    if( vkCmdDrawIndirect == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdDrawIndirect in sdk");
        return NULL;
    }


    vkDestroyInstance = (PFN_vkDestroyInstance)dlsym(vk_sdk, "vkDestroyInstance");
    if( vkDestroyInstance == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroyInstance in sdk");
        return NULL;
    }


    vkDestroyPipeline = (PFN_vkDestroyPipeline)dlsym(vk_sdk, "vkDestroyPipeline");
    if( vkDestroyPipeline == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroyPipeline in sdk");
        return NULL;
    }


    vkQueueBindSparse = (PFN_vkQueueBindSparse)dlsym(vk_sdk, "vkQueueBindSparse");
    if( vkQueueBindSparse == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkQueueBindSparse in sdk");
        return NULL;
    }


    vkDestroyEvent = (PFN_vkDestroyEvent)dlsym(vk_sdk, "vkDestroyEvent");
    if( vkDestroyEvent == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroyEvent in sdk");
        return NULL;
    }


    vkDestroyFence = (PFN_vkDestroyFence)dlsym(vk_sdk, "vkDestroyFence");
    if( vkDestroyFence == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroyFence in sdk");
        return NULL;
    }


    vkResetFences = (PFN_vkResetFences)dlsym(vk_sdk, "vkResetFences");
    if( vkResetFences == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkResetFences in sdk");
        return NULL;
    }


    vkCmdSetBlendConstants = (PFN_vkCmdSetBlendConstants)dlsym(vk_sdk, "vkCmdSetBlendConstants");
    if( vkCmdSetBlendConstants == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdSetBlendConstants in sdk");
        return NULL;
    }


    vkCreateImage = (PFN_vkCreateImage)dlsym(vk_sdk, "vkCreateImage");
    if( vkCreateImage == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreateImage in sdk");
        return NULL;
    }


    vkCreateDescriptorSetLayout = (PFN_vkCreateDescriptorSetLayout)dlsym(vk_sdk, "vkCreateDescriptorSetLayout");
    if( vkCreateDescriptorSetLayout == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCreateDescriptorSetLayout in sdk");
        return NULL;
    }


    vkGetImageSparseMemoryRequirements = (PFN_vkGetImageSparseMemoryRequirements)dlsym(vk_sdk, "vkGetImageSparseMemoryRequirements");
    if( vkGetImageSparseMemoryRequirements == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetImageSparseMemoryRequirements in sdk");
        return NULL;
    }


    vkGetPhysicalDeviceSparseImageFormatProperties = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceSparseImageFormatProperties");
    if( vkGetPhysicalDeviceSparseImageFormatProperties == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetPhysicalDeviceSparseImageFormatProperties in sdk");
        return NULL;
    }


    vkDestroyDevice = (PFN_vkDestroyDevice)dlsym(vk_sdk, "vkDestroyDevice");
    if( vkDestroyDevice == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkDestroyDevice in sdk");
        return NULL;
    }


    vkCmdClearDepthStencilImage = (PFN_vkCmdClearDepthStencilImage)dlsym(vk_sdk, "vkCmdClearDepthStencilImage");
    if( vkCmdClearDepthStencilImage == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdClearDepthStencilImage in sdk");
        return NULL;
    }


    vkResetCommandBuffer = (PFN_vkResetCommandBuffer)dlsym(vk_sdk, "vkResetCommandBuffer");
    if( vkResetCommandBuffer == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkResetCommandBuffer in sdk");
        return NULL;
    }


    vkCmdClearAttachments = (PFN_vkCmdClearAttachments)dlsym(vk_sdk, "vkCmdClearAttachments");
    if( vkCmdClearAttachments == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkCmdClearAttachments in sdk");
        return NULL;
    }


    vkGetDeviceMemoryCommitment = (PFN_vkGetDeviceMemoryCommitment)dlsym(vk_sdk, "vkGetDeviceMemoryCommitment");
    if( vkGetDeviceMemoryCommitment == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkGetDeviceMemoryCommitment in sdk");
        return NULL;
    }


    vkQueueSubmit = (PFN_vkQueueSubmit)dlsym(vk_sdk, "vkQueueSubmit");
    if( vkQueueSubmit == NULL ) {
        PyErr_SetString(PyExc_ImportError,
                        "Can't load vkQueueSubmit in sdk");
        return NULL;
    }


    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject* PyHandle_VkPhysicalDevice (PyObject *self, PyObject *args) {
    VkPhysicalDevice* handle = malloc(sizeof(VkPhysicalDevice));
    PyObject* value = PyCapsule_New(handle, "VkPhysicalDevice", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkSurfaceKHR (PyObject *self, PyObject *args) {
    VkSurfaceKHR* handle = malloc(sizeof(VkSurfaceKHR));
    PyObject* value = PyCapsule_New(handle, "VkSurfaceKHR", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkQueryPool (PyObject *self, PyObject *args) {
    VkQueryPool* handle = malloc(sizeof(VkQueryPool));
    PyObject* value = PyCapsule_New(handle, "VkQueryPool", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkImage (PyObject *self, PyObject *args) {
    VkImage* handle = malloc(sizeof(VkImage));
    PyObject* value = PyCapsule_New(handle, "VkImage", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkPipelineLayout (PyObject *self, PyObject *args) {
    VkPipelineLayout* handle = malloc(sizeof(VkPipelineLayout));
    PyObject* value = PyCapsule_New(handle, "VkPipelineLayout", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkDebugReportCallbackEXT (PyObject *self, PyObject *args) {
    VkDebugReportCallbackEXT* handle = malloc(sizeof(VkDebugReportCallbackEXT));
    PyObject* value = PyCapsule_New(handle, "VkDebugReportCallbackEXT", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkDeviceMemory (PyObject *self, PyObject *args) {
    VkDeviceMemory* handle = malloc(sizeof(VkDeviceMemory));
    PyObject* value = PyCapsule_New(handle, "VkDeviceMemory", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkShaderModule (PyObject *self, PyObject *args) {
    VkShaderModule* handle = malloc(sizeof(VkShaderModule));
    PyObject* value = PyCapsule_New(handle, "VkShaderModule", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkFramebuffer (PyObject *self, PyObject *args) {
    VkFramebuffer* handle = malloc(sizeof(VkFramebuffer));
    PyObject* value = PyCapsule_New(handle, "VkFramebuffer", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkImageView (PyObject *self, PyObject *args) {
    VkImageView* handle = malloc(sizeof(VkImageView));
    PyObject* value = PyCapsule_New(handle, "VkImageView", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkCommandPool (PyObject *self, PyObject *args) {
    VkCommandPool* handle = malloc(sizeof(VkCommandPool));
    PyObject* value = PyCapsule_New(handle, "VkCommandPool", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkDevice (PyObject *self, PyObject *args) {
    VkDevice* handle = malloc(sizeof(VkDevice));
    PyObject* value = PyCapsule_New(handle, "VkDevice", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkSwapchainKHR (PyObject *self, PyObject *args) {
    VkSwapchainKHR* handle = malloc(sizeof(VkSwapchainKHR));
    PyObject* value = PyCapsule_New(handle, "VkSwapchainKHR", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkCommandBuffer (PyObject *self, PyObject *args) {
    VkCommandBuffer* handle = malloc(sizeof(VkCommandBuffer));
    PyObject* value = PyCapsule_New(handle, "VkCommandBuffer", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkFence (PyObject *self, PyObject *args) {
    VkFence* handle = malloc(sizeof(VkFence));
    PyObject* value = PyCapsule_New(handle, "VkFence", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkEvent (PyObject *self, PyObject *args) {
    VkEvent* handle = malloc(sizeof(VkEvent));
    PyObject* value = PyCapsule_New(handle, "VkEvent", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkDescriptorSet (PyObject *self, PyObject *args) {
    VkDescriptorSet* handle = malloc(sizeof(VkDescriptorSet));
    PyObject* value = PyCapsule_New(handle, "VkDescriptorSet", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkInstance (PyObject *self, PyObject *args) {
    VkInstance* handle = malloc(sizeof(VkInstance));
    PyObject* value = PyCapsule_New(handle, "VkInstance", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkSemaphore (PyObject *self, PyObject *args) {
    VkSemaphore* handle = malloc(sizeof(VkSemaphore));
    PyObject* value = PyCapsule_New(handle, "VkSemaphore", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkPipelineCache (PyObject *self, PyObject *args) {
    VkPipelineCache* handle = malloc(sizeof(VkPipelineCache));
    PyObject* value = PyCapsule_New(handle, "VkPipelineCache", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkDisplayModeKHR (PyObject *self, PyObject *args) {
    VkDisplayModeKHR* handle = malloc(sizeof(VkDisplayModeKHR));
    PyObject* value = PyCapsule_New(handle, "VkDisplayModeKHR", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkDescriptorSetLayout (PyObject *self, PyObject *args) {
    VkDescriptorSetLayout* handle = malloc(sizeof(VkDescriptorSetLayout));
    PyObject* value = PyCapsule_New(handle, "VkDescriptorSetLayout", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkBuffer (PyObject *self, PyObject *args) {
    VkBuffer* handle = malloc(sizeof(VkBuffer));
    PyObject* value = PyCapsule_New(handle, "VkBuffer", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkQueue (PyObject *self, PyObject *args) {
    VkQueue* handle = malloc(sizeof(VkQueue));
    PyObject* value = PyCapsule_New(handle, "VkQueue", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkRenderPass (PyObject *self, PyObject *args) {
    VkRenderPass* handle = malloc(sizeof(VkRenderPass));
    PyObject* value = PyCapsule_New(handle, "VkRenderPass", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkDescriptorPool (PyObject *self, PyObject *args) {
    VkDescriptorPool* handle = malloc(sizeof(VkDescriptorPool));
    PyObject* value = PyCapsule_New(handle, "VkDescriptorPool", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkDisplayKHR (PyObject *self, PyObject *args) {
    VkDisplayKHR* handle = malloc(sizeof(VkDisplayKHR));
    PyObject* value = PyCapsule_New(handle, "VkDisplayKHR", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkPipeline (PyObject *self, PyObject *args) {
    VkPipeline* handle = malloc(sizeof(VkPipeline));
    PyObject* value = PyCapsule_New(handle, "VkPipeline", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkSampler (PyObject *self, PyObject *args) {
    VkSampler* handle = malloc(sizeof(VkSampler));
    PyObject* value = PyCapsule_New(handle, "VkSampler", NULL);
    if (value == NULL) return NULL;
    return value;
}

static PyObject* PyHandle_VkBufferView (PyObject *self, PyObject *args) {
    VkBufferView* handle = malloc(sizeof(VkBufferView));
    PyObject* value = PyCapsule_New(handle, "VkBufferView", NULL);
    if (value == NULL) return NULL;
    return value;
}

typedef struct {
    PyObject_HEAD VkOffset2D *base;
}
PyVkOffset2D;

typedef struct {
    PyObject_HEAD VkOffset3D *base;
}
PyVkOffset3D;

typedef struct {
    PyObject_HEAD VkExtent2D *base;
}
PyVkExtent2D;

typedef struct {
    PyObject_HEAD VkExtent3D *base;
}
PyVkExtent3D;

typedef struct {
    PyObject_HEAD VkViewport *base;
}
PyVkViewport;

typedef struct {
    PyObject_HEAD VkRect2D *base;
}
PyVkRect2D;

#ifdef hackdefine

typedef struct {
    PyObject_HEAD VkRect3D *base;
}
PyVkRect3D;

#endif

typedef struct {
    PyObject_HEAD VkClearRect *base;
}
PyVkClearRect;

typedef struct {
    PyObject_HEAD VkComponentMapping *base;
}
PyVkComponentMapping;

typedef struct {
    PyObject_HEAD VkPhysicalDeviceProperties *base;
}
PyVkPhysicalDeviceProperties;

typedef struct {
    PyObject_HEAD VkExtensionProperties *base;
}
PyVkExtensionProperties;

typedef struct {
    PyObject_HEAD VkLayerProperties *base;
}
PyVkLayerProperties;

typedef struct {
    PyObject_HEAD VkApplicationInfo *base;
}
PyVkApplicationInfo;

typedef struct {
    PyObject_HEAD VkAllocationCallbacks *base;
}
PyVkAllocationCallbacks;

typedef struct {
    PyObject_HEAD VkDeviceQueueCreateInfo *base;
}
PyVkDeviceQueueCreateInfo;

typedef struct {
    PyObject_HEAD VkDeviceCreateInfo *base;
}
PyVkDeviceCreateInfo;

typedef struct {
    PyObject_HEAD VkInstanceCreateInfo *base;
}
PyVkInstanceCreateInfo;

typedef struct {
    PyObject_HEAD VkQueueFamilyProperties *base;
}
PyVkQueueFamilyProperties;

typedef struct {
    PyObject_HEAD VkPhysicalDeviceMemoryProperties *base;
}
PyVkPhysicalDeviceMemoryProperties;

typedef struct {
    PyObject_HEAD VkMemoryAllocateInfo *base;
}
PyVkMemoryAllocateInfo;

typedef struct {
    PyObject_HEAD VkMemoryRequirements *base;
}
PyVkMemoryRequirements;

typedef struct {
    PyObject_HEAD VkSparseImageFormatProperties *base;
}
PyVkSparseImageFormatProperties;

typedef struct {
    PyObject_HEAD VkSparseImageMemoryRequirements *base;
}
PyVkSparseImageMemoryRequirements;

typedef struct {
    PyObject_HEAD VkMemoryType *base;
}
PyVkMemoryType;

typedef struct {
    PyObject_HEAD VkMemoryHeap *base;
}
PyVkMemoryHeap;

typedef struct {
    PyObject_HEAD VkMappedMemoryRange *base;
}
PyVkMappedMemoryRange;

typedef struct {
    PyObject_HEAD VkFormatProperties *base;
}
PyVkFormatProperties;

typedef struct {
    PyObject_HEAD VkImageFormatProperties *base;
}
PyVkImageFormatProperties;

typedef struct {
    PyObject_HEAD VkDescriptorBufferInfo *base;
}
PyVkDescriptorBufferInfo;

typedef struct {
    PyObject_HEAD VkDescriptorImageInfo *base;
}
PyVkDescriptorImageInfo;

typedef struct {
    PyObject_HEAD VkWriteDescriptorSet *base;
}
PyVkWriteDescriptorSet;

typedef struct {
    PyObject_HEAD VkCopyDescriptorSet *base;
}
PyVkCopyDescriptorSet;

typedef struct {
    PyObject_HEAD VkBufferCreateInfo *base;
}
PyVkBufferCreateInfo;

typedef struct {
    PyObject_HEAD VkBufferViewCreateInfo *base;
}
PyVkBufferViewCreateInfo;

typedef struct {
    PyObject_HEAD VkImageSubresource *base;
}
PyVkImageSubresource;

typedef struct {
    PyObject_HEAD VkImageSubresourceLayers *base;
}
PyVkImageSubresourceLayers;

typedef struct {
    PyObject_HEAD VkImageSubresourceRange *base;
}
PyVkImageSubresourceRange;

typedef struct {
    PyObject_HEAD VkMemoryBarrier *base;
}
PyVkMemoryBarrier;

typedef struct {
    PyObject_HEAD VkBufferMemoryBarrier *base;
}
PyVkBufferMemoryBarrier;

typedef struct {
    PyObject_HEAD VkImageMemoryBarrier *base;
}
PyVkImageMemoryBarrier;

typedef struct {
    PyObject_HEAD VkImageCreateInfo *base;
}
PyVkImageCreateInfo;

typedef struct {
    PyObject_HEAD VkSubresourceLayout *base;
}
PyVkSubresourceLayout;

typedef struct {
    PyObject_HEAD VkImageViewCreateInfo *base;
}
PyVkImageViewCreateInfo;

typedef struct {
    PyObject_HEAD VkBufferCopy *base;
}
PyVkBufferCopy;

typedef struct {
    PyObject_HEAD VkSparseMemoryBind *base;
}
PyVkSparseMemoryBind;

typedef struct {
    PyObject_HEAD VkSparseImageMemoryBind *base;
}
PyVkSparseImageMemoryBind;

typedef struct {
    PyObject_HEAD VkSparseBufferMemoryBindInfo *base;
}
PyVkSparseBufferMemoryBindInfo;

typedef struct {
    PyObject_HEAD VkSparseImageOpaqueMemoryBindInfo *base;
}
PyVkSparseImageOpaqueMemoryBindInfo;

typedef struct {
    PyObject_HEAD VkSparseImageMemoryBindInfo *base;
}
PyVkSparseImageMemoryBindInfo;

typedef struct {
    PyObject_HEAD VkBindSparseInfo *base;
}
PyVkBindSparseInfo;

typedef struct {
    PyObject_HEAD VkImageCopy *base;
}
PyVkImageCopy;

typedef struct {
    PyObject_HEAD VkImageBlit *base;
}
PyVkImageBlit;

typedef struct {
    PyObject_HEAD VkBufferImageCopy *base;
}
PyVkBufferImageCopy;

typedef struct {
    PyObject_HEAD VkImageResolve *base;
}
PyVkImageResolve;

typedef struct {
    PyObject_HEAD VkShaderModuleCreateInfo *base;
}
PyVkShaderModuleCreateInfo;

typedef struct {
    PyObject_HEAD VkDescriptorSetLayoutBinding *base;
}
PyVkDescriptorSetLayoutBinding;

typedef struct {
    PyObject_HEAD VkDescriptorSetLayoutCreateInfo *base;
}
PyVkDescriptorSetLayoutCreateInfo;

typedef struct {
    PyObject_HEAD VkDescriptorPoolSize *base;
}
PyVkDescriptorPoolSize;

typedef struct {
    PyObject_HEAD VkDescriptorPoolCreateInfo *base;
}
PyVkDescriptorPoolCreateInfo;

typedef struct {
    PyObject_HEAD VkDescriptorSetAllocateInfo *base;
}
PyVkDescriptorSetAllocateInfo;

typedef struct {
    PyObject_HEAD VkSpecializationMapEntry *base;
}
PyVkSpecializationMapEntry;

typedef struct {
    PyObject_HEAD VkSpecializationInfo *base;
}
PyVkSpecializationInfo;

typedef struct {
    PyObject_HEAD VkPipelineShaderStageCreateInfo *base;
}
PyVkPipelineShaderStageCreateInfo;

typedef struct {
    PyObject_HEAD VkComputePipelineCreateInfo *base;
}
PyVkComputePipelineCreateInfo;

typedef struct {
    PyObject_HEAD VkVertexInputBindingDescription *base;
}
PyVkVertexInputBindingDescription;

typedef struct {
    PyObject_HEAD VkVertexInputAttributeDescription *base;
}
PyVkVertexInputAttributeDescription;

typedef struct {
    PyObject_HEAD VkPipelineVertexInputStateCreateInfo *base;
}
PyVkPipelineVertexInputStateCreateInfo;

typedef struct {
    PyObject_HEAD VkPipelineInputAssemblyStateCreateInfo *base;
}
PyVkPipelineInputAssemblyStateCreateInfo;

typedef struct {
    PyObject_HEAD VkPipelineTessellationStateCreateInfo *base;
}
PyVkPipelineTessellationStateCreateInfo;

typedef struct {
    PyObject_HEAD VkPipelineViewportStateCreateInfo *base;
}
PyVkPipelineViewportStateCreateInfo;

typedef struct {
    PyObject_HEAD VkPipelineRasterizationStateCreateInfo *base;
}
PyVkPipelineRasterizationStateCreateInfo;

typedef struct {
    PyObject_HEAD VkPipelineMultisampleStateCreateInfo *base;
}
PyVkPipelineMultisampleStateCreateInfo;

typedef struct {
    PyObject_HEAD VkPipelineColorBlendAttachmentState *base;
}
PyVkPipelineColorBlendAttachmentState;

typedef struct {
    PyObject_HEAD VkPipelineColorBlendStateCreateInfo *base;
}
PyVkPipelineColorBlendStateCreateInfo;

typedef struct {
    PyObject_HEAD VkPipelineDynamicStateCreateInfo *base;
}
PyVkPipelineDynamicStateCreateInfo;

typedef struct {
    PyObject_HEAD VkStencilOpState *base;
}
PyVkStencilOpState;

typedef struct {
    PyObject_HEAD VkPipelineDepthStencilStateCreateInfo *base;
}
PyVkPipelineDepthStencilStateCreateInfo;

typedef struct {
    PyObject_HEAD VkGraphicsPipelineCreateInfo *base;
}
PyVkGraphicsPipelineCreateInfo;

typedef struct {
    PyObject_HEAD VkPipelineCacheCreateInfo *base;
}
PyVkPipelineCacheCreateInfo;

typedef struct {
    PyObject_HEAD VkPushConstantRange *base;
}
PyVkPushConstantRange;

typedef struct {
    PyObject_HEAD VkPipelineLayoutCreateInfo *base;
}
PyVkPipelineLayoutCreateInfo;

typedef struct {
    PyObject_HEAD VkSamplerCreateInfo *base;
}
PyVkSamplerCreateInfo;

typedef struct {
    PyObject_HEAD VkCommandPoolCreateInfo *base;
}
PyVkCommandPoolCreateInfo;

typedef struct {
    PyObject_HEAD VkCommandBufferAllocateInfo *base;
}
PyVkCommandBufferAllocateInfo;

typedef struct {
    PyObject_HEAD VkCommandBufferInheritanceInfo *base;
}
PyVkCommandBufferInheritanceInfo;

typedef struct {
    PyObject_HEAD VkCommandBufferBeginInfo *base;
}
PyVkCommandBufferBeginInfo;

typedef struct {
    PyObject_HEAD VkRenderPassBeginInfo *base;
}
PyVkRenderPassBeginInfo;

typedef struct {
    PyObject_HEAD VkClearDepthStencilValue *base;
}
PyVkClearDepthStencilValue;

typedef struct {
    PyObject_HEAD VkClearAttachment *base;
}
PyVkClearAttachment;

typedef struct {
    PyObject_HEAD VkAttachmentDescription *base;
}
PyVkAttachmentDescription;

typedef struct {
    PyObject_HEAD VkAttachmentReference *base;
}
PyVkAttachmentReference;

typedef struct {
    PyObject_HEAD VkSubpassDescription *base;
}
PyVkSubpassDescription;

typedef struct {
    PyObject_HEAD VkSubpassDependency *base;
}
PyVkSubpassDependency;

typedef struct {
    PyObject_HEAD VkRenderPassCreateInfo *base;
}
PyVkRenderPassCreateInfo;

typedef struct {
    PyObject_HEAD VkEventCreateInfo *base;
}
PyVkEventCreateInfo;

typedef struct {
    PyObject_HEAD VkFenceCreateInfo *base;
}
PyVkFenceCreateInfo;

typedef struct {
    PyObject_HEAD VkPhysicalDeviceFeatures *base;
}
PyVkPhysicalDeviceFeatures;

typedef struct {
    PyObject_HEAD VkPhysicalDeviceSparseProperties *base;
}
PyVkPhysicalDeviceSparseProperties;

typedef struct {
    PyObject_HEAD VkPhysicalDeviceLimits *base;
}
PyVkPhysicalDeviceLimits;

typedef struct {
    PyObject_HEAD VkSemaphoreCreateInfo *base;
}
PyVkSemaphoreCreateInfo;

typedef struct {
    PyObject_HEAD VkQueryPoolCreateInfo *base;
}
PyVkQueryPoolCreateInfo;

typedef struct {
    PyObject_HEAD VkFramebufferCreateInfo *base;
}
PyVkFramebufferCreateInfo;

typedef struct {
    PyObject_HEAD VkDrawIndirectCommand *base;
}
PyVkDrawIndirectCommand;

typedef struct {
    PyObject_HEAD VkDrawIndexedIndirectCommand *base;
}
PyVkDrawIndexedIndirectCommand;

typedef struct {
    PyObject_HEAD VkDispatchIndirectCommand *base;
}
PyVkDispatchIndirectCommand;

typedef struct {
    PyObject_HEAD VkSubmitInfo *base;
}
PyVkSubmitInfo;

typedef struct {
    PyObject_HEAD VkDisplayPropertiesKHR *base;
}
PyVkDisplayPropertiesKHR;

typedef struct {
    PyObject_HEAD VkDisplayPlanePropertiesKHR *base;
}
PyVkDisplayPlanePropertiesKHR;

typedef struct {
    PyObject_HEAD VkDisplayModeParametersKHR *base;
}
PyVkDisplayModeParametersKHR;

typedef struct {
    PyObject_HEAD VkDisplayModePropertiesKHR *base;
}
PyVkDisplayModePropertiesKHR;

typedef struct {
    PyObject_HEAD VkDisplayModeCreateInfoKHR *base;
}
PyVkDisplayModeCreateInfoKHR;

typedef struct {
    PyObject_HEAD VkDisplayPlaneCapabilitiesKHR *base;
}
PyVkDisplayPlaneCapabilitiesKHR;

typedef struct {
    PyObject_HEAD VkDisplaySurfaceCreateInfoKHR *base;
}
PyVkDisplaySurfaceCreateInfoKHR;

typedef struct {
    PyObject_HEAD VkDisplayPresentInfoKHR *base;
}
PyVkDisplayPresentInfoKHR;

typedef struct {
    PyObject_HEAD VkSurfaceCapabilitiesKHR *base;
}
PyVkSurfaceCapabilitiesKHR;

#ifdef VK_USE_PLATFORM_ANDROID_KHR

typedef struct {
    PyObject_HEAD VkAndroidSurfaceCreateInfoKHR *base;
}
PyVkAndroidSurfaceCreateInfoKHR;

#endif

#ifdef VK_USE_PLATFORM_MIR_KHR

typedef struct {
    PyObject_HEAD VkMirSurfaceCreateInfoKHR *base;
}
PyVkMirSurfaceCreateInfoKHR;

#endif

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

typedef struct {
    PyObject_HEAD VkWaylandSurfaceCreateInfoKHR *base;
}
PyVkWaylandSurfaceCreateInfoKHR;

#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

typedef struct {
    PyObject_HEAD VkWin32SurfaceCreateInfoKHR *base;
}
PyVkWin32SurfaceCreateInfoKHR;

#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR

typedef struct {
    PyObject_HEAD VkXlibSurfaceCreateInfoKHR *base;
}
PyVkXlibSurfaceCreateInfoKHR;

#endif

#ifdef VK_USE_PLATFORM_XCB_KHR

typedef struct {
    PyObject_HEAD VkXcbSurfaceCreateInfoKHR *base;
}
PyVkXcbSurfaceCreateInfoKHR;

#endif

typedef struct {
    PyObject_HEAD VkSurfaceFormatKHR *base;
}
PyVkSurfaceFormatKHR;

typedef struct {
    PyObject_HEAD VkSwapchainCreateInfoKHR *base;
}
PyVkSwapchainCreateInfoKHR;

typedef struct {
    PyObject_HEAD VkPresentInfoKHR *base;
}
PyVkPresentInfoKHR;

typedef struct {
    PyObject_HEAD VkDebugReportCallbackCreateInfoEXT *base;
}
PyVkDebugReportCallbackCreateInfoEXT;

typedef struct {
    PyObject_HEAD VkPipelineRasterizationStateRasterizationOrderAMD *base;
}
PyVkPipelineRasterizationStateRasterizationOrderAMD;

typedef struct {
    PyObject_HEAD VkDebugMarkerObjectNameInfoEXT *base;
}
PyVkDebugMarkerObjectNameInfoEXT;

typedef struct {
    PyObject_HEAD VkDebugMarkerObjectTagInfoEXT *base;
}
PyVkDebugMarkerObjectTagInfoEXT;

typedef struct {
    PyObject_HEAD VkDebugMarkerMarkerInfoEXT *base;
}
PyVkDebugMarkerMarkerInfoEXT;

typedef struct {
    PyObject_HEAD VkDedicatedAllocationImageCreateInfoNV *base;
}
PyVkDedicatedAllocationImageCreateInfoNV;

typedef struct {
    PyObject_HEAD VkDedicatedAllocationBufferCreateInfoNV *base;
}
PyVkDedicatedAllocationBufferCreateInfoNV;

typedef struct {
    PyObject_HEAD VkDedicatedAllocationMemoryAllocateInfoNV *base;
}
PyVkDedicatedAllocationMemoryAllocateInfoNV;

typedef struct {
    PyObject_HEAD VkExternalImageFormatPropertiesNV *base;
}
PyVkExternalImageFormatPropertiesNV;

typedef struct {
    PyObject_HEAD VkExternalMemoryImageCreateInfoNV *base;
}
PyVkExternalMemoryImageCreateInfoNV;

typedef struct {
    PyObject_HEAD VkExportMemoryAllocateInfoNV *base;
}
PyVkExportMemoryAllocateInfoNV;

#ifdef VK_USE_PLATFORM_WIN32_KHR

typedef struct {
    PyObject_HEAD VkImportMemoryWin32HandleInfoNV *base;
}
PyVkImportMemoryWin32HandleInfoNV;

#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

typedef struct {
    PyObject_HEAD VkExportMemoryWin32HandleInfoNV *base;
}
PyVkExportMemoryWin32HandleInfoNV;

#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

typedef struct {
    PyObject_HEAD VkWin32KeyedMutexAcquireReleaseInfoNV *base;
}
PyVkWin32KeyedMutexAcquireReleaseInfoNV;

#endif

typedef struct {
    PyObject_HEAD VkClearColorValue *base;
}
PyVkClearColorValue;

typedef struct {
    PyObject_HEAD VkClearValue *base;
}
PyVkClearValue;

static void PyVkOffset2D_del(PyVkOffset2D* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkOffset2D_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkOffset2D *self;
    self = (PyVkOffset2D *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkOffset2D));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkOffset2D");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkOffset2D_getx(PyVkOffset2D *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->x);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkOffset2D_gety(PyVkOffset2D *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->y);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkOffset2D_getsetters[] = {

    { "x", (getter)PyVkOffset2D_getx, NULL, "", NULL},

    { "y", (getter)PyVkOffset2D_gety, NULL, "", NULL},
    {NULL}
};

static int
PyVkOffset2D_init(PyVkOffset2D *self, PyObject *args, PyObject *kwds) {
    PyObject* x = NULL;
    PyObject* y = NULL;
    static char *kwlist[] = {"x","y",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &x, &y)) return -1;

    if (x != NULL && x != Py_None) {
        (self->base)->x = (int32_t) PyLong_AsLong(x);
    }

    if (y != NULL && y != Py_None) {
        (self->base)->y = (int32_t) PyLong_AsLong(y);
    }

    return 0;
}
static PyTypeObject PyVkOffset2DType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkOffset2D", sizeof(PyVkOffset2D), 0,
    (destructor)PyVkOffset2D_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkOffset2D object",0,0,0,0,0,0,0,0,
    PyVkOffset2D_getsetters,0,0,0,0,0,(initproc)PyVkOffset2D_init,0,PyVkOffset2D_new,
};

static void PyVkOffset3D_del(PyVkOffset3D* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkOffset3D_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkOffset3D *self;
    self = (PyVkOffset3D *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkOffset3D));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkOffset3D");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkOffset3D_getx(PyVkOffset3D *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->x);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkOffset3D_gety(PyVkOffset3D *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->y);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkOffset3D_getz(PyVkOffset3D *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->z);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkOffset3D_getsetters[] = {

    { "x", (getter)PyVkOffset3D_getx, NULL, "", NULL},

    { "y", (getter)PyVkOffset3D_gety, NULL, "", NULL},

    { "z", (getter)PyVkOffset3D_getz, NULL, "", NULL},
    {NULL}
};

static int
PyVkOffset3D_init(PyVkOffset3D *self, PyObject *args, PyObject *kwds) {
    PyObject* x = NULL;
    PyObject* y = NULL;
    PyObject* z = NULL;
    static char *kwlist[] = {"x","y","z",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &x, &y, &z)) return -1;

    if (x != NULL && x != Py_None) {
        (self->base)->x = (int32_t) PyLong_AsLong(x);
    }

    if (y != NULL && y != Py_None) {
        (self->base)->y = (int32_t) PyLong_AsLong(y);
    }

    if (z != NULL && z != Py_None) {
        (self->base)->z = (int32_t) PyLong_AsLong(z);
    }

    return 0;
}
static PyTypeObject PyVkOffset3DType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkOffset3D", sizeof(PyVkOffset3D), 0,
    (destructor)PyVkOffset3D_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkOffset3D object",0,0,0,0,0,0,0,0,
    PyVkOffset3D_getsetters,0,0,0,0,0,(initproc)PyVkOffset3D_init,0,PyVkOffset3D_new,
};

static void PyVkExtent2D_del(PyVkExtent2D* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkExtent2D_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkExtent2D *self;
    self = (PyVkExtent2D *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkExtent2D));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkExtent2D");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkExtent2D_getwidth(PyVkExtent2D *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->width);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkExtent2D_getheight(PyVkExtent2D *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->height);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkExtent2D_getsetters[] = {

    { "width", (getter)PyVkExtent2D_getwidth, NULL, "", NULL},

    { "height", (getter)PyVkExtent2D_getheight, NULL, "", NULL},
    {NULL}
};

static int
PyVkExtent2D_init(PyVkExtent2D *self, PyObject *args, PyObject *kwds) {
    PyObject* width = NULL;
    PyObject* height = NULL;
    static char *kwlist[] = {"width","height",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &width, &height)) return -1;

    if (width != NULL && width != Py_None) {
        (self->base)->width = (uint32_t) PyLong_AsLong(width);
    }

    if (height != NULL && height != Py_None) {
        (self->base)->height = (uint32_t) PyLong_AsLong(height);
    }

    return 0;
}
static PyTypeObject PyVkExtent2DType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkExtent2D", sizeof(PyVkExtent2D), 0,
    (destructor)PyVkExtent2D_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkExtent2D object",0,0,0,0,0,0,0,0,
    PyVkExtent2D_getsetters,0,0,0,0,0,(initproc)PyVkExtent2D_init,0,PyVkExtent2D_new,
};

static void PyVkExtent3D_del(PyVkExtent3D* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkExtent3D_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkExtent3D *self;
    self = (PyVkExtent3D *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkExtent3D));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkExtent3D");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkExtent3D_getwidth(PyVkExtent3D *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->width);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkExtent3D_getheight(PyVkExtent3D *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->height);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkExtent3D_getdepth(PyVkExtent3D *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->depth);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkExtent3D_getsetters[] = {

    { "width", (getter)PyVkExtent3D_getwidth, NULL, "", NULL},

    { "height", (getter)PyVkExtent3D_getheight, NULL, "", NULL},

    { "depth", (getter)PyVkExtent3D_getdepth, NULL, "", NULL},
    {NULL}
};

static int
PyVkExtent3D_init(PyVkExtent3D *self, PyObject *args, PyObject *kwds) {
    PyObject* width = NULL;
    PyObject* height = NULL;
    PyObject* depth = NULL;
    static char *kwlist[] = {"width","height","depth",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &width, &height, &depth)) return -1;

    if (width != NULL && width != Py_None) {
        (self->base)->width = (uint32_t) PyLong_AsLong(width);
    }

    if (height != NULL && height != Py_None) {
        (self->base)->height = (uint32_t) PyLong_AsLong(height);
    }

    if (depth != NULL && depth != Py_None) {
        (self->base)->depth = (uint32_t) PyLong_AsLong(depth);
    }

    return 0;
}
static PyTypeObject PyVkExtent3DType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkExtent3D", sizeof(PyVkExtent3D), 0,
    (destructor)PyVkExtent3D_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkExtent3D object",0,0,0,0,0,0,0,0,
    PyVkExtent3D_getsetters,0,0,0,0,0,(initproc)PyVkExtent3D_init,0,PyVkExtent3D_new,
};

static void PyVkViewport_del(PyVkViewport* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkViewport_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkViewport *self;
    self = (PyVkViewport *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkViewport));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkViewport");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkViewport_getx(PyVkViewport *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->x);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkViewport_gety(PyVkViewport *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->y);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkViewport_getwidth(PyVkViewport *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->width);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkViewport_getheight(PyVkViewport *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->height);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkViewport_getminDepth(PyVkViewport *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->minDepth);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkViewport_getmaxDepth(PyVkViewport *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->maxDepth);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkViewport_getsetters[] = {

    { "x", (getter)PyVkViewport_getx, NULL, "", NULL},

    { "y", (getter)PyVkViewport_gety, NULL, "", NULL},

    { "width", (getter)PyVkViewport_getwidth, NULL, "", NULL},

    { "height", (getter)PyVkViewport_getheight, NULL, "", NULL},

    { "minDepth", (getter)PyVkViewport_getminDepth, NULL, "", NULL},

    { "maxDepth", (getter)PyVkViewport_getmaxDepth, NULL, "", NULL},
    {NULL}
};

static int
PyVkViewport_init(PyVkViewport *self, PyObject *args, PyObject *kwds) {
    PyObject* x = NULL;
    PyObject* y = NULL;
    PyObject* width = NULL;
    PyObject* height = NULL;
    PyObject* minDepth = NULL;
    PyObject* maxDepth = NULL;
    static char *kwlist[] = {"x","y","width","height","minDepth","maxDepth",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &x, &y, &width, &height, &minDepth, &maxDepth)) return -1;

    if (x != NULL && x != Py_None) {
        (self->base)->x = (float) PyFloat_AsDouble(x);
    }

    if (y != NULL && y != Py_None) {
        (self->base)->y = (float) PyFloat_AsDouble(y);
    }

    if (width != NULL && width != Py_None) {
        (self->base)->width = (float) PyFloat_AsDouble(width);
    }

    if (height != NULL && height != Py_None) {
        (self->base)->height = (float) PyFloat_AsDouble(height);
    }

    if (minDepth != NULL && minDepth != Py_None) {
        (self->base)->minDepth = (float) PyFloat_AsDouble(minDepth);
    }

    if (maxDepth != NULL && maxDepth != Py_None) {
        (self->base)->maxDepth = (float) PyFloat_AsDouble(maxDepth);
    }

    return 0;
}
static PyTypeObject PyVkViewportType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkViewport", sizeof(PyVkViewport), 0,
    (destructor)PyVkViewport_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkViewport object",0,0,0,0,0,0,0,0,
    PyVkViewport_getsetters,0,0,0,0,0,(initproc)PyVkViewport_init,0,PyVkViewport_new,
};

static void PyVkRect2D_del(PyVkRect2D* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkRect2D_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkRect2D *self;
    self = (PyVkRect2D *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkRect2D));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkRect2D");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkRect2D_getsetters[] = {
    {NULL}
};

static int
PyVkRect2D_init(PyVkRect2D *self, PyObject *args, PyObject *kwds) {
    PyObject* offset = NULL;
    PyObject* extent = NULL;
    static char *kwlist[] = {"offset","extent",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &offset, &extent)) return -1;

    if (offset != NULL && offset != Py_None) {

        (self->base)->offset = *(((PyVkOffset2D*)offset)->base);

    }

    if (extent != NULL && extent != Py_None) {

        (self->base)->extent = *(((PyVkExtent2D*)extent)->base);

    }

    return 0;
}
static PyTypeObject PyVkRect2DType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkRect2D", sizeof(PyVkRect2D), 0,
    (destructor)PyVkRect2D_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkRect2D object",0,0,0,0,0,0,0,0,
    PyVkRect2D_getsetters,0,0,0,0,0,(initproc)PyVkRect2D_init,0,PyVkRect2D_new,
};

#ifdef hackdefine

static void PyVkRect3D_del(PyVkRect3D* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkRect3D_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkRect3D *self;
    self = (PyVkRect3D *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkRect3D));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkRect3D");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkRect3D_getsetters[] = {
    {NULL}
};

static int
PyVkRect3D_init(PyVkRect3D *self, PyObject *args, PyObject *kwds) {
    PyObject* offset = NULL;
    PyObject* extent = NULL;
    static char *kwlist[] = {"offset","extent",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &offset, &extent)) return -1;

    if (offset != NULL && offset != Py_None) {

        (self->base)->offset = *(((PyVkOffset3D*)offset)->base);

    }

    if (extent != NULL && extent != Py_None) {

        (self->base)->extent = *(((PyVkExtent3D*)extent)->base);

    }

    return 0;
}
static PyTypeObject PyVkRect3DType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkRect3D", sizeof(PyVkRect3D), 0,
    (destructor)PyVkRect3D_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkRect3D object",0,0,0,0,0,0,0,0,
    PyVkRect3D_getsetters,0,0,0,0,0,(initproc)PyVkRect3D_init,0,PyVkRect3D_new,
};

#endif

static void PyVkClearRect_del(PyVkClearRect* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkClearRect_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkClearRect *self;
    self = (PyVkClearRect *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkClearRect));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkClearRect");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkClearRect_getbaseArrayLayer(PyVkClearRect *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->baseArrayLayer);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkClearRect_getlayerCount(PyVkClearRect *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->layerCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkClearRect_getsetters[] = {

    { "baseArrayLayer", (getter)PyVkClearRect_getbaseArrayLayer, NULL, "", NULL},

    { "layerCount", (getter)PyVkClearRect_getlayerCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkClearRect_init(PyVkClearRect *self, PyObject *args, PyObject *kwds) {
    PyObject* rect = NULL;
    PyObject* baseArrayLayer = NULL;
    PyObject* layerCount = NULL;
    static char *kwlist[] = {"rect","baseArrayLayer","layerCount",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &rect, &baseArrayLayer, &layerCount)) return -1;

    if (rect != NULL && rect != Py_None) {

        (self->base)->rect = *(((PyVkRect2D*)rect)->base);

    }

    if (baseArrayLayer != NULL && baseArrayLayer != Py_None) {
        (self->base)->baseArrayLayer = (uint32_t) PyLong_AsLong(baseArrayLayer);
    }

    if (layerCount != NULL && layerCount != Py_None) {
        (self->base)->layerCount = (uint32_t) PyLong_AsLong(layerCount);
    }

    return 0;
}
static PyTypeObject PyVkClearRectType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkClearRect", sizeof(PyVkClearRect), 0,
    (destructor)PyVkClearRect_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkClearRect object",0,0,0,0,0,0,0,0,
    PyVkClearRect_getsetters,0,0,0,0,0,(initproc)PyVkClearRect_init,0,PyVkClearRect_new,
};

static void PyVkComponentMapping_del(PyVkComponentMapping* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkComponentMapping_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkComponentMapping *self;
    self = (PyVkComponentMapping *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkComponentMapping));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkComponentMapping");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkComponentMapping_getsetters[] = {
    {NULL}
};

static int
PyVkComponentMapping_init(PyVkComponentMapping *self, PyObject *args, PyObject *kwds) {
    PyObject* r = NULL;
    PyObject* g = NULL;
    PyObject* b = NULL;
    PyObject* a = NULL;
    static char *kwlist[] = {"r","g","b","a",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &r, &g, &b, &a)) return -1;

    if (r != NULL && r != Py_None) {

        (self->base)->r = PyLong_AsLong(r);

    }

    if (g != NULL && g != Py_None) {

        (self->base)->g = PyLong_AsLong(g);

    }

    if (b != NULL && b != Py_None) {

        (self->base)->b = PyLong_AsLong(b);

    }

    if (a != NULL && a != Py_None) {

        (self->base)->a = PyLong_AsLong(a);

    }

    return 0;
}
static PyTypeObject PyVkComponentMappingType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkComponentMapping", sizeof(PyVkComponentMapping), 0,
    (destructor)PyVkComponentMapping_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkComponentMapping object",0,0,0,0,0,0,0,0,
    PyVkComponentMapping_getsetters,0,0,0,0,0,(initproc)PyVkComponentMapping_init,0,PyVkComponentMapping_new,
};

static void PyVkPhysicalDeviceProperties_del(PyVkPhysicalDeviceProperties* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPhysicalDeviceProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPhysicalDeviceProperties *self;
    self = (PyVkPhysicalDeviceProperties *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPhysicalDeviceProperties));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPhysicalDeviceProperties");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkPhysicalDeviceProperties_getapiVersion(PyVkPhysicalDeviceProperties *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->apiVersion);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceProperties_getdriverVersion(PyVkPhysicalDeviceProperties *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->driverVersion);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceProperties_getvendorID(PyVkPhysicalDeviceProperties *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->vendorID);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceProperties_getdeviceID(PyVkPhysicalDeviceProperties *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->deviceID);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceProperties_getdeviceName(PyVkPhysicalDeviceProperties *self, void *closure) {
    PyObject* value = PyUnicode_FromString((const char *) (self->base)->deviceName);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceProperties_getpipelineCacheUUID(PyVkPhysicalDeviceProperties *self, void *closure) {

    PyObject* value = PyList_New(0);
    int nb = sizeof((self->base)->pipelineCacheUUID) / sizeof((self->base)->pipelineCacheUUID[0]);
    int i = 0;
    for (i = 0; i < nb; i++) {
        PyObject* py_tmp = PyLong_FromLong((long) (self->base)->pipelineCacheUUID[i]);
        PyList_Append(value, py_tmp);
    }

    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkPhysicalDeviceProperties_getsetters[] = {

    { "apiVersion", (getter)PyVkPhysicalDeviceProperties_getapiVersion, NULL, "", NULL},

    { "driverVersion", (getter)PyVkPhysicalDeviceProperties_getdriverVersion, NULL, "", NULL},

    { "vendorID", (getter)PyVkPhysicalDeviceProperties_getvendorID, NULL, "", NULL},

    { "deviceID", (getter)PyVkPhysicalDeviceProperties_getdeviceID, NULL, "", NULL},

    { "deviceName", (getter)PyVkPhysicalDeviceProperties_getdeviceName, NULL, "", NULL},

    { "pipelineCacheUUID", (getter)PyVkPhysicalDeviceProperties_getpipelineCacheUUID, NULL, "", NULL},
    {NULL}
};

static int
PyVkPhysicalDeviceProperties_init(PyVkPhysicalDeviceProperties *self, PyObject *args, PyObject *kwds) {
    return 0;
}
static PyTypeObject PyVkPhysicalDevicePropertiesType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPhysicalDeviceProperties", sizeof(PyVkPhysicalDeviceProperties), 0,
    (destructor)PyVkPhysicalDeviceProperties_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPhysicalDeviceProperties object",0,0,0,0,0,0,0,0,
    PyVkPhysicalDeviceProperties_getsetters,0,0,0,0,0,(initproc)PyVkPhysicalDeviceProperties_init,0,PyVkPhysicalDeviceProperties_new,
};

static void PyVkExtensionProperties_del(PyVkExtensionProperties* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkExtensionProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkExtensionProperties *self;
    self = (PyVkExtensionProperties *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkExtensionProperties));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkExtensionProperties");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkExtensionProperties_getextensionName(PyVkExtensionProperties *self, void *closure) {
    PyObject* value = PyUnicode_FromString((const char *) (self->base)->extensionName);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkExtensionProperties_getspecVersion(PyVkExtensionProperties *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->specVersion);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkExtensionProperties_getsetters[] = {

    { "extensionName", (getter)PyVkExtensionProperties_getextensionName, NULL, "", NULL},

    { "specVersion", (getter)PyVkExtensionProperties_getspecVersion, NULL, "", NULL},
    {NULL}
};

static int
PyVkExtensionProperties_init(PyVkExtensionProperties *self, PyObject *args, PyObject *kwds) {
    return 0;
}
static PyTypeObject PyVkExtensionPropertiesType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkExtensionProperties", sizeof(PyVkExtensionProperties), 0,
    (destructor)PyVkExtensionProperties_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkExtensionProperties object",0,0,0,0,0,0,0,0,
    PyVkExtensionProperties_getsetters,0,0,0,0,0,(initproc)PyVkExtensionProperties_init,0,PyVkExtensionProperties_new,
};

static void PyVkLayerProperties_del(PyVkLayerProperties* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkLayerProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkLayerProperties *self;
    self = (PyVkLayerProperties *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkLayerProperties));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkLayerProperties");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkLayerProperties_getlayerName(PyVkLayerProperties *self, void *closure) {
    PyObject* value = PyUnicode_FromString((const char *) (self->base)->layerName);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkLayerProperties_getspecVersion(PyVkLayerProperties *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->specVersion);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkLayerProperties_getimplementationVersion(PyVkLayerProperties *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->implementationVersion);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkLayerProperties_getdescription(PyVkLayerProperties *self, void *closure) {
    PyObject* value = PyUnicode_FromString((const char *) (self->base)->description);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkLayerProperties_getsetters[] = {

    { "layerName", (getter)PyVkLayerProperties_getlayerName, NULL, "", NULL},

    { "specVersion", (getter)PyVkLayerProperties_getspecVersion, NULL, "", NULL},

    { "implementationVersion", (getter)PyVkLayerProperties_getimplementationVersion, NULL, "", NULL},

    { "description", (getter)PyVkLayerProperties_getdescription, NULL, "", NULL},
    {NULL}
};

static int
PyVkLayerProperties_init(PyVkLayerProperties *self, PyObject *args, PyObject *kwds) {
    return 0;
}
static PyTypeObject PyVkLayerPropertiesType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkLayerProperties", sizeof(PyVkLayerProperties), 0,
    (destructor)PyVkLayerProperties_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkLayerProperties object",0,0,0,0,0,0,0,0,
    PyVkLayerProperties_getsetters,0,0,0,0,0,(initproc)PyVkLayerProperties_init,0,PyVkLayerProperties_new,
};

static void PyVkApplicationInfo_del(PyVkApplicationInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkApplicationInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkApplicationInfo *self;
    self = (PyVkApplicationInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkApplicationInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkApplicationInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkApplicationInfo_getpNext(PyVkApplicationInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkApplicationInfo_getpApplicationName(PyVkApplicationInfo *self, void *closure) {
    PyObject* value = PyUnicode_FromString((const char *) (self->base)->pApplicationName);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkApplicationInfo_getapplicationVersion(PyVkApplicationInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->applicationVersion);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkApplicationInfo_getpEngineName(PyVkApplicationInfo *self, void *closure) {
    PyObject* value = PyUnicode_FromString((const char *) (self->base)->pEngineName);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkApplicationInfo_getengineVersion(PyVkApplicationInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->engineVersion);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkApplicationInfo_getapiVersion(PyVkApplicationInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->apiVersion);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkApplicationInfo_getsetters[] = {

    { "pNext", (getter)PyVkApplicationInfo_getpNext, NULL, "", NULL},

    { "pApplicationName", (getter)PyVkApplicationInfo_getpApplicationName, NULL, "", NULL},

    { "applicationVersion", (getter)PyVkApplicationInfo_getapplicationVersion, NULL, "", NULL},

    { "pEngineName", (getter)PyVkApplicationInfo_getpEngineName, NULL, "", NULL},

    { "engineVersion", (getter)PyVkApplicationInfo_getengineVersion, NULL, "", NULL},

    { "apiVersion", (getter)PyVkApplicationInfo_getapiVersion, NULL, "", NULL},
    {NULL}
};

static int
PyVkApplicationInfo_init(PyVkApplicationInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* pApplicationName = NULL;
    PyObject* applicationVersion = NULL;
    PyObject* pEngineName = NULL;
    PyObject* engineVersion = NULL;
    PyObject* apiVersion = NULL;
    static char *kwlist[] = {"pApplicationName","applicationVersion","pEngineName","engineVersion","apiVersion",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &pApplicationName, &applicationVersion, &pEngineName, &engineVersion, &apiVersion)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;

    (self->base)->pNext = NULL;

    if (pApplicationName != NULL && pApplicationName != Py_None) {

        if (pApplicationName == Py_None) {
            (self->base)->pApplicationName = NULL;
        }
        else {
            PyObject * tmp90551415 = PyUnicode_AsASCIIString(pApplicationName);
            char* tmp66798238 = PyBytes_AsString(tmp90551415);
            char* tmp36296972 = strdup(tmp66798238);
            (self->base)->pApplicationName = tmp36296972;
            Py_DECREF(tmp90551415);
        }

    }

    if (applicationVersion != NULL && applicationVersion != Py_None) {
        (self->base)->applicationVersion = (uint32_t) PyLong_AsLong(applicationVersion);
    }

    if (pEngineName != NULL && pEngineName != Py_None) {

        if (pEngineName == Py_None) {
            (self->base)->pEngineName = NULL;
        }
        else {
            PyObject * tmp46425684 = PyUnicode_AsASCIIString(pEngineName);
            char* tmp7716771 = PyBytes_AsString(tmp46425684);
            char* tmp65964636 = strdup(tmp7716771);
            (self->base)->pEngineName = tmp65964636;
            Py_DECREF(tmp46425684);
        }

    }

    if (engineVersion != NULL && engineVersion != Py_None) {
        (self->base)->engineVersion = (uint32_t) PyLong_AsLong(engineVersion);
    }

    if (apiVersion != NULL && apiVersion != Py_None) {
        (self->base)->apiVersion = (uint32_t) PyLong_AsLong(apiVersion);
    }

    return 0;
}
static PyTypeObject PyVkApplicationInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkApplicationInfo", sizeof(PyVkApplicationInfo), 0,
    (destructor)PyVkApplicationInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkApplicationInfo object",0,0,0,0,0,0,0,0,
    PyVkApplicationInfo_getsetters,0,0,0,0,0,(initproc)PyVkApplicationInfo_init,0,PyVkApplicationInfo_new,
};

static void PyVkAllocationCallbacks_del(PyVkAllocationCallbacks* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkAllocationCallbacks_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkAllocationCallbacks *self;
    self = (PyVkAllocationCallbacks *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkAllocationCallbacks));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkAllocationCallbacks");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkAllocationCallbacks_getpUserData(PyVkAllocationCallbacks *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkAllocationCallbacks_getsetters[] = {

    { "pUserData", (getter)PyVkAllocationCallbacks_getpUserData, NULL, "", NULL},
    {NULL}
};

static int
PyVkAllocationCallbacks_init(PyVkAllocationCallbacks *self, PyObject *args, PyObject *kwds) {
    PyObject* pUserData = NULL;
    PyObject* pfnAllocation = NULL;
    PyObject* pfnReallocation = NULL;
    PyObject* pfnFree = NULL;
    PyObject* pfnInternalAllocation = NULL;
    PyObject* pfnInternalFree = NULL;
    static char *kwlist[] = {"pUserData","pfnAllocation","pfnReallocation","pfnFree","pfnInternalAllocation","pfnInternalFree",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &pUserData, &pfnAllocation, &pfnReallocation, &pfnFree, &pfnInternalAllocation, &pfnInternalFree)) return -1;

    if (pUserData != NULL && pUserData != Py_None) {
        (self->base)->pUserData = NULL;
    }

    return 0;
}
static PyTypeObject PyVkAllocationCallbacksType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkAllocationCallbacks", sizeof(PyVkAllocationCallbacks), 0,
    (destructor)PyVkAllocationCallbacks_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkAllocationCallbacks object",0,0,0,0,0,0,0,0,
    PyVkAllocationCallbacks_getsetters,0,0,0,0,0,(initproc)PyVkAllocationCallbacks_init,0,PyVkAllocationCallbacks_new,
};

static void PyVkDeviceQueueCreateInfo_del(PyVkDeviceQueueCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDeviceQueueCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDeviceQueueCreateInfo *self;
    self = (PyVkDeviceQueueCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDeviceQueueCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDeviceQueueCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDeviceQueueCreateInfo_getpNext(PyVkDeviceQueueCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDeviceQueueCreateInfo_getqueueFamilyIndex(PyVkDeviceQueueCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->queueFamilyIndex);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDeviceQueueCreateInfo_getqueueCount(PyVkDeviceQueueCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->queueCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDeviceQueueCreateInfo_getpQueuePriorities(PyVkDeviceQueueCreateInfo *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (*((self->base)->pQueuePriorities)));
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDeviceQueueCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkDeviceQueueCreateInfo_getpNext, NULL, "", NULL},

    { "queueFamilyIndex", (getter)PyVkDeviceQueueCreateInfo_getqueueFamilyIndex, NULL, "", NULL},

    { "queueCount", (getter)PyVkDeviceQueueCreateInfo_getqueueCount, NULL, "", NULL},

    { "pQueuePriorities", (getter)PyVkDeviceQueueCreateInfo_getpQueuePriorities, NULL, "", NULL},
    {NULL}
};

static int
PyVkDeviceQueueCreateInfo_init(PyVkDeviceQueueCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* queueFamilyIndex = NULL;
    PyObject* queueCount = NULL;
    PyObject* pQueuePriorities = NULL;
    static char *kwlist[] = {"flags","queueFamilyIndex","queueCount","pQueuePriorities",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &flags, &queueFamilyIndex, &queueCount, &pQueuePriorities)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (queueFamilyIndex != NULL && queueFamilyIndex != Py_None) {
        (self->base)->queueFamilyIndex = (uint32_t) PyLong_AsLong(queueFamilyIndex);
    }

    if (queueCount != NULL && queueCount != Py_None) {
        (self->base)->queueCount = (uint32_t) PyLong_AsLong(queueCount);
    }

    if (pQueuePriorities != NULL && pQueuePriorities != Py_None) {

        float tmp4763885 = (float) PyFloat_AsDouble(pQueuePriorities);
        float *tmp40084798 = malloc(sizeof(float));
        memcpy(tmp40084798, &tmp4763885, sizeof(float));
        (self->base)->pQueuePriorities = tmp40084798;

    }

    return 0;
}
static PyTypeObject PyVkDeviceQueueCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDeviceQueueCreateInfo", sizeof(PyVkDeviceQueueCreateInfo), 0,
    (destructor)PyVkDeviceQueueCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDeviceQueueCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkDeviceQueueCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkDeviceQueueCreateInfo_init,0,PyVkDeviceQueueCreateInfo_new,
};

static void PyVkDeviceCreateInfo_del(PyVkDeviceCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDeviceCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDeviceCreateInfo *self;
    self = (PyVkDeviceCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDeviceCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDeviceCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDeviceCreateInfo_getpNext(PyVkDeviceCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDeviceCreateInfo_getqueueCreateInfoCount(PyVkDeviceCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->queueCreateInfoCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDeviceCreateInfo_getenabledLayerCount(PyVkDeviceCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->enabledLayerCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDeviceCreateInfo_getppEnabledLayerNames(PyVkDeviceCreateInfo *self, void *closure) {

    if ((self->base)->ppEnabledLayerNames[0] == NULL) return PyList_New(0);;
    PyObject* value = PyList_New(0);
    int i = 0;
    while ((self->base)->ppEnabledLayerNames[i] != NULL) {
        PyObject* py_tmp = PyUnicode_FromString((const char *) (self->base)->ppEnabledLayerNames[i]);
        PyList_Append(value, py_tmp);
        i++;
    }

    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDeviceCreateInfo_getenabledExtensionCount(PyVkDeviceCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->enabledExtensionCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDeviceCreateInfo_getppEnabledExtensionNames(PyVkDeviceCreateInfo *self, void *closure) {

    if ((self->base)->ppEnabledExtensionNames[0] == NULL) return PyList_New(0);;
    PyObject* value = PyList_New(0);
    int i = 0;
    while ((self->base)->ppEnabledExtensionNames[i] != NULL) {
        PyObject* py_tmp = PyUnicode_FromString((const char *) (self->base)->ppEnabledExtensionNames[i]);
        PyList_Append(value, py_tmp);
        i++;
    }

    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDeviceCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkDeviceCreateInfo_getpNext, NULL, "", NULL},

    { "queueCreateInfoCount", (getter)PyVkDeviceCreateInfo_getqueueCreateInfoCount, NULL, "", NULL},

    { "enabledLayerCount", (getter)PyVkDeviceCreateInfo_getenabledLayerCount, NULL, "", NULL},

    { "ppEnabledLayerNames", (getter)PyVkDeviceCreateInfo_getppEnabledLayerNames, NULL, "", NULL},

    { "enabledExtensionCount", (getter)PyVkDeviceCreateInfo_getenabledExtensionCount, NULL, "", NULL},

    { "ppEnabledExtensionNames", (getter)PyVkDeviceCreateInfo_getppEnabledExtensionNames, NULL, "", NULL},
    {NULL}
};

static int
PyVkDeviceCreateInfo_init(PyVkDeviceCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* queueCreateInfoCount = NULL;
    PyObject* pQueueCreateInfos = NULL;
    PyObject* enabledLayerCount = NULL;
    PyObject* ppEnabledLayerNames = NULL;
    PyObject* enabledExtensionCount = NULL;
    PyObject* ppEnabledExtensionNames = NULL;
    PyObject* pEnabledFeatures = NULL;
    static char *kwlist[] = {"flags","queueCreateInfoCount","pQueueCreateInfos","enabledLayerCount","ppEnabledLayerNames","enabledExtensionCount","ppEnabledExtensionNames","pEnabledFeatures",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOO", kwlist, &flags, &queueCreateInfoCount, &pQueueCreateInfos, &enabledLayerCount, &ppEnabledLayerNames, &enabledExtensionCount, &ppEnabledExtensionNames, &pEnabledFeatures)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (queueCreateInfoCount != NULL && queueCreateInfoCount != Py_None) {
        (self->base)->queueCreateInfoCount = (uint32_t) PyLong_AsLong(queueCreateInfoCount);
    }

    if (pQueueCreateInfos != NULL && pQueueCreateInfos != Py_None) {

        (self->base)->pQueueCreateInfos = (((PyVkDeviceQueueCreateInfo*)pQueueCreateInfos)->base);

    }

    if (enabledLayerCount != NULL && enabledLayerCount != Py_None) {
        (self->base)->enabledLayerCount = (uint32_t) PyLong_AsLong(enabledLayerCount);
    }

    if (ppEnabledLayerNames != NULL && ppEnabledLayerNames != Py_None) {

        int tmp94857523 = PyList_Size(ppEnabledLayerNames);
        char** tmp3004203 = malloc(sizeof(char*)*tmp94857523 + 1);
        int tmp58617383;
        for (tmp58617383 = 0; tmp58617383 < tmp94857523; tmp58617383++) {
            PyObject* item = PyList_GetItem(ppEnabledLayerNames, tmp58617383);
            if (item == NULL) return -1;

            PyObject* ascii_str = PyUnicode_AsASCIIString(item);
            if (ascii_str == NULL) {
                PyErr_SetString(PyExc_TypeError,
                                "ppEnabledLayerNames must be a list of strings");
                return -1;
            }

            char* tmp2 = PyBytes_AsString(ascii_str);
            tmp3004203[tmp58617383] = strdup(tmp2);
            Py_DECREF(ascii_str);
        }
        tmp3004203[tmp58617383] = NULL; // sentinel
        (self->base)->ppEnabledLayerNames = tmp3004203;

    }

    if (enabledExtensionCount != NULL && enabledExtensionCount != Py_None) {
        (self->base)->enabledExtensionCount = (uint32_t) PyLong_AsLong(enabledExtensionCount);
    }

    if (ppEnabledExtensionNames != NULL && ppEnabledExtensionNames != Py_None) {

        int tmp61425785 = PyList_Size(ppEnabledExtensionNames);
        char** tmp6412378 = malloc(sizeof(char*)*tmp61425785 + 1);
        int tmp83079736;
        for (tmp83079736 = 0; tmp83079736 < tmp61425785; tmp83079736++) {
            PyObject* item = PyList_GetItem(ppEnabledExtensionNames, tmp83079736);
            if (item == NULL) return -1;

            PyObject* ascii_str = PyUnicode_AsASCIIString(item);
            if (ascii_str == NULL) {
                PyErr_SetString(PyExc_TypeError,
                                "ppEnabledExtensionNames must be a list of strings");
                return -1;
            }

            char* tmp2 = PyBytes_AsString(ascii_str);
            tmp6412378[tmp83079736] = strdup(tmp2);
            Py_DECREF(ascii_str);
        }
        tmp6412378[tmp83079736] = NULL; // sentinel
        (self->base)->ppEnabledExtensionNames = tmp6412378;

    }

    if (pEnabledFeatures != NULL && pEnabledFeatures != Py_None) {

        (self->base)->pEnabledFeatures = (((PyVkPhysicalDeviceFeatures*)pEnabledFeatures)->base);

    }

    return 0;
}
static PyTypeObject PyVkDeviceCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDeviceCreateInfo", sizeof(PyVkDeviceCreateInfo), 0,
    (destructor)PyVkDeviceCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDeviceCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkDeviceCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkDeviceCreateInfo_init,0,PyVkDeviceCreateInfo_new,
};

static void PyVkInstanceCreateInfo_del(PyVkInstanceCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkInstanceCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkInstanceCreateInfo *self;
    self = (PyVkInstanceCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkInstanceCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkInstanceCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkInstanceCreateInfo_getpNext(PyVkInstanceCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkInstanceCreateInfo_getenabledLayerCount(PyVkInstanceCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->enabledLayerCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkInstanceCreateInfo_getppEnabledLayerNames(PyVkInstanceCreateInfo *self, void *closure) {

    if ((self->base)->ppEnabledLayerNames[0] == NULL) return PyList_New(0);;
    PyObject* value = PyList_New(0);
    int i = 0;
    while ((self->base)->ppEnabledLayerNames[i] != NULL) {
        PyObject* py_tmp = PyUnicode_FromString((const char *) (self->base)->ppEnabledLayerNames[i]);
        PyList_Append(value, py_tmp);
        i++;
    }

    Py_INCREF(value);
    return value;
}

static PyObject * PyVkInstanceCreateInfo_getenabledExtensionCount(PyVkInstanceCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->enabledExtensionCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkInstanceCreateInfo_getppEnabledExtensionNames(PyVkInstanceCreateInfo *self, void *closure) {

    if ((self->base)->ppEnabledExtensionNames[0] == NULL) return PyList_New(0);;
    PyObject* value = PyList_New(0);
    int i = 0;
    while ((self->base)->ppEnabledExtensionNames[i] != NULL) {
        PyObject* py_tmp = PyUnicode_FromString((const char *) (self->base)->ppEnabledExtensionNames[i]);
        PyList_Append(value, py_tmp);
        i++;
    }

    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkInstanceCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkInstanceCreateInfo_getpNext, NULL, "", NULL},

    { "enabledLayerCount", (getter)PyVkInstanceCreateInfo_getenabledLayerCount, NULL, "", NULL},

    { "ppEnabledLayerNames", (getter)PyVkInstanceCreateInfo_getppEnabledLayerNames, NULL, "", NULL},

    { "enabledExtensionCount", (getter)PyVkInstanceCreateInfo_getenabledExtensionCount, NULL, "", NULL},

    { "ppEnabledExtensionNames", (getter)PyVkInstanceCreateInfo_getppEnabledExtensionNames, NULL, "", NULL},
    {NULL}
};

static int
PyVkInstanceCreateInfo_init(PyVkInstanceCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* pApplicationInfo = NULL;
    PyObject* enabledLayerCount = NULL;
    PyObject* ppEnabledLayerNames = NULL;
    PyObject* enabledExtensionCount = NULL;
    PyObject* ppEnabledExtensionNames = NULL;
    static char *kwlist[] = {"flags","pApplicationInfo","enabledLayerCount","ppEnabledLayerNames","enabledExtensionCount","ppEnabledExtensionNames",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &flags, &pApplicationInfo, &enabledLayerCount, &ppEnabledLayerNames, &enabledExtensionCount, &ppEnabledExtensionNames)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (pApplicationInfo != NULL && pApplicationInfo != Py_None) {

        (self->base)->pApplicationInfo = (((PyVkApplicationInfo*)pApplicationInfo)->base);

    }

    if (enabledLayerCount != NULL && enabledLayerCount != Py_None) {
        (self->base)->enabledLayerCount = (uint32_t) PyLong_AsLong(enabledLayerCount);
    }

    if (ppEnabledLayerNames != NULL && ppEnabledLayerNames != Py_None) {

        int tmp82361287 = PyList_Size(ppEnabledLayerNames);
        char** tmp80888468 = malloc(sizeof(char*)*tmp82361287 + 1);
        int tmp83817773;
        for (tmp83817773 = 0; tmp83817773 < tmp82361287; tmp83817773++) {
            PyObject* item = PyList_GetItem(ppEnabledLayerNames, tmp83817773);
            if (item == NULL) return -1;

            PyObject* ascii_str = PyUnicode_AsASCIIString(item);
            if (ascii_str == NULL) {
                PyErr_SetString(PyExc_TypeError,
                                "ppEnabledLayerNames must be a list of strings");
                return -1;
            }

            char* tmp2 = PyBytes_AsString(ascii_str);
            tmp80888468[tmp83817773] = strdup(tmp2);
            Py_DECREF(ascii_str);
        }
        tmp80888468[tmp83817773] = NULL; // sentinel
        (self->base)->ppEnabledLayerNames = tmp80888468;

    }

    if (enabledExtensionCount != NULL && enabledExtensionCount != Py_None) {
        (self->base)->enabledExtensionCount = (uint32_t) PyLong_AsLong(enabledExtensionCount);
    }

    if (ppEnabledExtensionNames != NULL && ppEnabledExtensionNames != Py_None) {

        int tmp63632281 = PyList_Size(ppEnabledExtensionNames);
        char** tmp38803825 = malloc(sizeof(char*)*tmp63632281 + 1);
        int tmp22236496;
        for (tmp22236496 = 0; tmp22236496 < tmp63632281; tmp22236496++) {
            PyObject* item = PyList_GetItem(ppEnabledExtensionNames, tmp22236496);
            if (item == NULL) return -1;

            PyObject* ascii_str = PyUnicode_AsASCIIString(item);
            if (ascii_str == NULL) {
                PyErr_SetString(PyExc_TypeError,
                                "ppEnabledExtensionNames must be a list of strings");
                return -1;
            }

            char* tmp2 = PyBytes_AsString(ascii_str);
            tmp38803825[tmp22236496] = strdup(tmp2);
            Py_DECREF(ascii_str);
        }
        tmp38803825[tmp22236496] = NULL; // sentinel
        (self->base)->ppEnabledExtensionNames = tmp38803825;

    }

    return 0;
}
static PyTypeObject PyVkInstanceCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkInstanceCreateInfo", sizeof(PyVkInstanceCreateInfo), 0,
    (destructor)PyVkInstanceCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkInstanceCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkInstanceCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkInstanceCreateInfo_init,0,PyVkInstanceCreateInfo_new,
};

static void PyVkQueueFamilyProperties_del(PyVkQueueFamilyProperties* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkQueueFamilyProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkQueueFamilyProperties *self;
    self = (PyVkQueueFamilyProperties *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkQueueFamilyProperties));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkQueueFamilyProperties");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkQueueFamilyProperties_getqueueCount(PyVkQueueFamilyProperties *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->queueCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkQueueFamilyProperties_gettimestampValidBits(PyVkQueueFamilyProperties *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->timestampValidBits);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkQueueFamilyProperties_getsetters[] = {

    { "queueCount", (getter)PyVkQueueFamilyProperties_getqueueCount, NULL, "", NULL},

    { "timestampValidBits", (getter)PyVkQueueFamilyProperties_gettimestampValidBits, NULL, "", NULL},
    {NULL}
};

static int
PyVkQueueFamilyProperties_init(PyVkQueueFamilyProperties *self, PyObject *args, PyObject *kwds) {
    return 0;
}
static PyTypeObject PyVkQueueFamilyPropertiesType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkQueueFamilyProperties", sizeof(PyVkQueueFamilyProperties), 0,
    (destructor)PyVkQueueFamilyProperties_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkQueueFamilyProperties object",0,0,0,0,0,0,0,0,
    PyVkQueueFamilyProperties_getsetters,0,0,0,0,0,(initproc)PyVkQueueFamilyProperties_init,0,PyVkQueueFamilyProperties_new,
};

static void PyVkPhysicalDeviceMemoryProperties_del(PyVkPhysicalDeviceMemoryProperties* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPhysicalDeviceMemoryProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPhysicalDeviceMemoryProperties *self;
    self = (PyVkPhysicalDeviceMemoryProperties *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPhysicalDeviceMemoryProperties));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPhysicalDeviceMemoryProperties");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkPhysicalDeviceMemoryProperties_getmemoryTypeCount(PyVkPhysicalDeviceMemoryProperties *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->memoryTypeCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceMemoryProperties_getmemoryHeapCount(PyVkPhysicalDeviceMemoryProperties *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->memoryHeapCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkPhysicalDeviceMemoryProperties_getsetters[] = {

    { "memoryTypeCount", (getter)PyVkPhysicalDeviceMemoryProperties_getmemoryTypeCount, NULL, "", NULL},

    { "memoryHeapCount", (getter)PyVkPhysicalDeviceMemoryProperties_getmemoryHeapCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkPhysicalDeviceMemoryProperties_init(PyVkPhysicalDeviceMemoryProperties *self, PyObject *args, PyObject *kwds) {
    return 0;
}
static PyTypeObject PyVkPhysicalDeviceMemoryPropertiesType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPhysicalDeviceMemoryProperties", sizeof(PyVkPhysicalDeviceMemoryProperties), 0,
    (destructor)PyVkPhysicalDeviceMemoryProperties_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPhysicalDeviceMemoryProperties object",0,0,0,0,0,0,0,0,
    PyVkPhysicalDeviceMemoryProperties_getsetters,0,0,0,0,0,(initproc)PyVkPhysicalDeviceMemoryProperties_init,0,PyVkPhysicalDeviceMemoryProperties_new,
};

static void PyVkMemoryAllocateInfo_del(PyVkMemoryAllocateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkMemoryAllocateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkMemoryAllocateInfo *self;
    self = (PyVkMemoryAllocateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkMemoryAllocateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkMemoryAllocateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkMemoryAllocateInfo_getpNext(PyVkMemoryAllocateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkMemoryAllocateInfo_getmemoryTypeIndex(PyVkMemoryAllocateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->memoryTypeIndex);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkMemoryAllocateInfo_getsetters[] = {

    { "pNext", (getter)PyVkMemoryAllocateInfo_getpNext, NULL, "", NULL},

    { "memoryTypeIndex", (getter)PyVkMemoryAllocateInfo_getmemoryTypeIndex, NULL, "", NULL},
    {NULL}
};

static int
PyVkMemoryAllocateInfo_init(PyVkMemoryAllocateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* allocationSize = NULL;
    PyObject* memoryTypeIndex = NULL;
    static char *kwlist[] = {"allocationSize","memoryTypeIndex",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &allocationSize, &memoryTypeIndex)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;

    (self->base)->pNext = NULL;

    if (allocationSize != NULL && allocationSize != Py_None) {

        (self->base)->allocationSize = PyLong_AsLong(allocationSize);

    }

    if (memoryTypeIndex != NULL && memoryTypeIndex != Py_None) {
        (self->base)->memoryTypeIndex = (uint32_t) PyLong_AsLong(memoryTypeIndex);
    }

    return 0;
}
static PyTypeObject PyVkMemoryAllocateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkMemoryAllocateInfo", sizeof(PyVkMemoryAllocateInfo), 0,
    (destructor)PyVkMemoryAllocateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkMemoryAllocateInfo object",0,0,0,0,0,0,0,0,
    PyVkMemoryAllocateInfo_getsetters,0,0,0,0,0,(initproc)PyVkMemoryAllocateInfo_init,0,PyVkMemoryAllocateInfo_new,
};

static void PyVkMemoryRequirements_del(PyVkMemoryRequirements* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkMemoryRequirements_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkMemoryRequirements *self;
    self = (PyVkMemoryRequirements *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkMemoryRequirements));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkMemoryRequirements");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkMemoryRequirements_getmemoryTypeBits(PyVkMemoryRequirements *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->memoryTypeBits);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkMemoryRequirements_getsetters[] = {

    { "memoryTypeBits", (getter)PyVkMemoryRequirements_getmemoryTypeBits, NULL, "", NULL},
    {NULL}
};

static int
PyVkMemoryRequirements_init(PyVkMemoryRequirements *self, PyObject *args, PyObject *kwds) {
    return 0;
}
static PyTypeObject PyVkMemoryRequirementsType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkMemoryRequirements", sizeof(PyVkMemoryRequirements), 0,
    (destructor)PyVkMemoryRequirements_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkMemoryRequirements object",0,0,0,0,0,0,0,0,
    PyVkMemoryRequirements_getsetters,0,0,0,0,0,(initproc)PyVkMemoryRequirements_init,0,PyVkMemoryRequirements_new,
};

static void PyVkSparseImageFormatProperties_del(PyVkSparseImageFormatProperties* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkSparseImageFormatProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkSparseImageFormatProperties *self;
    self = (PyVkSparseImageFormatProperties *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkSparseImageFormatProperties));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSparseImageFormatProperties");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkSparseImageFormatProperties_getsetters[] = {
    {NULL}
};

static int
PyVkSparseImageFormatProperties_init(PyVkSparseImageFormatProperties *self, PyObject *args, PyObject *kwds) {
    return 0;
}
static PyTypeObject PyVkSparseImageFormatPropertiesType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkSparseImageFormatProperties", sizeof(PyVkSparseImageFormatProperties), 0,
    (destructor)PyVkSparseImageFormatProperties_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkSparseImageFormatProperties object",0,0,0,0,0,0,0,0,
    PyVkSparseImageFormatProperties_getsetters,0,0,0,0,0,(initproc)PyVkSparseImageFormatProperties_init,0,PyVkSparseImageFormatProperties_new,
};

static void PyVkSparseImageMemoryRequirements_del(PyVkSparseImageMemoryRequirements* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkSparseImageMemoryRequirements_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkSparseImageMemoryRequirements *self;
    self = (PyVkSparseImageMemoryRequirements *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkSparseImageMemoryRequirements));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSparseImageMemoryRequirements");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkSparseImageMemoryRequirements_getimageMipTailFirstLod(PyVkSparseImageMemoryRequirements *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->imageMipTailFirstLod);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkSparseImageMemoryRequirements_getsetters[] = {

    { "imageMipTailFirstLod", (getter)PyVkSparseImageMemoryRequirements_getimageMipTailFirstLod, NULL, "", NULL},
    {NULL}
};

static int
PyVkSparseImageMemoryRequirements_init(PyVkSparseImageMemoryRequirements *self, PyObject *args, PyObject *kwds) {
    return 0;
}
static PyTypeObject PyVkSparseImageMemoryRequirementsType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkSparseImageMemoryRequirements", sizeof(PyVkSparseImageMemoryRequirements), 0,
    (destructor)PyVkSparseImageMemoryRequirements_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkSparseImageMemoryRequirements object",0,0,0,0,0,0,0,0,
    PyVkSparseImageMemoryRequirements_getsetters,0,0,0,0,0,(initproc)PyVkSparseImageMemoryRequirements_init,0,PyVkSparseImageMemoryRequirements_new,
};

static void PyVkMemoryType_del(PyVkMemoryType* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkMemoryType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkMemoryType *self;
    self = (PyVkMemoryType *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkMemoryType));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkMemoryType");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkMemoryType_getheapIndex(PyVkMemoryType *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->heapIndex);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkMemoryType_getsetters[] = {

    { "heapIndex", (getter)PyVkMemoryType_getheapIndex, NULL, "", NULL},
    {NULL}
};

static int
PyVkMemoryType_init(PyVkMemoryType *self, PyObject *args, PyObject *kwds) {
    return 0;
}
static PyTypeObject PyVkMemoryTypeType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkMemoryType", sizeof(PyVkMemoryType), 0,
    (destructor)PyVkMemoryType_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkMemoryType object",0,0,0,0,0,0,0,0,
    PyVkMemoryType_getsetters,0,0,0,0,0,(initproc)PyVkMemoryType_init,0,PyVkMemoryType_new,
};

static void PyVkMemoryHeap_del(PyVkMemoryHeap* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkMemoryHeap_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkMemoryHeap *self;
    self = (PyVkMemoryHeap *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkMemoryHeap));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkMemoryHeap");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkMemoryHeap_getsetters[] = {
    {NULL}
};

static int
PyVkMemoryHeap_init(PyVkMemoryHeap *self, PyObject *args, PyObject *kwds) {
    return 0;
}
static PyTypeObject PyVkMemoryHeapType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkMemoryHeap", sizeof(PyVkMemoryHeap), 0,
    (destructor)PyVkMemoryHeap_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkMemoryHeap object",0,0,0,0,0,0,0,0,
    PyVkMemoryHeap_getsetters,0,0,0,0,0,(initproc)PyVkMemoryHeap_init,0,PyVkMemoryHeap_new,
};

static void PyVkMappedMemoryRange_del(PyVkMappedMemoryRange* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkMappedMemoryRange_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkMappedMemoryRange *self;
    self = (PyVkMappedMemoryRange *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkMappedMemoryRange));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkMappedMemoryRange");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkMappedMemoryRange_getpNext(PyVkMappedMemoryRange *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkMappedMemoryRange_getsetters[] = {

    { "pNext", (getter)PyVkMappedMemoryRange_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkMappedMemoryRange_init(PyVkMappedMemoryRange *self, PyObject *args, PyObject *kwds) {
    PyObject* memory = NULL;
    PyObject* offset = NULL;
    PyObject* size = NULL;
    static char *kwlist[] = {"memory","offset","size",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &memory, &offset, &size)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;

    (self->base)->pNext = NULL;

    if (memory != NULL && memory != Py_None) {

        (self->base)->memory = PyCapsule_GetPointer(memory, "VkDeviceMemory");

    }

    if (offset != NULL && offset != Py_None) {

        (self->base)->offset = PyLong_AsLong(offset);

    }

    if (size != NULL && size != Py_None) {

        (self->base)->size = PyLong_AsLong(size);

    }

    return 0;
}
static PyTypeObject PyVkMappedMemoryRangeType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkMappedMemoryRange", sizeof(PyVkMappedMemoryRange), 0,
    (destructor)PyVkMappedMemoryRange_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkMappedMemoryRange object",0,0,0,0,0,0,0,0,
    PyVkMappedMemoryRange_getsetters,0,0,0,0,0,(initproc)PyVkMappedMemoryRange_init,0,PyVkMappedMemoryRange_new,
};

static void PyVkFormatProperties_del(PyVkFormatProperties* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkFormatProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkFormatProperties *self;
    self = (PyVkFormatProperties *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkFormatProperties));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkFormatProperties");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkFormatProperties_getsetters[] = {
    {NULL}
};

static int
PyVkFormatProperties_init(PyVkFormatProperties *self, PyObject *args, PyObject *kwds) {
    return 0;
}
static PyTypeObject PyVkFormatPropertiesType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkFormatProperties", sizeof(PyVkFormatProperties), 0,
    (destructor)PyVkFormatProperties_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkFormatProperties object",0,0,0,0,0,0,0,0,
    PyVkFormatProperties_getsetters,0,0,0,0,0,(initproc)PyVkFormatProperties_init,0,PyVkFormatProperties_new,
};

static void PyVkImageFormatProperties_del(PyVkImageFormatProperties* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkImageFormatProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkImageFormatProperties *self;
    self = (PyVkImageFormatProperties *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkImageFormatProperties));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageFormatProperties");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkImageFormatProperties_getmaxMipLevels(PyVkImageFormatProperties *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxMipLevels);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkImageFormatProperties_getmaxArrayLayers(PyVkImageFormatProperties *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxArrayLayers);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkImageFormatProperties_getsetters[] = {

    { "maxMipLevels", (getter)PyVkImageFormatProperties_getmaxMipLevels, NULL, "", NULL},

    { "maxArrayLayers", (getter)PyVkImageFormatProperties_getmaxArrayLayers, NULL, "", NULL},
    {NULL}
};

static int
PyVkImageFormatProperties_init(PyVkImageFormatProperties *self, PyObject *args, PyObject *kwds) {
    return 0;
}
static PyTypeObject PyVkImageFormatPropertiesType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkImageFormatProperties", sizeof(PyVkImageFormatProperties), 0,
    (destructor)PyVkImageFormatProperties_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkImageFormatProperties object",0,0,0,0,0,0,0,0,
    PyVkImageFormatProperties_getsetters,0,0,0,0,0,(initproc)PyVkImageFormatProperties_init,0,PyVkImageFormatProperties_new,
};

static void PyVkDescriptorBufferInfo_del(PyVkDescriptorBufferInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDescriptorBufferInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDescriptorBufferInfo *self;
    self = (PyVkDescriptorBufferInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDescriptorBufferInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDescriptorBufferInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkDescriptorBufferInfo_getsetters[] = {
    {NULL}
};

static int
PyVkDescriptorBufferInfo_init(PyVkDescriptorBufferInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* buffer = NULL;
    PyObject* offset = NULL;
    PyObject* range = NULL;
    static char *kwlist[] = {"buffer","offset","range",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &buffer, &offset, &range)) return -1;

    if (buffer != NULL && buffer != Py_None) {

        (self->base)->buffer = PyCapsule_GetPointer(buffer, "VkBuffer");

    }

    if (offset != NULL && offset != Py_None) {

        (self->base)->offset = PyLong_AsLong(offset);

    }

    if (range != NULL && range != Py_None) {

        (self->base)->range = PyLong_AsLong(range);

    }

    return 0;
}
static PyTypeObject PyVkDescriptorBufferInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDescriptorBufferInfo", sizeof(PyVkDescriptorBufferInfo), 0,
    (destructor)PyVkDescriptorBufferInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDescriptorBufferInfo object",0,0,0,0,0,0,0,0,
    PyVkDescriptorBufferInfo_getsetters,0,0,0,0,0,(initproc)PyVkDescriptorBufferInfo_init,0,PyVkDescriptorBufferInfo_new,
};

static void PyVkDescriptorImageInfo_del(PyVkDescriptorImageInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDescriptorImageInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDescriptorImageInfo *self;
    self = (PyVkDescriptorImageInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDescriptorImageInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDescriptorImageInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkDescriptorImageInfo_getsetters[] = {
    {NULL}
};

static int
PyVkDescriptorImageInfo_init(PyVkDescriptorImageInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* sampler = NULL;
    PyObject* imageView = NULL;
    PyObject* imageLayout = NULL;
    static char *kwlist[] = {"sampler","imageView","imageLayout",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &sampler, &imageView, &imageLayout)) return -1;

    if (sampler != NULL && sampler != Py_None) {

        (self->base)->sampler = PyCapsule_GetPointer(sampler, "VkSampler");

    }

    if (imageView != NULL && imageView != Py_None) {

        (self->base)->imageView = PyCapsule_GetPointer(imageView, "VkImageView");

    }

    if (imageLayout != NULL && imageLayout != Py_None) {

        (self->base)->imageLayout = PyLong_AsLong(imageLayout);

    }

    return 0;
}
static PyTypeObject PyVkDescriptorImageInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDescriptorImageInfo", sizeof(PyVkDescriptorImageInfo), 0,
    (destructor)PyVkDescriptorImageInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDescriptorImageInfo object",0,0,0,0,0,0,0,0,
    PyVkDescriptorImageInfo_getsetters,0,0,0,0,0,(initproc)PyVkDescriptorImageInfo_init,0,PyVkDescriptorImageInfo_new,
};

static void PyVkWriteDescriptorSet_del(PyVkWriteDescriptorSet* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkWriteDescriptorSet_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkWriteDescriptorSet *self;
    self = (PyVkWriteDescriptorSet *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkWriteDescriptorSet));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkWriteDescriptorSet");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkWriteDescriptorSet_getpNext(PyVkWriteDescriptorSet *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkWriteDescriptorSet_getdstBinding(PyVkWriteDescriptorSet *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->dstBinding);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkWriteDescriptorSet_getdstArrayElement(PyVkWriteDescriptorSet *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->dstArrayElement);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkWriteDescriptorSet_getdescriptorCount(PyVkWriteDescriptorSet *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->descriptorCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkWriteDescriptorSet_getsetters[] = {

    { "pNext", (getter)PyVkWriteDescriptorSet_getpNext, NULL, "", NULL},

    { "dstBinding", (getter)PyVkWriteDescriptorSet_getdstBinding, NULL, "", NULL},

    { "dstArrayElement", (getter)PyVkWriteDescriptorSet_getdstArrayElement, NULL, "", NULL},

    { "descriptorCount", (getter)PyVkWriteDescriptorSet_getdescriptorCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkWriteDescriptorSet_init(PyVkWriteDescriptorSet *self, PyObject *args, PyObject *kwds) {
    PyObject* dstSet = NULL;
    PyObject* dstBinding = NULL;
    PyObject* dstArrayElement = NULL;
    PyObject* descriptorCount = NULL;
    PyObject* descriptorType = NULL;
    PyObject* pImageInfo = NULL;
    PyObject* pBufferInfo = NULL;
    PyObject* pTexelBufferView = NULL;
    static char *kwlist[] = {"dstSet","dstBinding","dstArrayElement","descriptorCount","descriptorType","pImageInfo","pBufferInfo","pTexelBufferView",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOO", kwlist, &dstSet, &dstBinding, &dstArrayElement, &descriptorCount, &descriptorType, &pImageInfo, &pBufferInfo, &pTexelBufferView)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;

    (self->base)->pNext = NULL;

    if (dstSet != NULL && dstSet != Py_None) {

        (self->base)->dstSet = PyCapsule_GetPointer(dstSet, "VkDescriptorSet");

    }

    if (dstBinding != NULL && dstBinding != Py_None) {
        (self->base)->dstBinding = (uint32_t) PyLong_AsLong(dstBinding);
    }

    if (dstArrayElement != NULL && dstArrayElement != Py_None) {
        (self->base)->dstArrayElement = (uint32_t) PyLong_AsLong(dstArrayElement);
    }

    if (descriptorCount != NULL && descriptorCount != Py_None) {
        (self->base)->descriptorCount = (uint32_t) PyLong_AsLong(descriptorCount);
    }

    if (descriptorType != NULL && descriptorType != Py_None) {

        (self->base)->descriptorType = PyLong_AsLong(descriptorType);

    }

    if (pImageInfo != NULL && pImageInfo != Py_None) {

        (self->base)->pImageInfo = (((PyVkDescriptorImageInfo*)pImageInfo)->base);

    }

    if (pBufferInfo != NULL && pBufferInfo != Py_None) {

        (self->base)->pBufferInfo = (((PyVkDescriptorBufferInfo*)pBufferInfo)->base);

    }

    if (pTexelBufferView != NULL && pTexelBufferView != Py_None) {

        (self->base)->pTexelBufferView = PyCapsule_GetPointer(pTexelBufferView, "VkBufferView");

    }

    return 0;
}
static PyTypeObject PyVkWriteDescriptorSetType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkWriteDescriptorSet", sizeof(PyVkWriteDescriptorSet), 0,
    (destructor)PyVkWriteDescriptorSet_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkWriteDescriptorSet object",0,0,0,0,0,0,0,0,
    PyVkWriteDescriptorSet_getsetters,0,0,0,0,0,(initproc)PyVkWriteDescriptorSet_init,0,PyVkWriteDescriptorSet_new,
};

static void PyVkCopyDescriptorSet_del(PyVkCopyDescriptorSet* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkCopyDescriptorSet_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkCopyDescriptorSet *self;
    self = (PyVkCopyDescriptorSet *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkCopyDescriptorSet));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkCopyDescriptorSet");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkCopyDescriptorSet_getpNext(PyVkCopyDescriptorSet *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkCopyDescriptorSet_getsrcBinding(PyVkCopyDescriptorSet *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->srcBinding);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkCopyDescriptorSet_getsrcArrayElement(PyVkCopyDescriptorSet *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->srcArrayElement);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkCopyDescriptorSet_getdstBinding(PyVkCopyDescriptorSet *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->dstBinding);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkCopyDescriptorSet_getdstArrayElement(PyVkCopyDescriptorSet *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->dstArrayElement);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkCopyDescriptorSet_getdescriptorCount(PyVkCopyDescriptorSet *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->descriptorCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkCopyDescriptorSet_getsetters[] = {

    { "pNext", (getter)PyVkCopyDescriptorSet_getpNext, NULL, "", NULL},

    { "srcBinding", (getter)PyVkCopyDescriptorSet_getsrcBinding, NULL, "", NULL},

    { "srcArrayElement", (getter)PyVkCopyDescriptorSet_getsrcArrayElement, NULL, "", NULL},

    { "dstBinding", (getter)PyVkCopyDescriptorSet_getdstBinding, NULL, "", NULL},

    { "dstArrayElement", (getter)PyVkCopyDescriptorSet_getdstArrayElement, NULL, "", NULL},

    { "descriptorCount", (getter)PyVkCopyDescriptorSet_getdescriptorCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkCopyDescriptorSet_init(PyVkCopyDescriptorSet *self, PyObject *args, PyObject *kwds) {
    PyObject* srcSet = NULL;
    PyObject* srcBinding = NULL;
    PyObject* srcArrayElement = NULL;
    PyObject* dstSet = NULL;
    PyObject* dstBinding = NULL;
    PyObject* dstArrayElement = NULL;
    PyObject* descriptorCount = NULL;
    static char *kwlist[] = {"srcSet","srcBinding","srcArrayElement","dstSet","dstBinding","dstArrayElement","descriptorCount",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &srcSet, &srcBinding, &srcArrayElement, &dstSet, &dstBinding, &dstArrayElement, &descriptorCount)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET;

    (self->base)->pNext = NULL;

    if (srcSet != NULL && srcSet != Py_None) {

        (self->base)->srcSet = PyCapsule_GetPointer(srcSet, "VkDescriptorSet");

    }

    if (srcBinding != NULL && srcBinding != Py_None) {
        (self->base)->srcBinding = (uint32_t) PyLong_AsLong(srcBinding);
    }

    if (srcArrayElement != NULL && srcArrayElement != Py_None) {
        (self->base)->srcArrayElement = (uint32_t) PyLong_AsLong(srcArrayElement);
    }

    if (dstSet != NULL && dstSet != Py_None) {

        (self->base)->dstSet = PyCapsule_GetPointer(dstSet, "VkDescriptorSet");

    }

    if (dstBinding != NULL && dstBinding != Py_None) {
        (self->base)->dstBinding = (uint32_t) PyLong_AsLong(dstBinding);
    }

    if (dstArrayElement != NULL && dstArrayElement != Py_None) {
        (self->base)->dstArrayElement = (uint32_t) PyLong_AsLong(dstArrayElement);
    }

    if (descriptorCount != NULL && descriptorCount != Py_None) {
        (self->base)->descriptorCount = (uint32_t) PyLong_AsLong(descriptorCount);
    }

    return 0;
}
static PyTypeObject PyVkCopyDescriptorSetType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkCopyDescriptorSet", sizeof(PyVkCopyDescriptorSet), 0,
    (destructor)PyVkCopyDescriptorSet_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkCopyDescriptorSet object",0,0,0,0,0,0,0,0,
    PyVkCopyDescriptorSet_getsetters,0,0,0,0,0,(initproc)PyVkCopyDescriptorSet_init,0,PyVkCopyDescriptorSet_new,
};

static void PyVkBufferCreateInfo_del(PyVkBufferCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkBufferCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkBufferCreateInfo *self;
    self = (PyVkBufferCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkBufferCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkBufferCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkBufferCreateInfo_getpNext(PyVkBufferCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkBufferCreateInfo_getqueueFamilyIndexCount(PyVkBufferCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->queueFamilyIndexCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkBufferCreateInfo_getpQueueFamilyIndices(PyVkBufferCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (*((self->base)->pQueueFamilyIndices)));
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkBufferCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkBufferCreateInfo_getpNext, NULL, "", NULL},

    { "queueFamilyIndexCount", (getter)PyVkBufferCreateInfo_getqueueFamilyIndexCount, NULL, "", NULL},

    { "pQueueFamilyIndices", (getter)PyVkBufferCreateInfo_getpQueueFamilyIndices, NULL, "", NULL},
    {NULL}
};

static int
PyVkBufferCreateInfo_init(PyVkBufferCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* size = NULL;
    PyObject* usage = NULL;
    PyObject* sharingMode = NULL;
    PyObject* queueFamilyIndexCount = NULL;
    PyObject* pQueueFamilyIndices = NULL;
    static char *kwlist[] = {"flags","size","usage","sharingMode","queueFamilyIndexCount","pQueueFamilyIndices",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &flags, &size, &usage, &sharingMode, &queueFamilyIndexCount, &pQueueFamilyIndices)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (size != NULL && size != Py_None) {

        (self->base)->size = PyLong_AsLong(size);

    }

    if (usage != NULL && usage != Py_None) {

        (self->base)->usage = PyLong_AsLong(usage);

    }

    if (sharingMode != NULL && sharingMode != Py_None) {

        (self->base)->sharingMode = PyLong_AsLong(sharingMode);

    }

    if (queueFamilyIndexCount != NULL && queueFamilyIndexCount != Py_None) {
        (self->base)->queueFamilyIndexCount = (uint32_t) PyLong_AsLong(queueFamilyIndexCount);
    }

    if (pQueueFamilyIndices != NULL && pQueueFamilyIndices != Py_None) {

        uint32_t tmp72390011 = (uint32_t) PyLong_AsLong(pQueueFamilyIndices);
        uint32_t *tmp44105021 = malloc(sizeof(uint32_t));
        memcpy(tmp44105021, &tmp72390011, sizeof(uint32_t));
        (self->base)->pQueueFamilyIndices = tmp44105021;

    }

    return 0;
}
static PyTypeObject PyVkBufferCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkBufferCreateInfo", sizeof(PyVkBufferCreateInfo), 0,
    (destructor)PyVkBufferCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkBufferCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkBufferCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkBufferCreateInfo_init,0,PyVkBufferCreateInfo_new,
};

static void PyVkBufferViewCreateInfo_del(PyVkBufferViewCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkBufferViewCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkBufferViewCreateInfo *self;
    self = (PyVkBufferViewCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkBufferViewCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkBufferViewCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkBufferViewCreateInfo_getpNext(PyVkBufferViewCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkBufferViewCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkBufferViewCreateInfo_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkBufferViewCreateInfo_init(PyVkBufferViewCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* buffer = NULL;
    PyObject* format = NULL;
    PyObject* offset = NULL;
    PyObject* range = NULL;
    static char *kwlist[] = {"flags","buffer","format","offset","range",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &flags, &buffer, &format, &offset, &range)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (buffer != NULL && buffer != Py_None) {

        (self->base)->buffer = PyCapsule_GetPointer(buffer, "VkBuffer");

    }

    if (format != NULL && format != Py_None) {

        (self->base)->format = PyLong_AsLong(format);

    }

    if (offset != NULL && offset != Py_None) {

        (self->base)->offset = PyLong_AsLong(offset);

    }

    if (range != NULL && range != Py_None) {

        (self->base)->range = PyLong_AsLong(range);

    }

    return 0;
}
static PyTypeObject PyVkBufferViewCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkBufferViewCreateInfo", sizeof(PyVkBufferViewCreateInfo), 0,
    (destructor)PyVkBufferViewCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkBufferViewCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkBufferViewCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkBufferViewCreateInfo_init,0,PyVkBufferViewCreateInfo_new,
};

static void PyVkImageSubresource_del(PyVkImageSubresource* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkImageSubresource_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkImageSubresource *self;
    self = (PyVkImageSubresource *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkImageSubresource));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageSubresource");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkImageSubresource_getmipLevel(PyVkImageSubresource *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->mipLevel);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkImageSubresource_getarrayLayer(PyVkImageSubresource *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->arrayLayer);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkImageSubresource_getsetters[] = {

    { "mipLevel", (getter)PyVkImageSubresource_getmipLevel, NULL, "", NULL},

    { "arrayLayer", (getter)PyVkImageSubresource_getarrayLayer, NULL, "", NULL},
    {NULL}
};

static int
PyVkImageSubresource_init(PyVkImageSubresource *self, PyObject *args, PyObject *kwds) {
    PyObject* aspectMask = NULL;
    PyObject* mipLevel = NULL;
    PyObject* arrayLayer = NULL;
    static char *kwlist[] = {"aspectMask","mipLevel","arrayLayer",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &aspectMask, &mipLevel, &arrayLayer)) return -1;

    if (aspectMask != NULL && aspectMask != Py_None) {

        (self->base)->aspectMask = PyLong_AsLong(aspectMask);

    }

    if (mipLevel != NULL && mipLevel != Py_None) {
        (self->base)->mipLevel = (uint32_t) PyLong_AsLong(mipLevel);
    }

    if (arrayLayer != NULL && arrayLayer != Py_None) {
        (self->base)->arrayLayer = (uint32_t) PyLong_AsLong(arrayLayer);
    }

    return 0;
}
static PyTypeObject PyVkImageSubresourceType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkImageSubresource", sizeof(PyVkImageSubresource), 0,
    (destructor)PyVkImageSubresource_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkImageSubresource object",0,0,0,0,0,0,0,0,
    PyVkImageSubresource_getsetters,0,0,0,0,0,(initproc)PyVkImageSubresource_init,0,PyVkImageSubresource_new,
};

static void PyVkImageSubresourceLayers_del(PyVkImageSubresourceLayers* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkImageSubresourceLayers_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkImageSubresourceLayers *self;
    self = (PyVkImageSubresourceLayers *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkImageSubresourceLayers));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageSubresourceLayers");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkImageSubresourceLayers_getmipLevel(PyVkImageSubresourceLayers *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->mipLevel);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkImageSubresourceLayers_getbaseArrayLayer(PyVkImageSubresourceLayers *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->baseArrayLayer);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkImageSubresourceLayers_getlayerCount(PyVkImageSubresourceLayers *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->layerCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkImageSubresourceLayers_getsetters[] = {

    { "mipLevel", (getter)PyVkImageSubresourceLayers_getmipLevel, NULL, "", NULL},

    { "baseArrayLayer", (getter)PyVkImageSubresourceLayers_getbaseArrayLayer, NULL, "", NULL},

    { "layerCount", (getter)PyVkImageSubresourceLayers_getlayerCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkImageSubresourceLayers_init(PyVkImageSubresourceLayers *self, PyObject *args, PyObject *kwds) {
    PyObject* aspectMask = NULL;
    PyObject* mipLevel = NULL;
    PyObject* baseArrayLayer = NULL;
    PyObject* layerCount = NULL;
    static char *kwlist[] = {"aspectMask","mipLevel","baseArrayLayer","layerCount",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &aspectMask, &mipLevel, &baseArrayLayer, &layerCount)) return -1;

    if (aspectMask != NULL && aspectMask != Py_None) {

        (self->base)->aspectMask = PyLong_AsLong(aspectMask);

    }

    if (mipLevel != NULL && mipLevel != Py_None) {
        (self->base)->mipLevel = (uint32_t) PyLong_AsLong(mipLevel);
    }

    if (baseArrayLayer != NULL && baseArrayLayer != Py_None) {
        (self->base)->baseArrayLayer = (uint32_t) PyLong_AsLong(baseArrayLayer);
    }

    if (layerCount != NULL && layerCount != Py_None) {
        (self->base)->layerCount = (uint32_t) PyLong_AsLong(layerCount);
    }

    return 0;
}
static PyTypeObject PyVkImageSubresourceLayersType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkImageSubresourceLayers", sizeof(PyVkImageSubresourceLayers), 0,
    (destructor)PyVkImageSubresourceLayers_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkImageSubresourceLayers object",0,0,0,0,0,0,0,0,
    PyVkImageSubresourceLayers_getsetters,0,0,0,0,0,(initproc)PyVkImageSubresourceLayers_init,0,PyVkImageSubresourceLayers_new,
};

static void PyVkImageSubresourceRange_del(PyVkImageSubresourceRange* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkImageSubresourceRange_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkImageSubresourceRange *self;
    self = (PyVkImageSubresourceRange *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkImageSubresourceRange));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageSubresourceRange");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkImageSubresourceRange_getbaseMipLevel(PyVkImageSubresourceRange *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->baseMipLevel);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkImageSubresourceRange_getlevelCount(PyVkImageSubresourceRange *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->levelCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkImageSubresourceRange_getbaseArrayLayer(PyVkImageSubresourceRange *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->baseArrayLayer);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkImageSubresourceRange_getlayerCount(PyVkImageSubresourceRange *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->layerCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkImageSubresourceRange_getsetters[] = {

    { "baseMipLevel", (getter)PyVkImageSubresourceRange_getbaseMipLevel, NULL, "", NULL},

    { "levelCount", (getter)PyVkImageSubresourceRange_getlevelCount, NULL, "", NULL},

    { "baseArrayLayer", (getter)PyVkImageSubresourceRange_getbaseArrayLayer, NULL, "", NULL},

    { "layerCount", (getter)PyVkImageSubresourceRange_getlayerCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkImageSubresourceRange_init(PyVkImageSubresourceRange *self, PyObject *args, PyObject *kwds) {
    PyObject* aspectMask = NULL;
    PyObject* baseMipLevel = NULL;
    PyObject* levelCount = NULL;
    PyObject* baseArrayLayer = NULL;
    PyObject* layerCount = NULL;
    static char *kwlist[] = {"aspectMask","baseMipLevel","levelCount","baseArrayLayer","layerCount",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &aspectMask, &baseMipLevel, &levelCount, &baseArrayLayer, &layerCount)) return -1;

    if (aspectMask != NULL && aspectMask != Py_None) {

        (self->base)->aspectMask = PyLong_AsLong(aspectMask);

    }

    if (baseMipLevel != NULL && baseMipLevel != Py_None) {
        (self->base)->baseMipLevel = (uint32_t) PyLong_AsLong(baseMipLevel);
    }

    if (levelCount != NULL && levelCount != Py_None) {
        (self->base)->levelCount = (uint32_t) PyLong_AsLong(levelCount);
    }

    if (baseArrayLayer != NULL && baseArrayLayer != Py_None) {
        (self->base)->baseArrayLayer = (uint32_t) PyLong_AsLong(baseArrayLayer);
    }

    if (layerCount != NULL && layerCount != Py_None) {
        (self->base)->layerCount = (uint32_t) PyLong_AsLong(layerCount);
    }

    return 0;
}
static PyTypeObject PyVkImageSubresourceRangeType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkImageSubresourceRange", sizeof(PyVkImageSubresourceRange), 0,
    (destructor)PyVkImageSubresourceRange_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkImageSubresourceRange object",0,0,0,0,0,0,0,0,
    PyVkImageSubresourceRange_getsetters,0,0,0,0,0,(initproc)PyVkImageSubresourceRange_init,0,PyVkImageSubresourceRange_new,
};

static void PyVkMemoryBarrier_del(PyVkMemoryBarrier* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkMemoryBarrier_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkMemoryBarrier *self;
    self = (PyVkMemoryBarrier *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkMemoryBarrier));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkMemoryBarrier");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkMemoryBarrier_getpNext(PyVkMemoryBarrier *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkMemoryBarrier_getsetters[] = {

    { "pNext", (getter)PyVkMemoryBarrier_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkMemoryBarrier_init(PyVkMemoryBarrier *self, PyObject *args, PyObject *kwds) {
    PyObject* srcAccessMask = NULL;
    PyObject* dstAccessMask = NULL;
    static char *kwlist[] = {"srcAccessMask","dstAccessMask",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &srcAccessMask, &dstAccessMask)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;

    (self->base)->pNext = NULL;

    if (srcAccessMask != NULL && srcAccessMask != Py_None) {

        (self->base)->srcAccessMask = PyLong_AsLong(srcAccessMask);

    }

    if (dstAccessMask != NULL && dstAccessMask != Py_None) {

        (self->base)->dstAccessMask = PyLong_AsLong(dstAccessMask);

    }

    return 0;
}
static PyTypeObject PyVkMemoryBarrierType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkMemoryBarrier", sizeof(PyVkMemoryBarrier), 0,
    (destructor)PyVkMemoryBarrier_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkMemoryBarrier object",0,0,0,0,0,0,0,0,
    PyVkMemoryBarrier_getsetters,0,0,0,0,0,(initproc)PyVkMemoryBarrier_init,0,PyVkMemoryBarrier_new,
};

static void PyVkBufferMemoryBarrier_del(PyVkBufferMemoryBarrier* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkBufferMemoryBarrier_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkBufferMemoryBarrier *self;
    self = (PyVkBufferMemoryBarrier *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkBufferMemoryBarrier));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkBufferMemoryBarrier");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkBufferMemoryBarrier_getpNext(PyVkBufferMemoryBarrier *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkBufferMemoryBarrier_getsrcQueueFamilyIndex(PyVkBufferMemoryBarrier *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->srcQueueFamilyIndex);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkBufferMemoryBarrier_getdstQueueFamilyIndex(PyVkBufferMemoryBarrier *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->dstQueueFamilyIndex);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkBufferMemoryBarrier_getsetters[] = {

    { "pNext", (getter)PyVkBufferMemoryBarrier_getpNext, NULL, "", NULL},

    { "srcQueueFamilyIndex", (getter)PyVkBufferMemoryBarrier_getsrcQueueFamilyIndex, NULL, "", NULL},

    { "dstQueueFamilyIndex", (getter)PyVkBufferMemoryBarrier_getdstQueueFamilyIndex, NULL, "", NULL},
    {NULL}
};

static int
PyVkBufferMemoryBarrier_init(PyVkBufferMemoryBarrier *self, PyObject *args, PyObject *kwds) {
    PyObject* srcAccessMask = NULL;
    PyObject* dstAccessMask = NULL;
    PyObject* srcQueueFamilyIndex = NULL;
    PyObject* dstQueueFamilyIndex = NULL;
    PyObject* buffer = NULL;
    PyObject* offset = NULL;
    PyObject* size = NULL;
    static char *kwlist[] = {"srcAccessMask","dstAccessMask","srcQueueFamilyIndex","dstQueueFamilyIndex","buffer","offset","size",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &srcAccessMask, &dstAccessMask, &srcQueueFamilyIndex, &dstQueueFamilyIndex, &buffer, &offset, &size)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;

    (self->base)->pNext = NULL;

    if (srcAccessMask != NULL && srcAccessMask != Py_None) {

        (self->base)->srcAccessMask = PyLong_AsLong(srcAccessMask);

    }

    if (dstAccessMask != NULL && dstAccessMask != Py_None) {

        (self->base)->dstAccessMask = PyLong_AsLong(dstAccessMask);

    }

    if (srcQueueFamilyIndex != NULL && srcQueueFamilyIndex != Py_None) {
        (self->base)->srcQueueFamilyIndex = (uint32_t) PyLong_AsLong(srcQueueFamilyIndex);
    }

    if (dstQueueFamilyIndex != NULL && dstQueueFamilyIndex != Py_None) {
        (self->base)->dstQueueFamilyIndex = (uint32_t) PyLong_AsLong(dstQueueFamilyIndex);
    }

    if (buffer != NULL && buffer != Py_None) {

        (self->base)->buffer = PyCapsule_GetPointer(buffer, "VkBuffer");

    }

    if (offset != NULL && offset != Py_None) {

        (self->base)->offset = PyLong_AsLong(offset);

    }

    if (size != NULL && size != Py_None) {

        (self->base)->size = PyLong_AsLong(size);

    }

    return 0;
}
static PyTypeObject PyVkBufferMemoryBarrierType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkBufferMemoryBarrier", sizeof(PyVkBufferMemoryBarrier), 0,
    (destructor)PyVkBufferMemoryBarrier_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkBufferMemoryBarrier object",0,0,0,0,0,0,0,0,
    PyVkBufferMemoryBarrier_getsetters,0,0,0,0,0,(initproc)PyVkBufferMemoryBarrier_init,0,PyVkBufferMemoryBarrier_new,
};

static void PyVkImageMemoryBarrier_del(PyVkImageMemoryBarrier* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkImageMemoryBarrier_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkImageMemoryBarrier *self;
    self = (PyVkImageMemoryBarrier *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkImageMemoryBarrier));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageMemoryBarrier");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkImageMemoryBarrier_getpNext(PyVkImageMemoryBarrier *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkImageMemoryBarrier_getsrcQueueFamilyIndex(PyVkImageMemoryBarrier *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->srcQueueFamilyIndex);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkImageMemoryBarrier_getdstQueueFamilyIndex(PyVkImageMemoryBarrier *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->dstQueueFamilyIndex);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkImageMemoryBarrier_getsetters[] = {

    { "pNext", (getter)PyVkImageMemoryBarrier_getpNext, NULL, "", NULL},

    { "srcQueueFamilyIndex", (getter)PyVkImageMemoryBarrier_getsrcQueueFamilyIndex, NULL, "", NULL},

    { "dstQueueFamilyIndex", (getter)PyVkImageMemoryBarrier_getdstQueueFamilyIndex, NULL, "", NULL},
    {NULL}
};

static int
PyVkImageMemoryBarrier_init(PyVkImageMemoryBarrier *self, PyObject *args, PyObject *kwds) {
    PyObject* srcAccessMask = NULL;
    PyObject* dstAccessMask = NULL;
    PyObject* oldLayout = NULL;
    PyObject* newLayout = NULL;
    PyObject* srcQueueFamilyIndex = NULL;
    PyObject* dstQueueFamilyIndex = NULL;
    PyObject* image = NULL;
    PyObject* subresourceRange = NULL;
    static char *kwlist[] = {"srcAccessMask","dstAccessMask","oldLayout","newLayout","srcQueueFamilyIndex","dstQueueFamilyIndex","image","subresourceRange",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOO", kwlist, &srcAccessMask, &dstAccessMask, &oldLayout, &newLayout, &srcQueueFamilyIndex, &dstQueueFamilyIndex, &image, &subresourceRange)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;

    (self->base)->pNext = NULL;

    if (srcAccessMask != NULL && srcAccessMask != Py_None) {

        (self->base)->srcAccessMask = PyLong_AsLong(srcAccessMask);

    }

    if (dstAccessMask != NULL && dstAccessMask != Py_None) {

        (self->base)->dstAccessMask = PyLong_AsLong(dstAccessMask);

    }

    if (oldLayout != NULL && oldLayout != Py_None) {

        (self->base)->oldLayout = PyLong_AsLong(oldLayout);

    }

    if (newLayout != NULL && newLayout != Py_None) {

        (self->base)->newLayout = PyLong_AsLong(newLayout);

    }

    if (srcQueueFamilyIndex != NULL && srcQueueFamilyIndex != Py_None) {
        (self->base)->srcQueueFamilyIndex = (uint32_t) PyLong_AsLong(srcQueueFamilyIndex);
    }

    if (dstQueueFamilyIndex != NULL && dstQueueFamilyIndex != Py_None) {
        (self->base)->dstQueueFamilyIndex = (uint32_t) PyLong_AsLong(dstQueueFamilyIndex);
    }

    if (image != NULL && image != Py_None) {

        (self->base)->image = PyCapsule_GetPointer(image, "VkImage");

    }

    if (subresourceRange != NULL && subresourceRange != Py_None) {

        (self->base)->subresourceRange = *(((PyVkImageSubresourceRange*)subresourceRange)->base);

    }

    return 0;
}
static PyTypeObject PyVkImageMemoryBarrierType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkImageMemoryBarrier", sizeof(PyVkImageMemoryBarrier), 0,
    (destructor)PyVkImageMemoryBarrier_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkImageMemoryBarrier object",0,0,0,0,0,0,0,0,
    PyVkImageMemoryBarrier_getsetters,0,0,0,0,0,(initproc)PyVkImageMemoryBarrier_init,0,PyVkImageMemoryBarrier_new,
};

static void PyVkImageCreateInfo_del(PyVkImageCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkImageCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkImageCreateInfo *self;
    self = (PyVkImageCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkImageCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkImageCreateInfo_getpNext(PyVkImageCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkImageCreateInfo_getmipLevels(PyVkImageCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->mipLevels);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkImageCreateInfo_getarrayLayers(PyVkImageCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->arrayLayers);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkImageCreateInfo_getqueueFamilyIndexCount(PyVkImageCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->queueFamilyIndexCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkImageCreateInfo_getpQueueFamilyIndices(PyVkImageCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (*((self->base)->pQueueFamilyIndices)));
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkImageCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkImageCreateInfo_getpNext, NULL, "", NULL},

    { "mipLevels", (getter)PyVkImageCreateInfo_getmipLevels, NULL, "", NULL},

    { "arrayLayers", (getter)PyVkImageCreateInfo_getarrayLayers, NULL, "", NULL},

    { "queueFamilyIndexCount", (getter)PyVkImageCreateInfo_getqueueFamilyIndexCount, NULL, "", NULL},

    { "pQueueFamilyIndices", (getter)PyVkImageCreateInfo_getpQueueFamilyIndices, NULL, "", NULL},
    {NULL}
};

static int
PyVkImageCreateInfo_init(PyVkImageCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* imageType = NULL;
    PyObject* format = NULL;
    PyObject* extent = NULL;
    PyObject* mipLevels = NULL;
    PyObject* arrayLayers = NULL;
    PyObject* samples = NULL;
    PyObject* tiling = NULL;
    PyObject* usage = NULL;
    PyObject* sharingMode = NULL;
    PyObject* queueFamilyIndexCount = NULL;
    PyObject* pQueueFamilyIndices = NULL;
    PyObject* initialLayout = NULL;
    static char *kwlist[] = {"flags","imageType","format","extent","mipLevels","arrayLayers","samples","tiling","usage","sharingMode","queueFamilyIndexCount","pQueueFamilyIndices","initialLayout",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOOOOOOO", kwlist, &flags, &imageType, &format, &extent, &mipLevels, &arrayLayers, &samples, &tiling, &usage, &sharingMode, &queueFamilyIndexCount, &pQueueFamilyIndices, &initialLayout)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (imageType != NULL && imageType != Py_None) {

        (self->base)->imageType = PyLong_AsLong(imageType);

    }

    if (format != NULL && format != Py_None) {

        (self->base)->format = PyLong_AsLong(format);

    }

    if (extent != NULL && extent != Py_None) {

        (self->base)->extent = *(((PyVkExtent3D*)extent)->base);

    }

    if (mipLevels != NULL && mipLevels != Py_None) {
        (self->base)->mipLevels = (uint32_t) PyLong_AsLong(mipLevels);
    }

    if (arrayLayers != NULL && arrayLayers != Py_None) {
        (self->base)->arrayLayers = (uint32_t) PyLong_AsLong(arrayLayers);
    }

    if (samples != NULL && samples != Py_None) {

        (self->base)->samples = PyLong_AsLong(samples);

    }

    if (tiling != NULL && tiling != Py_None) {

        (self->base)->tiling = PyLong_AsLong(tiling);

    }

    if (usage != NULL && usage != Py_None) {

        (self->base)->usage = PyLong_AsLong(usage);

    }

    if (sharingMode != NULL && sharingMode != Py_None) {

        (self->base)->sharingMode = PyLong_AsLong(sharingMode);

    }

    if (queueFamilyIndexCount != NULL && queueFamilyIndexCount != Py_None) {
        (self->base)->queueFamilyIndexCount = (uint32_t) PyLong_AsLong(queueFamilyIndexCount);
    }

    if (pQueueFamilyIndices != NULL && pQueueFamilyIndices != Py_None) {

        uint32_t tmp80279813 = (uint32_t) PyLong_AsLong(pQueueFamilyIndices);
        uint32_t *tmp40981969 = malloc(sizeof(uint32_t));
        memcpy(tmp40981969, &tmp80279813, sizeof(uint32_t));
        (self->base)->pQueueFamilyIndices = tmp40981969;

    }

    if (initialLayout != NULL && initialLayout != Py_None) {

        (self->base)->initialLayout = PyLong_AsLong(initialLayout);

    }

    return 0;
}
static PyTypeObject PyVkImageCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkImageCreateInfo", sizeof(PyVkImageCreateInfo), 0,
    (destructor)PyVkImageCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkImageCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkImageCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkImageCreateInfo_init,0,PyVkImageCreateInfo_new,
};

static void PyVkSubresourceLayout_del(PyVkSubresourceLayout* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkSubresourceLayout_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkSubresourceLayout *self;
    self = (PyVkSubresourceLayout *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkSubresourceLayout));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSubresourceLayout");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkSubresourceLayout_getsetters[] = {
    {NULL}
};

static int
PyVkSubresourceLayout_init(PyVkSubresourceLayout *self, PyObject *args, PyObject *kwds) {
    return 0;
}
static PyTypeObject PyVkSubresourceLayoutType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkSubresourceLayout", sizeof(PyVkSubresourceLayout), 0,
    (destructor)PyVkSubresourceLayout_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkSubresourceLayout object",0,0,0,0,0,0,0,0,
    PyVkSubresourceLayout_getsetters,0,0,0,0,0,(initproc)PyVkSubresourceLayout_init,0,PyVkSubresourceLayout_new,
};

static void PyVkImageViewCreateInfo_del(PyVkImageViewCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkImageViewCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkImageViewCreateInfo *self;
    self = (PyVkImageViewCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkImageViewCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageViewCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkImageViewCreateInfo_getpNext(PyVkImageViewCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkImageViewCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkImageViewCreateInfo_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkImageViewCreateInfo_init(PyVkImageViewCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* image = NULL;
    PyObject* viewType = NULL;
    PyObject* format = NULL;
    PyObject* components = NULL;
    PyObject* subresourceRange = NULL;
    static char *kwlist[] = {"flags","image","viewType","format","components","subresourceRange",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &flags, &image, &viewType, &format, &components, &subresourceRange)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (image != NULL && image != Py_None) {

        (self->base)->image = PyCapsule_GetPointer(image, "VkImage");

    }

    if (viewType != NULL && viewType != Py_None) {

        (self->base)->viewType = PyLong_AsLong(viewType);

    }

    if (format != NULL && format != Py_None) {

        (self->base)->format = PyLong_AsLong(format);

    }

    if (components != NULL && components != Py_None) {

        (self->base)->components = *(((PyVkComponentMapping*)components)->base);

    }

    if (subresourceRange != NULL && subresourceRange != Py_None) {

        (self->base)->subresourceRange = *(((PyVkImageSubresourceRange*)subresourceRange)->base);

    }

    return 0;
}
static PyTypeObject PyVkImageViewCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkImageViewCreateInfo", sizeof(PyVkImageViewCreateInfo), 0,
    (destructor)PyVkImageViewCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkImageViewCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkImageViewCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkImageViewCreateInfo_init,0,PyVkImageViewCreateInfo_new,
};

static void PyVkBufferCopy_del(PyVkBufferCopy* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkBufferCopy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkBufferCopy *self;
    self = (PyVkBufferCopy *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkBufferCopy));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkBufferCopy");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkBufferCopy_getsetters[] = {
    {NULL}
};

static int
PyVkBufferCopy_init(PyVkBufferCopy *self, PyObject *args, PyObject *kwds) {
    PyObject* srcOffset = NULL;
    PyObject* dstOffset = NULL;
    PyObject* size = NULL;
    static char *kwlist[] = {"srcOffset","dstOffset","size",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &srcOffset, &dstOffset, &size)) return -1;

    if (srcOffset != NULL && srcOffset != Py_None) {

        (self->base)->srcOffset = PyLong_AsLong(srcOffset);

    }

    if (dstOffset != NULL && dstOffset != Py_None) {

        (self->base)->dstOffset = PyLong_AsLong(dstOffset);

    }

    if (size != NULL && size != Py_None) {

        (self->base)->size = PyLong_AsLong(size);

    }

    return 0;
}
static PyTypeObject PyVkBufferCopyType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkBufferCopy", sizeof(PyVkBufferCopy), 0,
    (destructor)PyVkBufferCopy_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkBufferCopy object",0,0,0,0,0,0,0,0,
    PyVkBufferCopy_getsetters,0,0,0,0,0,(initproc)PyVkBufferCopy_init,0,PyVkBufferCopy_new,
};

static void PyVkSparseMemoryBind_del(PyVkSparseMemoryBind* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkSparseMemoryBind_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkSparseMemoryBind *self;
    self = (PyVkSparseMemoryBind *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkSparseMemoryBind));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSparseMemoryBind");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkSparseMemoryBind_getsetters[] = {
    {NULL}
};

static int
PyVkSparseMemoryBind_init(PyVkSparseMemoryBind *self, PyObject *args, PyObject *kwds) {
    PyObject* resourceOffset = NULL;
    PyObject* size = NULL;
    PyObject* memory = NULL;
    PyObject* memoryOffset = NULL;
    PyObject* flags = NULL;
    static char *kwlist[] = {"resourceOffset","size","memory","memoryOffset","flags",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &resourceOffset, &size, &memory, &memoryOffset, &flags)) return -1;

    if (resourceOffset != NULL && resourceOffset != Py_None) {

        (self->base)->resourceOffset = PyLong_AsLong(resourceOffset);

    }

    if (size != NULL && size != Py_None) {

        (self->base)->size = PyLong_AsLong(size);

    }

    if (memory != NULL && memory != Py_None) {

        (self->base)->memory = PyCapsule_GetPointer(memory, "VkDeviceMemory");

    }

    if (memoryOffset != NULL && memoryOffset != Py_None) {

        (self->base)->memoryOffset = PyLong_AsLong(memoryOffset);

    }

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    return 0;
}
static PyTypeObject PyVkSparseMemoryBindType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkSparseMemoryBind", sizeof(PyVkSparseMemoryBind), 0,
    (destructor)PyVkSparseMemoryBind_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkSparseMemoryBind object",0,0,0,0,0,0,0,0,
    PyVkSparseMemoryBind_getsetters,0,0,0,0,0,(initproc)PyVkSparseMemoryBind_init,0,PyVkSparseMemoryBind_new,
};

static void PyVkSparseImageMemoryBind_del(PyVkSparseImageMemoryBind* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkSparseImageMemoryBind_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkSparseImageMemoryBind *self;
    self = (PyVkSparseImageMemoryBind *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkSparseImageMemoryBind));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSparseImageMemoryBind");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkSparseImageMemoryBind_getsetters[] = {
    {NULL}
};

static int
PyVkSparseImageMemoryBind_init(PyVkSparseImageMemoryBind *self, PyObject *args, PyObject *kwds) {
    PyObject* subresource = NULL;
    PyObject* offset = NULL;
    PyObject* extent = NULL;
    PyObject* memory = NULL;
    PyObject* memoryOffset = NULL;
    PyObject* flags = NULL;
    static char *kwlist[] = {"subresource","offset","extent","memory","memoryOffset","flags",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &subresource, &offset, &extent, &memory, &memoryOffset, &flags)) return -1;

    if (subresource != NULL && subresource != Py_None) {

        (self->base)->subresource = *(((PyVkImageSubresource*)subresource)->base);

    }

    if (offset != NULL && offset != Py_None) {

        (self->base)->offset = *(((PyVkOffset3D*)offset)->base);

    }

    if (extent != NULL && extent != Py_None) {

        (self->base)->extent = *(((PyVkExtent3D*)extent)->base);

    }

    if (memory != NULL && memory != Py_None) {

        (self->base)->memory = PyCapsule_GetPointer(memory, "VkDeviceMemory");

    }

    if (memoryOffset != NULL && memoryOffset != Py_None) {

        (self->base)->memoryOffset = PyLong_AsLong(memoryOffset);

    }

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    return 0;
}
static PyTypeObject PyVkSparseImageMemoryBindType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkSparseImageMemoryBind", sizeof(PyVkSparseImageMemoryBind), 0,
    (destructor)PyVkSparseImageMemoryBind_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkSparseImageMemoryBind object",0,0,0,0,0,0,0,0,
    PyVkSparseImageMemoryBind_getsetters,0,0,0,0,0,(initproc)PyVkSparseImageMemoryBind_init,0,PyVkSparseImageMemoryBind_new,
};

static void PyVkSparseBufferMemoryBindInfo_del(PyVkSparseBufferMemoryBindInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkSparseBufferMemoryBindInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkSparseBufferMemoryBindInfo *self;
    self = (PyVkSparseBufferMemoryBindInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkSparseBufferMemoryBindInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSparseBufferMemoryBindInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkSparseBufferMemoryBindInfo_getbindCount(PyVkSparseBufferMemoryBindInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->bindCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkSparseBufferMemoryBindInfo_getsetters[] = {

    { "bindCount", (getter)PyVkSparseBufferMemoryBindInfo_getbindCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkSparseBufferMemoryBindInfo_init(PyVkSparseBufferMemoryBindInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* buffer = NULL;
    PyObject* bindCount = NULL;
    PyObject* pBinds = NULL;
    static char *kwlist[] = {"buffer","bindCount","pBinds",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &buffer, &bindCount, &pBinds)) return -1;

    if (buffer != NULL && buffer != Py_None) {

        (self->base)->buffer = PyCapsule_GetPointer(buffer, "VkBuffer");

    }

    if (bindCount != NULL && bindCount != Py_None) {
        (self->base)->bindCount = (uint32_t) PyLong_AsLong(bindCount);
    }

    if (pBinds != NULL && pBinds != Py_None) {

        (self->base)->pBinds = (((PyVkSparseMemoryBind*)pBinds)->base);

    }

    return 0;
}
static PyTypeObject PyVkSparseBufferMemoryBindInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkSparseBufferMemoryBindInfo", sizeof(PyVkSparseBufferMemoryBindInfo), 0,
    (destructor)PyVkSparseBufferMemoryBindInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkSparseBufferMemoryBindInfo object",0,0,0,0,0,0,0,0,
    PyVkSparseBufferMemoryBindInfo_getsetters,0,0,0,0,0,(initproc)PyVkSparseBufferMemoryBindInfo_init,0,PyVkSparseBufferMemoryBindInfo_new,
};

static void PyVkSparseImageOpaqueMemoryBindInfo_del(PyVkSparseImageOpaqueMemoryBindInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkSparseImageOpaqueMemoryBindInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkSparseImageOpaqueMemoryBindInfo *self;
    self = (PyVkSparseImageOpaqueMemoryBindInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkSparseImageOpaqueMemoryBindInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSparseImageOpaqueMemoryBindInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkSparseImageOpaqueMemoryBindInfo_getbindCount(PyVkSparseImageOpaqueMemoryBindInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->bindCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkSparseImageOpaqueMemoryBindInfo_getsetters[] = {

    { "bindCount", (getter)PyVkSparseImageOpaqueMemoryBindInfo_getbindCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkSparseImageOpaqueMemoryBindInfo_init(PyVkSparseImageOpaqueMemoryBindInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* image = NULL;
    PyObject* bindCount = NULL;
    PyObject* pBinds = NULL;
    static char *kwlist[] = {"image","bindCount","pBinds",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &image, &bindCount, &pBinds)) return -1;

    if (image != NULL && image != Py_None) {

        (self->base)->image = PyCapsule_GetPointer(image, "VkImage");

    }

    if (bindCount != NULL && bindCount != Py_None) {
        (self->base)->bindCount = (uint32_t) PyLong_AsLong(bindCount);
    }

    if (pBinds != NULL && pBinds != Py_None) {

        (self->base)->pBinds = (((PyVkSparseMemoryBind*)pBinds)->base);

    }

    return 0;
}
static PyTypeObject PyVkSparseImageOpaqueMemoryBindInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkSparseImageOpaqueMemoryBindInfo", sizeof(PyVkSparseImageOpaqueMemoryBindInfo), 0,
    (destructor)PyVkSparseImageOpaqueMemoryBindInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkSparseImageOpaqueMemoryBindInfo object",0,0,0,0,0,0,0,0,
    PyVkSparseImageOpaqueMemoryBindInfo_getsetters,0,0,0,0,0,(initproc)PyVkSparseImageOpaqueMemoryBindInfo_init,0,PyVkSparseImageOpaqueMemoryBindInfo_new,
};

static void PyVkSparseImageMemoryBindInfo_del(PyVkSparseImageMemoryBindInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkSparseImageMemoryBindInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkSparseImageMemoryBindInfo *self;
    self = (PyVkSparseImageMemoryBindInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkSparseImageMemoryBindInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSparseImageMemoryBindInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkSparseImageMemoryBindInfo_getbindCount(PyVkSparseImageMemoryBindInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->bindCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkSparseImageMemoryBindInfo_getsetters[] = {

    { "bindCount", (getter)PyVkSparseImageMemoryBindInfo_getbindCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkSparseImageMemoryBindInfo_init(PyVkSparseImageMemoryBindInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* image = NULL;
    PyObject* bindCount = NULL;
    PyObject* pBinds = NULL;
    static char *kwlist[] = {"image","bindCount","pBinds",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &image, &bindCount, &pBinds)) return -1;

    if (image != NULL && image != Py_None) {

        (self->base)->image = PyCapsule_GetPointer(image, "VkImage");

    }

    if (bindCount != NULL && bindCount != Py_None) {
        (self->base)->bindCount = (uint32_t) PyLong_AsLong(bindCount);
    }

    if (pBinds != NULL && pBinds != Py_None) {

        (self->base)->pBinds = (((PyVkSparseImageMemoryBind*)pBinds)->base);

    }

    return 0;
}
static PyTypeObject PyVkSparseImageMemoryBindInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkSparseImageMemoryBindInfo", sizeof(PyVkSparseImageMemoryBindInfo), 0,
    (destructor)PyVkSparseImageMemoryBindInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkSparseImageMemoryBindInfo object",0,0,0,0,0,0,0,0,
    PyVkSparseImageMemoryBindInfo_getsetters,0,0,0,0,0,(initproc)PyVkSparseImageMemoryBindInfo_init,0,PyVkSparseImageMemoryBindInfo_new,
};

static void PyVkBindSparseInfo_del(PyVkBindSparseInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkBindSparseInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkBindSparseInfo *self;
    self = (PyVkBindSparseInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkBindSparseInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkBindSparseInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkBindSparseInfo_getpNext(PyVkBindSparseInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkBindSparseInfo_getwaitSemaphoreCount(PyVkBindSparseInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->waitSemaphoreCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkBindSparseInfo_getbufferBindCount(PyVkBindSparseInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->bufferBindCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkBindSparseInfo_getimageOpaqueBindCount(PyVkBindSparseInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->imageOpaqueBindCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkBindSparseInfo_getimageBindCount(PyVkBindSparseInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->imageBindCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkBindSparseInfo_getsignalSemaphoreCount(PyVkBindSparseInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->signalSemaphoreCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkBindSparseInfo_getsetters[] = {

    { "pNext", (getter)PyVkBindSparseInfo_getpNext, NULL, "", NULL},

    { "waitSemaphoreCount", (getter)PyVkBindSparseInfo_getwaitSemaphoreCount, NULL, "", NULL},

    { "bufferBindCount", (getter)PyVkBindSparseInfo_getbufferBindCount, NULL, "", NULL},

    { "imageOpaqueBindCount", (getter)PyVkBindSparseInfo_getimageOpaqueBindCount, NULL, "", NULL},

    { "imageBindCount", (getter)PyVkBindSparseInfo_getimageBindCount, NULL, "", NULL},

    { "signalSemaphoreCount", (getter)PyVkBindSparseInfo_getsignalSemaphoreCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkBindSparseInfo_init(PyVkBindSparseInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* waitSemaphoreCount = NULL;
    PyObject* pWaitSemaphores = NULL;
    PyObject* bufferBindCount = NULL;
    PyObject* pBufferBinds = NULL;
    PyObject* imageOpaqueBindCount = NULL;
    PyObject* pImageOpaqueBinds = NULL;
    PyObject* imageBindCount = NULL;
    PyObject* pImageBinds = NULL;
    PyObject* signalSemaphoreCount = NULL;
    PyObject* pSignalSemaphores = NULL;
    static char *kwlist[] = {"waitSemaphoreCount","pWaitSemaphores","bufferBindCount","pBufferBinds","imageOpaqueBindCount","pImageOpaqueBinds","imageBindCount","pImageBinds","signalSemaphoreCount","pSignalSemaphores",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOOOO", kwlist, &waitSemaphoreCount, &pWaitSemaphores, &bufferBindCount, &pBufferBinds, &imageOpaqueBindCount, &pImageOpaqueBinds, &imageBindCount, &pImageBinds, &signalSemaphoreCount, &pSignalSemaphores)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_BIND_SPARSE_INFO;

    (self->base)->pNext = NULL;

    if (waitSemaphoreCount != NULL && waitSemaphoreCount != Py_None) {
        (self->base)->waitSemaphoreCount = (uint32_t) PyLong_AsLong(waitSemaphoreCount);
    }

    if (pWaitSemaphores != NULL && pWaitSemaphores != Py_None) {

        (self->base)->pWaitSemaphores = PyCapsule_GetPointer(pWaitSemaphores, "VkSemaphore");

    }

    if (bufferBindCount != NULL && bufferBindCount != Py_None) {
        (self->base)->bufferBindCount = (uint32_t) PyLong_AsLong(bufferBindCount);
    }

    if (pBufferBinds != NULL && pBufferBinds != Py_None) {

        (self->base)->pBufferBinds = (((PyVkSparseBufferMemoryBindInfo*)pBufferBinds)->base);

    }

    if (imageOpaqueBindCount != NULL && imageOpaqueBindCount != Py_None) {
        (self->base)->imageOpaqueBindCount = (uint32_t) PyLong_AsLong(imageOpaqueBindCount);
    }

    if (pImageOpaqueBinds != NULL && pImageOpaqueBinds != Py_None) {

        (self->base)->pImageOpaqueBinds = (((PyVkSparseImageOpaqueMemoryBindInfo*)pImageOpaqueBinds)->base);

    }

    if (imageBindCount != NULL && imageBindCount != Py_None) {
        (self->base)->imageBindCount = (uint32_t) PyLong_AsLong(imageBindCount);
    }

    if (pImageBinds != NULL && pImageBinds != Py_None) {

        (self->base)->pImageBinds = (((PyVkSparseImageMemoryBindInfo*)pImageBinds)->base);

    }

    if (signalSemaphoreCount != NULL && signalSemaphoreCount != Py_None) {
        (self->base)->signalSemaphoreCount = (uint32_t) PyLong_AsLong(signalSemaphoreCount);
    }

    if (pSignalSemaphores != NULL && pSignalSemaphores != Py_None) {

        (self->base)->pSignalSemaphores = PyCapsule_GetPointer(pSignalSemaphores, "VkSemaphore");

    }

    return 0;
}
static PyTypeObject PyVkBindSparseInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkBindSparseInfo", sizeof(PyVkBindSparseInfo), 0,
    (destructor)PyVkBindSparseInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkBindSparseInfo object",0,0,0,0,0,0,0,0,
    PyVkBindSparseInfo_getsetters,0,0,0,0,0,(initproc)PyVkBindSparseInfo_init,0,PyVkBindSparseInfo_new,
};

static void PyVkImageCopy_del(PyVkImageCopy* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkImageCopy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkImageCopy *self;
    self = (PyVkImageCopy *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkImageCopy));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageCopy");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkImageCopy_getsetters[] = {
    {NULL}
};

static int
PyVkImageCopy_init(PyVkImageCopy *self, PyObject *args, PyObject *kwds) {
    PyObject* srcSubresource = NULL;
    PyObject* srcOffset = NULL;
    PyObject* dstSubresource = NULL;
    PyObject* dstOffset = NULL;
    PyObject* extent = NULL;
    static char *kwlist[] = {"srcSubresource","srcOffset","dstSubresource","dstOffset","extent",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &srcSubresource, &srcOffset, &dstSubresource, &dstOffset, &extent)) return -1;

    if (srcSubresource != NULL && srcSubresource != Py_None) {

        (self->base)->srcSubresource = *(((PyVkImageSubresourceLayers*)srcSubresource)->base);

    }

    if (srcOffset != NULL && srcOffset != Py_None) {

        (self->base)->srcOffset = *(((PyVkOffset3D*)srcOffset)->base);

    }

    if (dstSubresource != NULL && dstSubresource != Py_None) {

        (self->base)->dstSubresource = *(((PyVkImageSubresourceLayers*)dstSubresource)->base);

    }

    if (dstOffset != NULL && dstOffset != Py_None) {

        (self->base)->dstOffset = *(((PyVkOffset3D*)dstOffset)->base);

    }

    if (extent != NULL && extent != Py_None) {

        (self->base)->extent = *(((PyVkExtent3D*)extent)->base);

    }

    return 0;
}
static PyTypeObject PyVkImageCopyType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkImageCopy", sizeof(PyVkImageCopy), 0,
    (destructor)PyVkImageCopy_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkImageCopy object",0,0,0,0,0,0,0,0,
    PyVkImageCopy_getsetters,0,0,0,0,0,(initproc)PyVkImageCopy_init,0,PyVkImageCopy_new,
};

static void PyVkImageBlit_del(PyVkImageBlit* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkImageBlit_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkImageBlit *self;
    self = (PyVkImageBlit *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkImageBlit));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageBlit");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkImageBlit_getsetters[] = {
    {NULL}
};

static int
PyVkImageBlit_init(PyVkImageBlit *self, PyObject *args, PyObject *kwds) {
    PyObject* srcSubresource = NULL;
    PyObject* srcOffsets = NULL;
    PyObject* dstSubresource = NULL;
    PyObject* dstOffsets = NULL;
    static char *kwlist[] = {"srcSubresource","srcOffsets","dstSubresource","dstOffsets",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &srcSubresource, &srcOffsets, &dstSubresource, &dstOffsets)) return -1;

    if (srcSubresource != NULL && srcSubresource != Py_None) {

        (self->base)->srcSubresource = *(((PyVkImageSubresourceLayers*)srcSubresource)->base);

    }

    if (srcOffsets != NULL && srcOffsets != Py_None) {

        int tmp71520759 = PyList_Size(srcOffsets);
        int tmp74174820;
        for (tmp74174820 = 0; tmp74174820 < tmp71520759; tmp74174820++) {
            PyObject* tmp = PyList_GetItem(srcOffsets, tmp74174820);
            ((self->base)->srcOffsets)[tmp74174820] = *(((PyVkOffset3D*)tmp)->base);
        }

    }

    if (dstSubresource != NULL && dstSubresource != Py_None) {

        (self->base)->dstSubresource = *(((PyVkImageSubresourceLayers*)dstSubresource)->base);

    }

    if (dstOffsets != NULL && dstOffsets != Py_None) {

        int tmp45884753 = PyList_Size(dstOffsets);
        int tmp82824408;
        for (tmp82824408 = 0; tmp82824408 < tmp45884753; tmp82824408++) {
            PyObject* tmp = PyList_GetItem(dstOffsets, tmp82824408);
            ((self->base)->dstOffsets)[tmp82824408] = *(((PyVkOffset3D*)tmp)->base);
        }

    }

    return 0;
}
static PyTypeObject PyVkImageBlitType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkImageBlit", sizeof(PyVkImageBlit), 0,
    (destructor)PyVkImageBlit_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkImageBlit object",0,0,0,0,0,0,0,0,
    PyVkImageBlit_getsetters,0,0,0,0,0,(initproc)PyVkImageBlit_init,0,PyVkImageBlit_new,
};

static void PyVkBufferImageCopy_del(PyVkBufferImageCopy* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkBufferImageCopy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkBufferImageCopy *self;
    self = (PyVkBufferImageCopy *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkBufferImageCopy));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkBufferImageCopy");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkBufferImageCopy_getbufferRowLength(PyVkBufferImageCopy *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->bufferRowLength);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkBufferImageCopy_getbufferImageHeight(PyVkBufferImageCopy *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->bufferImageHeight);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkBufferImageCopy_getsetters[] = {

    { "bufferRowLength", (getter)PyVkBufferImageCopy_getbufferRowLength, NULL, "", NULL},

    { "bufferImageHeight", (getter)PyVkBufferImageCopy_getbufferImageHeight, NULL, "", NULL},
    {NULL}
};

static int
PyVkBufferImageCopy_init(PyVkBufferImageCopy *self, PyObject *args, PyObject *kwds) {
    PyObject* bufferOffset = NULL;
    PyObject* bufferRowLength = NULL;
    PyObject* bufferImageHeight = NULL;
    PyObject* imageSubresource = NULL;
    PyObject* imageOffset = NULL;
    PyObject* imageExtent = NULL;
    static char *kwlist[] = {"bufferOffset","bufferRowLength","bufferImageHeight","imageSubresource","imageOffset","imageExtent",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &bufferOffset, &bufferRowLength, &bufferImageHeight, &imageSubresource, &imageOffset, &imageExtent)) return -1;

    if (bufferOffset != NULL && bufferOffset != Py_None) {

        (self->base)->bufferOffset = PyLong_AsLong(bufferOffset);

    }

    if (bufferRowLength != NULL && bufferRowLength != Py_None) {
        (self->base)->bufferRowLength = (uint32_t) PyLong_AsLong(bufferRowLength);
    }

    if (bufferImageHeight != NULL && bufferImageHeight != Py_None) {
        (self->base)->bufferImageHeight = (uint32_t) PyLong_AsLong(bufferImageHeight);
    }

    if (imageSubresource != NULL && imageSubresource != Py_None) {

        (self->base)->imageSubresource = *(((PyVkImageSubresourceLayers*)imageSubresource)->base);

    }

    if (imageOffset != NULL && imageOffset != Py_None) {

        (self->base)->imageOffset = *(((PyVkOffset3D*)imageOffset)->base);

    }

    if (imageExtent != NULL && imageExtent != Py_None) {

        (self->base)->imageExtent = *(((PyVkExtent3D*)imageExtent)->base);

    }

    return 0;
}
static PyTypeObject PyVkBufferImageCopyType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkBufferImageCopy", sizeof(PyVkBufferImageCopy), 0,
    (destructor)PyVkBufferImageCopy_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkBufferImageCopy object",0,0,0,0,0,0,0,0,
    PyVkBufferImageCopy_getsetters,0,0,0,0,0,(initproc)PyVkBufferImageCopy_init,0,PyVkBufferImageCopy_new,
};

static void PyVkImageResolve_del(PyVkImageResolve* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkImageResolve_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkImageResolve *self;
    self = (PyVkImageResolve *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkImageResolve));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImageResolve");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkImageResolve_getsetters[] = {
    {NULL}
};

static int
PyVkImageResolve_init(PyVkImageResolve *self, PyObject *args, PyObject *kwds) {
    PyObject* srcSubresource = NULL;
    PyObject* srcOffset = NULL;
    PyObject* dstSubresource = NULL;
    PyObject* dstOffset = NULL;
    PyObject* extent = NULL;
    static char *kwlist[] = {"srcSubresource","srcOffset","dstSubresource","dstOffset","extent",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &srcSubresource, &srcOffset, &dstSubresource, &dstOffset, &extent)) return -1;

    if (srcSubresource != NULL && srcSubresource != Py_None) {

        (self->base)->srcSubresource = *(((PyVkImageSubresourceLayers*)srcSubresource)->base);

    }

    if (srcOffset != NULL && srcOffset != Py_None) {

        (self->base)->srcOffset = *(((PyVkOffset3D*)srcOffset)->base);

    }

    if (dstSubresource != NULL && dstSubresource != Py_None) {

        (self->base)->dstSubresource = *(((PyVkImageSubresourceLayers*)dstSubresource)->base);

    }

    if (dstOffset != NULL && dstOffset != Py_None) {

        (self->base)->dstOffset = *(((PyVkOffset3D*)dstOffset)->base);

    }

    if (extent != NULL && extent != Py_None) {

        (self->base)->extent = *(((PyVkExtent3D*)extent)->base);

    }

    return 0;
}
static PyTypeObject PyVkImageResolveType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkImageResolve", sizeof(PyVkImageResolve), 0,
    (destructor)PyVkImageResolve_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkImageResolve object",0,0,0,0,0,0,0,0,
    PyVkImageResolve_getsetters,0,0,0,0,0,(initproc)PyVkImageResolve_init,0,PyVkImageResolve_new,
};

static void PyVkShaderModuleCreateInfo_del(PyVkShaderModuleCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkShaderModuleCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkShaderModuleCreateInfo *self;
    self = (PyVkShaderModuleCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkShaderModuleCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkShaderModuleCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkShaderModuleCreateInfo_getpNext(PyVkShaderModuleCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkShaderModuleCreateInfo_getcodeSize(PyVkShaderModuleCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->codeSize);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkShaderModuleCreateInfo_getpCode(PyVkShaderModuleCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (*((self->base)->pCode)));
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkShaderModuleCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkShaderModuleCreateInfo_getpNext, NULL, "", NULL},

    { "codeSize", (getter)PyVkShaderModuleCreateInfo_getcodeSize, NULL, "", NULL},

    { "pCode", (getter)PyVkShaderModuleCreateInfo_getpCode, NULL, "", NULL},
    {NULL}
};

static int
PyVkShaderModuleCreateInfo_init(PyVkShaderModuleCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* codeSize = NULL;
    PyObject* pCode = NULL;
    static char *kwlist[] = {"flags","codeSize","pCode",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &flags, &codeSize, &pCode)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (codeSize != NULL && codeSize != Py_None) {
        (self->base)->codeSize = (size_t) PyLong_AsLong(codeSize);
    }

    if (pCode != NULL && pCode != Py_None) {

        uint32_t tmp62142653 = (uint32_t) PyLong_AsLong(pCode);
        uint32_t *tmp10924274 = malloc(sizeof(uint32_t));
        memcpy(tmp10924274, &tmp62142653, sizeof(uint32_t));
        (self->base)->pCode = tmp10924274;

    }

    return 0;
}
static PyTypeObject PyVkShaderModuleCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkShaderModuleCreateInfo", sizeof(PyVkShaderModuleCreateInfo), 0,
    (destructor)PyVkShaderModuleCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkShaderModuleCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkShaderModuleCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkShaderModuleCreateInfo_init,0,PyVkShaderModuleCreateInfo_new,
};

static void PyVkDescriptorSetLayoutBinding_del(PyVkDescriptorSetLayoutBinding* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDescriptorSetLayoutBinding_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDescriptorSetLayoutBinding *self;
    self = (PyVkDescriptorSetLayoutBinding *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDescriptorSetLayoutBinding));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDescriptorSetLayoutBinding");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDescriptorSetLayoutBinding_getbinding(PyVkDescriptorSetLayoutBinding *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->binding);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDescriptorSetLayoutBinding_getdescriptorCount(PyVkDescriptorSetLayoutBinding *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->descriptorCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDescriptorSetLayoutBinding_getsetters[] = {

    { "binding", (getter)PyVkDescriptorSetLayoutBinding_getbinding, NULL, "", NULL},

    { "descriptorCount", (getter)PyVkDescriptorSetLayoutBinding_getdescriptorCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkDescriptorSetLayoutBinding_init(PyVkDescriptorSetLayoutBinding *self, PyObject *args, PyObject *kwds) {
    PyObject* binding = NULL;
    PyObject* descriptorType = NULL;
    PyObject* descriptorCount = NULL;
    PyObject* stageFlags = NULL;
    PyObject* pImmutableSamplers = NULL;
    static char *kwlist[] = {"binding","descriptorType","descriptorCount","stageFlags","pImmutableSamplers",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &binding, &descriptorType, &descriptorCount, &stageFlags, &pImmutableSamplers)) return -1;

    if (binding != NULL && binding != Py_None) {
        (self->base)->binding = (uint32_t) PyLong_AsLong(binding);
    }

    if (descriptorType != NULL && descriptorType != Py_None) {

        (self->base)->descriptorType = PyLong_AsLong(descriptorType);

    }

    if (descriptorCount != NULL && descriptorCount != Py_None) {
        (self->base)->descriptorCount = (uint32_t) PyLong_AsLong(descriptorCount);
    }

    if (stageFlags != NULL && stageFlags != Py_None) {

        (self->base)->stageFlags = PyLong_AsLong(stageFlags);

    }

    if (pImmutableSamplers != NULL && pImmutableSamplers != Py_None) {

        (self->base)->pImmutableSamplers = PyCapsule_GetPointer(pImmutableSamplers, "VkSampler");

    }

    return 0;
}
static PyTypeObject PyVkDescriptorSetLayoutBindingType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDescriptorSetLayoutBinding", sizeof(PyVkDescriptorSetLayoutBinding), 0,
    (destructor)PyVkDescriptorSetLayoutBinding_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDescriptorSetLayoutBinding object",0,0,0,0,0,0,0,0,
    PyVkDescriptorSetLayoutBinding_getsetters,0,0,0,0,0,(initproc)PyVkDescriptorSetLayoutBinding_init,0,PyVkDescriptorSetLayoutBinding_new,
};

static void PyVkDescriptorSetLayoutCreateInfo_del(PyVkDescriptorSetLayoutCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDescriptorSetLayoutCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDescriptorSetLayoutCreateInfo *self;
    self = (PyVkDescriptorSetLayoutCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDescriptorSetLayoutCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDescriptorSetLayoutCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDescriptorSetLayoutCreateInfo_getpNext(PyVkDescriptorSetLayoutCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDescriptorSetLayoutCreateInfo_getbindingCount(PyVkDescriptorSetLayoutCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->bindingCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDescriptorSetLayoutCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkDescriptorSetLayoutCreateInfo_getpNext, NULL, "", NULL},

    { "bindingCount", (getter)PyVkDescriptorSetLayoutCreateInfo_getbindingCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkDescriptorSetLayoutCreateInfo_init(PyVkDescriptorSetLayoutCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* bindingCount = NULL;
    PyObject* pBindings = NULL;
    static char *kwlist[] = {"flags","bindingCount","pBindings",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &flags, &bindingCount, &pBindings)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (bindingCount != NULL && bindingCount != Py_None) {
        (self->base)->bindingCount = (uint32_t) PyLong_AsLong(bindingCount);
    }

    if (pBindings != NULL && pBindings != Py_None) {

        (self->base)->pBindings = (((PyVkDescriptorSetLayoutBinding*)pBindings)->base);

    }

    return 0;
}
static PyTypeObject PyVkDescriptorSetLayoutCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDescriptorSetLayoutCreateInfo", sizeof(PyVkDescriptorSetLayoutCreateInfo), 0,
    (destructor)PyVkDescriptorSetLayoutCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDescriptorSetLayoutCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkDescriptorSetLayoutCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkDescriptorSetLayoutCreateInfo_init,0,PyVkDescriptorSetLayoutCreateInfo_new,
};

static void PyVkDescriptorPoolSize_del(PyVkDescriptorPoolSize* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDescriptorPoolSize_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDescriptorPoolSize *self;
    self = (PyVkDescriptorPoolSize *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDescriptorPoolSize));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDescriptorPoolSize");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDescriptorPoolSize_getdescriptorCount(PyVkDescriptorPoolSize *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->descriptorCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDescriptorPoolSize_getsetters[] = {

    { "descriptorCount", (getter)PyVkDescriptorPoolSize_getdescriptorCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkDescriptorPoolSize_init(PyVkDescriptorPoolSize *self, PyObject *args, PyObject *kwds) {
    PyObject* type = NULL;
    PyObject* descriptorCount = NULL;
    static char *kwlist[] = {"type","descriptorCount",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &type, &descriptorCount)) return -1;

    if (type != NULL && type != Py_None) {

        (self->base)->type = PyLong_AsLong(type);

    }

    if (descriptorCount != NULL && descriptorCount != Py_None) {
        (self->base)->descriptorCount = (uint32_t) PyLong_AsLong(descriptorCount);
    }

    return 0;
}
static PyTypeObject PyVkDescriptorPoolSizeType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDescriptorPoolSize", sizeof(PyVkDescriptorPoolSize), 0,
    (destructor)PyVkDescriptorPoolSize_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDescriptorPoolSize object",0,0,0,0,0,0,0,0,
    PyVkDescriptorPoolSize_getsetters,0,0,0,0,0,(initproc)PyVkDescriptorPoolSize_init,0,PyVkDescriptorPoolSize_new,
};

static void PyVkDescriptorPoolCreateInfo_del(PyVkDescriptorPoolCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDescriptorPoolCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDescriptorPoolCreateInfo *self;
    self = (PyVkDescriptorPoolCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDescriptorPoolCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDescriptorPoolCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDescriptorPoolCreateInfo_getpNext(PyVkDescriptorPoolCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDescriptorPoolCreateInfo_getmaxSets(PyVkDescriptorPoolCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxSets);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDescriptorPoolCreateInfo_getpoolSizeCount(PyVkDescriptorPoolCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->poolSizeCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDescriptorPoolCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkDescriptorPoolCreateInfo_getpNext, NULL, "", NULL},

    { "maxSets", (getter)PyVkDescriptorPoolCreateInfo_getmaxSets, NULL, "", NULL},

    { "poolSizeCount", (getter)PyVkDescriptorPoolCreateInfo_getpoolSizeCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkDescriptorPoolCreateInfo_init(PyVkDescriptorPoolCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* maxSets = NULL;
    PyObject* poolSizeCount = NULL;
    PyObject* pPoolSizes = NULL;
    static char *kwlist[] = {"flags","maxSets","poolSizeCount","pPoolSizes",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &flags, &maxSets, &poolSizeCount, &pPoolSizes)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (maxSets != NULL && maxSets != Py_None) {
        (self->base)->maxSets = (uint32_t) PyLong_AsLong(maxSets);
    }

    if (poolSizeCount != NULL && poolSizeCount != Py_None) {
        (self->base)->poolSizeCount = (uint32_t) PyLong_AsLong(poolSizeCount);
    }

    if (pPoolSizes != NULL && pPoolSizes != Py_None) {

        (self->base)->pPoolSizes = (((PyVkDescriptorPoolSize*)pPoolSizes)->base);

    }

    return 0;
}
static PyTypeObject PyVkDescriptorPoolCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDescriptorPoolCreateInfo", sizeof(PyVkDescriptorPoolCreateInfo), 0,
    (destructor)PyVkDescriptorPoolCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDescriptorPoolCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkDescriptorPoolCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkDescriptorPoolCreateInfo_init,0,PyVkDescriptorPoolCreateInfo_new,
};

static void PyVkDescriptorSetAllocateInfo_del(PyVkDescriptorSetAllocateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDescriptorSetAllocateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDescriptorSetAllocateInfo *self;
    self = (PyVkDescriptorSetAllocateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDescriptorSetAllocateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDescriptorSetAllocateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDescriptorSetAllocateInfo_getpNext(PyVkDescriptorSetAllocateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDescriptorSetAllocateInfo_getdescriptorSetCount(PyVkDescriptorSetAllocateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->descriptorSetCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDescriptorSetAllocateInfo_getsetters[] = {

    { "pNext", (getter)PyVkDescriptorSetAllocateInfo_getpNext, NULL, "", NULL},

    { "descriptorSetCount", (getter)PyVkDescriptorSetAllocateInfo_getdescriptorSetCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkDescriptorSetAllocateInfo_init(PyVkDescriptorSetAllocateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* descriptorPool = NULL;
    PyObject* descriptorSetCount = NULL;
    PyObject* pSetLayouts = NULL;
    static char *kwlist[] = {"descriptorPool","descriptorSetCount","pSetLayouts",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &descriptorPool, &descriptorSetCount, &pSetLayouts)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;

    (self->base)->pNext = NULL;

    if (descriptorPool != NULL && descriptorPool != Py_None) {

        (self->base)->descriptorPool = PyCapsule_GetPointer(descriptorPool, "VkDescriptorPool");

    }

    if (descriptorSetCount != NULL && descriptorSetCount != Py_None) {
        (self->base)->descriptorSetCount = (uint32_t) PyLong_AsLong(descriptorSetCount);
    }

    if (pSetLayouts != NULL && pSetLayouts != Py_None) {

        (self->base)->pSetLayouts = PyCapsule_GetPointer(pSetLayouts, "VkDescriptorSetLayout");

    }

    return 0;
}
static PyTypeObject PyVkDescriptorSetAllocateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDescriptorSetAllocateInfo", sizeof(PyVkDescriptorSetAllocateInfo), 0,
    (destructor)PyVkDescriptorSetAllocateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDescriptorSetAllocateInfo object",0,0,0,0,0,0,0,0,
    PyVkDescriptorSetAllocateInfo_getsetters,0,0,0,0,0,(initproc)PyVkDescriptorSetAllocateInfo_init,0,PyVkDescriptorSetAllocateInfo_new,
};

static void PyVkSpecializationMapEntry_del(PyVkSpecializationMapEntry* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkSpecializationMapEntry_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkSpecializationMapEntry *self;
    self = (PyVkSpecializationMapEntry *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkSpecializationMapEntry));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSpecializationMapEntry");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkSpecializationMapEntry_getconstantID(PyVkSpecializationMapEntry *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->constantID);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSpecializationMapEntry_getoffset(PyVkSpecializationMapEntry *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->offset);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSpecializationMapEntry_getsize(PyVkSpecializationMapEntry *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->size);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkSpecializationMapEntry_getsetters[] = {

    { "constantID", (getter)PyVkSpecializationMapEntry_getconstantID, NULL, "", NULL},

    { "offset", (getter)PyVkSpecializationMapEntry_getoffset, NULL, "", NULL},

    { "size", (getter)PyVkSpecializationMapEntry_getsize, NULL, "", NULL},
    {NULL}
};

static int
PyVkSpecializationMapEntry_init(PyVkSpecializationMapEntry *self, PyObject *args, PyObject *kwds) {
    PyObject* constantID = NULL;
    PyObject* offset = NULL;
    PyObject* size = NULL;
    static char *kwlist[] = {"constantID","offset","size",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &constantID, &offset, &size)) return -1;

    if (constantID != NULL && constantID != Py_None) {
        (self->base)->constantID = (uint32_t) PyLong_AsLong(constantID);
    }

    if (offset != NULL && offset != Py_None) {
        (self->base)->offset = (uint32_t) PyLong_AsLong(offset);
    }

    if (size != NULL && size != Py_None) {
        (self->base)->size = (size_t) PyLong_AsLong(size);
    }

    return 0;
}
static PyTypeObject PyVkSpecializationMapEntryType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkSpecializationMapEntry", sizeof(PyVkSpecializationMapEntry), 0,
    (destructor)PyVkSpecializationMapEntry_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkSpecializationMapEntry object",0,0,0,0,0,0,0,0,
    PyVkSpecializationMapEntry_getsetters,0,0,0,0,0,(initproc)PyVkSpecializationMapEntry_init,0,PyVkSpecializationMapEntry_new,
};

static void PyVkSpecializationInfo_del(PyVkSpecializationInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkSpecializationInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkSpecializationInfo *self;
    self = (PyVkSpecializationInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkSpecializationInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSpecializationInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkSpecializationInfo_getmapEntryCount(PyVkSpecializationInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->mapEntryCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSpecializationInfo_getdataSize(PyVkSpecializationInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->dataSize);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSpecializationInfo_getpData(PyVkSpecializationInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkSpecializationInfo_getsetters[] = {

    { "mapEntryCount", (getter)PyVkSpecializationInfo_getmapEntryCount, NULL, "", NULL},

    { "dataSize", (getter)PyVkSpecializationInfo_getdataSize, NULL, "", NULL},

    { "pData", (getter)PyVkSpecializationInfo_getpData, NULL, "", NULL},
    {NULL}
};

static int
PyVkSpecializationInfo_init(PyVkSpecializationInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* mapEntryCount = NULL;
    PyObject* pMapEntries = NULL;
    PyObject* dataSize = NULL;
    PyObject* pData = NULL;
    static char *kwlist[] = {"mapEntryCount","pMapEntries","dataSize","pData",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &mapEntryCount, &pMapEntries, &dataSize, &pData)) return -1;

    if (mapEntryCount != NULL && mapEntryCount != Py_None) {
        (self->base)->mapEntryCount = (uint32_t) PyLong_AsLong(mapEntryCount);
    }

    if (pMapEntries != NULL && pMapEntries != Py_None) {

        (self->base)->pMapEntries = (((PyVkSpecializationMapEntry*)pMapEntries)->base);

    }

    if (dataSize != NULL && dataSize != Py_None) {
        (self->base)->dataSize = (size_t) PyLong_AsLong(dataSize);
    }

    if (pData != NULL && pData != Py_None) {
        (self->base)->pData = NULL;
    }

    return 0;
}
static PyTypeObject PyVkSpecializationInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkSpecializationInfo", sizeof(PyVkSpecializationInfo), 0,
    (destructor)PyVkSpecializationInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkSpecializationInfo object",0,0,0,0,0,0,0,0,
    PyVkSpecializationInfo_getsetters,0,0,0,0,0,(initproc)PyVkSpecializationInfo_init,0,PyVkSpecializationInfo_new,
};

static void PyVkPipelineShaderStageCreateInfo_del(PyVkPipelineShaderStageCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPipelineShaderStageCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPipelineShaderStageCreateInfo *self;
    self = (PyVkPipelineShaderStageCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPipelineShaderStageCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineShaderStageCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkPipelineShaderStageCreateInfo_getpNext(PyVkPipelineShaderStageCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineShaderStageCreateInfo_getpName(PyVkPipelineShaderStageCreateInfo *self, void *closure) {
    PyObject* value = PyUnicode_FromString((const char *) (self->base)->pName);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkPipelineShaderStageCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkPipelineShaderStageCreateInfo_getpNext, NULL, "", NULL},

    { "pName", (getter)PyVkPipelineShaderStageCreateInfo_getpName, NULL, "", NULL},
    {NULL}
};

static int
PyVkPipelineShaderStageCreateInfo_init(PyVkPipelineShaderStageCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* stage = NULL;
    PyObject* module = NULL;
    PyObject* pName = NULL;
    PyObject* pSpecializationInfo = NULL;
    static char *kwlist[] = {"flags","stage","module","pName","pSpecializationInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &flags, &stage, &module, &pName, &pSpecializationInfo)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (stage != NULL && stage != Py_None) {

        (self->base)->stage = PyLong_AsLong(stage);

    }

    if (module != NULL && module != Py_None) {

        (self->base)->module = PyCapsule_GetPointer(module, "VkShaderModule");

    }

    if (pName != NULL && pName != Py_None) {

        if (pName == Py_None) {
            (self->base)->pName = NULL;
        }
        else {
            PyObject * tmp32539244 = PyUnicode_AsASCIIString(pName);
            char* tmp96435442 = PyBytes_AsString(tmp32539244);
            char* tmp86714592 = strdup(tmp96435442);
            (self->base)->pName = tmp86714592;
            Py_DECREF(tmp32539244);
        }

    }

    if (pSpecializationInfo != NULL && pSpecializationInfo != Py_None) {

        (self->base)->pSpecializationInfo = (((PyVkSpecializationInfo*)pSpecializationInfo)->base);

    }

    return 0;
}
static PyTypeObject PyVkPipelineShaderStageCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPipelineShaderStageCreateInfo", sizeof(PyVkPipelineShaderStageCreateInfo), 0,
    (destructor)PyVkPipelineShaderStageCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPipelineShaderStageCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkPipelineShaderStageCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineShaderStageCreateInfo_init,0,PyVkPipelineShaderStageCreateInfo_new,
};

static void PyVkComputePipelineCreateInfo_del(PyVkComputePipelineCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkComputePipelineCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkComputePipelineCreateInfo *self;
    self = (PyVkComputePipelineCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkComputePipelineCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkComputePipelineCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkComputePipelineCreateInfo_getpNext(PyVkComputePipelineCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkComputePipelineCreateInfo_getbasePipelineIndex(PyVkComputePipelineCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->basePipelineIndex);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkComputePipelineCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkComputePipelineCreateInfo_getpNext, NULL, "", NULL},

    { "basePipelineIndex", (getter)PyVkComputePipelineCreateInfo_getbasePipelineIndex, NULL, "", NULL},
    {NULL}
};

static int
PyVkComputePipelineCreateInfo_init(PyVkComputePipelineCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* stage = NULL;
    PyObject* layout = NULL;
    PyObject* basePipelineHandle = NULL;
    PyObject* basePipelineIndex = NULL;
    static char *kwlist[] = {"flags","stage","layout","basePipelineHandle","basePipelineIndex",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &flags, &stage, &layout, &basePipelineHandle, &basePipelineIndex)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (stage != NULL && stage != Py_None) {

        (self->base)->stage = *(((PyVkPipelineShaderStageCreateInfo*)stage)->base);

    }

    if (layout != NULL && layout != Py_None) {

        (self->base)->layout = PyCapsule_GetPointer(layout, "VkPipelineLayout");

    }

    if (basePipelineHandle != NULL && basePipelineHandle != Py_None) {

        (self->base)->basePipelineHandle = PyCapsule_GetPointer(basePipelineHandle, "VkPipeline");

    }

    if (basePipelineIndex != NULL && basePipelineIndex != Py_None) {
        (self->base)->basePipelineIndex = (int32_t) PyLong_AsLong(basePipelineIndex);
    }

    return 0;
}
static PyTypeObject PyVkComputePipelineCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkComputePipelineCreateInfo", sizeof(PyVkComputePipelineCreateInfo), 0,
    (destructor)PyVkComputePipelineCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkComputePipelineCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkComputePipelineCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkComputePipelineCreateInfo_init,0,PyVkComputePipelineCreateInfo_new,
};

static void PyVkVertexInputBindingDescription_del(PyVkVertexInputBindingDescription* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkVertexInputBindingDescription_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkVertexInputBindingDescription *self;
    self = (PyVkVertexInputBindingDescription *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkVertexInputBindingDescription));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkVertexInputBindingDescription");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkVertexInputBindingDescription_getbinding(PyVkVertexInputBindingDescription *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->binding);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkVertexInputBindingDescription_getstride(PyVkVertexInputBindingDescription *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->stride);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkVertexInputBindingDescription_getsetters[] = {

    { "binding", (getter)PyVkVertexInputBindingDescription_getbinding, NULL, "", NULL},

    { "stride", (getter)PyVkVertexInputBindingDescription_getstride, NULL, "", NULL},
    {NULL}
};

static int
PyVkVertexInputBindingDescription_init(PyVkVertexInputBindingDescription *self, PyObject *args, PyObject *kwds) {
    PyObject* binding = NULL;
    PyObject* stride = NULL;
    PyObject* inputRate = NULL;
    static char *kwlist[] = {"binding","stride","inputRate",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &binding, &stride, &inputRate)) return -1;

    if (binding != NULL && binding != Py_None) {
        (self->base)->binding = (uint32_t) PyLong_AsLong(binding);
    }

    if (stride != NULL && stride != Py_None) {
        (self->base)->stride = (uint32_t) PyLong_AsLong(stride);
    }

    if (inputRate != NULL && inputRate != Py_None) {

        (self->base)->inputRate = PyLong_AsLong(inputRate);

    }

    return 0;
}
static PyTypeObject PyVkVertexInputBindingDescriptionType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkVertexInputBindingDescription", sizeof(PyVkVertexInputBindingDescription), 0,
    (destructor)PyVkVertexInputBindingDescription_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkVertexInputBindingDescription object",0,0,0,0,0,0,0,0,
    PyVkVertexInputBindingDescription_getsetters,0,0,0,0,0,(initproc)PyVkVertexInputBindingDescription_init,0,PyVkVertexInputBindingDescription_new,
};

static void PyVkVertexInputAttributeDescription_del(PyVkVertexInputAttributeDescription* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkVertexInputAttributeDescription_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkVertexInputAttributeDescription *self;
    self = (PyVkVertexInputAttributeDescription *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkVertexInputAttributeDescription));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkVertexInputAttributeDescription");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkVertexInputAttributeDescription_getlocation(PyVkVertexInputAttributeDescription *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->location);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkVertexInputAttributeDescription_getbinding(PyVkVertexInputAttributeDescription *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->binding);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkVertexInputAttributeDescription_getoffset(PyVkVertexInputAttributeDescription *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->offset);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkVertexInputAttributeDescription_getsetters[] = {

    { "location", (getter)PyVkVertexInputAttributeDescription_getlocation, NULL, "", NULL},

    { "binding", (getter)PyVkVertexInputAttributeDescription_getbinding, NULL, "", NULL},

    { "offset", (getter)PyVkVertexInputAttributeDescription_getoffset, NULL, "", NULL},
    {NULL}
};

static int
PyVkVertexInputAttributeDescription_init(PyVkVertexInputAttributeDescription *self, PyObject *args, PyObject *kwds) {
    PyObject* location = NULL;
    PyObject* binding = NULL;
    PyObject* format = NULL;
    PyObject* offset = NULL;
    static char *kwlist[] = {"location","binding","format","offset",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &location, &binding, &format, &offset)) return -1;

    if (location != NULL && location != Py_None) {
        (self->base)->location = (uint32_t) PyLong_AsLong(location);
    }

    if (binding != NULL && binding != Py_None) {
        (self->base)->binding = (uint32_t) PyLong_AsLong(binding);
    }

    if (format != NULL && format != Py_None) {

        (self->base)->format = PyLong_AsLong(format);

    }

    if (offset != NULL && offset != Py_None) {
        (self->base)->offset = (uint32_t) PyLong_AsLong(offset);
    }

    return 0;
}
static PyTypeObject PyVkVertexInputAttributeDescriptionType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkVertexInputAttributeDescription", sizeof(PyVkVertexInputAttributeDescription), 0,
    (destructor)PyVkVertexInputAttributeDescription_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkVertexInputAttributeDescription object",0,0,0,0,0,0,0,0,
    PyVkVertexInputAttributeDescription_getsetters,0,0,0,0,0,(initproc)PyVkVertexInputAttributeDescription_init,0,PyVkVertexInputAttributeDescription_new,
};

static void PyVkPipelineVertexInputStateCreateInfo_del(PyVkPipelineVertexInputStateCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPipelineVertexInputStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPipelineVertexInputStateCreateInfo *self;
    self = (PyVkPipelineVertexInputStateCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPipelineVertexInputStateCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineVertexInputStateCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkPipelineVertexInputStateCreateInfo_getpNext(PyVkPipelineVertexInputStateCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineVertexInputStateCreateInfo_getvertexBindingDescriptionCount(PyVkPipelineVertexInputStateCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->vertexBindingDescriptionCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineVertexInputStateCreateInfo_getvertexAttributeDescriptionCount(PyVkPipelineVertexInputStateCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->vertexAttributeDescriptionCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkPipelineVertexInputStateCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkPipelineVertexInputStateCreateInfo_getpNext, NULL, "", NULL},

    { "vertexBindingDescriptionCount", (getter)PyVkPipelineVertexInputStateCreateInfo_getvertexBindingDescriptionCount, NULL, "", NULL},

    { "vertexAttributeDescriptionCount", (getter)PyVkPipelineVertexInputStateCreateInfo_getvertexAttributeDescriptionCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkPipelineVertexInputStateCreateInfo_init(PyVkPipelineVertexInputStateCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* vertexBindingDescriptionCount = NULL;
    PyObject* pVertexBindingDescriptions = NULL;
    PyObject* vertexAttributeDescriptionCount = NULL;
    PyObject* pVertexAttributeDescriptions = NULL;
    static char *kwlist[] = {"flags","vertexBindingDescriptionCount","pVertexBindingDescriptions","vertexAttributeDescriptionCount","pVertexAttributeDescriptions",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &flags, &vertexBindingDescriptionCount, &pVertexBindingDescriptions, &vertexAttributeDescriptionCount, &pVertexAttributeDescriptions)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (vertexBindingDescriptionCount != NULL && vertexBindingDescriptionCount != Py_None) {
        (self->base)->vertexBindingDescriptionCount = (uint32_t) PyLong_AsLong(vertexBindingDescriptionCount);
    }

    if (pVertexBindingDescriptions != NULL && pVertexBindingDescriptions != Py_None) {

        (self->base)->pVertexBindingDescriptions = (((PyVkVertexInputBindingDescription*)pVertexBindingDescriptions)->base);

    }

    if (vertexAttributeDescriptionCount != NULL && vertexAttributeDescriptionCount != Py_None) {
        (self->base)->vertexAttributeDescriptionCount = (uint32_t) PyLong_AsLong(vertexAttributeDescriptionCount);
    }

    if (pVertexAttributeDescriptions != NULL && pVertexAttributeDescriptions != Py_None) {

        (self->base)->pVertexAttributeDescriptions = (((PyVkVertexInputAttributeDescription*)pVertexAttributeDescriptions)->base);

    }

    return 0;
}
static PyTypeObject PyVkPipelineVertexInputStateCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPipelineVertexInputStateCreateInfo", sizeof(PyVkPipelineVertexInputStateCreateInfo), 0,
    (destructor)PyVkPipelineVertexInputStateCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPipelineVertexInputStateCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkPipelineVertexInputStateCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineVertexInputStateCreateInfo_init,0,PyVkPipelineVertexInputStateCreateInfo_new,
};

static void PyVkPipelineInputAssemblyStateCreateInfo_del(PyVkPipelineInputAssemblyStateCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPipelineInputAssemblyStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPipelineInputAssemblyStateCreateInfo *self;
    self = (PyVkPipelineInputAssemblyStateCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPipelineInputAssemblyStateCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineInputAssemblyStateCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkPipelineInputAssemblyStateCreateInfo_getpNext(PyVkPipelineInputAssemblyStateCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkPipelineInputAssemblyStateCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkPipelineInputAssemblyStateCreateInfo_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkPipelineInputAssemblyStateCreateInfo_init(PyVkPipelineInputAssemblyStateCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* topology = NULL;
    PyObject* primitiveRestartEnable = NULL;
    static char *kwlist[] = {"flags","topology","primitiveRestartEnable",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &flags, &topology, &primitiveRestartEnable)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (topology != NULL && topology != Py_None) {

        (self->base)->topology = PyLong_AsLong(topology);

    }

    if (primitiveRestartEnable != NULL && primitiveRestartEnable != Py_None) {

        (self->base)->primitiveRestartEnable = PyLong_AsLong(primitiveRestartEnable);

    }

    return 0;
}
static PyTypeObject PyVkPipelineInputAssemblyStateCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPipelineInputAssemblyStateCreateInfo", sizeof(PyVkPipelineInputAssemblyStateCreateInfo), 0,
    (destructor)PyVkPipelineInputAssemblyStateCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPipelineInputAssemblyStateCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkPipelineInputAssemblyStateCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineInputAssemblyStateCreateInfo_init,0,PyVkPipelineInputAssemblyStateCreateInfo_new,
};

static void PyVkPipelineTessellationStateCreateInfo_del(PyVkPipelineTessellationStateCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPipelineTessellationStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPipelineTessellationStateCreateInfo *self;
    self = (PyVkPipelineTessellationStateCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPipelineTessellationStateCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineTessellationStateCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkPipelineTessellationStateCreateInfo_getpNext(PyVkPipelineTessellationStateCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineTessellationStateCreateInfo_getpatchControlPoints(PyVkPipelineTessellationStateCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->patchControlPoints);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkPipelineTessellationStateCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkPipelineTessellationStateCreateInfo_getpNext, NULL, "", NULL},

    { "patchControlPoints", (getter)PyVkPipelineTessellationStateCreateInfo_getpatchControlPoints, NULL, "", NULL},
    {NULL}
};

static int
PyVkPipelineTessellationStateCreateInfo_init(PyVkPipelineTessellationStateCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* patchControlPoints = NULL;
    static char *kwlist[] = {"flags","patchControlPoints",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &flags, &patchControlPoints)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (patchControlPoints != NULL && patchControlPoints != Py_None) {
        (self->base)->patchControlPoints = (uint32_t) PyLong_AsLong(patchControlPoints);
    }

    return 0;
}
static PyTypeObject PyVkPipelineTessellationStateCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPipelineTessellationStateCreateInfo", sizeof(PyVkPipelineTessellationStateCreateInfo), 0,
    (destructor)PyVkPipelineTessellationStateCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPipelineTessellationStateCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkPipelineTessellationStateCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineTessellationStateCreateInfo_init,0,PyVkPipelineTessellationStateCreateInfo_new,
};

static void PyVkPipelineViewportStateCreateInfo_del(PyVkPipelineViewportStateCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPipelineViewportStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPipelineViewportStateCreateInfo *self;
    self = (PyVkPipelineViewportStateCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPipelineViewportStateCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineViewportStateCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkPipelineViewportStateCreateInfo_getpNext(PyVkPipelineViewportStateCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineViewportStateCreateInfo_getviewportCount(PyVkPipelineViewportStateCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->viewportCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineViewportStateCreateInfo_getscissorCount(PyVkPipelineViewportStateCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->scissorCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkPipelineViewportStateCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkPipelineViewportStateCreateInfo_getpNext, NULL, "", NULL},

    { "viewportCount", (getter)PyVkPipelineViewportStateCreateInfo_getviewportCount, NULL, "", NULL},

    { "scissorCount", (getter)PyVkPipelineViewportStateCreateInfo_getscissorCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkPipelineViewportStateCreateInfo_init(PyVkPipelineViewportStateCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* viewportCount = NULL;
    PyObject* pViewports = NULL;
    PyObject* scissorCount = NULL;
    PyObject* pScissors = NULL;
    static char *kwlist[] = {"flags","viewportCount","pViewports","scissorCount","pScissors",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &flags, &viewportCount, &pViewports, &scissorCount, &pScissors)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (viewportCount != NULL && viewportCount != Py_None) {
        (self->base)->viewportCount = (uint32_t) PyLong_AsLong(viewportCount);
    }

    if (pViewports != NULL && pViewports != Py_None) {

        (self->base)->pViewports = (((PyVkViewport*)pViewports)->base);

    }

    if (scissorCount != NULL && scissorCount != Py_None) {
        (self->base)->scissorCount = (uint32_t) PyLong_AsLong(scissorCount);
    }

    if (pScissors != NULL && pScissors != Py_None) {

        (self->base)->pScissors = (((PyVkRect2D*)pScissors)->base);

    }

    return 0;
}
static PyTypeObject PyVkPipelineViewportStateCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPipelineViewportStateCreateInfo", sizeof(PyVkPipelineViewportStateCreateInfo), 0,
    (destructor)PyVkPipelineViewportStateCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPipelineViewportStateCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkPipelineViewportStateCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineViewportStateCreateInfo_init,0,PyVkPipelineViewportStateCreateInfo_new,
};

static void PyVkPipelineRasterizationStateCreateInfo_del(PyVkPipelineRasterizationStateCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPipelineRasterizationStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPipelineRasterizationStateCreateInfo *self;
    self = (PyVkPipelineRasterizationStateCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPipelineRasterizationStateCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineRasterizationStateCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkPipelineRasterizationStateCreateInfo_getpNext(PyVkPipelineRasterizationStateCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineRasterizationStateCreateInfo_getdepthBiasConstantFactor(PyVkPipelineRasterizationStateCreateInfo *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->depthBiasConstantFactor);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineRasterizationStateCreateInfo_getdepthBiasClamp(PyVkPipelineRasterizationStateCreateInfo *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->depthBiasClamp);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineRasterizationStateCreateInfo_getdepthBiasSlopeFactor(PyVkPipelineRasterizationStateCreateInfo *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->depthBiasSlopeFactor);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineRasterizationStateCreateInfo_getlineWidth(PyVkPipelineRasterizationStateCreateInfo *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->lineWidth);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkPipelineRasterizationStateCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkPipelineRasterizationStateCreateInfo_getpNext, NULL, "", NULL},

    { "depthBiasConstantFactor", (getter)PyVkPipelineRasterizationStateCreateInfo_getdepthBiasConstantFactor, NULL, "", NULL},

    { "depthBiasClamp", (getter)PyVkPipelineRasterizationStateCreateInfo_getdepthBiasClamp, NULL, "", NULL},

    { "depthBiasSlopeFactor", (getter)PyVkPipelineRasterizationStateCreateInfo_getdepthBiasSlopeFactor, NULL, "", NULL},

    { "lineWidth", (getter)PyVkPipelineRasterizationStateCreateInfo_getlineWidth, NULL, "", NULL},
    {NULL}
};

static int
PyVkPipelineRasterizationStateCreateInfo_init(PyVkPipelineRasterizationStateCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* depthClampEnable = NULL;
    PyObject* rasterizerDiscardEnable = NULL;
    PyObject* polygonMode = NULL;
    PyObject* cullMode = NULL;
    PyObject* frontFace = NULL;
    PyObject* depthBiasEnable = NULL;
    PyObject* depthBiasConstantFactor = NULL;
    PyObject* depthBiasClamp = NULL;
    PyObject* depthBiasSlopeFactor = NULL;
    PyObject* lineWidth = NULL;
    static char *kwlist[] = {"flags","depthClampEnable","rasterizerDiscardEnable","polygonMode","cullMode","frontFace","depthBiasEnable","depthBiasConstantFactor","depthBiasClamp","depthBiasSlopeFactor","lineWidth",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOOOOO", kwlist, &flags, &depthClampEnable, &rasterizerDiscardEnable, &polygonMode, &cullMode, &frontFace, &depthBiasEnable, &depthBiasConstantFactor, &depthBiasClamp, &depthBiasSlopeFactor, &lineWidth)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (depthClampEnable != NULL && depthClampEnable != Py_None) {

        (self->base)->depthClampEnable = PyLong_AsLong(depthClampEnable);

    }

    if (rasterizerDiscardEnable != NULL && rasterizerDiscardEnable != Py_None) {

        (self->base)->rasterizerDiscardEnable = PyLong_AsLong(rasterizerDiscardEnable);

    }

    if (polygonMode != NULL && polygonMode != Py_None) {

        (self->base)->polygonMode = PyLong_AsLong(polygonMode);

    }

    if (cullMode != NULL && cullMode != Py_None) {

        (self->base)->cullMode = PyLong_AsLong(cullMode);

    }

    if (frontFace != NULL && frontFace != Py_None) {

        (self->base)->frontFace = PyLong_AsLong(frontFace);

    }

    if (depthBiasEnable != NULL && depthBiasEnable != Py_None) {

        (self->base)->depthBiasEnable = PyLong_AsLong(depthBiasEnable);

    }

    if (depthBiasConstantFactor != NULL && depthBiasConstantFactor != Py_None) {
        (self->base)->depthBiasConstantFactor = (float) PyFloat_AsDouble(depthBiasConstantFactor);
    }

    if (depthBiasClamp != NULL && depthBiasClamp != Py_None) {
        (self->base)->depthBiasClamp = (float) PyFloat_AsDouble(depthBiasClamp);
    }

    if (depthBiasSlopeFactor != NULL && depthBiasSlopeFactor != Py_None) {
        (self->base)->depthBiasSlopeFactor = (float) PyFloat_AsDouble(depthBiasSlopeFactor);
    }

    if (lineWidth != NULL && lineWidth != Py_None) {
        (self->base)->lineWidth = (float) PyFloat_AsDouble(lineWidth);
    }

    return 0;
}
static PyTypeObject PyVkPipelineRasterizationStateCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPipelineRasterizationStateCreateInfo", sizeof(PyVkPipelineRasterizationStateCreateInfo), 0,
    (destructor)PyVkPipelineRasterizationStateCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPipelineRasterizationStateCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkPipelineRasterizationStateCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineRasterizationStateCreateInfo_init,0,PyVkPipelineRasterizationStateCreateInfo_new,
};

static void PyVkPipelineMultisampleStateCreateInfo_del(PyVkPipelineMultisampleStateCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPipelineMultisampleStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPipelineMultisampleStateCreateInfo *self;
    self = (PyVkPipelineMultisampleStateCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPipelineMultisampleStateCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineMultisampleStateCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkPipelineMultisampleStateCreateInfo_getpNext(PyVkPipelineMultisampleStateCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineMultisampleStateCreateInfo_getminSampleShading(PyVkPipelineMultisampleStateCreateInfo *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->minSampleShading);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkPipelineMultisampleStateCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkPipelineMultisampleStateCreateInfo_getpNext, NULL, "", NULL},

    { "minSampleShading", (getter)PyVkPipelineMultisampleStateCreateInfo_getminSampleShading, NULL, "", NULL},
    {NULL}
};

static int
PyVkPipelineMultisampleStateCreateInfo_init(PyVkPipelineMultisampleStateCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* rasterizationSamples = NULL;
    PyObject* sampleShadingEnable = NULL;
    PyObject* minSampleShading = NULL;
    PyObject* pSampleMask = NULL;
    PyObject* alphaToCoverageEnable = NULL;
    PyObject* alphaToOneEnable = NULL;
    static char *kwlist[] = {"flags","rasterizationSamples","sampleShadingEnable","minSampleShading","pSampleMask","alphaToCoverageEnable","alphaToOneEnable",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &flags, &rasterizationSamples, &sampleShadingEnable, &minSampleShading, &pSampleMask, &alphaToCoverageEnable, &alphaToOneEnable)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (rasterizationSamples != NULL && rasterizationSamples != Py_None) {

        (self->base)->rasterizationSamples = PyLong_AsLong(rasterizationSamples);

    }

    if (sampleShadingEnable != NULL && sampleShadingEnable != Py_None) {

        (self->base)->sampleShadingEnable = PyLong_AsLong(sampleShadingEnable);

    }

    if (minSampleShading != NULL && minSampleShading != Py_None) {
        (self->base)->minSampleShading = (float) PyFloat_AsDouble(minSampleShading);
    }

    if (pSampleMask != NULL && pSampleMask != Py_None) {

        VkSampleMask tmp = PyLong_AsLong(pSampleMask);
        (self->base)->pSampleMask = &tmp;

    }

    if (alphaToCoverageEnable != NULL && alphaToCoverageEnable != Py_None) {

        (self->base)->alphaToCoverageEnable = PyLong_AsLong(alphaToCoverageEnable);

    }

    if (alphaToOneEnable != NULL && alphaToOneEnable != Py_None) {

        (self->base)->alphaToOneEnable = PyLong_AsLong(alphaToOneEnable);

    }

    return 0;
}
static PyTypeObject PyVkPipelineMultisampleStateCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPipelineMultisampleStateCreateInfo", sizeof(PyVkPipelineMultisampleStateCreateInfo), 0,
    (destructor)PyVkPipelineMultisampleStateCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPipelineMultisampleStateCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkPipelineMultisampleStateCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineMultisampleStateCreateInfo_init,0,PyVkPipelineMultisampleStateCreateInfo_new,
};

static void PyVkPipelineColorBlendAttachmentState_del(PyVkPipelineColorBlendAttachmentState* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPipelineColorBlendAttachmentState_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPipelineColorBlendAttachmentState *self;
    self = (PyVkPipelineColorBlendAttachmentState *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPipelineColorBlendAttachmentState));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineColorBlendAttachmentState");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkPipelineColorBlendAttachmentState_getsetters[] = {
    {NULL}
};

static int
PyVkPipelineColorBlendAttachmentState_init(PyVkPipelineColorBlendAttachmentState *self, PyObject *args, PyObject *kwds) {
    PyObject* blendEnable = NULL;
    PyObject* srcColorBlendFactor = NULL;
    PyObject* dstColorBlendFactor = NULL;
    PyObject* colorBlendOp = NULL;
    PyObject* srcAlphaBlendFactor = NULL;
    PyObject* dstAlphaBlendFactor = NULL;
    PyObject* alphaBlendOp = NULL;
    PyObject* colorWriteMask = NULL;
    static char *kwlist[] = {"blendEnable","srcColorBlendFactor","dstColorBlendFactor","colorBlendOp","srcAlphaBlendFactor","dstAlphaBlendFactor","alphaBlendOp","colorWriteMask",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOO", kwlist, &blendEnable, &srcColorBlendFactor, &dstColorBlendFactor, &colorBlendOp, &srcAlphaBlendFactor, &dstAlphaBlendFactor, &alphaBlendOp, &colorWriteMask)) return -1;

    if (blendEnable != NULL && blendEnable != Py_None) {

        (self->base)->blendEnable = PyLong_AsLong(blendEnable);

    }

    if (srcColorBlendFactor != NULL && srcColorBlendFactor != Py_None) {

        (self->base)->srcColorBlendFactor = PyLong_AsLong(srcColorBlendFactor);

    }

    if (dstColorBlendFactor != NULL && dstColorBlendFactor != Py_None) {

        (self->base)->dstColorBlendFactor = PyLong_AsLong(dstColorBlendFactor);

    }

    if (colorBlendOp != NULL && colorBlendOp != Py_None) {

        (self->base)->colorBlendOp = PyLong_AsLong(colorBlendOp);

    }

    if (srcAlphaBlendFactor != NULL && srcAlphaBlendFactor != Py_None) {

        (self->base)->srcAlphaBlendFactor = PyLong_AsLong(srcAlphaBlendFactor);

    }

    if (dstAlphaBlendFactor != NULL && dstAlphaBlendFactor != Py_None) {

        (self->base)->dstAlphaBlendFactor = PyLong_AsLong(dstAlphaBlendFactor);

    }

    if (alphaBlendOp != NULL && alphaBlendOp != Py_None) {

        (self->base)->alphaBlendOp = PyLong_AsLong(alphaBlendOp);

    }

    if (colorWriteMask != NULL && colorWriteMask != Py_None) {

        (self->base)->colorWriteMask = PyLong_AsLong(colorWriteMask);

    }

    return 0;
}
static PyTypeObject PyVkPipelineColorBlendAttachmentStateType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPipelineColorBlendAttachmentState", sizeof(PyVkPipelineColorBlendAttachmentState), 0,
    (destructor)PyVkPipelineColorBlendAttachmentState_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPipelineColorBlendAttachmentState object",0,0,0,0,0,0,0,0,
    PyVkPipelineColorBlendAttachmentState_getsetters,0,0,0,0,0,(initproc)PyVkPipelineColorBlendAttachmentState_init,0,PyVkPipelineColorBlendAttachmentState_new,
};

static void PyVkPipelineColorBlendStateCreateInfo_del(PyVkPipelineColorBlendStateCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPipelineColorBlendStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPipelineColorBlendStateCreateInfo *self;
    self = (PyVkPipelineColorBlendStateCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPipelineColorBlendStateCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineColorBlendStateCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkPipelineColorBlendStateCreateInfo_getpNext(PyVkPipelineColorBlendStateCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineColorBlendStateCreateInfo_getattachmentCount(PyVkPipelineColorBlendStateCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->attachmentCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineColorBlendStateCreateInfo_getblendConstants(PyVkPipelineColorBlendStateCreateInfo *self, void *closure) {

    PyObject* value = PyList_New(0);
    int nb = sizeof((self->base)->blendConstants) / sizeof((self->base)->blendConstants[0]);
    int i = 0;
    for (i = 0; i < nb; i++) {
        PyObject* py_tmp = PyFloat_FromDouble((double) (self->base)->blendConstants[i]);
        PyList_Append(value, py_tmp);
    }

    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkPipelineColorBlendStateCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkPipelineColorBlendStateCreateInfo_getpNext, NULL, "", NULL},

    { "attachmentCount", (getter)PyVkPipelineColorBlendStateCreateInfo_getattachmentCount, NULL, "", NULL},

    { "blendConstants", (getter)PyVkPipelineColorBlendStateCreateInfo_getblendConstants, NULL, "", NULL},
    {NULL}
};

static int
PyVkPipelineColorBlendStateCreateInfo_init(PyVkPipelineColorBlendStateCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* logicOpEnable = NULL;
    PyObject* logicOp = NULL;
    PyObject* attachmentCount = NULL;
    PyObject* pAttachments = NULL;
    PyObject* blendConstants = NULL;
    static char *kwlist[] = {"flags","logicOpEnable","logicOp","attachmentCount","pAttachments","blendConstants",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &flags, &logicOpEnable, &logicOp, &attachmentCount, &pAttachments, &blendConstants)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (logicOpEnable != NULL && logicOpEnable != Py_None) {

        (self->base)->logicOpEnable = PyLong_AsLong(logicOpEnable);

    }

    if (logicOp != NULL && logicOp != Py_None) {

        (self->base)->logicOp = PyLong_AsLong(logicOp);

    }

    if (attachmentCount != NULL && attachmentCount != Py_None) {
        (self->base)->attachmentCount = (uint32_t) PyLong_AsLong(attachmentCount);
    }

    if (pAttachments != NULL && pAttachments != Py_None) {

        (self->base)->pAttachments = (((PyVkPipelineColorBlendAttachmentState*)pAttachments)->base);

    }

    if (blendConstants != NULL && blendConstants != Py_None) {

        int tmp17949403 = PyList_Size(blendConstants);
        int tmp55085452;
        for (tmp55085452 = 0; tmp55085452 < tmp17949403; tmp55085452++) {
            float tmp = (float) PyFloat_AsDouble(
                            PyList_GetItem(blendConstants, tmp55085452));
            ((self->base)->blendConstants)[tmp55085452] = tmp;
        }

    }

    return 0;
}
static PyTypeObject PyVkPipelineColorBlendStateCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPipelineColorBlendStateCreateInfo", sizeof(PyVkPipelineColorBlendStateCreateInfo), 0,
    (destructor)PyVkPipelineColorBlendStateCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPipelineColorBlendStateCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkPipelineColorBlendStateCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineColorBlendStateCreateInfo_init,0,PyVkPipelineColorBlendStateCreateInfo_new,
};

static void PyVkPipelineDynamicStateCreateInfo_del(PyVkPipelineDynamicStateCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPipelineDynamicStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPipelineDynamicStateCreateInfo *self;
    self = (PyVkPipelineDynamicStateCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPipelineDynamicStateCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineDynamicStateCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkPipelineDynamicStateCreateInfo_getpNext(PyVkPipelineDynamicStateCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineDynamicStateCreateInfo_getdynamicStateCount(PyVkPipelineDynamicStateCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->dynamicStateCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkPipelineDynamicStateCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkPipelineDynamicStateCreateInfo_getpNext, NULL, "", NULL},

    { "dynamicStateCount", (getter)PyVkPipelineDynamicStateCreateInfo_getdynamicStateCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkPipelineDynamicStateCreateInfo_init(PyVkPipelineDynamicStateCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* dynamicStateCount = NULL;
    PyObject* pDynamicStates = NULL;
    static char *kwlist[] = {"flags","dynamicStateCount","pDynamicStates",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &flags, &dynamicStateCount, &pDynamicStates)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (dynamicStateCount != NULL && dynamicStateCount != Py_None) {
        (self->base)->dynamicStateCount = (uint32_t) PyLong_AsLong(dynamicStateCount);
    }

    if (pDynamicStates != NULL && pDynamicStates != Py_None) {

        VkDynamicState tmp = PyLong_AsLong(pDynamicStates);
        (self->base)->pDynamicStates = &tmp;

    }

    return 0;
}
static PyTypeObject PyVkPipelineDynamicStateCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPipelineDynamicStateCreateInfo", sizeof(PyVkPipelineDynamicStateCreateInfo), 0,
    (destructor)PyVkPipelineDynamicStateCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPipelineDynamicStateCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkPipelineDynamicStateCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineDynamicStateCreateInfo_init,0,PyVkPipelineDynamicStateCreateInfo_new,
};

static void PyVkStencilOpState_del(PyVkStencilOpState* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkStencilOpState_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkStencilOpState *self;
    self = (PyVkStencilOpState *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkStencilOpState));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkStencilOpState");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkStencilOpState_getcompareMask(PyVkStencilOpState *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->compareMask);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkStencilOpState_getwriteMask(PyVkStencilOpState *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->writeMask);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkStencilOpState_getreference(PyVkStencilOpState *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->reference);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkStencilOpState_getsetters[] = {

    { "compareMask", (getter)PyVkStencilOpState_getcompareMask, NULL, "", NULL},

    { "writeMask", (getter)PyVkStencilOpState_getwriteMask, NULL, "", NULL},

    { "reference", (getter)PyVkStencilOpState_getreference, NULL, "", NULL},
    {NULL}
};

static int
PyVkStencilOpState_init(PyVkStencilOpState *self, PyObject *args, PyObject *kwds) {
    PyObject* failOp = NULL;
    PyObject* passOp = NULL;
    PyObject* depthFailOp = NULL;
    PyObject* compareOp = NULL;
    PyObject* compareMask = NULL;
    PyObject* writeMask = NULL;
    PyObject* reference = NULL;
    static char *kwlist[] = {"failOp","passOp","depthFailOp","compareOp","compareMask","writeMask","reference",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &failOp, &passOp, &depthFailOp, &compareOp, &compareMask, &writeMask, &reference)) return -1;

    if (failOp != NULL && failOp != Py_None) {

        (self->base)->failOp = PyLong_AsLong(failOp);

    }

    if (passOp != NULL && passOp != Py_None) {

        (self->base)->passOp = PyLong_AsLong(passOp);

    }

    if (depthFailOp != NULL && depthFailOp != Py_None) {

        (self->base)->depthFailOp = PyLong_AsLong(depthFailOp);

    }

    if (compareOp != NULL && compareOp != Py_None) {

        (self->base)->compareOp = PyLong_AsLong(compareOp);

    }

    if (compareMask != NULL && compareMask != Py_None) {
        (self->base)->compareMask = (uint32_t) PyLong_AsLong(compareMask);
    }

    if (writeMask != NULL && writeMask != Py_None) {
        (self->base)->writeMask = (uint32_t) PyLong_AsLong(writeMask);
    }

    if (reference != NULL && reference != Py_None) {
        (self->base)->reference = (uint32_t) PyLong_AsLong(reference);
    }

    return 0;
}
static PyTypeObject PyVkStencilOpStateType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkStencilOpState", sizeof(PyVkStencilOpState), 0,
    (destructor)PyVkStencilOpState_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkStencilOpState object",0,0,0,0,0,0,0,0,
    PyVkStencilOpState_getsetters,0,0,0,0,0,(initproc)PyVkStencilOpState_init,0,PyVkStencilOpState_new,
};

static void PyVkPipelineDepthStencilStateCreateInfo_del(PyVkPipelineDepthStencilStateCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPipelineDepthStencilStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPipelineDepthStencilStateCreateInfo *self;
    self = (PyVkPipelineDepthStencilStateCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPipelineDepthStencilStateCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineDepthStencilStateCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkPipelineDepthStencilStateCreateInfo_getpNext(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineDepthStencilStateCreateInfo_getminDepthBounds(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->minDepthBounds);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineDepthStencilStateCreateInfo_getmaxDepthBounds(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->maxDepthBounds);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkPipelineDepthStencilStateCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkPipelineDepthStencilStateCreateInfo_getpNext, NULL, "", NULL},

    { "minDepthBounds", (getter)PyVkPipelineDepthStencilStateCreateInfo_getminDepthBounds, NULL, "", NULL},

    { "maxDepthBounds", (getter)PyVkPipelineDepthStencilStateCreateInfo_getmaxDepthBounds, NULL, "", NULL},
    {NULL}
};

static int
PyVkPipelineDepthStencilStateCreateInfo_init(PyVkPipelineDepthStencilStateCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* depthTestEnable = NULL;
    PyObject* depthWriteEnable = NULL;
    PyObject* depthCompareOp = NULL;
    PyObject* depthBoundsTestEnable = NULL;
    PyObject* stencilTestEnable = NULL;
    PyObject* front = NULL;
    PyObject* back = NULL;
    PyObject* minDepthBounds = NULL;
    PyObject* maxDepthBounds = NULL;
    static char *kwlist[] = {"flags","depthTestEnable","depthWriteEnable","depthCompareOp","depthBoundsTestEnable","stencilTestEnable","front","back","minDepthBounds","maxDepthBounds",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOOOO", kwlist, &flags, &depthTestEnable, &depthWriteEnable, &depthCompareOp, &depthBoundsTestEnable, &stencilTestEnable, &front, &back, &minDepthBounds, &maxDepthBounds)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (depthTestEnable != NULL && depthTestEnable != Py_None) {

        (self->base)->depthTestEnable = PyLong_AsLong(depthTestEnable);

    }

    if (depthWriteEnable != NULL && depthWriteEnable != Py_None) {

        (self->base)->depthWriteEnable = PyLong_AsLong(depthWriteEnable);

    }

    if (depthCompareOp != NULL && depthCompareOp != Py_None) {

        (self->base)->depthCompareOp = PyLong_AsLong(depthCompareOp);

    }

    if (depthBoundsTestEnable != NULL && depthBoundsTestEnable != Py_None) {

        (self->base)->depthBoundsTestEnable = PyLong_AsLong(depthBoundsTestEnable);

    }

    if (stencilTestEnable != NULL && stencilTestEnable != Py_None) {

        (self->base)->stencilTestEnable = PyLong_AsLong(stencilTestEnable);

    }

    if (front != NULL && front != Py_None) {

        (self->base)->front = *(((PyVkStencilOpState*)front)->base);

    }

    if (back != NULL && back != Py_None) {

        (self->base)->back = *(((PyVkStencilOpState*)back)->base);

    }

    if (minDepthBounds != NULL && minDepthBounds != Py_None) {
        (self->base)->minDepthBounds = (float) PyFloat_AsDouble(minDepthBounds);
    }

    if (maxDepthBounds != NULL && maxDepthBounds != Py_None) {
        (self->base)->maxDepthBounds = (float) PyFloat_AsDouble(maxDepthBounds);
    }

    return 0;
}
static PyTypeObject PyVkPipelineDepthStencilStateCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPipelineDepthStencilStateCreateInfo", sizeof(PyVkPipelineDepthStencilStateCreateInfo), 0,
    (destructor)PyVkPipelineDepthStencilStateCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPipelineDepthStencilStateCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkPipelineDepthStencilStateCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineDepthStencilStateCreateInfo_init,0,PyVkPipelineDepthStencilStateCreateInfo_new,
};

static void PyVkGraphicsPipelineCreateInfo_del(PyVkGraphicsPipelineCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkGraphicsPipelineCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkGraphicsPipelineCreateInfo *self;
    self = (PyVkGraphicsPipelineCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkGraphicsPipelineCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkGraphicsPipelineCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkGraphicsPipelineCreateInfo_getpNext(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkGraphicsPipelineCreateInfo_getstageCount(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->stageCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkGraphicsPipelineCreateInfo_getsubpass(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->subpass);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkGraphicsPipelineCreateInfo_getbasePipelineIndex(PyVkGraphicsPipelineCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->basePipelineIndex);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkGraphicsPipelineCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkGraphicsPipelineCreateInfo_getpNext, NULL, "", NULL},

    { "stageCount", (getter)PyVkGraphicsPipelineCreateInfo_getstageCount, NULL, "", NULL},

    { "subpass", (getter)PyVkGraphicsPipelineCreateInfo_getsubpass, NULL, "", NULL},

    { "basePipelineIndex", (getter)PyVkGraphicsPipelineCreateInfo_getbasePipelineIndex, NULL, "", NULL},
    {NULL}
};

static int
PyVkGraphicsPipelineCreateInfo_init(PyVkGraphicsPipelineCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* stageCount = NULL;
    PyObject* pStages = NULL;
    PyObject* pVertexInputState = NULL;
    PyObject* pInputAssemblyState = NULL;
    PyObject* pTessellationState = NULL;
    PyObject* pViewportState = NULL;
    PyObject* pRasterizationState = NULL;
    PyObject* pMultisampleState = NULL;
    PyObject* pDepthStencilState = NULL;
    PyObject* pColorBlendState = NULL;
    PyObject* pDynamicState = NULL;
    PyObject* layout = NULL;
    PyObject* renderPass = NULL;
    PyObject* subpass = NULL;
    PyObject* basePipelineHandle = NULL;
    PyObject* basePipelineIndex = NULL;
    static char *kwlist[] = {"flags","stageCount","pStages","pVertexInputState","pInputAssemblyState","pTessellationState","pViewportState","pRasterizationState","pMultisampleState","pDepthStencilState","pColorBlendState","pDynamicState","layout","renderPass","subpass","basePipelineHandle","basePipelineIndex",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOOOOOOOOOOO", kwlist, &flags, &stageCount, &pStages, &pVertexInputState, &pInputAssemblyState, &pTessellationState, &pViewportState, &pRasterizationState, &pMultisampleState, &pDepthStencilState, &pColorBlendState, &pDynamicState, &layout, &renderPass, &subpass, &basePipelineHandle, &basePipelineIndex)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (stageCount != NULL && stageCount != Py_None) {
        (self->base)->stageCount = (uint32_t) PyLong_AsLong(stageCount);
    }

    if (pStages != NULL && pStages != Py_None) {

        (self->base)->pStages = (((PyVkPipelineShaderStageCreateInfo*)pStages)->base);

    }

    if (pVertexInputState != NULL && pVertexInputState != Py_None) {

        (self->base)->pVertexInputState = (((PyVkPipelineVertexInputStateCreateInfo*)pVertexInputState)->base);

    }

    if (pInputAssemblyState != NULL && pInputAssemblyState != Py_None) {

        (self->base)->pInputAssemblyState = (((PyVkPipelineInputAssemblyStateCreateInfo*)pInputAssemblyState)->base);

    }

    if (pTessellationState != NULL && pTessellationState != Py_None) {

        (self->base)->pTessellationState = (((PyVkPipelineTessellationStateCreateInfo*)pTessellationState)->base);

    }

    if (pViewportState != NULL && pViewportState != Py_None) {

        (self->base)->pViewportState = (((PyVkPipelineViewportStateCreateInfo*)pViewportState)->base);

    }

    if (pRasterizationState != NULL && pRasterizationState != Py_None) {

        (self->base)->pRasterizationState = (((PyVkPipelineRasterizationStateCreateInfo*)pRasterizationState)->base);

    }

    if (pMultisampleState != NULL && pMultisampleState != Py_None) {

        (self->base)->pMultisampleState = (((PyVkPipelineMultisampleStateCreateInfo*)pMultisampleState)->base);

    }

    if (pDepthStencilState != NULL && pDepthStencilState != Py_None) {

        (self->base)->pDepthStencilState = (((PyVkPipelineDepthStencilStateCreateInfo*)pDepthStencilState)->base);

    }

    if (pColorBlendState != NULL && pColorBlendState != Py_None) {

        (self->base)->pColorBlendState = (((PyVkPipelineColorBlendStateCreateInfo*)pColorBlendState)->base);

    }

    if (pDynamicState != NULL && pDynamicState != Py_None) {

        (self->base)->pDynamicState = (((PyVkPipelineDynamicStateCreateInfo*)pDynamicState)->base);

    }

    if (layout != NULL && layout != Py_None) {

        (self->base)->layout = PyCapsule_GetPointer(layout, "VkPipelineLayout");

    }

    if (renderPass != NULL && renderPass != Py_None) {

        (self->base)->renderPass = PyCapsule_GetPointer(renderPass, "VkRenderPass");

    }

    if (subpass != NULL && subpass != Py_None) {
        (self->base)->subpass = (uint32_t) PyLong_AsLong(subpass);
    }

    if (basePipelineHandle != NULL && basePipelineHandle != Py_None) {

        (self->base)->basePipelineHandle = PyCapsule_GetPointer(basePipelineHandle, "VkPipeline");

    }

    if (basePipelineIndex != NULL && basePipelineIndex != Py_None) {
        (self->base)->basePipelineIndex = (int32_t) PyLong_AsLong(basePipelineIndex);
    }

    return 0;
}
static PyTypeObject PyVkGraphicsPipelineCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkGraphicsPipelineCreateInfo", sizeof(PyVkGraphicsPipelineCreateInfo), 0,
    (destructor)PyVkGraphicsPipelineCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkGraphicsPipelineCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkGraphicsPipelineCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkGraphicsPipelineCreateInfo_init,0,PyVkGraphicsPipelineCreateInfo_new,
};

static void PyVkPipelineCacheCreateInfo_del(PyVkPipelineCacheCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPipelineCacheCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPipelineCacheCreateInfo *self;
    self = (PyVkPipelineCacheCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPipelineCacheCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineCacheCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkPipelineCacheCreateInfo_getpNext(PyVkPipelineCacheCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineCacheCreateInfo_getinitialDataSize(PyVkPipelineCacheCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->initialDataSize);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineCacheCreateInfo_getpInitialData(PyVkPipelineCacheCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkPipelineCacheCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkPipelineCacheCreateInfo_getpNext, NULL, "", NULL},

    { "initialDataSize", (getter)PyVkPipelineCacheCreateInfo_getinitialDataSize, NULL, "", NULL},

    { "pInitialData", (getter)PyVkPipelineCacheCreateInfo_getpInitialData, NULL, "", NULL},
    {NULL}
};

static int
PyVkPipelineCacheCreateInfo_init(PyVkPipelineCacheCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* initialDataSize = NULL;
    PyObject* pInitialData = NULL;
    static char *kwlist[] = {"flags","initialDataSize","pInitialData",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &flags, &initialDataSize, &pInitialData)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (initialDataSize != NULL && initialDataSize != Py_None) {
        (self->base)->initialDataSize = (size_t) PyLong_AsLong(initialDataSize);
    }

    if (pInitialData != NULL && pInitialData != Py_None) {
        (self->base)->pInitialData = NULL;
    }

    return 0;
}
static PyTypeObject PyVkPipelineCacheCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPipelineCacheCreateInfo", sizeof(PyVkPipelineCacheCreateInfo), 0,
    (destructor)PyVkPipelineCacheCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPipelineCacheCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkPipelineCacheCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineCacheCreateInfo_init,0,PyVkPipelineCacheCreateInfo_new,
};

static void PyVkPushConstantRange_del(PyVkPushConstantRange* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPushConstantRange_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPushConstantRange *self;
    self = (PyVkPushConstantRange *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPushConstantRange));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPushConstantRange");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkPushConstantRange_getoffset(PyVkPushConstantRange *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->offset);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPushConstantRange_getsize(PyVkPushConstantRange *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->size);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkPushConstantRange_getsetters[] = {

    { "offset", (getter)PyVkPushConstantRange_getoffset, NULL, "", NULL},

    { "size", (getter)PyVkPushConstantRange_getsize, NULL, "", NULL},
    {NULL}
};

static int
PyVkPushConstantRange_init(PyVkPushConstantRange *self, PyObject *args, PyObject *kwds) {
    PyObject* stageFlags = NULL;
    PyObject* offset = NULL;
    PyObject* size = NULL;
    static char *kwlist[] = {"stageFlags","offset","size",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &stageFlags, &offset, &size)) return -1;

    if (stageFlags != NULL && stageFlags != Py_None) {

        (self->base)->stageFlags = PyLong_AsLong(stageFlags);

    }

    if (offset != NULL && offset != Py_None) {
        (self->base)->offset = (uint32_t) PyLong_AsLong(offset);
    }

    if (size != NULL && size != Py_None) {
        (self->base)->size = (uint32_t) PyLong_AsLong(size);
    }

    return 0;
}
static PyTypeObject PyVkPushConstantRangeType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPushConstantRange", sizeof(PyVkPushConstantRange), 0,
    (destructor)PyVkPushConstantRange_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPushConstantRange object",0,0,0,0,0,0,0,0,
    PyVkPushConstantRange_getsetters,0,0,0,0,0,(initproc)PyVkPushConstantRange_init,0,PyVkPushConstantRange_new,
};

static void PyVkPipelineLayoutCreateInfo_del(PyVkPipelineLayoutCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPipelineLayoutCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPipelineLayoutCreateInfo *self;
    self = (PyVkPipelineLayoutCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPipelineLayoutCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineLayoutCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkPipelineLayoutCreateInfo_getpNext(PyVkPipelineLayoutCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineLayoutCreateInfo_getsetLayoutCount(PyVkPipelineLayoutCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->setLayoutCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPipelineLayoutCreateInfo_getpushConstantRangeCount(PyVkPipelineLayoutCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->pushConstantRangeCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkPipelineLayoutCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkPipelineLayoutCreateInfo_getpNext, NULL, "", NULL},

    { "setLayoutCount", (getter)PyVkPipelineLayoutCreateInfo_getsetLayoutCount, NULL, "", NULL},

    { "pushConstantRangeCount", (getter)PyVkPipelineLayoutCreateInfo_getpushConstantRangeCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkPipelineLayoutCreateInfo_init(PyVkPipelineLayoutCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* setLayoutCount = NULL;
    PyObject* pSetLayouts = NULL;
    PyObject* pushConstantRangeCount = NULL;
    PyObject* pPushConstantRanges = NULL;
    static char *kwlist[] = {"flags","setLayoutCount","pSetLayouts","pushConstantRangeCount","pPushConstantRanges",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &flags, &setLayoutCount, &pSetLayouts, &pushConstantRangeCount, &pPushConstantRanges)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (setLayoutCount != NULL && setLayoutCount != Py_None) {
        (self->base)->setLayoutCount = (uint32_t) PyLong_AsLong(setLayoutCount);
    }

    if (pSetLayouts != NULL && pSetLayouts != Py_None) {

        (self->base)->pSetLayouts = PyCapsule_GetPointer(pSetLayouts, "VkDescriptorSetLayout");

    }

    if (pushConstantRangeCount != NULL && pushConstantRangeCount != Py_None) {
        (self->base)->pushConstantRangeCount = (uint32_t) PyLong_AsLong(pushConstantRangeCount);
    }

    if (pPushConstantRanges != NULL && pPushConstantRanges != Py_None) {

        (self->base)->pPushConstantRanges = (((PyVkPushConstantRange*)pPushConstantRanges)->base);

    }

    return 0;
}
static PyTypeObject PyVkPipelineLayoutCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPipelineLayoutCreateInfo", sizeof(PyVkPipelineLayoutCreateInfo), 0,
    (destructor)PyVkPipelineLayoutCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPipelineLayoutCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkPipelineLayoutCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkPipelineLayoutCreateInfo_init,0,PyVkPipelineLayoutCreateInfo_new,
};

static void PyVkSamplerCreateInfo_del(PyVkSamplerCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkSamplerCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkSamplerCreateInfo *self;
    self = (PyVkSamplerCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkSamplerCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSamplerCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkSamplerCreateInfo_getpNext(PyVkSamplerCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSamplerCreateInfo_getmipLodBias(PyVkSamplerCreateInfo *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->mipLodBias);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSamplerCreateInfo_getmaxAnisotropy(PyVkSamplerCreateInfo *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->maxAnisotropy);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSamplerCreateInfo_getminLod(PyVkSamplerCreateInfo *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->minLod);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSamplerCreateInfo_getmaxLod(PyVkSamplerCreateInfo *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->maxLod);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkSamplerCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkSamplerCreateInfo_getpNext, NULL, "", NULL},

    { "mipLodBias", (getter)PyVkSamplerCreateInfo_getmipLodBias, NULL, "", NULL},

    { "maxAnisotropy", (getter)PyVkSamplerCreateInfo_getmaxAnisotropy, NULL, "", NULL},

    { "minLod", (getter)PyVkSamplerCreateInfo_getminLod, NULL, "", NULL},

    { "maxLod", (getter)PyVkSamplerCreateInfo_getmaxLod, NULL, "", NULL},
    {NULL}
};

static int
PyVkSamplerCreateInfo_init(PyVkSamplerCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* magFilter = NULL;
    PyObject* minFilter = NULL;
    PyObject* mipmapMode = NULL;
    PyObject* addressModeU = NULL;
    PyObject* addressModeV = NULL;
    PyObject* addressModeW = NULL;
    PyObject* mipLodBias = NULL;
    PyObject* anisotropyEnable = NULL;
    PyObject* maxAnisotropy = NULL;
    PyObject* compareEnable = NULL;
    PyObject* compareOp = NULL;
    PyObject* minLod = NULL;
    PyObject* maxLod = NULL;
    PyObject* borderColor = NULL;
    PyObject* unnormalizedCoordinates = NULL;
    static char *kwlist[] = {"flags","magFilter","minFilter","mipmapMode","addressModeU","addressModeV","addressModeW","mipLodBias","anisotropyEnable","maxAnisotropy","compareEnable","compareOp","minLod","maxLod","borderColor","unnormalizedCoordinates",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOOOOOOOOOO", kwlist, &flags, &magFilter, &minFilter, &mipmapMode, &addressModeU, &addressModeV, &addressModeW, &mipLodBias, &anisotropyEnable, &maxAnisotropy, &compareEnable, &compareOp, &minLod, &maxLod, &borderColor, &unnormalizedCoordinates)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (magFilter != NULL && magFilter != Py_None) {

        (self->base)->magFilter = PyLong_AsLong(magFilter);

    }

    if (minFilter != NULL && minFilter != Py_None) {

        (self->base)->minFilter = PyLong_AsLong(minFilter);

    }

    if (mipmapMode != NULL && mipmapMode != Py_None) {

        (self->base)->mipmapMode = PyLong_AsLong(mipmapMode);

    }

    if (addressModeU != NULL && addressModeU != Py_None) {

        (self->base)->addressModeU = PyLong_AsLong(addressModeU);

    }

    if (addressModeV != NULL && addressModeV != Py_None) {

        (self->base)->addressModeV = PyLong_AsLong(addressModeV);

    }

    if (addressModeW != NULL && addressModeW != Py_None) {

        (self->base)->addressModeW = PyLong_AsLong(addressModeW);

    }

    if (mipLodBias != NULL && mipLodBias != Py_None) {
        (self->base)->mipLodBias = (float) PyFloat_AsDouble(mipLodBias);
    }

    if (anisotropyEnable != NULL && anisotropyEnable != Py_None) {

        (self->base)->anisotropyEnable = PyLong_AsLong(anisotropyEnable);

    }

    if (maxAnisotropy != NULL && maxAnisotropy != Py_None) {
        (self->base)->maxAnisotropy = (float) PyFloat_AsDouble(maxAnisotropy);
    }

    if (compareEnable != NULL && compareEnable != Py_None) {

        (self->base)->compareEnable = PyLong_AsLong(compareEnable);

    }

    if (compareOp != NULL && compareOp != Py_None) {

        (self->base)->compareOp = PyLong_AsLong(compareOp);

    }

    if (minLod != NULL && minLod != Py_None) {
        (self->base)->minLod = (float) PyFloat_AsDouble(minLod);
    }

    if (maxLod != NULL && maxLod != Py_None) {
        (self->base)->maxLod = (float) PyFloat_AsDouble(maxLod);
    }

    if (borderColor != NULL && borderColor != Py_None) {

        (self->base)->borderColor = PyLong_AsLong(borderColor);

    }

    if (unnormalizedCoordinates != NULL && unnormalizedCoordinates != Py_None) {

        (self->base)->unnormalizedCoordinates = PyLong_AsLong(unnormalizedCoordinates);

    }

    return 0;
}
static PyTypeObject PyVkSamplerCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkSamplerCreateInfo", sizeof(PyVkSamplerCreateInfo), 0,
    (destructor)PyVkSamplerCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkSamplerCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkSamplerCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkSamplerCreateInfo_init,0,PyVkSamplerCreateInfo_new,
};

static void PyVkCommandPoolCreateInfo_del(PyVkCommandPoolCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkCommandPoolCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkCommandPoolCreateInfo *self;
    self = (PyVkCommandPoolCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkCommandPoolCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkCommandPoolCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkCommandPoolCreateInfo_getpNext(PyVkCommandPoolCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkCommandPoolCreateInfo_getqueueFamilyIndex(PyVkCommandPoolCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->queueFamilyIndex);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkCommandPoolCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkCommandPoolCreateInfo_getpNext, NULL, "", NULL},

    { "queueFamilyIndex", (getter)PyVkCommandPoolCreateInfo_getqueueFamilyIndex, NULL, "", NULL},
    {NULL}
};

static int
PyVkCommandPoolCreateInfo_init(PyVkCommandPoolCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* queueFamilyIndex = NULL;
    static char *kwlist[] = {"flags","queueFamilyIndex",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &flags, &queueFamilyIndex)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (queueFamilyIndex != NULL && queueFamilyIndex != Py_None) {
        (self->base)->queueFamilyIndex = (uint32_t) PyLong_AsLong(queueFamilyIndex);
    }

    return 0;
}
static PyTypeObject PyVkCommandPoolCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkCommandPoolCreateInfo", sizeof(PyVkCommandPoolCreateInfo), 0,
    (destructor)PyVkCommandPoolCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkCommandPoolCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkCommandPoolCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkCommandPoolCreateInfo_init,0,PyVkCommandPoolCreateInfo_new,
};

static void PyVkCommandBufferAllocateInfo_del(PyVkCommandBufferAllocateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkCommandBufferAllocateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkCommandBufferAllocateInfo *self;
    self = (PyVkCommandBufferAllocateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkCommandBufferAllocateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkCommandBufferAllocateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkCommandBufferAllocateInfo_getpNext(PyVkCommandBufferAllocateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkCommandBufferAllocateInfo_getcommandBufferCount(PyVkCommandBufferAllocateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->commandBufferCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkCommandBufferAllocateInfo_getsetters[] = {

    { "pNext", (getter)PyVkCommandBufferAllocateInfo_getpNext, NULL, "", NULL},

    { "commandBufferCount", (getter)PyVkCommandBufferAllocateInfo_getcommandBufferCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkCommandBufferAllocateInfo_init(PyVkCommandBufferAllocateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* commandPool = NULL;
    PyObject* level = NULL;
    PyObject* commandBufferCount = NULL;
    static char *kwlist[] = {"commandPool","level","commandBufferCount",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandPool, &level, &commandBufferCount)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;

    (self->base)->pNext = NULL;

    if (commandPool != NULL && commandPool != Py_None) {

        (self->base)->commandPool = PyCapsule_GetPointer(commandPool, "VkCommandPool");

    }

    if (level != NULL && level != Py_None) {

        (self->base)->level = PyLong_AsLong(level);

    }

    if (commandBufferCount != NULL && commandBufferCount != Py_None) {
        (self->base)->commandBufferCount = (uint32_t) PyLong_AsLong(commandBufferCount);
    }

    return 0;
}
static PyTypeObject PyVkCommandBufferAllocateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkCommandBufferAllocateInfo", sizeof(PyVkCommandBufferAllocateInfo), 0,
    (destructor)PyVkCommandBufferAllocateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkCommandBufferAllocateInfo object",0,0,0,0,0,0,0,0,
    PyVkCommandBufferAllocateInfo_getsetters,0,0,0,0,0,(initproc)PyVkCommandBufferAllocateInfo_init,0,PyVkCommandBufferAllocateInfo_new,
};

static void PyVkCommandBufferInheritanceInfo_del(PyVkCommandBufferInheritanceInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkCommandBufferInheritanceInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkCommandBufferInheritanceInfo *self;
    self = (PyVkCommandBufferInheritanceInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkCommandBufferInheritanceInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkCommandBufferInheritanceInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkCommandBufferInheritanceInfo_getpNext(PyVkCommandBufferInheritanceInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkCommandBufferInheritanceInfo_getsubpass(PyVkCommandBufferInheritanceInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->subpass);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkCommandBufferInheritanceInfo_getsetters[] = {

    { "pNext", (getter)PyVkCommandBufferInheritanceInfo_getpNext, NULL, "", NULL},

    { "subpass", (getter)PyVkCommandBufferInheritanceInfo_getsubpass, NULL, "", NULL},
    {NULL}
};

static int
PyVkCommandBufferInheritanceInfo_init(PyVkCommandBufferInheritanceInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* renderPass = NULL;
    PyObject* subpass = NULL;
    PyObject* framebuffer = NULL;
    PyObject* occlusionQueryEnable = NULL;
    PyObject* queryFlags = NULL;
    PyObject* pipelineStatistics = NULL;
    static char *kwlist[] = {"renderPass","subpass","framebuffer","occlusionQueryEnable","queryFlags","pipelineStatistics",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &renderPass, &subpass, &framebuffer, &occlusionQueryEnable, &queryFlags, &pipelineStatistics)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO;

    (self->base)->pNext = NULL;

    if (renderPass != NULL && renderPass != Py_None) {

        (self->base)->renderPass = PyCapsule_GetPointer(renderPass, "VkRenderPass");

    }

    if (subpass != NULL && subpass != Py_None) {
        (self->base)->subpass = (uint32_t) PyLong_AsLong(subpass);
    }

    if (framebuffer != NULL && framebuffer != Py_None) {

        (self->base)->framebuffer = PyCapsule_GetPointer(framebuffer, "VkFramebuffer");

    }

    if (occlusionQueryEnable != NULL && occlusionQueryEnable != Py_None) {

        (self->base)->occlusionQueryEnable = PyLong_AsLong(occlusionQueryEnable);

    }

    if (queryFlags != NULL && queryFlags != Py_None) {

        (self->base)->queryFlags = PyLong_AsLong(queryFlags);

    }

    if (pipelineStatistics != NULL && pipelineStatistics != Py_None) {

        (self->base)->pipelineStatistics = PyLong_AsLong(pipelineStatistics);

    }

    return 0;
}
static PyTypeObject PyVkCommandBufferInheritanceInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkCommandBufferInheritanceInfo", sizeof(PyVkCommandBufferInheritanceInfo), 0,
    (destructor)PyVkCommandBufferInheritanceInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkCommandBufferInheritanceInfo object",0,0,0,0,0,0,0,0,
    PyVkCommandBufferInheritanceInfo_getsetters,0,0,0,0,0,(initproc)PyVkCommandBufferInheritanceInfo_init,0,PyVkCommandBufferInheritanceInfo_new,
};

static void PyVkCommandBufferBeginInfo_del(PyVkCommandBufferBeginInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkCommandBufferBeginInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkCommandBufferBeginInfo *self;
    self = (PyVkCommandBufferBeginInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkCommandBufferBeginInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkCommandBufferBeginInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkCommandBufferBeginInfo_getpNext(PyVkCommandBufferBeginInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkCommandBufferBeginInfo_getsetters[] = {

    { "pNext", (getter)PyVkCommandBufferBeginInfo_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkCommandBufferBeginInfo_init(PyVkCommandBufferBeginInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* pInheritanceInfo = NULL;
    static char *kwlist[] = {"flags","pInheritanceInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &flags, &pInheritanceInfo)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (pInheritanceInfo != NULL && pInheritanceInfo != Py_None) {

        (self->base)->pInheritanceInfo = (((PyVkCommandBufferInheritanceInfo*)pInheritanceInfo)->base);

    }

    return 0;
}
static PyTypeObject PyVkCommandBufferBeginInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkCommandBufferBeginInfo", sizeof(PyVkCommandBufferBeginInfo), 0,
    (destructor)PyVkCommandBufferBeginInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkCommandBufferBeginInfo object",0,0,0,0,0,0,0,0,
    PyVkCommandBufferBeginInfo_getsetters,0,0,0,0,0,(initproc)PyVkCommandBufferBeginInfo_init,0,PyVkCommandBufferBeginInfo_new,
};

static void PyVkRenderPassBeginInfo_del(PyVkRenderPassBeginInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkRenderPassBeginInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkRenderPassBeginInfo *self;
    self = (PyVkRenderPassBeginInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkRenderPassBeginInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkRenderPassBeginInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkRenderPassBeginInfo_getpNext(PyVkRenderPassBeginInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkRenderPassBeginInfo_getclearValueCount(PyVkRenderPassBeginInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->clearValueCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkRenderPassBeginInfo_getsetters[] = {

    { "pNext", (getter)PyVkRenderPassBeginInfo_getpNext, NULL, "", NULL},

    { "clearValueCount", (getter)PyVkRenderPassBeginInfo_getclearValueCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkRenderPassBeginInfo_init(PyVkRenderPassBeginInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* renderPass = NULL;
    PyObject* framebuffer = NULL;
    PyObject* renderArea = NULL;
    PyObject* clearValueCount = NULL;
    PyObject* pClearValues = NULL;
    static char *kwlist[] = {"renderPass","framebuffer","renderArea","clearValueCount","pClearValues",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &renderPass, &framebuffer, &renderArea, &clearValueCount, &pClearValues)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;

    (self->base)->pNext = NULL;

    if (renderPass != NULL && renderPass != Py_None) {

        (self->base)->renderPass = PyCapsule_GetPointer(renderPass, "VkRenderPass");

    }

    if (framebuffer != NULL && framebuffer != Py_None) {

        (self->base)->framebuffer = PyCapsule_GetPointer(framebuffer, "VkFramebuffer");

    }

    if (renderArea != NULL && renderArea != Py_None) {

        (self->base)->renderArea = *(((PyVkRect2D*)renderArea)->base);

    }

    if (clearValueCount != NULL && clearValueCount != Py_None) {
        (self->base)->clearValueCount = (uint32_t) PyLong_AsLong(clearValueCount);
    }

    if (pClearValues != NULL && pClearValues != Py_None) {

        (self->base)->pClearValues = (((PyVkClearValue*)pClearValues)->base);

    }

    return 0;
}
static PyTypeObject PyVkRenderPassBeginInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkRenderPassBeginInfo", sizeof(PyVkRenderPassBeginInfo), 0,
    (destructor)PyVkRenderPassBeginInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkRenderPassBeginInfo object",0,0,0,0,0,0,0,0,
    PyVkRenderPassBeginInfo_getsetters,0,0,0,0,0,(initproc)PyVkRenderPassBeginInfo_init,0,PyVkRenderPassBeginInfo_new,
};

static void PyVkClearDepthStencilValue_del(PyVkClearDepthStencilValue* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkClearDepthStencilValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkClearDepthStencilValue *self;
    self = (PyVkClearDepthStencilValue *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkClearDepthStencilValue));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkClearDepthStencilValue");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkClearDepthStencilValue_getdepth(PyVkClearDepthStencilValue *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->depth);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkClearDepthStencilValue_getstencil(PyVkClearDepthStencilValue *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->stencil);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkClearDepthStencilValue_getsetters[] = {

    { "depth", (getter)PyVkClearDepthStencilValue_getdepth, NULL, "", NULL},

    { "stencil", (getter)PyVkClearDepthStencilValue_getstencil, NULL, "", NULL},
    {NULL}
};

static int
PyVkClearDepthStencilValue_init(PyVkClearDepthStencilValue *self, PyObject *args, PyObject *kwds) {
    PyObject* depth = NULL;
    PyObject* stencil = NULL;
    static char *kwlist[] = {"depth","stencil",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &depth, &stencil)) return -1;

    if (depth != NULL && depth != Py_None) {
        (self->base)->depth = (float) PyFloat_AsDouble(depth);
    }

    if (stencil != NULL && stencil != Py_None) {
        (self->base)->stencil = (uint32_t) PyLong_AsLong(stencil);
    }

    return 0;
}
static PyTypeObject PyVkClearDepthStencilValueType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkClearDepthStencilValue", sizeof(PyVkClearDepthStencilValue), 0,
    (destructor)PyVkClearDepthStencilValue_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkClearDepthStencilValue object",0,0,0,0,0,0,0,0,
    PyVkClearDepthStencilValue_getsetters,0,0,0,0,0,(initproc)PyVkClearDepthStencilValue_init,0,PyVkClearDepthStencilValue_new,
};

static void PyVkClearAttachment_del(PyVkClearAttachment* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkClearAttachment_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkClearAttachment *self;
    self = (PyVkClearAttachment *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkClearAttachment));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkClearAttachment");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkClearAttachment_getcolorAttachment(PyVkClearAttachment *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->colorAttachment);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkClearAttachment_getsetters[] = {

    { "colorAttachment", (getter)PyVkClearAttachment_getcolorAttachment, NULL, "", NULL},
    {NULL}
};

static int
PyVkClearAttachment_init(PyVkClearAttachment *self, PyObject *args, PyObject *kwds) {
    PyObject* aspectMask = NULL;
    PyObject* colorAttachment = NULL;
    PyObject* clearValue = NULL;
    static char *kwlist[] = {"aspectMask","colorAttachment","clearValue",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &aspectMask, &colorAttachment, &clearValue)) return -1;

    if (aspectMask != NULL && aspectMask != Py_None) {

        (self->base)->aspectMask = PyLong_AsLong(aspectMask);

    }

    if (colorAttachment != NULL && colorAttachment != Py_None) {
        (self->base)->colorAttachment = (uint32_t) PyLong_AsLong(colorAttachment);
    }

    if (clearValue != NULL && clearValue != Py_None) {

        (self->base)->clearValue = *(((PyVkClearValue*)clearValue)->base);

    }

    return 0;
}
static PyTypeObject PyVkClearAttachmentType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkClearAttachment", sizeof(PyVkClearAttachment), 0,
    (destructor)PyVkClearAttachment_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkClearAttachment object",0,0,0,0,0,0,0,0,
    PyVkClearAttachment_getsetters,0,0,0,0,0,(initproc)PyVkClearAttachment_init,0,PyVkClearAttachment_new,
};

static void PyVkAttachmentDescription_del(PyVkAttachmentDescription* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkAttachmentDescription_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkAttachmentDescription *self;
    self = (PyVkAttachmentDescription *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkAttachmentDescription));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkAttachmentDescription");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkAttachmentDescription_getsetters[] = {
    {NULL}
};

static int
PyVkAttachmentDescription_init(PyVkAttachmentDescription *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* format = NULL;
    PyObject* samples = NULL;
    PyObject* loadOp = NULL;
    PyObject* storeOp = NULL;
    PyObject* stencilLoadOp = NULL;
    PyObject* stencilStoreOp = NULL;
    PyObject* initialLayout = NULL;
    PyObject* finalLayout = NULL;
    static char *kwlist[] = {"flags","format","samples","loadOp","storeOp","stencilLoadOp","stencilStoreOp","initialLayout","finalLayout",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOOO", kwlist, &flags, &format, &samples, &loadOp, &storeOp, &stencilLoadOp, &stencilStoreOp, &initialLayout, &finalLayout)) return -1;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (format != NULL && format != Py_None) {

        (self->base)->format = PyLong_AsLong(format);

    }

    if (samples != NULL && samples != Py_None) {

        (self->base)->samples = PyLong_AsLong(samples);

    }

    if (loadOp != NULL && loadOp != Py_None) {

        (self->base)->loadOp = PyLong_AsLong(loadOp);

    }

    if (storeOp != NULL && storeOp != Py_None) {

        (self->base)->storeOp = PyLong_AsLong(storeOp);

    }

    if (stencilLoadOp != NULL && stencilLoadOp != Py_None) {

        (self->base)->stencilLoadOp = PyLong_AsLong(stencilLoadOp);

    }

    if (stencilStoreOp != NULL && stencilStoreOp != Py_None) {

        (self->base)->stencilStoreOp = PyLong_AsLong(stencilStoreOp);

    }

    if (initialLayout != NULL && initialLayout != Py_None) {

        (self->base)->initialLayout = PyLong_AsLong(initialLayout);

    }

    if (finalLayout != NULL && finalLayout != Py_None) {

        (self->base)->finalLayout = PyLong_AsLong(finalLayout);

    }

    return 0;
}
static PyTypeObject PyVkAttachmentDescriptionType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkAttachmentDescription", sizeof(PyVkAttachmentDescription), 0,
    (destructor)PyVkAttachmentDescription_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkAttachmentDescription object",0,0,0,0,0,0,0,0,
    PyVkAttachmentDescription_getsetters,0,0,0,0,0,(initproc)PyVkAttachmentDescription_init,0,PyVkAttachmentDescription_new,
};

static void PyVkAttachmentReference_del(PyVkAttachmentReference* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkAttachmentReference_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkAttachmentReference *self;
    self = (PyVkAttachmentReference *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkAttachmentReference));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkAttachmentReference");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkAttachmentReference_getattachment(PyVkAttachmentReference *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->attachment);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkAttachmentReference_getsetters[] = {

    { "attachment", (getter)PyVkAttachmentReference_getattachment, NULL, "", NULL},
    {NULL}
};

static int
PyVkAttachmentReference_init(PyVkAttachmentReference *self, PyObject *args, PyObject *kwds) {
    PyObject* attachment = NULL;
    PyObject* layout = NULL;
    static char *kwlist[] = {"attachment","layout",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &attachment, &layout)) return -1;

    if (attachment != NULL && attachment != Py_None) {
        (self->base)->attachment = (uint32_t) PyLong_AsLong(attachment);
    }

    if (layout != NULL && layout != Py_None) {

        (self->base)->layout = PyLong_AsLong(layout);

    }

    return 0;
}
static PyTypeObject PyVkAttachmentReferenceType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkAttachmentReference", sizeof(PyVkAttachmentReference), 0,
    (destructor)PyVkAttachmentReference_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkAttachmentReference object",0,0,0,0,0,0,0,0,
    PyVkAttachmentReference_getsetters,0,0,0,0,0,(initproc)PyVkAttachmentReference_init,0,PyVkAttachmentReference_new,
};

static void PyVkSubpassDescription_del(PyVkSubpassDescription* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkSubpassDescription_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkSubpassDescription *self;
    self = (PyVkSubpassDescription *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkSubpassDescription));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSubpassDescription");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkSubpassDescription_getinputAttachmentCount(PyVkSubpassDescription *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->inputAttachmentCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSubpassDescription_getcolorAttachmentCount(PyVkSubpassDescription *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->colorAttachmentCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSubpassDescription_getpreserveAttachmentCount(PyVkSubpassDescription *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->preserveAttachmentCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSubpassDescription_getpPreserveAttachments(PyVkSubpassDescription *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (*((self->base)->pPreserveAttachments)));
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkSubpassDescription_getsetters[] = {

    { "inputAttachmentCount", (getter)PyVkSubpassDescription_getinputAttachmentCount, NULL, "", NULL},

    { "colorAttachmentCount", (getter)PyVkSubpassDescription_getcolorAttachmentCount, NULL, "", NULL},

    { "preserveAttachmentCount", (getter)PyVkSubpassDescription_getpreserveAttachmentCount, NULL, "", NULL},

    { "pPreserveAttachments", (getter)PyVkSubpassDescription_getpPreserveAttachments, NULL, "", NULL},
    {NULL}
};

static int
PyVkSubpassDescription_init(PyVkSubpassDescription *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* pipelineBindPoint = NULL;
    PyObject* inputAttachmentCount = NULL;
    PyObject* pInputAttachments = NULL;
    PyObject* colorAttachmentCount = NULL;
    PyObject* pColorAttachments = NULL;
    PyObject* pResolveAttachments = NULL;
    PyObject* pDepthStencilAttachment = NULL;
    PyObject* preserveAttachmentCount = NULL;
    PyObject* pPreserveAttachments = NULL;
    static char *kwlist[] = {"flags","pipelineBindPoint","inputAttachmentCount","pInputAttachments","colorAttachmentCount","pColorAttachments","pResolveAttachments","pDepthStencilAttachment","preserveAttachmentCount","pPreserveAttachments",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOOOO", kwlist, &flags, &pipelineBindPoint, &inputAttachmentCount, &pInputAttachments, &colorAttachmentCount, &pColorAttachments, &pResolveAttachments, &pDepthStencilAttachment, &preserveAttachmentCount, &pPreserveAttachments)) return -1;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (pipelineBindPoint != NULL && pipelineBindPoint != Py_None) {

        (self->base)->pipelineBindPoint = PyLong_AsLong(pipelineBindPoint);

    }

    if (inputAttachmentCount != NULL && inputAttachmentCount != Py_None) {
        (self->base)->inputAttachmentCount = (uint32_t) PyLong_AsLong(inputAttachmentCount);
    }

    if (pInputAttachments != NULL && pInputAttachments != Py_None) {

        (self->base)->pInputAttachments = (((PyVkAttachmentReference*)pInputAttachments)->base);

    }

    if (colorAttachmentCount != NULL && colorAttachmentCount != Py_None) {
        (self->base)->colorAttachmentCount = (uint32_t) PyLong_AsLong(colorAttachmentCount);
    }

    if (pColorAttachments != NULL && pColorAttachments != Py_None) {

        (self->base)->pColorAttachments = (((PyVkAttachmentReference*)pColorAttachments)->base);

    }

    if (pResolveAttachments != NULL && pResolveAttachments != Py_None) {

        (self->base)->pResolveAttachments = (((PyVkAttachmentReference*)pResolveAttachments)->base);

    }

    if (pDepthStencilAttachment != NULL && pDepthStencilAttachment != Py_None) {

        (self->base)->pDepthStencilAttachment = (((PyVkAttachmentReference*)pDepthStencilAttachment)->base);

    }

    if (preserveAttachmentCount != NULL && preserveAttachmentCount != Py_None) {
        (self->base)->preserveAttachmentCount = (uint32_t) PyLong_AsLong(preserveAttachmentCount);
    }

    if (pPreserveAttachments != NULL && pPreserveAttachments != Py_None) {

        uint32_t tmp27657762 = (uint32_t) PyLong_AsLong(pPreserveAttachments);
        uint32_t *tmp23337775 = malloc(sizeof(uint32_t));
        memcpy(tmp23337775, &tmp27657762, sizeof(uint32_t));
        (self->base)->pPreserveAttachments = tmp23337775;

    }

    return 0;
}
static PyTypeObject PyVkSubpassDescriptionType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkSubpassDescription", sizeof(PyVkSubpassDescription), 0,
    (destructor)PyVkSubpassDescription_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkSubpassDescription object",0,0,0,0,0,0,0,0,
    PyVkSubpassDescription_getsetters,0,0,0,0,0,(initproc)PyVkSubpassDescription_init,0,PyVkSubpassDescription_new,
};

static void PyVkSubpassDependency_del(PyVkSubpassDependency* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkSubpassDependency_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkSubpassDependency *self;
    self = (PyVkSubpassDependency *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkSubpassDependency));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSubpassDependency");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkSubpassDependency_getsrcSubpass(PyVkSubpassDependency *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->srcSubpass);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSubpassDependency_getdstSubpass(PyVkSubpassDependency *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->dstSubpass);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkSubpassDependency_getsetters[] = {

    { "srcSubpass", (getter)PyVkSubpassDependency_getsrcSubpass, NULL, "", NULL},

    { "dstSubpass", (getter)PyVkSubpassDependency_getdstSubpass, NULL, "", NULL},
    {NULL}
};

static int
PyVkSubpassDependency_init(PyVkSubpassDependency *self, PyObject *args, PyObject *kwds) {
    PyObject* srcSubpass = NULL;
    PyObject* dstSubpass = NULL;
    PyObject* srcStageMask = NULL;
    PyObject* dstStageMask = NULL;
    PyObject* srcAccessMask = NULL;
    PyObject* dstAccessMask = NULL;
    PyObject* dependencyFlags = NULL;
    static char *kwlist[] = {"srcSubpass","dstSubpass","srcStageMask","dstStageMask","srcAccessMask","dstAccessMask","dependencyFlags",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &srcSubpass, &dstSubpass, &srcStageMask, &dstStageMask, &srcAccessMask, &dstAccessMask, &dependencyFlags)) return -1;

    if (srcSubpass != NULL && srcSubpass != Py_None) {
        (self->base)->srcSubpass = (uint32_t) PyLong_AsLong(srcSubpass);
    }

    if (dstSubpass != NULL && dstSubpass != Py_None) {
        (self->base)->dstSubpass = (uint32_t) PyLong_AsLong(dstSubpass);
    }

    if (srcStageMask != NULL && srcStageMask != Py_None) {

        (self->base)->srcStageMask = PyLong_AsLong(srcStageMask);

    }

    if (dstStageMask != NULL && dstStageMask != Py_None) {

        (self->base)->dstStageMask = PyLong_AsLong(dstStageMask);

    }

    if (srcAccessMask != NULL && srcAccessMask != Py_None) {

        (self->base)->srcAccessMask = PyLong_AsLong(srcAccessMask);

    }

    if (dstAccessMask != NULL && dstAccessMask != Py_None) {

        (self->base)->dstAccessMask = PyLong_AsLong(dstAccessMask);

    }

    if (dependencyFlags != NULL && dependencyFlags != Py_None) {

        (self->base)->dependencyFlags = PyLong_AsLong(dependencyFlags);

    }

    return 0;
}
static PyTypeObject PyVkSubpassDependencyType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkSubpassDependency", sizeof(PyVkSubpassDependency), 0,
    (destructor)PyVkSubpassDependency_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkSubpassDependency object",0,0,0,0,0,0,0,0,
    PyVkSubpassDependency_getsetters,0,0,0,0,0,(initproc)PyVkSubpassDependency_init,0,PyVkSubpassDependency_new,
};

static void PyVkRenderPassCreateInfo_del(PyVkRenderPassCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkRenderPassCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkRenderPassCreateInfo *self;
    self = (PyVkRenderPassCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkRenderPassCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkRenderPassCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkRenderPassCreateInfo_getpNext(PyVkRenderPassCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkRenderPassCreateInfo_getattachmentCount(PyVkRenderPassCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->attachmentCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkRenderPassCreateInfo_getsubpassCount(PyVkRenderPassCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->subpassCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkRenderPassCreateInfo_getdependencyCount(PyVkRenderPassCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->dependencyCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkRenderPassCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkRenderPassCreateInfo_getpNext, NULL, "", NULL},

    { "attachmentCount", (getter)PyVkRenderPassCreateInfo_getattachmentCount, NULL, "", NULL},

    { "subpassCount", (getter)PyVkRenderPassCreateInfo_getsubpassCount, NULL, "", NULL},

    { "dependencyCount", (getter)PyVkRenderPassCreateInfo_getdependencyCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkRenderPassCreateInfo_init(PyVkRenderPassCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* attachmentCount = NULL;
    PyObject* pAttachments = NULL;
    PyObject* subpassCount = NULL;
    PyObject* pSubpasses = NULL;
    PyObject* dependencyCount = NULL;
    PyObject* pDependencies = NULL;
    static char *kwlist[] = {"flags","attachmentCount","pAttachments","subpassCount","pSubpasses","dependencyCount","pDependencies",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &flags, &attachmentCount, &pAttachments, &subpassCount, &pSubpasses, &dependencyCount, &pDependencies)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (attachmentCount != NULL && attachmentCount != Py_None) {
        (self->base)->attachmentCount = (uint32_t) PyLong_AsLong(attachmentCount);
    }

    if (pAttachments != NULL && pAttachments != Py_None) {

        (self->base)->pAttachments = (((PyVkAttachmentDescription*)pAttachments)->base);

    }

    if (subpassCount != NULL && subpassCount != Py_None) {
        (self->base)->subpassCount = (uint32_t) PyLong_AsLong(subpassCount);
    }

    if (pSubpasses != NULL && pSubpasses != Py_None) {

        (self->base)->pSubpasses = (((PyVkSubpassDescription*)pSubpasses)->base);

    }

    if (dependencyCount != NULL && dependencyCount != Py_None) {
        (self->base)->dependencyCount = (uint32_t) PyLong_AsLong(dependencyCount);
    }

    if (pDependencies != NULL && pDependencies != Py_None) {

        (self->base)->pDependencies = (((PyVkSubpassDependency*)pDependencies)->base);

    }

    return 0;
}
static PyTypeObject PyVkRenderPassCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkRenderPassCreateInfo", sizeof(PyVkRenderPassCreateInfo), 0,
    (destructor)PyVkRenderPassCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkRenderPassCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkRenderPassCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkRenderPassCreateInfo_init,0,PyVkRenderPassCreateInfo_new,
};

static void PyVkEventCreateInfo_del(PyVkEventCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkEventCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkEventCreateInfo *self;
    self = (PyVkEventCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkEventCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkEventCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkEventCreateInfo_getpNext(PyVkEventCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkEventCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkEventCreateInfo_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkEventCreateInfo_init(PyVkEventCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    static char *kwlist[] = {"flags",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &flags)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    return 0;
}
static PyTypeObject PyVkEventCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkEventCreateInfo", sizeof(PyVkEventCreateInfo), 0,
    (destructor)PyVkEventCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkEventCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkEventCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkEventCreateInfo_init,0,PyVkEventCreateInfo_new,
};

static void PyVkFenceCreateInfo_del(PyVkFenceCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkFenceCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkFenceCreateInfo *self;
    self = (PyVkFenceCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkFenceCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkFenceCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkFenceCreateInfo_getpNext(PyVkFenceCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkFenceCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkFenceCreateInfo_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkFenceCreateInfo_init(PyVkFenceCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    static char *kwlist[] = {"flags",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &flags)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    return 0;
}
static PyTypeObject PyVkFenceCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkFenceCreateInfo", sizeof(PyVkFenceCreateInfo), 0,
    (destructor)PyVkFenceCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkFenceCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkFenceCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkFenceCreateInfo_init,0,PyVkFenceCreateInfo_new,
};

static void PyVkPhysicalDeviceFeatures_del(PyVkPhysicalDeviceFeatures* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPhysicalDeviceFeatures_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPhysicalDeviceFeatures *self;
    self = (PyVkPhysicalDeviceFeatures *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPhysicalDeviceFeatures));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPhysicalDeviceFeatures");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkPhysicalDeviceFeatures_getsetters[] = {
    {NULL}
};

static int
PyVkPhysicalDeviceFeatures_init(PyVkPhysicalDeviceFeatures *self, PyObject *args, PyObject *kwds) {
    PyObject* robustBufferAccess = NULL;
    PyObject* fullDrawIndexUint32 = NULL;
    PyObject* imageCubeArray = NULL;
    PyObject* independentBlend = NULL;
    PyObject* geometryShader = NULL;
    PyObject* tessellationShader = NULL;
    PyObject* sampleRateShading = NULL;
    PyObject* dualSrcBlend = NULL;
    PyObject* logicOp = NULL;
    PyObject* multiDrawIndirect = NULL;
    PyObject* drawIndirectFirstInstance = NULL;
    PyObject* depthClamp = NULL;
    PyObject* depthBiasClamp = NULL;
    PyObject* fillModeNonSolid = NULL;
    PyObject* depthBounds = NULL;
    PyObject* wideLines = NULL;
    PyObject* largePoints = NULL;
    PyObject* alphaToOne = NULL;
    PyObject* multiViewport = NULL;
    PyObject* samplerAnisotropy = NULL;
    PyObject* textureCompressionETC2 = NULL;
    PyObject* textureCompressionASTC_LDR = NULL;
    PyObject* textureCompressionBC = NULL;
    PyObject* occlusionQueryPrecise = NULL;
    PyObject* pipelineStatisticsQuery = NULL;
    PyObject* vertexPipelineStoresAndAtomics = NULL;
    PyObject* fragmentStoresAndAtomics = NULL;
    PyObject* shaderTessellationAndGeometryPointSize = NULL;
    PyObject* shaderImageGatherExtended = NULL;
    PyObject* shaderStorageImageExtendedFormats = NULL;
    PyObject* shaderStorageImageMultisample = NULL;
    PyObject* shaderStorageImageReadWithoutFormat = NULL;
    PyObject* shaderStorageImageWriteWithoutFormat = NULL;
    PyObject* shaderUniformBufferArrayDynamicIndexing = NULL;
    PyObject* shaderSampledImageArrayDynamicIndexing = NULL;
    PyObject* shaderStorageBufferArrayDynamicIndexing = NULL;
    PyObject* shaderStorageImageArrayDynamicIndexing = NULL;
    PyObject* shaderClipDistance = NULL;
    PyObject* shaderCullDistance = NULL;
    PyObject* shaderFloat64 = NULL;
    PyObject* shaderInt64 = NULL;
    PyObject* shaderInt16 = NULL;
    PyObject* shaderResourceResidency = NULL;
    PyObject* shaderResourceMinLod = NULL;
    PyObject* sparseBinding = NULL;
    PyObject* sparseResidencyBuffer = NULL;
    PyObject* sparseResidencyImage2D = NULL;
    PyObject* sparseResidencyImage3D = NULL;
    PyObject* sparseResidency2Samples = NULL;
    PyObject* sparseResidency4Samples = NULL;
    PyObject* sparseResidency8Samples = NULL;
    PyObject* sparseResidency16Samples = NULL;
    PyObject* sparseResidencyAliased = NULL;
    PyObject* variableMultisampleRate = NULL;
    PyObject* inheritedQueries = NULL;
    static char *kwlist[] = {"robustBufferAccess","fullDrawIndexUint32","imageCubeArray","independentBlend","geometryShader","tessellationShader","sampleRateShading","dualSrcBlend","logicOp","multiDrawIndirect","drawIndirectFirstInstance","depthClamp","depthBiasClamp","fillModeNonSolid","depthBounds","wideLines","largePoints","alphaToOne","multiViewport","samplerAnisotropy","textureCompressionETC2","textureCompressionASTC_LDR","textureCompressionBC","occlusionQueryPrecise","pipelineStatisticsQuery","vertexPipelineStoresAndAtomics","fragmentStoresAndAtomics","shaderTessellationAndGeometryPointSize","shaderImageGatherExtended","shaderStorageImageExtendedFormats","shaderStorageImageMultisample","shaderStorageImageReadWithoutFormat","shaderStorageImageWriteWithoutFormat","shaderUniformBufferArrayDynamicIndexing","shaderSampledImageArrayDynamicIndexing","shaderStorageBufferArrayDynamicIndexing","shaderStorageImageArrayDynamicIndexing","shaderClipDistance","shaderCullDistance","shaderFloat64","shaderInt64","shaderInt16","shaderResourceResidency","shaderResourceMinLod","sparseBinding","sparseResidencyBuffer","sparseResidencyImage2D","sparseResidencyImage3D","sparseResidency2Samples","sparseResidency4Samples","sparseResidency8Samples","sparseResidency16Samples","sparseResidencyAliased","variableMultisampleRate","inheritedQueries",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO", kwlist, &robustBufferAccess, &fullDrawIndexUint32, &imageCubeArray, &independentBlend, &geometryShader, &tessellationShader, &sampleRateShading, &dualSrcBlend, &logicOp, &multiDrawIndirect, &drawIndirectFirstInstance, &depthClamp, &depthBiasClamp, &fillModeNonSolid, &depthBounds, &wideLines, &largePoints, &alphaToOne, &multiViewport, &samplerAnisotropy, &textureCompressionETC2, &textureCompressionASTC_LDR, &textureCompressionBC, &occlusionQueryPrecise, &pipelineStatisticsQuery, &vertexPipelineStoresAndAtomics, &fragmentStoresAndAtomics, &shaderTessellationAndGeometryPointSize, &shaderImageGatherExtended, &shaderStorageImageExtendedFormats, &shaderStorageImageMultisample, &shaderStorageImageReadWithoutFormat, &shaderStorageImageWriteWithoutFormat, &shaderUniformBufferArrayDynamicIndexing, &shaderSampledImageArrayDynamicIndexing, &shaderStorageBufferArrayDynamicIndexing, &shaderStorageImageArrayDynamicIndexing, &shaderClipDistance, &shaderCullDistance, &shaderFloat64, &shaderInt64, &shaderInt16, &shaderResourceResidency, &shaderResourceMinLod, &sparseBinding, &sparseResidencyBuffer, &sparseResidencyImage2D, &sparseResidencyImage3D, &sparseResidency2Samples, &sparseResidency4Samples, &sparseResidency8Samples, &sparseResidency16Samples, &sparseResidencyAliased, &variableMultisampleRate, &inheritedQueries)) return -1;

    if (robustBufferAccess != NULL && robustBufferAccess != Py_None) {

        (self->base)->robustBufferAccess = PyLong_AsLong(robustBufferAccess);

    }

    if (fullDrawIndexUint32 != NULL && fullDrawIndexUint32 != Py_None) {

        (self->base)->fullDrawIndexUint32 = PyLong_AsLong(fullDrawIndexUint32);

    }

    if (imageCubeArray != NULL && imageCubeArray != Py_None) {

        (self->base)->imageCubeArray = PyLong_AsLong(imageCubeArray);

    }

    if (independentBlend != NULL && independentBlend != Py_None) {

        (self->base)->independentBlend = PyLong_AsLong(independentBlend);

    }

    if (geometryShader != NULL && geometryShader != Py_None) {

        (self->base)->geometryShader = PyLong_AsLong(geometryShader);

    }

    if (tessellationShader != NULL && tessellationShader != Py_None) {

        (self->base)->tessellationShader = PyLong_AsLong(tessellationShader);

    }

    if (sampleRateShading != NULL && sampleRateShading != Py_None) {

        (self->base)->sampleRateShading = PyLong_AsLong(sampleRateShading);

    }

    if (dualSrcBlend != NULL && dualSrcBlend != Py_None) {

        (self->base)->dualSrcBlend = PyLong_AsLong(dualSrcBlend);

    }

    if (logicOp != NULL && logicOp != Py_None) {

        (self->base)->logicOp = PyLong_AsLong(logicOp);

    }

    if (multiDrawIndirect != NULL && multiDrawIndirect != Py_None) {

        (self->base)->multiDrawIndirect = PyLong_AsLong(multiDrawIndirect);

    }

    if (drawIndirectFirstInstance != NULL && drawIndirectFirstInstance != Py_None) {

        (self->base)->drawIndirectFirstInstance = PyLong_AsLong(drawIndirectFirstInstance);

    }

    if (depthClamp != NULL && depthClamp != Py_None) {

        (self->base)->depthClamp = PyLong_AsLong(depthClamp);

    }

    if (depthBiasClamp != NULL && depthBiasClamp != Py_None) {

        (self->base)->depthBiasClamp = PyLong_AsLong(depthBiasClamp);

    }

    if (fillModeNonSolid != NULL && fillModeNonSolid != Py_None) {

        (self->base)->fillModeNonSolid = PyLong_AsLong(fillModeNonSolid);

    }

    if (depthBounds != NULL && depthBounds != Py_None) {

        (self->base)->depthBounds = PyLong_AsLong(depthBounds);

    }

    if (wideLines != NULL && wideLines != Py_None) {

        (self->base)->wideLines = PyLong_AsLong(wideLines);

    }

    if (largePoints != NULL && largePoints != Py_None) {

        (self->base)->largePoints = PyLong_AsLong(largePoints);

    }

    if (alphaToOne != NULL && alphaToOne != Py_None) {

        (self->base)->alphaToOne = PyLong_AsLong(alphaToOne);

    }

    if (multiViewport != NULL && multiViewport != Py_None) {

        (self->base)->multiViewport = PyLong_AsLong(multiViewport);

    }

    if (samplerAnisotropy != NULL && samplerAnisotropy != Py_None) {

        (self->base)->samplerAnisotropy = PyLong_AsLong(samplerAnisotropy);

    }

    if (textureCompressionETC2 != NULL && textureCompressionETC2 != Py_None) {

        (self->base)->textureCompressionETC2 = PyLong_AsLong(textureCompressionETC2);

    }

    if (textureCompressionASTC_LDR != NULL && textureCompressionASTC_LDR != Py_None) {

        (self->base)->textureCompressionASTC_LDR = PyLong_AsLong(textureCompressionASTC_LDR);

    }

    if (textureCompressionBC != NULL && textureCompressionBC != Py_None) {

        (self->base)->textureCompressionBC = PyLong_AsLong(textureCompressionBC);

    }

    if (occlusionQueryPrecise != NULL && occlusionQueryPrecise != Py_None) {

        (self->base)->occlusionQueryPrecise = PyLong_AsLong(occlusionQueryPrecise);

    }

    if (pipelineStatisticsQuery != NULL && pipelineStatisticsQuery != Py_None) {

        (self->base)->pipelineStatisticsQuery = PyLong_AsLong(pipelineStatisticsQuery);

    }

    if (vertexPipelineStoresAndAtomics != NULL && vertexPipelineStoresAndAtomics != Py_None) {

        (self->base)->vertexPipelineStoresAndAtomics = PyLong_AsLong(vertexPipelineStoresAndAtomics);

    }

    if (fragmentStoresAndAtomics != NULL && fragmentStoresAndAtomics != Py_None) {

        (self->base)->fragmentStoresAndAtomics = PyLong_AsLong(fragmentStoresAndAtomics);

    }

    if (shaderTessellationAndGeometryPointSize != NULL && shaderTessellationAndGeometryPointSize != Py_None) {

        (self->base)->shaderTessellationAndGeometryPointSize = PyLong_AsLong(shaderTessellationAndGeometryPointSize);

    }

    if (shaderImageGatherExtended != NULL && shaderImageGatherExtended != Py_None) {

        (self->base)->shaderImageGatherExtended = PyLong_AsLong(shaderImageGatherExtended);

    }

    if (shaderStorageImageExtendedFormats != NULL && shaderStorageImageExtendedFormats != Py_None) {

        (self->base)->shaderStorageImageExtendedFormats = PyLong_AsLong(shaderStorageImageExtendedFormats);

    }

    if (shaderStorageImageMultisample != NULL && shaderStorageImageMultisample != Py_None) {

        (self->base)->shaderStorageImageMultisample = PyLong_AsLong(shaderStorageImageMultisample);

    }

    if (shaderStorageImageReadWithoutFormat != NULL && shaderStorageImageReadWithoutFormat != Py_None) {

        (self->base)->shaderStorageImageReadWithoutFormat = PyLong_AsLong(shaderStorageImageReadWithoutFormat);

    }

    if (shaderStorageImageWriteWithoutFormat != NULL && shaderStorageImageWriteWithoutFormat != Py_None) {

        (self->base)->shaderStorageImageWriteWithoutFormat = PyLong_AsLong(shaderStorageImageWriteWithoutFormat);

    }

    if (shaderUniformBufferArrayDynamicIndexing != NULL && shaderUniformBufferArrayDynamicIndexing != Py_None) {

        (self->base)->shaderUniformBufferArrayDynamicIndexing = PyLong_AsLong(shaderUniformBufferArrayDynamicIndexing);

    }

    if (shaderSampledImageArrayDynamicIndexing != NULL && shaderSampledImageArrayDynamicIndexing != Py_None) {

        (self->base)->shaderSampledImageArrayDynamicIndexing = PyLong_AsLong(shaderSampledImageArrayDynamicIndexing);

    }

    if (shaderStorageBufferArrayDynamicIndexing != NULL && shaderStorageBufferArrayDynamicIndexing != Py_None) {

        (self->base)->shaderStorageBufferArrayDynamicIndexing = PyLong_AsLong(shaderStorageBufferArrayDynamicIndexing);

    }

    if (shaderStorageImageArrayDynamicIndexing != NULL && shaderStorageImageArrayDynamicIndexing != Py_None) {

        (self->base)->shaderStorageImageArrayDynamicIndexing = PyLong_AsLong(shaderStorageImageArrayDynamicIndexing);

    }

    if (shaderClipDistance != NULL && shaderClipDistance != Py_None) {

        (self->base)->shaderClipDistance = PyLong_AsLong(shaderClipDistance);

    }

    if (shaderCullDistance != NULL && shaderCullDistance != Py_None) {

        (self->base)->shaderCullDistance = PyLong_AsLong(shaderCullDistance);

    }

    if (shaderFloat64 != NULL && shaderFloat64 != Py_None) {

        (self->base)->shaderFloat64 = PyLong_AsLong(shaderFloat64);

    }

    if (shaderInt64 != NULL && shaderInt64 != Py_None) {

        (self->base)->shaderInt64 = PyLong_AsLong(shaderInt64);

    }

    if (shaderInt16 != NULL && shaderInt16 != Py_None) {

        (self->base)->shaderInt16 = PyLong_AsLong(shaderInt16);

    }

    if (shaderResourceResidency != NULL && shaderResourceResidency != Py_None) {

        (self->base)->shaderResourceResidency = PyLong_AsLong(shaderResourceResidency);

    }

    if (shaderResourceMinLod != NULL && shaderResourceMinLod != Py_None) {

        (self->base)->shaderResourceMinLod = PyLong_AsLong(shaderResourceMinLod);

    }

    if (sparseBinding != NULL && sparseBinding != Py_None) {

        (self->base)->sparseBinding = PyLong_AsLong(sparseBinding);

    }

    if (sparseResidencyBuffer != NULL && sparseResidencyBuffer != Py_None) {

        (self->base)->sparseResidencyBuffer = PyLong_AsLong(sparseResidencyBuffer);

    }

    if (sparseResidencyImage2D != NULL && sparseResidencyImage2D != Py_None) {

        (self->base)->sparseResidencyImage2D = PyLong_AsLong(sparseResidencyImage2D);

    }

    if (sparseResidencyImage3D != NULL && sparseResidencyImage3D != Py_None) {

        (self->base)->sparseResidencyImage3D = PyLong_AsLong(sparseResidencyImage3D);

    }

    if (sparseResidency2Samples != NULL && sparseResidency2Samples != Py_None) {

        (self->base)->sparseResidency2Samples = PyLong_AsLong(sparseResidency2Samples);

    }

    if (sparseResidency4Samples != NULL && sparseResidency4Samples != Py_None) {

        (self->base)->sparseResidency4Samples = PyLong_AsLong(sparseResidency4Samples);

    }

    if (sparseResidency8Samples != NULL && sparseResidency8Samples != Py_None) {

        (self->base)->sparseResidency8Samples = PyLong_AsLong(sparseResidency8Samples);

    }

    if (sparseResidency16Samples != NULL && sparseResidency16Samples != Py_None) {

        (self->base)->sparseResidency16Samples = PyLong_AsLong(sparseResidency16Samples);

    }

    if (sparseResidencyAliased != NULL && sparseResidencyAliased != Py_None) {

        (self->base)->sparseResidencyAliased = PyLong_AsLong(sparseResidencyAliased);

    }

    if (variableMultisampleRate != NULL && variableMultisampleRate != Py_None) {

        (self->base)->variableMultisampleRate = PyLong_AsLong(variableMultisampleRate);

    }

    if (inheritedQueries != NULL && inheritedQueries != Py_None) {

        (self->base)->inheritedQueries = PyLong_AsLong(inheritedQueries);

    }

    return 0;
}
static PyTypeObject PyVkPhysicalDeviceFeaturesType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPhysicalDeviceFeatures", sizeof(PyVkPhysicalDeviceFeatures), 0,
    (destructor)PyVkPhysicalDeviceFeatures_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPhysicalDeviceFeatures object",0,0,0,0,0,0,0,0,
    PyVkPhysicalDeviceFeatures_getsetters,0,0,0,0,0,(initproc)PyVkPhysicalDeviceFeatures_init,0,PyVkPhysicalDeviceFeatures_new,
};

static void PyVkPhysicalDeviceSparseProperties_del(PyVkPhysicalDeviceSparseProperties* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPhysicalDeviceSparseProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPhysicalDeviceSparseProperties *self;
    self = (PyVkPhysicalDeviceSparseProperties *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPhysicalDeviceSparseProperties));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPhysicalDeviceSparseProperties");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkPhysicalDeviceSparseProperties_getsetters[] = {
    {NULL}
};

static int
PyVkPhysicalDeviceSparseProperties_init(PyVkPhysicalDeviceSparseProperties *self, PyObject *args, PyObject *kwds) {
    return 0;
}
static PyTypeObject PyVkPhysicalDeviceSparsePropertiesType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPhysicalDeviceSparseProperties", sizeof(PyVkPhysicalDeviceSparseProperties), 0,
    (destructor)PyVkPhysicalDeviceSparseProperties_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPhysicalDeviceSparseProperties object",0,0,0,0,0,0,0,0,
    PyVkPhysicalDeviceSparseProperties_getsetters,0,0,0,0,0,(initproc)PyVkPhysicalDeviceSparseProperties_init,0,PyVkPhysicalDeviceSparseProperties_new,
};

static void PyVkPhysicalDeviceLimits_del(PyVkPhysicalDeviceLimits* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPhysicalDeviceLimits_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPhysicalDeviceLimits *self;
    self = (PyVkPhysicalDeviceLimits *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPhysicalDeviceLimits));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPhysicalDeviceLimits");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxImageDimension1D(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxImageDimension1D);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxImageDimension2D(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxImageDimension2D);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxImageDimension3D(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxImageDimension3D);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxImageDimensionCube(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxImageDimensionCube);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxImageArrayLayers(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxImageArrayLayers);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxTexelBufferElements(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxTexelBufferElements);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxUniformBufferRange(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxUniformBufferRange);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxStorageBufferRange(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxStorageBufferRange);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxPushConstantsSize(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxPushConstantsSize);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxMemoryAllocationCount(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxMemoryAllocationCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxSamplerAllocationCount(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxSamplerAllocationCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxBoundDescriptorSets(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxBoundDescriptorSets);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorSamplers(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageDescriptorSamplers);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorUniformBuffers(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageDescriptorUniformBuffers);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorStorageBuffers(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageDescriptorStorageBuffers);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorSampledImages(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageDescriptorSampledImages);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorStorageImages(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageDescriptorStorageImages);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorInputAttachments(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageDescriptorInputAttachments);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageResources(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageResources);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetSamplers(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetSamplers);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetUniformBuffers(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetUniformBuffers);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetUniformBuffersDynamic(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetUniformBuffersDynamic);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageBuffers(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetStorageBuffers);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageBuffersDynamic(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetStorageBuffersDynamic);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetSampledImages(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetSampledImages);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageImages(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetStorageImages);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetInputAttachments(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetInputAttachments);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxVertexInputAttributes(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxVertexInputAttributes);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxVertexInputBindings(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxVertexInputBindings);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxVertexInputAttributeOffset(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxVertexInputAttributeOffset);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxVertexInputBindingStride(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxVertexInputBindingStride);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxVertexOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxVertexOutputComponents);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationGenerationLevel(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationGenerationLevel);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationPatchSize(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationPatchSize);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationControlPerVertexInputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationControlPerVertexInputComponents);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationControlPerVertexOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationControlPerVertexOutputComponents);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationControlPerPatchOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationControlPerPatchOutputComponents);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationControlTotalOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationControlTotalOutputComponents);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationEvaluationInputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationEvaluationInputComponents);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationEvaluationOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationEvaluationOutputComponents);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxGeometryShaderInvocations(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxGeometryShaderInvocations);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxGeometryInputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxGeometryInputComponents);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxGeometryOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxGeometryOutputComponents);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxGeometryOutputVertices(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxGeometryOutputVertices);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxGeometryTotalOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxGeometryTotalOutputComponents);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxFragmentInputComponents(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxFragmentInputComponents);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxFragmentOutputAttachments(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxFragmentOutputAttachments);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxFragmentDualSrcAttachments(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxFragmentDualSrcAttachments);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxFragmentCombinedOutputResources(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxFragmentCombinedOutputResources);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxComputeSharedMemorySize(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxComputeSharedMemorySize);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupCount(PyVkPhysicalDeviceLimits *self, void *closure) {

    PyObject* value = PyList_New(0);
    int nb = sizeof((self->base)->maxComputeWorkGroupCount) / sizeof((self->base)->maxComputeWorkGroupCount[0]);
    int i = 0;
    for (i = 0; i < nb; i++) {
        PyObject* py_tmp = PyLong_FromLong((long) (self->base)->maxComputeWorkGroupCount[i]);
        PyList_Append(value, py_tmp);
    }

    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupInvocations(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxComputeWorkGroupInvocations);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupSize(PyVkPhysicalDeviceLimits *self, void *closure) {

    PyObject* value = PyList_New(0);
    int nb = sizeof((self->base)->maxComputeWorkGroupSize) / sizeof((self->base)->maxComputeWorkGroupSize[0]);
    int i = 0;
    for (i = 0; i < nb; i++) {
        PyObject* py_tmp = PyLong_FromLong((long) (self->base)->maxComputeWorkGroupSize[i]);
        PyList_Append(value, py_tmp);
    }

    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getsubPixelPrecisionBits(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->subPixelPrecisionBits);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getsubTexelPrecisionBits(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->subTexelPrecisionBits);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmipmapPrecisionBits(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->mipmapPrecisionBits);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxDrawIndexedIndexValue(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxDrawIndexedIndexValue);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxDrawIndirectCount(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxDrawIndirectCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxSamplerLodBias(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->maxSamplerLodBias);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxSamplerAnisotropy(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->maxSamplerAnisotropy);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxViewports(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxViewports);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxViewportDimensions(PyVkPhysicalDeviceLimits *self, void *closure) {

    PyObject* value = PyList_New(0);
    int nb = sizeof((self->base)->maxViewportDimensions) / sizeof((self->base)->maxViewportDimensions[0]);
    int i = 0;
    for (i = 0; i < nb; i++) {
        PyObject* py_tmp = PyLong_FromLong((long) (self->base)->maxViewportDimensions[i]);
        PyList_Append(value, py_tmp);
    }

    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getviewportBoundsRange(PyVkPhysicalDeviceLimits *self, void *closure) {

    PyObject* value = PyList_New(0);
    int nb = sizeof((self->base)->viewportBoundsRange) / sizeof((self->base)->viewportBoundsRange[0]);
    int i = 0;
    for (i = 0; i < nb; i++) {
        PyObject* py_tmp = PyFloat_FromDouble((double) (self->base)->viewportBoundsRange[i]);
        PyList_Append(value, py_tmp);
    }

    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getviewportSubPixelBits(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->viewportSubPixelBits);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getminMemoryMapAlignment(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->minMemoryMapAlignment);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getminTexelOffset(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->minTexelOffset);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxTexelOffset(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxTexelOffset);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getminTexelGatherOffset(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->minTexelGatherOffset);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxTexelGatherOffset(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxTexelGatherOffset);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getminInterpolationOffset(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->minInterpolationOffset);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxInterpolationOffset(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->maxInterpolationOffset);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getsubPixelInterpolationOffsetBits(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->subPixelInterpolationOffsetBits);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxFramebufferWidth(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxFramebufferWidth);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxFramebufferHeight(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxFramebufferHeight);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxFramebufferLayers(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxFramebufferLayers);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxColorAttachments(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxColorAttachments);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxSampleMaskWords(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxSampleMaskWords);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_gettimestampPeriod(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->timestampPeriod);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxClipDistances(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxClipDistances);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxCullDistances(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxCullDistances);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getmaxCombinedClipAndCullDistances(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxCombinedClipAndCullDistances);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getdiscreteQueuePriorities(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->discreteQueuePriorities);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getpointSizeRange(PyVkPhysicalDeviceLimits *self, void *closure) {

    PyObject* value = PyList_New(0);
    int nb = sizeof((self->base)->pointSizeRange) / sizeof((self->base)->pointSizeRange[0]);
    int i = 0;
    for (i = 0; i < nb; i++) {
        PyObject* py_tmp = PyFloat_FromDouble((double) (self->base)->pointSizeRange[i]);
        PyList_Append(value, py_tmp);
    }

    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getlineWidthRange(PyVkPhysicalDeviceLimits *self, void *closure) {

    PyObject* value = PyList_New(0);
    int nb = sizeof((self->base)->lineWidthRange) / sizeof((self->base)->lineWidthRange[0]);
    int i = 0;
    for (i = 0; i < nb; i++) {
        PyObject* py_tmp = PyFloat_FromDouble((double) (self->base)->lineWidthRange[i]);
        PyList_Append(value, py_tmp);
    }

    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getpointSizeGranularity(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->pointSizeGranularity);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPhysicalDeviceLimits_getlineWidthGranularity(PyVkPhysicalDeviceLimits *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->lineWidthGranularity);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkPhysicalDeviceLimits_getsetters[] = {

    { "maxImageDimension1D", (getter)PyVkPhysicalDeviceLimits_getmaxImageDimension1D, NULL, "", NULL},

    { "maxImageDimension2D", (getter)PyVkPhysicalDeviceLimits_getmaxImageDimension2D, NULL, "", NULL},

    { "maxImageDimension3D", (getter)PyVkPhysicalDeviceLimits_getmaxImageDimension3D, NULL, "", NULL},

    { "maxImageDimensionCube", (getter)PyVkPhysicalDeviceLimits_getmaxImageDimensionCube, NULL, "", NULL},

    { "maxImageArrayLayers", (getter)PyVkPhysicalDeviceLimits_getmaxImageArrayLayers, NULL, "", NULL},

    { "maxTexelBufferElements", (getter)PyVkPhysicalDeviceLimits_getmaxTexelBufferElements, NULL, "", NULL},

    { "maxUniformBufferRange", (getter)PyVkPhysicalDeviceLimits_getmaxUniformBufferRange, NULL, "", NULL},

    { "maxStorageBufferRange", (getter)PyVkPhysicalDeviceLimits_getmaxStorageBufferRange, NULL, "", NULL},

    { "maxPushConstantsSize", (getter)PyVkPhysicalDeviceLimits_getmaxPushConstantsSize, NULL, "", NULL},

    { "maxMemoryAllocationCount", (getter)PyVkPhysicalDeviceLimits_getmaxMemoryAllocationCount, NULL, "", NULL},

    { "maxSamplerAllocationCount", (getter)PyVkPhysicalDeviceLimits_getmaxSamplerAllocationCount, NULL, "", NULL},

    { "maxBoundDescriptorSets", (getter)PyVkPhysicalDeviceLimits_getmaxBoundDescriptorSets, NULL, "", NULL},

    { "maxPerStageDescriptorSamplers", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorSamplers, NULL, "", NULL},

    { "maxPerStageDescriptorUniformBuffers", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorUniformBuffers, NULL, "", NULL},

    { "maxPerStageDescriptorStorageBuffers", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorStorageBuffers, NULL, "", NULL},

    { "maxPerStageDescriptorSampledImages", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorSampledImages, NULL, "", NULL},

    { "maxPerStageDescriptorStorageImages", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorStorageImages, NULL, "", NULL},

    { "maxPerStageDescriptorInputAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorInputAttachments, NULL, "", NULL},

    { "maxPerStageResources", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageResources, NULL, "", NULL},

    { "maxDescriptorSetSamplers", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetSamplers, NULL, "", NULL},

    { "maxDescriptorSetUniformBuffers", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetUniformBuffers, NULL, "", NULL},

    { "maxDescriptorSetUniformBuffersDynamic", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetUniformBuffersDynamic, NULL, "", NULL},

    { "maxDescriptorSetStorageBuffers", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageBuffers, NULL, "", NULL},

    { "maxDescriptorSetStorageBuffersDynamic", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageBuffersDynamic, NULL, "", NULL},

    { "maxDescriptorSetSampledImages", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetSampledImages, NULL, "", NULL},

    { "maxDescriptorSetStorageImages", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageImages, NULL, "", NULL},

    { "maxDescriptorSetInputAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetInputAttachments, NULL, "", NULL},

    { "maxVertexInputAttributes", (getter)PyVkPhysicalDeviceLimits_getmaxVertexInputAttributes, NULL, "", NULL},

    { "maxVertexInputBindings", (getter)PyVkPhysicalDeviceLimits_getmaxVertexInputBindings, NULL, "", NULL},

    { "maxVertexInputAttributeOffset", (getter)PyVkPhysicalDeviceLimits_getmaxVertexInputAttributeOffset, NULL, "", NULL},

    { "maxVertexInputBindingStride", (getter)PyVkPhysicalDeviceLimits_getmaxVertexInputBindingStride, NULL, "", NULL},

    { "maxVertexOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxVertexOutputComponents, NULL, "", NULL},

    { "maxTessellationGenerationLevel", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationGenerationLevel, NULL, "", NULL},

    { "maxTessellationPatchSize", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationPatchSize, NULL, "", NULL},

    { "maxTessellationControlPerVertexInputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationControlPerVertexInputComponents, NULL, "", NULL},

    { "maxTessellationControlPerVertexOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationControlPerVertexOutputComponents, NULL, "", NULL},

    { "maxTessellationControlPerPatchOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationControlPerPatchOutputComponents, NULL, "", NULL},

    { "maxTessellationControlTotalOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationControlTotalOutputComponents, NULL, "", NULL},

    { "maxTessellationEvaluationInputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationEvaluationInputComponents, NULL, "", NULL},

    { "maxTessellationEvaluationOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationEvaluationOutputComponents, NULL, "", NULL},

    { "maxGeometryShaderInvocations", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryShaderInvocations, NULL, "", NULL},

    { "maxGeometryInputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryInputComponents, NULL, "", NULL},

    { "maxGeometryOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryOutputComponents, NULL, "", NULL},

    { "maxGeometryOutputVertices", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryOutputVertices, NULL, "", NULL},

    { "maxGeometryTotalOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryTotalOutputComponents, NULL, "", NULL},

    { "maxFragmentInputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxFragmentInputComponents, NULL, "", NULL},

    { "maxFragmentOutputAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxFragmentOutputAttachments, NULL, "", NULL},

    { "maxFragmentDualSrcAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxFragmentDualSrcAttachments, NULL, "", NULL},

    { "maxFragmentCombinedOutputResources", (getter)PyVkPhysicalDeviceLimits_getmaxFragmentCombinedOutputResources, NULL, "", NULL},

    { "maxComputeSharedMemorySize", (getter)PyVkPhysicalDeviceLimits_getmaxComputeSharedMemorySize, NULL, "", NULL},

    { "maxComputeWorkGroupCount", (getter)PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupCount, NULL, "", NULL},

    { "maxComputeWorkGroupInvocations", (getter)PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupInvocations, NULL, "", NULL},

    { "maxComputeWorkGroupSize", (getter)PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupSize, NULL, "", NULL},

    { "subPixelPrecisionBits", (getter)PyVkPhysicalDeviceLimits_getsubPixelPrecisionBits, NULL, "", NULL},

    { "subTexelPrecisionBits", (getter)PyVkPhysicalDeviceLimits_getsubTexelPrecisionBits, NULL, "", NULL},

    { "mipmapPrecisionBits", (getter)PyVkPhysicalDeviceLimits_getmipmapPrecisionBits, NULL, "", NULL},

    { "maxDrawIndexedIndexValue", (getter)PyVkPhysicalDeviceLimits_getmaxDrawIndexedIndexValue, NULL, "", NULL},

    { "maxDrawIndirectCount", (getter)PyVkPhysicalDeviceLimits_getmaxDrawIndirectCount, NULL, "", NULL},

    { "maxSamplerLodBias", (getter)PyVkPhysicalDeviceLimits_getmaxSamplerLodBias, NULL, "", NULL},

    { "maxSamplerAnisotropy", (getter)PyVkPhysicalDeviceLimits_getmaxSamplerAnisotropy, NULL, "", NULL},

    { "maxViewports", (getter)PyVkPhysicalDeviceLimits_getmaxViewports, NULL, "", NULL},

    { "maxViewportDimensions", (getter)PyVkPhysicalDeviceLimits_getmaxViewportDimensions, NULL, "", NULL},

    { "viewportBoundsRange", (getter)PyVkPhysicalDeviceLimits_getviewportBoundsRange, NULL, "", NULL},

    { "viewportSubPixelBits", (getter)PyVkPhysicalDeviceLimits_getviewportSubPixelBits, NULL, "", NULL},

    { "minMemoryMapAlignment", (getter)PyVkPhysicalDeviceLimits_getminMemoryMapAlignment, NULL, "", NULL},

    { "minTexelOffset", (getter)PyVkPhysicalDeviceLimits_getminTexelOffset, NULL, "", NULL},

    { "maxTexelOffset", (getter)PyVkPhysicalDeviceLimits_getmaxTexelOffset, NULL, "", NULL},

    { "minTexelGatherOffset", (getter)PyVkPhysicalDeviceLimits_getminTexelGatherOffset, NULL, "", NULL},

    { "maxTexelGatherOffset", (getter)PyVkPhysicalDeviceLimits_getmaxTexelGatherOffset, NULL, "", NULL},

    { "minInterpolationOffset", (getter)PyVkPhysicalDeviceLimits_getminInterpolationOffset, NULL, "", NULL},

    { "maxInterpolationOffset", (getter)PyVkPhysicalDeviceLimits_getmaxInterpolationOffset, NULL, "", NULL},

    { "subPixelInterpolationOffsetBits", (getter)PyVkPhysicalDeviceLimits_getsubPixelInterpolationOffsetBits, NULL, "", NULL},

    { "maxFramebufferWidth", (getter)PyVkPhysicalDeviceLimits_getmaxFramebufferWidth, NULL, "", NULL},

    { "maxFramebufferHeight", (getter)PyVkPhysicalDeviceLimits_getmaxFramebufferHeight, NULL, "", NULL},

    { "maxFramebufferLayers", (getter)PyVkPhysicalDeviceLimits_getmaxFramebufferLayers, NULL, "", NULL},

    { "maxColorAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxColorAttachments, NULL, "", NULL},

    { "maxSampleMaskWords", (getter)PyVkPhysicalDeviceLimits_getmaxSampleMaskWords, NULL, "", NULL},

    { "timestampPeriod", (getter)PyVkPhysicalDeviceLimits_gettimestampPeriod, NULL, "", NULL},

    { "maxClipDistances", (getter)PyVkPhysicalDeviceLimits_getmaxClipDistances, NULL, "", NULL},

    { "maxCullDistances", (getter)PyVkPhysicalDeviceLimits_getmaxCullDistances, NULL, "", NULL},

    { "maxCombinedClipAndCullDistances", (getter)PyVkPhysicalDeviceLimits_getmaxCombinedClipAndCullDistances, NULL, "", NULL},

    { "discreteQueuePriorities", (getter)PyVkPhysicalDeviceLimits_getdiscreteQueuePriorities, NULL, "", NULL},

    { "pointSizeRange", (getter)PyVkPhysicalDeviceLimits_getpointSizeRange, NULL, "", NULL},

    { "lineWidthRange", (getter)PyVkPhysicalDeviceLimits_getlineWidthRange, NULL, "", NULL},

    { "pointSizeGranularity", (getter)PyVkPhysicalDeviceLimits_getpointSizeGranularity, NULL, "", NULL},

    { "lineWidthGranularity", (getter)PyVkPhysicalDeviceLimits_getlineWidthGranularity, NULL, "", NULL},
    {NULL}
};

static int
PyVkPhysicalDeviceLimits_init(PyVkPhysicalDeviceLimits *self, PyObject *args, PyObject *kwds) {
    return 0;
}
static PyTypeObject PyVkPhysicalDeviceLimitsType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPhysicalDeviceLimits", sizeof(PyVkPhysicalDeviceLimits), 0,
    (destructor)PyVkPhysicalDeviceLimits_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPhysicalDeviceLimits object",0,0,0,0,0,0,0,0,
    PyVkPhysicalDeviceLimits_getsetters,0,0,0,0,0,(initproc)PyVkPhysicalDeviceLimits_init,0,PyVkPhysicalDeviceLimits_new,
};

static void PyVkSemaphoreCreateInfo_del(PyVkSemaphoreCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkSemaphoreCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkSemaphoreCreateInfo *self;
    self = (PyVkSemaphoreCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkSemaphoreCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSemaphoreCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkSemaphoreCreateInfo_getpNext(PyVkSemaphoreCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkSemaphoreCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkSemaphoreCreateInfo_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkSemaphoreCreateInfo_init(PyVkSemaphoreCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    static char *kwlist[] = {"flags",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &flags)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    return 0;
}
static PyTypeObject PyVkSemaphoreCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkSemaphoreCreateInfo", sizeof(PyVkSemaphoreCreateInfo), 0,
    (destructor)PyVkSemaphoreCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkSemaphoreCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkSemaphoreCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkSemaphoreCreateInfo_init,0,PyVkSemaphoreCreateInfo_new,
};

static void PyVkQueryPoolCreateInfo_del(PyVkQueryPoolCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkQueryPoolCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkQueryPoolCreateInfo *self;
    self = (PyVkQueryPoolCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkQueryPoolCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkQueryPoolCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkQueryPoolCreateInfo_getpNext(PyVkQueryPoolCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkQueryPoolCreateInfo_getqueryCount(PyVkQueryPoolCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->queryCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkQueryPoolCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkQueryPoolCreateInfo_getpNext, NULL, "", NULL},

    { "queryCount", (getter)PyVkQueryPoolCreateInfo_getqueryCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkQueryPoolCreateInfo_init(PyVkQueryPoolCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* queryType = NULL;
    PyObject* queryCount = NULL;
    PyObject* pipelineStatistics = NULL;
    static char *kwlist[] = {"flags","queryType","queryCount","pipelineStatistics",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &flags, &queryType, &queryCount, &pipelineStatistics)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (queryType != NULL && queryType != Py_None) {

        (self->base)->queryType = PyLong_AsLong(queryType);

    }

    if (queryCount != NULL && queryCount != Py_None) {
        (self->base)->queryCount = (uint32_t) PyLong_AsLong(queryCount);
    }

    if (pipelineStatistics != NULL && pipelineStatistics != Py_None) {

        (self->base)->pipelineStatistics = PyLong_AsLong(pipelineStatistics);

    }

    return 0;
}
static PyTypeObject PyVkQueryPoolCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkQueryPoolCreateInfo", sizeof(PyVkQueryPoolCreateInfo), 0,
    (destructor)PyVkQueryPoolCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkQueryPoolCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkQueryPoolCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkQueryPoolCreateInfo_init,0,PyVkQueryPoolCreateInfo_new,
};

static void PyVkFramebufferCreateInfo_del(PyVkFramebufferCreateInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkFramebufferCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkFramebufferCreateInfo *self;
    self = (PyVkFramebufferCreateInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkFramebufferCreateInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkFramebufferCreateInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkFramebufferCreateInfo_getpNext(PyVkFramebufferCreateInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkFramebufferCreateInfo_getattachmentCount(PyVkFramebufferCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->attachmentCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkFramebufferCreateInfo_getwidth(PyVkFramebufferCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->width);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkFramebufferCreateInfo_getheight(PyVkFramebufferCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->height);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkFramebufferCreateInfo_getlayers(PyVkFramebufferCreateInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->layers);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkFramebufferCreateInfo_getsetters[] = {

    { "pNext", (getter)PyVkFramebufferCreateInfo_getpNext, NULL, "", NULL},

    { "attachmentCount", (getter)PyVkFramebufferCreateInfo_getattachmentCount, NULL, "", NULL},

    { "width", (getter)PyVkFramebufferCreateInfo_getwidth, NULL, "", NULL},

    { "height", (getter)PyVkFramebufferCreateInfo_getheight, NULL, "", NULL},

    { "layers", (getter)PyVkFramebufferCreateInfo_getlayers, NULL, "", NULL},
    {NULL}
};

static int
PyVkFramebufferCreateInfo_init(PyVkFramebufferCreateInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* renderPass = NULL;
    PyObject* attachmentCount = NULL;
    PyObject* pAttachments = NULL;
    PyObject* width = NULL;
    PyObject* height = NULL;
    PyObject* layers = NULL;
    static char *kwlist[] = {"flags","renderPass","attachmentCount","pAttachments","width","height","layers",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &flags, &renderPass, &attachmentCount, &pAttachments, &width, &height, &layers)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (renderPass != NULL && renderPass != Py_None) {

        (self->base)->renderPass = PyCapsule_GetPointer(renderPass, "VkRenderPass");

    }

    if (attachmentCount != NULL && attachmentCount != Py_None) {
        (self->base)->attachmentCount = (uint32_t) PyLong_AsLong(attachmentCount);
    }

    if (pAttachments != NULL && pAttachments != Py_None) {

        (self->base)->pAttachments = PyCapsule_GetPointer(pAttachments, "VkImageView");

    }

    if (width != NULL && width != Py_None) {
        (self->base)->width = (uint32_t) PyLong_AsLong(width);
    }

    if (height != NULL && height != Py_None) {
        (self->base)->height = (uint32_t) PyLong_AsLong(height);
    }

    if (layers != NULL && layers != Py_None) {
        (self->base)->layers = (uint32_t) PyLong_AsLong(layers);
    }

    return 0;
}
static PyTypeObject PyVkFramebufferCreateInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkFramebufferCreateInfo", sizeof(PyVkFramebufferCreateInfo), 0,
    (destructor)PyVkFramebufferCreateInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkFramebufferCreateInfo object",0,0,0,0,0,0,0,0,
    PyVkFramebufferCreateInfo_getsetters,0,0,0,0,0,(initproc)PyVkFramebufferCreateInfo_init,0,PyVkFramebufferCreateInfo_new,
};

static void PyVkDrawIndirectCommand_del(PyVkDrawIndirectCommand* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDrawIndirectCommand_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDrawIndirectCommand *self;
    self = (PyVkDrawIndirectCommand *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDrawIndirectCommand));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDrawIndirectCommand");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDrawIndirectCommand_getvertexCount(PyVkDrawIndirectCommand *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->vertexCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDrawIndirectCommand_getinstanceCount(PyVkDrawIndirectCommand *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->instanceCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDrawIndirectCommand_getfirstVertex(PyVkDrawIndirectCommand *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->firstVertex);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDrawIndirectCommand_getfirstInstance(PyVkDrawIndirectCommand *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->firstInstance);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDrawIndirectCommand_getsetters[] = {

    { "vertexCount", (getter)PyVkDrawIndirectCommand_getvertexCount, NULL, "", NULL},

    { "instanceCount", (getter)PyVkDrawIndirectCommand_getinstanceCount, NULL, "", NULL},

    { "firstVertex", (getter)PyVkDrawIndirectCommand_getfirstVertex, NULL, "", NULL},

    { "firstInstance", (getter)PyVkDrawIndirectCommand_getfirstInstance, NULL, "", NULL},
    {NULL}
};

static int
PyVkDrawIndirectCommand_init(PyVkDrawIndirectCommand *self, PyObject *args, PyObject *kwds) {
    PyObject* vertexCount = NULL;
    PyObject* instanceCount = NULL;
    PyObject* firstVertex = NULL;
    PyObject* firstInstance = NULL;
    static char *kwlist[] = {"vertexCount","instanceCount","firstVertex","firstInstance",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &vertexCount, &instanceCount, &firstVertex, &firstInstance)) return -1;

    if (vertexCount != NULL && vertexCount != Py_None) {
        (self->base)->vertexCount = (uint32_t) PyLong_AsLong(vertexCount);
    }

    if (instanceCount != NULL && instanceCount != Py_None) {
        (self->base)->instanceCount = (uint32_t) PyLong_AsLong(instanceCount);
    }

    if (firstVertex != NULL && firstVertex != Py_None) {
        (self->base)->firstVertex = (uint32_t) PyLong_AsLong(firstVertex);
    }

    if (firstInstance != NULL && firstInstance != Py_None) {
        (self->base)->firstInstance = (uint32_t) PyLong_AsLong(firstInstance);
    }

    return 0;
}
static PyTypeObject PyVkDrawIndirectCommandType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDrawIndirectCommand", sizeof(PyVkDrawIndirectCommand), 0,
    (destructor)PyVkDrawIndirectCommand_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDrawIndirectCommand object",0,0,0,0,0,0,0,0,
    PyVkDrawIndirectCommand_getsetters,0,0,0,0,0,(initproc)PyVkDrawIndirectCommand_init,0,PyVkDrawIndirectCommand_new,
};

static void PyVkDrawIndexedIndirectCommand_del(PyVkDrawIndexedIndirectCommand* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDrawIndexedIndirectCommand_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDrawIndexedIndirectCommand *self;
    self = (PyVkDrawIndexedIndirectCommand *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDrawIndexedIndirectCommand));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDrawIndexedIndirectCommand");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDrawIndexedIndirectCommand_getindexCount(PyVkDrawIndexedIndirectCommand *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->indexCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDrawIndexedIndirectCommand_getinstanceCount(PyVkDrawIndexedIndirectCommand *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->instanceCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDrawIndexedIndirectCommand_getfirstIndex(PyVkDrawIndexedIndirectCommand *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->firstIndex);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDrawIndexedIndirectCommand_getvertexOffset(PyVkDrawIndexedIndirectCommand *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->vertexOffset);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDrawIndexedIndirectCommand_getfirstInstance(PyVkDrawIndexedIndirectCommand *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->firstInstance);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDrawIndexedIndirectCommand_getsetters[] = {

    { "indexCount", (getter)PyVkDrawIndexedIndirectCommand_getindexCount, NULL, "", NULL},

    { "instanceCount", (getter)PyVkDrawIndexedIndirectCommand_getinstanceCount, NULL, "", NULL},

    { "firstIndex", (getter)PyVkDrawIndexedIndirectCommand_getfirstIndex, NULL, "", NULL},

    { "vertexOffset", (getter)PyVkDrawIndexedIndirectCommand_getvertexOffset, NULL, "", NULL},

    { "firstInstance", (getter)PyVkDrawIndexedIndirectCommand_getfirstInstance, NULL, "", NULL},
    {NULL}
};

static int
PyVkDrawIndexedIndirectCommand_init(PyVkDrawIndexedIndirectCommand *self, PyObject *args, PyObject *kwds) {
    PyObject* indexCount = NULL;
    PyObject* instanceCount = NULL;
    PyObject* firstIndex = NULL;
    PyObject* vertexOffset = NULL;
    PyObject* firstInstance = NULL;
    static char *kwlist[] = {"indexCount","instanceCount","firstIndex","vertexOffset","firstInstance",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &indexCount, &instanceCount, &firstIndex, &vertexOffset, &firstInstance)) return -1;

    if (indexCount != NULL && indexCount != Py_None) {
        (self->base)->indexCount = (uint32_t) PyLong_AsLong(indexCount);
    }

    if (instanceCount != NULL && instanceCount != Py_None) {
        (self->base)->instanceCount = (uint32_t) PyLong_AsLong(instanceCount);
    }

    if (firstIndex != NULL && firstIndex != Py_None) {
        (self->base)->firstIndex = (uint32_t) PyLong_AsLong(firstIndex);
    }

    if (vertexOffset != NULL && vertexOffset != Py_None) {
        (self->base)->vertexOffset = (int32_t) PyLong_AsLong(vertexOffset);
    }

    if (firstInstance != NULL && firstInstance != Py_None) {
        (self->base)->firstInstance = (uint32_t) PyLong_AsLong(firstInstance);
    }

    return 0;
}
static PyTypeObject PyVkDrawIndexedIndirectCommandType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDrawIndexedIndirectCommand", sizeof(PyVkDrawIndexedIndirectCommand), 0,
    (destructor)PyVkDrawIndexedIndirectCommand_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDrawIndexedIndirectCommand object",0,0,0,0,0,0,0,0,
    PyVkDrawIndexedIndirectCommand_getsetters,0,0,0,0,0,(initproc)PyVkDrawIndexedIndirectCommand_init,0,PyVkDrawIndexedIndirectCommand_new,
};

static void PyVkDispatchIndirectCommand_del(PyVkDispatchIndirectCommand* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDispatchIndirectCommand_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDispatchIndirectCommand *self;
    self = (PyVkDispatchIndirectCommand *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDispatchIndirectCommand));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDispatchIndirectCommand");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDispatchIndirectCommand_getx(PyVkDispatchIndirectCommand *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->x);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDispatchIndirectCommand_gety(PyVkDispatchIndirectCommand *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->y);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDispatchIndirectCommand_getz(PyVkDispatchIndirectCommand *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->z);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDispatchIndirectCommand_getsetters[] = {

    { "x", (getter)PyVkDispatchIndirectCommand_getx, NULL, "", NULL},

    { "y", (getter)PyVkDispatchIndirectCommand_gety, NULL, "", NULL},

    { "z", (getter)PyVkDispatchIndirectCommand_getz, NULL, "", NULL},
    {NULL}
};

static int
PyVkDispatchIndirectCommand_init(PyVkDispatchIndirectCommand *self, PyObject *args, PyObject *kwds) {
    PyObject* x = NULL;
    PyObject* y = NULL;
    PyObject* z = NULL;
    static char *kwlist[] = {"x","y","z",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &x, &y, &z)) return -1;

    if (x != NULL && x != Py_None) {
        (self->base)->x = (uint32_t) PyLong_AsLong(x);
    }

    if (y != NULL && y != Py_None) {
        (self->base)->y = (uint32_t) PyLong_AsLong(y);
    }

    if (z != NULL && z != Py_None) {
        (self->base)->z = (uint32_t) PyLong_AsLong(z);
    }

    return 0;
}
static PyTypeObject PyVkDispatchIndirectCommandType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDispatchIndirectCommand", sizeof(PyVkDispatchIndirectCommand), 0,
    (destructor)PyVkDispatchIndirectCommand_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDispatchIndirectCommand object",0,0,0,0,0,0,0,0,
    PyVkDispatchIndirectCommand_getsetters,0,0,0,0,0,(initproc)PyVkDispatchIndirectCommand_init,0,PyVkDispatchIndirectCommand_new,
};

static void PyVkSubmitInfo_del(PyVkSubmitInfo* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkSubmitInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkSubmitInfo *self;
    self = (PyVkSubmitInfo *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkSubmitInfo));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSubmitInfo");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkSubmitInfo_getpNext(PyVkSubmitInfo *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSubmitInfo_getwaitSemaphoreCount(PyVkSubmitInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->waitSemaphoreCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSubmitInfo_getcommandBufferCount(PyVkSubmitInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->commandBufferCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSubmitInfo_getsignalSemaphoreCount(PyVkSubmitInfo *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->signalSemaphoreCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkSubmitInfo_getsetters[] = {

    { "pNext", (getter)PyVkSubmitInfo_getpNext, NULL, "", NULL},

    { "waitSemaphoreCount", (getter)PyVkSubmitInfo_getwaitSemaphoreCount, NULL, "", NULL},

    { "commandBufferCount", (getter)PyVkSubmitInfo_getcommandBufferCount, NULL, "", NULL},

    { "signalSemaphoreCount", (getter)PyVkSubmitInfo_getsignalSemaphoreCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkSubmitInfo_init(PyVkSubmitInfo *self, PyObject *args, PyObject *kwds) {
    PyObject* waitSemaphoreCount = NULL;
    PyObject* pWaitSemaphores = NULL;
    PyObject* pWaitDstStageMask = NULL;
    PyObject* commandBufferCount = NULL;
    PyObject* pCommandBuffers = NULL;
    PyObject* signalSemaphoreCount = NULL;
    PyObject* pSignalSemaphores = NULL;
    static char *kwlist[] = {"waitSemaphoreCount","pWaitSemaphores","pWaitDstStageMask","commandBufferCount","pCommandBuffers","signalSemaphoreCount","pSignalSemaphores",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &waitSemaphoreCount, &pWaitSemaphores, &pWaitDstStageMask, &commandBufferCount, &pCommandBuffers, &signalSemaphoreCount, &pSignalSemaphores)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

    (self->base)->pNext = NULL;

    if (waitSemaphoreCount != NULL && waitSemaphoreCount != Py_None) {
        (self->base)->waitSemaphoreCount = (uint32_t) PyLong_AsLong(waitSemaphoreCount);
    }

    if (pWaitSemaphores != NULL && pWaitSemaphores != Py_None) {

        (self->base)->pWaitSemaphores = PyCapsule_GetPointer(pWaitSemaphores, "VkSemaphore");

    }

    if (pWaitDstStageMask != NULL && pWaitDstStageMask != Py_None) {

        VkPipelineStageFlags tmp = PyLong_AsLong(pWaitDstStageMask);
        (self->base)->pWaitDstStageMask = &tmp;

    }

    if (commandBufferCount != NULL && commandBufferCount != Py_None) {
        (self->base)->commandBufferCount = (uint32_t) PyLong_AsLong(commandBufferCount);
    }

    if (pCommandBuffers != NULL && pCommandBuffers != Py_None) {

        (self->base)->pCommandBuffers = PyCapsule_GetPointer(pCommandBuffers, "VkCommandBuffer");

    }

    if (signalSemaphoreCount != NULL && signalSemaphoreCount != Py_None) {
        (self->base)->signalSemaphoreCount = (uint32_t) PyLong_AsLong(signalSemaphoreCount);
    }

    if (pSignalSemaphores != NULL && pSignalSemaphores != Py_None) {

        (self->base)->pSignalSemaphores = PyCapsule_GetPointer(pSignalSemaphores, "VkSemaphore");

    }

    return 0;
}
static PyTypeObject PyVkSubmitInfoType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkSubmitInfo", sizeof(PyVkSubmitInfo), 0,
    (destructor)PyVkSubmitInfo_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkSubmitInfo object",0,0,0,0,0,0,0,0,
    PyVkSubmitInfo_getsetters,0,0,0,0,0,(initproc)PyVkSubmitInfo_init,0,PyVkSubmitInfo_new,
};

static void PyVkDisplayPropertiesKHR_del(PyVkDisplayPropertiesKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDisplayPropertiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDisplayPropertiesKHR *self;
    self = (PyVkDisplayPropertiesKHR *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDisplayPropertiesKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDisplayPropertiesKHR");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDisplayPropertiesKHR_getdisplayName(PyVkDisplayPropertiesKHR *self, void *closure) {
    PyObject* value = PyUnicode_FromString((const char *) (self->base)->displayName);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDisplayPropertiesKHR_getsetters[] = {

    { "displayName", (getter)PyVkDisplayPropertiesKHR_getdisplayName, NULL, "", NULL},
    {NULL}
};

static int
PyVkDisplayPropertiesKHR_init(PyVkDisplayPropertiesKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* display = NULL;
    PyObject* displayName = NULL;
    PyObject* physicalDimensions = NULL;
    PyObject* physicalResolution = NULL;
    PyObject* supportedTransforms = NULL;
    PyObject* planeReorderPossible = NULL;
    PyObject* persistentContent = NULL;
    static char *kwlist[] = {"display","displayName","physicalDimensions","physicalResolution","supportedTransforms","planeReorderPossible","persistentContent",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &display, &displayName, &physicalDimensions, &physicalResolution, &supportedTransforms, &planeReorderPossible, &persistentContent)) return -1;

    if (display != NULL && display != Py_None) {

        (self->base)->display = PyCapsule_GetPointer(display, "VkDisplayKHR");

    }

    if (displayName != NULL && displayName != Py_None) {

        if (displayName == Py_None) {
            (self->base)->displayName = NULL;
        }
        else {
            PyObject * tmp55874673 = PyUnicode_AsASCIIString(displayName);
            char* tmp58276175 = PyBytes_AsString(tmp55874673);
            char* tmp32432837 = strdup(tmp58276175);
            (self->base)->displayName = tmp32432837;
            Py_DECREF(tmp55874673);
        }

    }

    if (physicalDimensions != NULL && physicalDimensions != Py_None) {

        (self->base)->physicalDimensions = *(((PyVkExtent2D*)physicalDimensions)->base);

    }

    if (physicalResolution != NULL && physicalResolution != Py_None) {

        (self->base)->physicalResolution = *(((PyVkExtent2D*)physicalResolution)->base);

    }

    if (supportedTransforms != NULL && supportedTransforms != Py_None) {

        (self->base)->supportedTransforms = PyLong_AsLong(supportedTransforms);

    }

    if (planeReorderPossible != NULL && planeReorderPossible != Py_None) {

        (self->base)->planeReorderPossible = PyLong_AsLong(planeReorderPossible);

    }

    if (persistentContent != NULL && persistentContent != Py_None) {

        (self->base)->persistentContent = PyLong_AsLong(persistentContent);

    }

    return 0;
}
static PyTypeObject PyVkDisplayPropertiesKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDisplayPropertiesKHR", sizeof(PyVkDisplayPropertiesKHR), 0,
    (destructor)PyVkDisplayPropertiesKHR_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDisplayPropertiesKHR object",0,0,0,0,0,0,0,0,
    PyVkDisplayPropertiesKHR_getsetters,0,0,0,0,0,(initproc)PyVkDisplayPropertiesKHR_init,0,PyVkDisplayPropertiesKHR_new,
};

static void PyVkDisplayPlanePropertiesKHR_del(PyVkDisplayPlanePropertiesKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDisplayPlanePropertiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDisplayPlanePropertiesKHR *self;
    self = (PyVkDisplayPlanePropertiesKHR *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDisplayPlanePropertiesKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDisplayPlanePropertiesKHR");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDisplayPlanePropertiesKHR_getcurrentStackIndex(PyVkDisplayPlanePropertiesKHR *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->currentStackIndex);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDisplayPlanePropertiesKHR_getsetters[] = {

    { "currentStackIndex", (getter)PyVkDisplayPlanePropertiesKHR_getcurrentStackIndex, NULL, "", NULL},
    {NULL}
};

static int
PyVkDisplayPlanePropertiesKHR_init(PyVkDisplayPlanePropertiesKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* currentDisplay = NULL;
    PyObject* currentStackIndex = NULL;
    static char *kwlist[] = {"currentDisplay","currentStackIndex",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &currentDisplay, &currentStackIndex)) return -1;

    if (currentDisplay != NULL && currentDisplay != Py_None) {

        (self->base)->currentDisplay = PyCapsule_GetPointer(currentDisplay, "VkDisplayKHR");

    }

    if (currentStackIndex != NULL && currentStackIndex != Py_None) {
        (self->base)->currentStackIndex = (uint32_t) PyLong_AsLong(currentStackIndex);
    }

    return 0;
}
static PyTypeObject PyVkDisplayPlanePropertiesKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDisplayPlanePropertiesKHR", sizeof(PyVkDisplayPlanePropertiesKHR), 0,
    (destructor)PyVkDisplayPlanePropertiesKHR_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDisplayPlanePropertiesKHR object",0,0,0,0,0,0,0,0,
    PyVkDisplayPlanePropertiesKHR_getsetters,0,0,0,0,0,(initproc)PyVkDisplayPlanePropertiesKHR_init,0,PyVkDisplayPlanePropertiesKHR_new,
};

static void PyVkDisplayModeParametersKHR_del(PyVkDisplayModeParametersKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDisplayModeParametersKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDisplayModeParametersKHR *self;
    self = (PyVkDisplayModeParametersKHR *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDisplayModeParametersKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDisplayModeParametersKHR");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDisplayModeParametersKHR_getrefreshRate(PyVkDisplayModeParametersKHR *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->refreshRate);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDisplayModeParametersKHR_getsetters[] = {

    { "refreshRate", (getter)PyVkDisplayModeParametersKHR_getrefreshRate, NULL, "", NULL},
    {NULL}
};

static int
PyVkDisplayModeParametersKHR_init(PyVkDisplayModeParametersKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* visibleRegion = NULL;
    PyObject* refreshRate = NULL;
    static char *kwlist[] = {"visibleRegion","refreshRate",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &visibleRegion, &refreshRate)) return -1;

    if (visibleRegion != NULL && visibleRegion != Py_None) {

        (self->base)->visibleRegion = *(((PyVkExtent2D*)visibleRegion)->base);

    }

    if (refreshRate != NULL && refreshRate != Py_None) {
        (self->base)->refreshRate = (uint32_t) PyLong_AsLong(refreshRate);
    }

    return 0;
}
static PyTypeObject PyVkDisplayModeParametersKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDisplayModeParametersKHR", sizeof(PyVkDisplayModeParametersKHR), 0,
    (destructor)PyVkDisplayModeParametersKHR_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDisplayModeParametersKHR object",0,0,0,0,0,0,0,0,
    PyVkDisplayModeParametersKHR_getsetters,0,0,0,0,0,(initproc)PyVkDisplayModeParametersKHR_init,0,PyVkDisplayModeParametersKHR_new,
};

static void PyVkDisplayModePropertiesKHR_del(PyVkDisplayModePropertiesKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDisplayModePropertiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDisplayModePropertiesKHR *self;
    self = (PyVkDisplayModePropertiesKHR *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDisplayModePropertiesKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDisplayModePropertiesKHR");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkDisplayModePropertiesKHR_getsetters[] = {
    {NULL}
};

static int
PyVkDisplayModePropertiesKHR_init(PyVkDisplayModePropertiesKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* displayMode = NULL;
    PyObject* parameters = NULL;
    static char *kwlist[] = {"displayMode","parameters",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &displayMode, &parameters)) return -1;

    if (displayMode != NULL && displayMode != Py_None) {

        (self->base)->displayMode = PyCapsule_GetPointer(displayMode, "VkDisplayModeKHR");

    }

    if (parameters != NULL && parameters != Py_None) {

        (self->base)->parameters = *(((PyVkDisplayModeParametersKHR*)parameters)->base);

    }

    return 0;
}
static PyTypeObject PyVkDisplayModePropertiesKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDisplayModePropertiesKHR", sizeof(PyVkDisplayModePropertiesKHR), 0,
    (destructor)PyVkDisplayModePropertiesKHR_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDisplayModePropertiesKHR object",0,0,0,0,0,0,0,0,
    PyVkDisplayModePropertiesKHR_getsetters,0,0,0,0,0,(initproc)PyVkDisplayModePropertiesKHR_init,0,PyVkDisplayModePropertiesKHR_new,
};

static void PyVkDisplayModeCreateInfoKHR_del(PyVkDisplayModeCreateInfoKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDisplayModeCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDisplayModeCreateInfoKHR *self;
    self = (PyVkDisplayModeCreateInfoKHR *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDisplayModeCreateInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDisplayModeCreateInfoKHR");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDisplayModeCreateInfoKHR_getpNext(PyVkDisplayModeCreateInfoKHR *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDisplayModeCreateInfoKHR_getsetters[] = {

    { "pNext", (getter)PyVkDisplayModeCreateInfoKHR_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkDisplayModeCreateInfoKHR_init(PyVkDisplayModeCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* parameters = NULL;
    static char *kwlist[] = {"flags","parameters",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &flags, &parameters)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (parameters != NULL && parameters != Py_None) {

        (self->base)->parameters = *(((PyVkDisplayModeParametersKHR*)parameters)->base);

    }

    return 0;
}
static PyTypeObject PyVkDisplayModeCreateInfoKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDisplayModeCreateInfoKHR", sizeof(PyVkDisplayModeCreateInfoKHR), 0,
    (destructor)PyVkDisplayModeCreateInfoKHR_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDisplayModeCreateInfoKHR object",0,0,0,0,0,0,0,0,
    PyVkDisplayModeCreateInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkDisplayModeCreateInfoKHR_init,0,PyVkDisplayModeCreateInfoKHR_new,
};

static void PyVkDisplayPlaneCapabilitiesKHR_del(PyVkDisplayPlaneCapabilitiesKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDisplayPlaneCapabilitiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDisplayPlaneCapabilitiesKHR *self;
    self = (PyVkDisplayPlaneCapabilitiesKHR *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDisplayPlaneCapabilitiesKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDisplayPlaneCapabilitiesKHR");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkDisplayPlaneCapabilitiesKHR_getsetters[] = {
    {NULL}
};

static int
PyVkDisplayPlaneCapabilitiesKHR_init(PyVkDisplayPlaneCapabilitiesKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* supportedAlpha = NULL;
    PyObject* minSrcPosition = NULL;
    PyObject* maxSrcPosition = NULL;
    PyObject* minSrcExtent = NULL;
    PyObject* maxSrcExtent = NULL;
    PyObject* minDstPosition = NULL;
    PyObject* maxDstPosition = NULL;
    PyObject* minDstExtent = NULL;
    PyObject* maxDstExtent = NULL;
    static char *kwlist[] = {"supportedAlpha","minSrcPosition","maxSrcPosition","minSrcExtent","maxSrcExtent","minDstPosition","maxDstPosition","minDstExtent","maxDstExtent",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOOO", kwlist, &supportedAlpha, &minSrcPosition, &maxSrcPosition, &minSrcExtent, &maxSrcExtent, &minDstPosition, &maxDstPosition, &minDstExtent, &maxDstExtent)) return -1;

    if (supportedAlpha != NULL && supportedAlpha != Py_None) {

        (self->base)->supportedAlpha = PyLong_AsLong(supportedAlpha);

    }

    if (minSrcPosition != NULL && minSrcPosition != Py_None) {

        (self->base)->minSrcPosition = *(((PyVkOffset2D*)minSrcPosition)->base);

    }

    if (maxSrcPosition != NULL && maxSrcPosition != Py_None) {

        (self->base)->maxSrcPosition = *(((PyVkOffset2D*)maxSrcPosition)->base);

    }

    if (minSrcExtent != NULL && minSrcExtent != Py_None) {

        (self->base)->minSrcExtent = *(((PyVkExtent2D*)minSrcExtent)->base);

    }

    if (maxSrcExtent != NULL && maxSrcExtent != Py_None) {

        (self->base)->maxSrcExtent = *(((PyVkExtent2D*)maxSrcExtent)->base);

    }

    if (minDstPosition != NULL && minDstPosition != Py_None) {

        (self->base)->minDstPosition = *(((PyVkOffset2D*)minDstPosition)->base);

    }

    if (maxDstPosition != NULL && maxDstPosition != Py_None) {

        (self->base)->maxDstPosition = *(((PyVkOffset2D*)maxDstPosition)->base);

    }

    if (minDstExtent != NULL && minDstExtent != Py_None) {

        (self->base)->minDstExtent = *(((PyVkExtent2D*)minDstExtent)->base);

    }

    if (maxDstExtent != NULL && maxDstExtent != Py_None) {

        (self->base)->maxDstExtent = *(((PyVkExtent2D*)maxDstExtent)->base);

    }

    return 0;
}
static PyTypeObject PyVkDisplayPlaneCapabilitiesKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDisplayPlaneCapabilitiesKHR", sizeof(PyVkDisplayPlaneCapabilitiesKHR), 0,
    (destructor)PyVkDisplayPlaneCapabilitiesKHR_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDisplayPlaneCapabilitiesKHR object",0,0,0,0,0,0,0,0,
    PyVkDisplayPlaneCapabilitiesKHR_getsetters,0,0,0,0,0,(initproc)PyVkDisplayPlaneCapabilitiesKHR_init,0,PyVkDisplayPlaneCapabilitiesKHR_new,
};

static void PyVkDisplaySurfaceCreateInfoKHR_del(PyVkDisplaySurfaceCreateInfoKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDisplaySurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDisplaySurfaceCreateInfoKHR *self;
    self = (PyVkDisplaySurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDisplaySurfaceCreateInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDisplaySurfaceCreateInfoKHR");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDisplaySurfaceCreateInfoKHR_getpNext(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDisplaySurfaceCreateInfoKHR_getplaneIndex(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->planeIndex);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDisplaySurfaceCreateInfoKHR_getplaneStackIndex(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->planeStackIndex);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDisplaySurfaceCreateInfoKHR_getglobalAlpha(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure) {
    PyObject* value = PyFloat_FromDouble((double) (self->base)->globalAlpha);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDisplaySurfaceCreateInfoKHR_getsetters[] = {

    { "pNext", (getter)PyVkDisplaySurfaceCreateInfoKHR_getpNext, NULL, "", NULL},

    { "planeIndex", (getter)PyVkDisplaySurfaceCreateInfoKHR_getplaneIndex, NULL, "", NULL},

    { "planeStackIndex", (getter)PyVkDisplaySurfaceCreateInfoKHR_getplaneStackIndex, NULL, "", NULL},

    { "globalAlpha", (getter)PyVkDisplaySurfaceCreateInfoKHR_getglobalAlpha, NULL, "", NULL},
    {NULL}
};

static int
PyVkDisplaySurfaceCreateInfoKHR_init(PyVkDisplaySurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* displayMode = NULL;
    PyObject* planeIndex = NULL;
    PyObject* planeStackIndex = NULL;
    PyObject* transform = NULL;
    PyObject* globalAlpha = NULL;
    PyObject* alphaMode = NULL;
    PyObject* imageExtent = NULL;
    static char *kwlist[] = {"flags","displayMode","planeIndex","planeStackIndex","transform","globalAlpha","alphaMode","imageExtent",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOO", kwlist, &flags, &displayMode, &planeIndex, &planeStackIndex, &transform, &globalAlpha, &alphaMode, &imageExtent)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (displayMode != NULL && displayMode != Py_None) {

        (self->base)->displayMode = PyCapsule_GetPointer(displayMode, "VkDisplayModeKHR");

    }

    if (planeIndex != NULL && planeIndex != Py_None) {
        (self->base)->planeIndex = (uint32_t) PyLong_AsLong(planeIndex);
    }

    if (planeStackIndex != NULL && planeStackIndex != Py_None) {
        (self->base)->planeStackIndex = (uint32_t) PyLong_AsLong(planeStackIndex);
    }

    if (transform != NULL && transform != Py_None) {

        (self->base)->transform = PyLong_AsLong(transform);

    }

    if (globalAlpha != NULL && globalAlpha != Py_None) {
        (self->base)->globalAlpha = (float) PyFloat_AsDouble(globalAlpha);
    }

    if (alphaMode != NULL && alphaMode != Py_None) {

        (self->base)->alphaMode = PyLong_AsLong(alphaMode);

    }

    if (imageExtent != NULL && imageExtent != Py_None) {

        (self->base)->imageExtent = *(((PyVkExtent2D*)imageExtent)->base);

    }

    return 0;
}
static PyTypeObject PyVkDisplaySurfaceCreateInfoKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDisplaySurfaceCreateInfoKHR", sizeof(PyVkDisplaySurfaceCreateInfoKHR), 0,
    (destructor)PyVkDisplaySurfaceCreateInfoKHR_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDisplaySurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
    PyVkDisplaySurfaceCreateInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkDisplaySurfaceCreateInfoKHR_init,0,PyVkDisplaySurfaceCreateInfoKHR_new,
};

static void PyVkDisplayPresentInfoKHR_del(PyVkDisplayPresentInfoKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDisplayPresentInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDisplayPresentInfoKHR *self;
    self = (PyVkDisplayPresentInfoKHR *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDisplayPresentInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDisplayPresentInfoKHR");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDisplayPresentInfoKHR_getpNext(PyVkDisplayPresentInfoKHR *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDisplayPresentInfoKHR_getsetters[] = {

    { "pNext", (getter)PyVkDisplayPresentInfoKHR_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkDisplayPresentInfoKHR_init(PyVkDisplayPresentInfoKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* srcRect = NULL;
    PyObject* dstRect = NULL;
    PyObject* persistent = NULL;
    static char *kwlist[] = {"srcRect","dstRect","persistent",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &srcRect, &dstRect, &persistent)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR;

    (self->base)->pNext = NULL;

    if (srcRect != NULL && srcRect != Py_None) {

        (self->base)->srcRect = *(((PyVkRect2D*)srcRect)->base);

    }

    if (dstRect != NULL && dstRect != Py_None) {

        (self->base)->dstRect = *(((PyVkRect2D*)dstRect)->base);

    }

    if (persistent != NULL && persistent != Py_None) {

        (self->base)->persistent = PyLong_AsLong(persistent);

    }

    return 0;
}
static PyTypeObject PyVkDisplayPresentInfoKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDisplayPresentInfoKHR", sizeof(PyVkDisplayPresentInfoKHR), 0,
    (destructor)PyVkDisplayPresentInfoKHR_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDisplayPresentInfoKHR object",0,0,0,0,0,0,0,0,
    PyVkDisplayPresentInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkDisplayPresentInfoKHR_init,0,PyVkDisplayPresentInfoKHR_new,
};

static void PyVkSurfaceCapabilitiesKHR_del(PyVkSurfaceCapabilitiesKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkSurfaceCapabilitiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkSurfaceCapabilitiesKHR *self;
    self = (PyVkSurfaceCapabilitiesKHR *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkSurfaceCapabilitiesKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSurfaceCapabilitiesKHR");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkSurfaceCapabilitiesKHR_getminImageCount(PyVkSurfaceCapabilitiesKHR *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->minImageCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSurfaceCapabilitiesKHR_getmaxImageCount(PyVkSurfaceCapabilitiesKHR *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxImageCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSurfaceCapabilitiesKHR_getmaxImageArrayLayers(PyVkSurfaceCapabilitiesKHR *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->maxImageArrayLayers);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkSurfaceCapabilitiesKHR_getsetters[] = {

    { "minImageCount", (getter)PyVkSurfaceCapabilitiesKHR_getminImageCount, NULL, "", NULL},

    { "maxImageCount", (getter)PyVkSurfaceCapabilitiesKHR_getmaxImageCount, NULL, "", NULL},

    { "maxImageArrayLayers", (getter)PyVkSurfaceCapabilitiesKHR_getmaxImageArrayLayers, NULL, "", NULL},
    {NULL}
};

static int
PyVkSurfaceCapabilitiesKHR_init(PyVkSurfaceCapabilitiesKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* minImageCount = NULL;
    PyObject* maxImageCount = NULL;
    PyObject* currentExtent = NULL;
    PyObject* minImageExtent = NULL;
    PyObject* maxImageExtent = NULL;
    PyObject* maxImageArrayLayers = NULL;
    PyObject* supportedTransforms = NULL;
    PyObject* currentTransform = NULL;
    PyObject* supportedCompositeAlpha = NULL;
    PyObject* supportedUsageFlags = NULL;
    static char *kwlist[] = {"minImageCount","maxImageCount","currentExtent","minImageExtent","maxImageExtent","maxImageArrayLayers","supportedTransforms","currentTransform","supportedCompositeAlpha","supportedUsageFlags",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOOOO", kwlist, &minImageCount, &maxImageCount, &currentExtent, &minImageExtent, &maxImageExtent, &maxImageArrayLayers, &supportedTransforms, &currentTransform, &supportedCompositeAlpha, &supportedUsageFlags)) return -1;

    if (minImageCount != NULL && minImageCount != Py_None) {
        (self->base)->minImageCount = (uint32_t) PyLong_AsLong(minImageCount);
    }

    if (maxImageCount != NULL && maxImageCount != Py_None) {
        (self->base)->maxImageCount = (uint32_t) PyLong_AsLong(maxImageCount);
    }

    if (currentExtent != NULL && currentExtent != Py_None) {

        (self->base)->currentExtent = *(((PyVkExtent2D*)currentExtent)->base);

    }

    if (minImageExtent != NULL && minImageExtent != Py_None) {

        (self->base)->minImageExtent = *(((PyVkExtent2D*)minImageExtent)->base);

    }

    if (maxImageExtent != NULL && maxImageExtent != Py_None) {

        (self->base)->maxImageExtent = *(((PyVkExtent2D*)maxImageExtent)->base);

    }

    if (maxImageArrayLayers != NULL && maxImageArrayLayers != Py_None) {
        (self->base)->maxImageArrayLayers = (uint32_t) PyLong_AsLong(maxImageArrayLayers);
    }

    if (supportedTransforms != NULL && supportedTransforms != Py_None) {

        (self->base)->supportedTransforms = PyLong_AsLong(supportedTransforms);

    }

    if (currentTransform != NULL && currentTransform != Py_None) {

        (self->base)->currentTransform = PyLong_AsLong(currentTransform);

    }

    if (supportedCompositeAlpha != NULL && supportedCompositeAlpha != Py_None) {

        (self->base)->supportedCompositeAlpha = PyLong_AsLong(supportedCompositeAlpha);

    }

    if (supportedUsageFlags != NULL && supportedUsageFlags != Py_None) {

        (self->base)->supportedUsageFlags = PyLong_AsLong(supportedUsageFlags);

    }

    return 0;
}
static PyTypeObject PyVkSurfaceCapabilitiesKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkSurfaceCapabilitiesKHR", sizeof(PyVkSurfaceCapabilitiesKHR), 0,
    (destructor)PyVkSurfaceCapabilitiesKHR_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkSurfaceCapabilitiesKHR object",0,0,0,0,0,0,0,0,
    PyVkSurfaceCapabilitiesKHR_getsetters,0,0,0,0,0,(initproc)PyVkSurfaceCapabilitiesKHR_init,0,PyVkSurfaceCapabilitiesKHR_new,
};

#ifdef VK_USE_PLATFORM_ANDROID_KHR

static void PyVkAndroidSurfaceCreateInfoKHR_del(PyVkAndroidSurfaceCreateInfoKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkAndroidSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkAndroidSurfaceCreateInfoKHR *self;
    self = (PyVkAndroidSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkAndroidSurfaceCreateInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkAndroidSurfaceCreateInfoKHR");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkAndroidSurfaceCreateInfoKHR_getpNext(PyVkAndroidSurfaceCreateInfoKHR *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkAndroidSurfaceCreateInfoKHR_getsetters[] = {

    { "pNext", (getter)PyVkAndroidSurfaceCreateInfoKHR_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkAndroidSurfaceCreateInfoKHR_init(PyVkAndroidSurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* window = NULL;
    static char *kwlist[] = {"flags","window",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &flags, &window)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    return 0;
}
static PyTypeObject PyVkAndroidSurfaceCreateInfoKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkAndroidSurfaceCreateInfoKHR", sizeof(PyVkAndroidSurfaceCreateInfoKHR), 0,
    (destructor)PyVkAndroidSurfaceCreateInfoKHR_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkAndroidSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
    PyVkAndroidSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkAndroidSurfaceCreateInfoKHR_init,0,PyVkAndroidSurfaceCreateInfoKHR_new,
};

#endif

#ifdef VK_USE_PLATFORM_MIR_KHR

static void PyVkMirSurfaceCreateInfoKHR_del(PyVkMirSurfaceCreateInfoKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkMirSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkMirSurfaceCreateInfoKHR *self;
    self = (PyVkMirSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkMirSurfaceCreateInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkMirSurfaceCreateInfoKHR");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkMirSurfaceCreateInfoKHR_getpNext(PyVkMirSurfaceCreateInfoKHR *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkMirSurfaceCreateInfoKHR_getsetters[] = {

    { "pNext", (getter)PyVkMirSurfaceCreateInfoKHR_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkMirSurfaceCreateInfoKHR_init(PyVkMirSurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* connection = NULL;
    PyObject* mirSurface = NULL;
    static char *kwlist[] = {"flags","connection","mirSurface",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &flags, &connection, &mirSurface)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    return 0;
}
static PyTypeObject PyVkMirSurfaceCreateInfoKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkMirSurfaceCreateInfoKHR", sizeof(PyVkMirSurfaceCreateInfoKHR), 0,
    (destructor)PyVkMirSurfaceCreateInfoKHR_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkMirSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
    PyVkMirSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkMirSurfaceCreateInfoKHR_init,0,PyVkMirSurfaceCreateInfoKHR_new,
};

#endif

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

static void PyVkWaylandSurfaceCreateInfoKHR_del(PyVkWaylandSurfaceCreateInfoKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkWaylandSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkWaylandSurfaceCreateInfoKHR *self;
    self = (PyVkWaylandSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkWaylandSurfaceCreateInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkWaylandSurfaceCreateInfoKHR");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkWaylandSurfaceCreateInfoKHR_getpNext(PyVkWaylandSurfaceCreateInfoKHR *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkWaylandSurfaceCreateInfoKHR_getsetters[] = {

    { "pNext", (getter)PyVkWaylandSurfaceCreateInfoKHR_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkWaylandSurfaceCreateInfoKHR_init(PyVkWaylandSurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* display = NULL;
    PyObject* surface = NULL;
    static char *kwlist[] = {"flags","display","surface",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &flags, &display, &surface)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    return 0;
}
static PyTypeObject PyVkWaylandSurfaceCreateInfoKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkWaylandSurfaceCreateInfoKHR", sizeof(PyVkWaylandSurfaceCreateInfoKHR), 0,
    (destructor)PyVkWaylandSurfaceCreateInfoKHR_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkWaylandSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
    PyVkWaylandSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkWaylandSurfaceCreateInfoKHR_init,0,PyVkWaylandSurfaceCreateInfoKHR_new,
};

#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

static void PyVkWin32SurfaceCreateInfoKHR_del(PyVkWin32SurfaceCreateInfoKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkWin32SurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkWin32SurfaceCreateInfoKHR *self;
    self = (PyVkWin32SurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkWin32SurfaceCreateInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkWin32SurfaceCreateInfoKHR");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkWin32SurfaceCreateInfoKHR_getpNext(PyVkWin32SurfaceCreateInfoKHR *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkWin32SurfaceCreateInfoKHR_getsetters[] = {

    { "pNext", (getter)PyVkWin32SurfaceCreateInfoKHR_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkWin32SurfaceCreateInfoKHR_init(PyVkWin32SurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* hinstance = NULL;
    PyObject* hwnd = NULL;
    static char *kwlist[] = {"flags","hinstance","hwnd",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &flags, &hinstance, &hwnd)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    return 0;
}
static PyTypeObject PyVkWin32SurfaceCreateInfoKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkWin32SurfaceCreateInfoKHR", sizeof(PyVkWin32SurfaceCreateInfoKHR), 0,
    (destructor)PyVkWin32SurfaceCreateInfoKHR_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkWin32SurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
    PyVkWin32SurfaceCreateInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkWin32SurfaceCreateInfoKHR_init,0,PyVkWin32SurfaceCreateInfoKHR_new,
};

#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR

static void PyVkXlibSurfaceCreateInfoKHR_del(PyVkXlibSurfaceCreateInfoKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkXlibSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkXlibSurfaceCreateInfoKHR *self;
    self = (PyVkXlibSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkXlibSurfaceCreateInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkXlibSurfaceCreateInfoKHR");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkXlibSurfaceCreateInfoKHR_getpNext(PyVkXlibSurfaceCreateInfoKHR *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkXlibSurfaceCreateInfoKHR_getdpy(PyVkXlibSurfaceCreateInfoKHR *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkXlibSurfaceCreateInfoKHR_getwindow(PyVkXlibSurfaceCreateInfoKHR *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->window);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkXlibSurfaceCreateInfoKHR_getsetters[] = {

    { "pNext", (getter)PyVkXlibSurfaceCreateInfoKHR_getpNext, NULL, "", NULL},

    { "dpy", (getter)PyVkXlibSurfaceCreateInfoKHR_getdpy, NULL, "", NULL},

    { "window", (getter)PyVkXlibSurfaceCreateInfoKHR_getwindow, NULL, "", NULL},
    {NULL}
};

static int
PyVkXlibSurfaceCreateInfoKHR_init(PyVkXlibSurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* dpy = NULL;
    PyObject* window = NULL;
    static char *kwlist[] = {"flags","dpy","window",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &flags, &dpy, &window)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (dpy != NULL && dpy != Py_None) {
        (self->base)->dpy = (Display *) PyLong_AsLong(dpy);
    }

    if (window != NULL && window != Py_None) {
        (self->base)->window = (XID) PyLong_AsLong(window);
    }

    return 0;
}
static PyTypeObject PyVkXlibSurfaceCreateInfoKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkXlibSurfaceCreateInfoKHR", sizeof(PyVkXlibSurfaceCreateInfoKHR), 0,
    (destructor)PyVkXlibSurfaceCreateInfoKHR_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkXlibSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
    PyVkXlibSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkXlibSurfaceCreateInfoKHR_init,0,PyVkXlibSurfaceCreateInfoKHR_new,
};

#endif

#ifdef VK_USE_PLATFORM_XCB_KHR

static void PyVkXcbSurfaceCreateInfoKHR_del(PyVkXcbSurfaceCreateInfoKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkXcbSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkXcbSurfaceCreateInfoKHR *self;
    self = (PyVkXcbSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkXcbSurfaceCreateInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkXcbSurfaceCreateInfoKHR");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkXcbSurfaceCreateInfoKHR_getpNext(PyVkXcbSurfaceCreateInfoKHR *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkXcbSurfaceCreateInfoKHR_getsetters[] = {

    { "pNext", (getter)PyVkXcbSurfaceCreateInfoKHR_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkXcbSurfaceCreateInfoKHR_init(PyVkXcbSurfaceCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* connection = NULL;
    PyObject* window = NULL;
    static char *kwlist[] = {"flags","connection","window",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &flags, &connection, &window)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    return 0;
}
static PyTypeObject PyVkXcbSurfaceCreateInfoKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkXcbSurfaceCreateInfoKHR", sizeof(PyVkXcbSurfaceCreateInfoKHR), 0,
    (destructor)PyVkXcbSurfaceCreateInfoKHR_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkXcbSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
    PyVkXcbSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkXcbSurfaceCreateInfoKHR_init,0,PyVkXcbSurfaceCreateInfoKHR_new,
};

#endif

static void PyVkSurfaceFormatKHR_del(PyVkSurfaceFormatKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkSurfaceFormatKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkSurfaceFormatKHR *self;
    self = (PyVkSurfaceFormatKHR *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkSurfaceFormatKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSurfaceFormatKHR");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkSurfaceFormatKHR_getsetters[] = {
    {NULL}
};

static int
PyVkSurfaceFormatKHR_init(PyVkSurfaceFormatKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* format = NULL;
    PyObject* colorSpace = NULL;
    static char *kwlist[] = {"format","colorSpace",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &format, &colorSpace)) return -1;

    if (format != NULL && format != Py_None) {

        (self->base)->format = PyLong_AsLong(format);

    }

    if (colorSpace != NULL && colorSpace != Py_None) {

        (self->base)->colorSpace = PyLong_AsLong(colorSpace);

    }

    return 0;
}
static PyTypeObject PyVkSurfaceFormatKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkSurfaceFormatKHR", sizeof(PyVkSurfaceFormatKHR), 0,
    (destructor)PyVkSurfaceFormatKHR_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkSurfaceFormatKHR object",0,0,0,0,0,0,0,0,
    PyVkSurfaceFormatKHR_getsetters,0,0,0,0,0,(initproc)PyVkSurfaceFormatKHR_init,0,PyVkSurfaceFormatKHR_new,
};

static void PyVkSwapchainCreateInfoKHR_del(PyVkSwapchainCreateInfoKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkSwapchainCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkSwapchainCreateInfoKHR *self;
    self = (PyVkSwapchainCreateInfoKHR *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkSwapchainCreateInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkSwapchainCreateInfoKHR");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkSwapchainCreateInfoKHR_getpNext(PyVkSwapchainCreateInfoKHR *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSwapchainCreateInfoKHR_getminImageCount(PyVkSwapchainCreateInfoKHR *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->minImageCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSwapchainCreateInfoKHR_getimageArrayLayers(PyVkSwapchainCreateInfoKHR *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->imageArrayLayers);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSwapchainCreateInfoKHR_getqueueFamilyIndexCount(PyVkSwapchainCreateInfoKHR *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->queueFamilyIndexCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkSwapchainCreateInfoKHR_getpQueueFamilyIndices(PyVkSwapchainCreateInfoKHR *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (*((self->base)->pQueueFamilyIndices)));
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkSwapchainCreateInfoKHR_getsetters[] = {

    { "pNext", (getter)PyVkSwapchainCreateInfoKHR_getpNext, NULL, "", NULL},

    { "minImageCount", (getter)PyVkSwapchainCreateInfoKHR_getminImageCount, NULL, "", NULL},

    { "imageArrayLayers", (getter)PyVkSwapchainCreateInfoKHR_getimageArrayLayers, NULL, "", NULL},

    { "queueFamilyIndexCount", (getter)PyVkSwapchainCreateInfoKHR_getqueueFamilyIndexCount, NULL, "", NULL},

    { "pQueueFamilyIndices", (getter)PyVkSwapchainCreateInfoKHR_getpQueueFamilyIndices, NULL, "", NULL},
    {NULL}
};

static int
PyVkSwapchainCreateInfoKHR_init(PyVkSwapchainCreateInfoKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* surface = NULL;
    PyObject* minImageCount = NULL;
    PyObject* imageFormat = NULL;
    PyObject* imageColorSpace = NULL;
    PyObject* imageExtent = NULL;
    PyObject* imageArrayLayers = NULL;
    PyObject* imageUsage = NULL;
    PyObject* imageSharingMode = NULL;
    PyObject* queueFamilyIndexCount = NULL;
    PyObject* pQueueFamilyIndices = NULL;
    PyObject* preTransform = NULL;
    PyObject* compositeAlpha = NULL;
    PyObject* presentMode = NULL;
    PyObject* clipped = NULL;
    PyObject* oldSwapchain = NULL;
    static char *kwlist[] = {"flags","surface","minImageCount","imageFormat","imageColorSpace","imageExtent","imageArrayLayers","imageUsage","imageSharingMode","queueFamilyIndexCount","pQueueFamilyIndices","preTransform","compositeAlpha","presentMode","clipped","oldSwapchain",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOOOOOOOOOO", kwlist, &flags, &surface, &minImageCount, &imageFormat, &imageColorSpace, &imageExtent, &imageArrayLayers, &imageUsage, &imageSharingMode, &queueFamilyIndexCount, &pQueueFamilyIndices, &preTransform, &compositeAlpha, &presentMode, &clipped, &oldSwapchain)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (surface != NULL && surface != Py_None) {

        (self->base)->surface = PyCapsule_GetPointer(surface, "VkSurfaceKHR");

    }

    if (minImageCount != NULL && minImageCount != Py_None) {
        (self->base)->minImageCount = (uint32_t) PyLong_AsLong(minImageCount);
    }

    if (imageFormat != NULL && imageFormat != Py_None) {

        (self->base)->imageFormat = PyLong_AsLong(imageFormat);

    }

    if (imageColorSpace != NULL && imageColorSpace != Py_None) {

        (self->base)->imageColorSpace = PyLong_AsLong(imageColorSpace);

    }

    if (imageExtent != NULL && imageExtent != Py_None) {

        (self->base)->imageExtent = *(((PyVkExtent2D*)imageExtent)->base);

    }

    if (imageArrayLayers != NULL && imageArrayLayers != Py_None) {
        (self->base)->imageArrayLayers = (uint32_t) PyLong_AsLong(imageArrayLayers);
    }

    if (imageUsage != NULL && imageUsage != Py_None) {

        (self->base)->imageUsage = PyLong_AsLong(imageUsage);

    }

    if (imageSharingMode != NULL && imageSharingMode != Py_None) {

        (self->base)->imageSharingMode = PyLong_AsLong(imageSharingMode);

    }

    if (queueFamilyIndexCount != NULL && queueFamilyIndexCount != Py_None) {
        (self->base)->queueFamilyIndexCount = (uint32_t) PyLong_AsLong(queueFamilyIndexCount);
    }

    if (pQueueFamilyIndices != NULL && pQueueFamilyIndices != Py_None) {

        uint32_t tmp10616594 = (uint32_t) PyLong_AsLong(pQueueFamilyIndices);
        uint32_t *tmp72594054 = malloc(sizeof(uint32_t));
        memcpy(tmp72594054, &tmp10616594, sizeof(uint32_t));
        (self->base)->pQueueFamilyIndices = tmp72594054;

    }

    if (preTransform != NULL && preTransform != Py_None) {

        (self->base)->preTransform = PyLong_AsLong(preTransform);

    }

    if (compositeAlpha != NULL && compositeAlpha != Py_None) {

        (self->base)->compositeAlpha = PyLong_AsLong(compositeAlpha);

    }

    if (presentMode != NULL && presentMode != Py_None) {

        (self->base)->presentMode = PyLong_AsLong(presentMode);

    }

    if (clipped != NULL && clipped != Py_None) {

        (self->base)->clipped = PyLong_AsLong(clipped);

    }

    if (oldSwapchain != NULL && oldSwapchain != Py_None) {

        (self->base)->oldSwapchain = PyCapsule_GetPointer(oldSwapchain, "VkSwapchainKHR");

    }

    return 0;
}
static PyTypeObject PyVkSwapchainCreateInfoKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkSwapchainCreateInfoKHR", sizeof(PyVkSwapchainCreateInfoKHR), 0,
    (destructor)PyVkSwapchainCreateInfoKHR_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkSwapchainCreateInfoKHR object",0,0,0,0,0,0,0,0,
    PyVkSwapchainCreateInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkSwapchainCreateInfoKHR_init,0,PyVkSwapchainCreateInfoKHR_new,
};

static void PyVkPresentInfoKHR_del(PyVkPresentInfoKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPresentInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPresentInfoKHR *self;
    self = (PyVkPresentInfoKHR *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPresentInfoKHR));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPresentInfoKHR");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkPresentInfoKHR_getpNext(PyVkPresentInfoKHR *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPresentInfoKHR_getwaitSemaphoreCount(PyVkPresentInfoKHR *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->waitSemaphoreCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPresentInfoKHR_getswapchainCount(PyVkPresentInfoKHR *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->swapchainCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkPresentInfoKHR_getpImageIndices(PyVkPresentInfoKHR *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (*((self->base)->pImageIndices)));
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkPresentInfoKHR_getsetters[] = {

    { "pNext", (getter)PyVkPresentInfoKHR_getpNext, NULL, "", NULL},

    { "waitSemaphoreCount", (getter)PyVkPresentInfoKHR_getwaitSemaphoreCount, NULL, "", NULL},

    { "swapchainCount", (getter)PyVkPresentInfoKHR_getswapchainCount, NULL, "", NULL},

    { "pImageIndices", (getter)PyVkPresentInfoKHR_getpImageIndices, NULL, "", NULL},
    {NULL}
};

static int
PyVkPresentInfoKHR_init(PyVkPresentInfoKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* waitSemaphoreCount = NULL;
    PyObject* pWaitSemaphores = NULL;
    PyObject* swapchainCount = NULL;
    PyObject* pSwapchains = NULL;
    PyObject* pImageIndices = NULL;
    PyObject* pResults = NULL;
    static char *kwlist[] = {"waitSemaphoreCount","pWaitSemaphores","swapchainCount","pSwapchains","pImageIndices","pResults",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &waitSemaphoreCount, &pWaitSemaphores, &swapchainCount, &pSwapchains, &pImageIndices, &pResults)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;

    (self->base)->pNext = NULL;

    if (waitSemaphoreCount != NULL && waitSemaphoreCount != Py_None) {
        (self->base)->waitSemaphoreCount = (uint32_t) PyLong_AsLong(waitSemaphoreCount);
    }

    if (pWaitSemaphores != NULL && pWaitSemaphores != Py_None) {

        (self->base)->pWaitSemaphores = PyCapsule_GetPointer(pWaitSemaphores, "VkSemaphore");

    }

    if (swapchainCount != NULL && swapchainCount != Py_None) {
        (self->base)->swapchainCount = (uint32_t) PyLong_AsLong(swapchainCount);
    }

    if (pSwapchains != NULL && pSwapchains != Py_None) {

        (self->base)->pSwapchains = PyCapsule_GetPointer(pSwapchains, "VkSwapchainKHR");

    }

    if (pImageIndices != NULL && pImageIndices != Py_None) {

        uint32_t tmp75602451 = (uint32_t) PyLong_AsLong(pImageIndices);
        uint32_t *tmp1302614 = malloc(sizeof(uint32_t));
        memcpy(tmp1302614, &tmp75602451, sizeof(uint32_t));
        (self->base)->pImageIndices = tmp1302614;

    }

    if (pResults != NULL && pResults != Py_None) {

        VkResult tmp = PyLong_AsLong(pResults);
        (self->base)->pResults = &tmp;

    }

    return 0;
}
static PyTypeObject PyVkPresentInfoKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPresentInfoKHR", sizeof(PyVkPresentInfoKHR), 0,
    (destructor)PyVkPresentInfoKHR_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPresentInfoKHR object",0,0,0,0,0,0,0,0,
    PyVkPresentInfoKHR_getsetters,0,0,0,0,0,(initproc)PyVkPresentInfoKHR_init,0,PyVkPresentInfoKHR_new,
};

static void PyVkDebugReportCallbackCreateInfoEXT_del(PyVkDebugReportCallbackCreateInfoEXT* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDebugReportCallbackCreateInfoEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDebugReportCallbackCreateInfoEXT *self;
    self = (PyVkDebugReportCallbackCreateInfoEXT *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDebugReportCallbackCreateInfoEXT));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDebugReportCallbackCreateInfoEXT");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDebugReportCallbackCreateInfoEXT_getpNext(PyVkDebugReportCallbackCreateInfoEXT *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDebugReportCallbackCreateInfoEXT_getpUserData(PyVkDebugReportCallbackCreateInfoEXT *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDebugReportCallbackCreateInfoEXT_getsetters[] = {

    { "pNext", (getter)PyVkDebugReportCallbackCreateInfoEXT_getpNext, NULL, "", NULL},

    { "pUserData", (getter)PyVkDebugReportCallbackCreateInfoEXT_getpUserData, NULL, "", NULL},
    {NULL}
};

static int
PyVkDebugReportCallbackCreateInfoEXT_init(PyVkDebugReportCallbackCreateInfoEXT *self, PyObject *args, PyObject *kwds) {
    PyObject* flags = NULL;
    PyObject* pfnCallback = NULL;
    PyObject* pUserData = NULL;
    static char *kwlist[] = {"flags","pfnCallback","pUserData",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &flags, &pfnCallback, &pUserData)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;

    (self->base)->pNext = NULL;

    if (flags != NULL && flags != Py_None) {

        (self->base)->flags = PyLong_AsLong(flags);

    }

    if (pUserData != NULL && pUserData != Py_None) {
        (self->base)->pUserData = NULL;
    }

    return 0;
}
static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDebugReportCallbackCreateInfoEXT", sizeof(PyVkDebugReportCallbackCreateInfoEXT), 0,
    (destructor)PyVkDebugReportCallbackCreateInfoEXT_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDebugReportCallbackCreateInfoEXT object",0,0,0,0,0,0,0,0,
    PyVkDebugReportCallbackCreateInfoEXT_getsetters,0,0,0,0,0,(initproc)PyVkDebugReportCallbackCreateInfoEXT_init,0,PyVkDebugReportCallbackCreateInfoEXT_new,
};

static void PyVkPipelineRasterizationStateRasterizationOrderAMD_del(PyVkPipelineRasterizationStateRasterizationOrderAMD* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkPipelineRasterizationStateRasterizationOrderAMD_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkPipelineRasterizationStateRasterizationOrderAMD *self;
    self = (PyVkPipelineRasterizationStateRasterizationOrderAMD *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkPipelineRasterizationStateRasterizationOrderAMD));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkPipelineRasterizationStateRasterizationOrderAMD");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkPipelineRasterizationStateRasterizationOrderAMD_getpNext(PyVkPipelineRasterizationStateRasterizationOrderAMD *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkPipelineRasterizationStateRasterizationOrderAMD_getsetters[] = {

    { "pNext", (getter)PyVkPipelineRasterizationStateRasterizationOrderAMD_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkPipelineRasterizationStateRasterizationOrderAMD_init(PyVkPipelineRasterizationStateRasterizationOrderAMD *self, PyObject *args, PyObject *kwds) {
    PyObject* rasterizationOrder = NULL;
    static char *kwlist[] = {"rasterizationOrder",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &rasterizationOrder)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD;

    (self->base)->pNext = NULL;

    if (rasterizationOrder != NULL && rasterizationOrder != Py_None) {

        (self->base)->rasterizationOrder = PyLong_AsLong(rasterizationOrder);

    }

    return 0;
}
static PyTypeObject PyVkPipelineRasterizationStateRasterizationOrderAMDType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkPipelineRasterizationStateRasterizationOrderAMD", sizeof(PyVkPipelineRasterizationStateRasterizationOrderAMD), 0,
    (destructor)PyVkPipelineRasterizationStateRasterizationOrderAMD_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkPipelineRasterizationStateRasterizationOrderAMD object",0,0,0,0,0,0,0,0,
    PyVkPipelineRasterizationStateRasterizationOrderAMD_getsetters,0,0,0,0,0,(initproc)PyVkPipelineRasterizationStateRasterizationOrderAMD_init,0,PyVkPipelineRasterizationStateRasterizationOrderAMD_new,
};

static void PyVkDebugMarkerObjectNameInfoEXT_del(PyVkDebugMarkerObjectNameInfoEXT* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDebugMarkerObjectNameInfoEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDebugMarkerObjectNameInfoEXT *self;
    self = (PyVkDebugMarkerObjectNameInfoEXT *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDebugMarkerObjectNameInfoEXT));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDebugMarkerObjectNameInfoEXT");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDebugMarkerObjectNameInfoEXT_getpNext(PyVkDebugMarkerObjectNameInfoEXT *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDebugMarkerObjectNameInfoEXT_getobject(PyVkDebugMarkerObjectNameInfoEXT *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->object);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDebugMarkerObjectNameInfoEXT_getpObjectName(PyVkDebugMarkerObjectNameInfoEXT *self, void *closure) {
    PyObject* value = PyUnicode_FromString((const char *) (self->base)->pObjectName);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDebugMarkerObjectNameInfoEXT_getsetters[] = {

    { "pNext", (getter)PyVkDebugMarkerObjectNameInfoEXT_getpNext, NULL, "", NULL},

    { "object", (getter)PyVkDebugMarkerObjectNameInfoEXT_getobject, NULL, "", NULL},

    { "pObjectName", (getter)PyVkDebugMarkerObjectNameInfoEXT_getpObjectName, NULL, "", NULL},
    {NULL}
};

static int
PyVkDebugMarkerObjectNameInfoEXT_init(PyVkDebugMarkerObjectNameInfoEXT *self, PyObject *args, PyObject *kwds) {
    PyObject* objectType = NULL;
    PyObject* object = NULL;
    PyObject* pObjectName = NULL;
    static char *kwlist[] = {"objectType","object","pObjectName",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &objectType, &object, &pObjectName)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT;

    (self->base)->pNext = NULL;

    if (objectType != NULL && objectType != Py_None) {

        (self->base)->objectType = PyLong_AsLong(objectType);

    }

    if (object != NULL && object != Py_None) {
        (self->base)->object = (uint64_t) PyLong_AsLong(object);
    }

    if (pObjectName != NULL && pObjectName != Py_None) {

        if (pObjectName == Py_None) {
            (self->base)->pObjectName = NULL;
        }
        else {
            PyObject * tmp22618905 = PyUnicode_AsASCIIString(pObjectName);
            char* tmp20055296 = PyBytes_AsString(tmp22618905);
            char* tmp45904734 = strdup(tmp20055296);
            (self->base)->pObjectName = tmp45904734;
            Py_DECREF(tmp22618905);
        }

    }

    return 0;
}
static PyTypeObject PyVkDebugMarkerObjectNameInfoEXTType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDebugMarkerObjectNameInfoEXT", sizeof(PyVkDebugMarkerObjectNameInfoEXT), 0,
    (destructor)PyVkDebugMarkerObjectNameInfoEXT_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDebugMarkerObjectNameInfoEXT object",0,0,0,0,0,0,0,0,
    PyVkDebugMarkerObjectNameInfoEXT_getsetters,0,0,0,0,0,(initproc)PyVkDebugMarkerObjectNameInfoEXT_init,0,PyVkDebugMarkerObjectNameInfoEXT_new,
};

static void PyVkDebugMarkerObjectTagInfoEXT_del(PyVkDebugMarkerObjectTagInfoEXT* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDebugMarkerObjectTagInfoEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDebugMarkerObjectTagInfoEXT *self;
    self = (PyVkDebugMarkerObjectTagInfoEXT *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDebugMarkerObjectTagInfoEXT));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDebugMarkerObjectTagInfoEXT");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDebugMarkerObjectTagInfoEXT_getpNext(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDebugMarkerObjectTagInfoEXT_getobject(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->object);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDebugMarkerObjectTagInfoEXT_gettagName(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->tagName);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDebugMarkerObjectTagInfoEXT_gettagSize(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->tagSize);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDebugMarkerObjectTagInfoEXT_getpTag(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDebugMarkerObjectTagInfoEXT_getsetters[] = {

    { "pNext", (getter)PyVkDebugMarkerObjectTagInfoEXT_getpNext, NULL, "", NULL},

    { "object", (getter)PyVkDebugMarkerObjectTagInfoEXT_getobject, NULL, "", NULL},

    { "tagName", (getter)PyVkDebugMarkerObjectTagInfoEXT_gettagName, NULL, "", NULL},

    { "tagSize", (getter)PyVkDebugMarkerObjectTagInfoEXT_gettagSize, NULL, "", NULL},

    { "pTag", (getter)PyVkDebugMarkerObjectTagInfoEXT_getpTag, NULL, "", NULL},
    {NULL}
};

static int
PyVkDebugMarkerObjectTagInfoEXT_init(PyVkDebugMarkerObjectTagInfoEXT *self, PyObject *args, PyObject *kwds) {
    PyObject* objectType = NULL;
    PyObject* object = NULL;
    PyObject* tagName = NULL;
    PyObject* tagSize = NULL;
    PyObject* pTag = NULL;
    static char *kwlist[] = {"objectType","object","tagName","tagSize","pTag",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &objectType, &object, &tagName, &tagSize, &pTag)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT;

    (self->base)->pNext = NULL;

    if (objectType != NULL && objectType != Py_None) {

        (self->base)->objectType = PyLong_AsLong(objectType);

    }

    if (object != NULL && object != Py_None) {
        (self->base)->object = (uint64_t) PyLong_AsLong(object);
    }

    if (tagName != NULL && tagName != Py_None) {
        (self->base)->tagName = (uint64_t) PyLong_AsLong(tagName);
    }

    if (tagSize != NULL && tagSize != Py_None) {
        (self->base)->tagSize = (size_t) PyLong_AsLong(tagSize);
    }

    if (pTag != NULL && pTag != Py_None) {
        (self->base)->pTag = NULL;
    }

    return 0;
}
static PyTypeObject PyVkDebugMarkerObjectTagInfoEXTType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDebugMarkerObjectTagInfoEXT", sizeof(PyVkDebugMarkerObjectTagInfoEXT), 0,
    (destructor)PyVkDebugMarkerObjectTagInfoEXT_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDebugMarkerObjectTagInfoEXT object",0,0,0,0,0,0,0,0,
    PyVkDebugMarkerObjectTagInfoEXT_getsetters,0,0,0,0,0,(initproc)PyVkDebugMarkerObjectTagInfoEXT_init,0,PyVkDebugMarkerObjectTagInfoEXT_new,
};

static void PyVkDebugMarkerMarkerInfoEXT_del(PyVkDebugMarkerMarkerInfoEXT* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDebugMarkerMarkerInfoEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDebugMarkerMarkerInfoEXT *self;
    self = (PyVkDebugMarkerMarkerInfoEXT *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDebugMarkerMarkerInfoEXT));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDebugMarkerMarkerInfoEXT");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDebugMarkerMarkerInfoEXT_getpNext(PyVkDebugMarkerMarkerInfoEXT *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDebugMarkerMarkerInfoEXT_getpMarkerName(PyVkDebugMarkerMarkerInfoEXT *self, void *closure) {
    PyObject* value = PyUnicode_FromString((const char *) (self->base)->pMarkerName);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkDebugMarkerMarkerInfoEXT_getcolor(PyVkDebugMarkerMarkerInfoEXT *self, void *closure) {

    PyObject* value = PyList_New(0);
    int nb = sizeof((self->base)->color) / sizeof((self->base)->color[0]);
    int i = 0;
    for (i = 0; i < nb; i++) {
        PyObject* py_tmp = PyFloat_FromDouble((double) (self->base)->color[i]);
        PyList_Append(value, py_tmp);
    }

    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDebugMarkerMarkerInfoEXT_getsetters[] = {

    { "pNext", (getter)PyVkDebugMarkerMarkerInfoEXT_getpNext, NULL, "", NULL},

    { "pMarkerName", (getter)PyVkDebugMarkerMarkerInfoEXT_getpMarkerName, NULL, "", NULL},

    { "color", (getter)PyVkDebugMarkerMarkerInfoEXT_getcolor, NULL, "", NULL},
    {NULL}
};

static int
PyVkDebugMarkerMarkerInfoEXT_init(PyVkDebugMarkerMarkerInfoEXT *self, PyObject *args, PyObject *kwds) {
    PyObject* pMarkerName = NULL;
    PyObject* color = NULL;
    static char *kwlist[] = {"pMarkerName","color",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &pMarkerName, &color)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT;

    (self->base)->pNext = NULL;

    if (pMarkerName != NULL && pMarkerName != Py_None) {

        if (pMarkerName == Py_None) {
            (self->base)->pMarkerName = NULL;
        }
        else {
            PyObject * tmp99770433 = PyUnicode_AsASCIIString(pMarkerName);
            char* tmp3910418 = PyBytes_AsString(tmp99770433);
            char* tmp75297646 = strdup(tmp3910418);
            (self->base)->pMarkerName = tmp75297646;
            Py_DECREF(tmp99770433);
        }

    }

    if (color != NULL && color != Py_None) {

        int tmp27323921 = PyList_Size(color);
        int tmp57217953;
        for (tmp57217953 = 0; tmp57217953 < tmp27323921; tmp57217953++) {
            float tmp = (float) PyFloat_AsDouble(
                            PyList_GetItem(color, tmp57217953));
            ((self->base)->color)[tmp57217953] = tmp;
        }

    }

    return 0;
}
static PyTypeObject PyVkDebugMarkerMarkerInfoEXTType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDebugMarkerMarkerInfoEXT", sizeof(PyVkDebugMarkerMarkerInfoEXT), 0,
    (destructor)PyVkDebugMarkerMarkerInfoEXT_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDebugMarkerMarkerInfoEXT object",0,0,0,0,0,0,0,0,
    PyVkDebugMarkerMarkerInfoEXT_getsetters,0,0,0,0,0,(initproc)PyVkDebugMarkerMarkerInfoEXT_init,0,PyVkDebugMarkerMarkerInfoEXT_new,
};

static void PyVkDedicatedAllocationImageCreateInfoNV_del(PyVkDedicatedAllocationImageCreateInfoNV* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDedicatedAllocationImageCreateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDedicatedAllocationImageCreateInfoNV *self;
    self = (PyVkDedicatedAllocationImageCreateInfoNV *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDedicatedAllocationImageCreateInfoNV));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDedicatedAllocationImageCreateInfoNV");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDedicatedAllocationImageCreateInfoNV_getpNext(PyVkDedicatedAllocationImageCreateInfoNV *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDedicatedAllocationImageCreateInfoNV_getsetters[] = {

    { "pNext", (getter)PyVkDedicatedAllocationImageCreateInfoNV_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkDedicatedAllocationImageCreateInfoNV_init(PyVkDedicatedAllocationImageCreateInfoNV *self, PyObject *args, PyObject *kwds) {
    PyObject* dedicatedAllocation = NULL;
    static char *kwlist[] = {"dedicatedAllocation",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &dedicatedAllocation)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV;

    (self->base)->pNext = NULL;

    if (dedicatedAllocation != NULL && dedicatedAllocation != Py_None) {

        (self->base)->dedicatedAllocation = PyLong_AsLong(dedicatedAllocation);

    }

    return 0;
}
static PyTypeObject PyVkDedicatedAllocationImageCreateInfoNVType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDedicatedAllocationImageCreateInfoNV", sizeof(PyVkDedicatedAllocationImageCreateInfoNV), 0,
    (destructor)PyVkDedicatedAllocationImageCreateInfoNV_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDedicatedAllocationImageCreateInfoNV object",0,0,0,0,0,0,0,0,
    PyVkDedicatedAllocationImageCreateInfoNV_getsetters,0,0,0,0,0,(initproc)PyVkDedicatedAllocationImageCreateInfoNV_init,0,PyVkDedicatedAllocationImageCreateInfoNV_new,
};

static void PyVkDedicatedAllocationBufferCreateInfoNV_del(PyVkDedicatedAllocationBufferCreateInfoNV* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDedicatedAllocationBufferCreateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDedicatedAllocationBufferCreateInfoNV *self;
    self = (PyVkDedicatedAllocationBufferCreateInfoNV *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDedicatedAllocationBufferCreateInfoNV));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDedicatedAllocationBufferCreateInfoNV");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDedicatedAllocationBufferCreateInfoNV_getpNext(PyVkDedicatedAllocationBufferCreateInfoNV *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDedicatedAllocationBufferCreateInfoNV_getsetters[] = {

    { "pNext", (getter)PyVkDedicatedAllocationBufferCreateInfoNV_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkDedicatedAllocationBufferCreateInfoNV_init(PyVkDedicatedAllocationBufferCreateInfoNV *self, PyObject *args, PyObject *kwds) {
    PyObject* dedicatedAllocation = NULL;
    static char *kwlist[] = {"dedicatedAllocation",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &dedicatedAllocation)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV;

    (self->base)->pNext = NULL;

    if (dedicatedAllocation != NULL && dedicatedAllocation != Py_None) {

        (self->base)->dedicatedAllocation = PyLong_AsLong(dedicatedAllocation);

    }

    return 0;
}
static PyTypeObject PyVkDedicatedAllocationBufferCreateInfoNVType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDedicatedAllocationBufferCreateInfoNV", sizeof(PyVkDedicatedAllocationBufferCreateInfoNV), 0,
    (destructor)PyVkDedicatedAllocationBufferCreateInfoNV_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDedicatedAllocationBufferCreateInfoNV object",0,0,0,0,0,0,0,0,
    PyVkDedicatedAllocationBufferCreateInfoNV_getsetters,0,0,0,0,0,(initproc)PyVkDedicatedAllocationBufferCreateInfoNV_init,0,PyVkDedicatedAllocationBufferCreateInfoNV_new,
};

static void PyVkDedicatedAllocationMemoryAllocateInfoNV_del(PyVkDedicatedAllocationMemoryAllocateInfoNV* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkDedicatedAllocationMemoryAllocateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkDedicatedAllocationMemoryAllocateInfoNV *self;
    self = (PyVkDedicatedAllocationMemoryAllocateInfoNV *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkDedicatedAllocationMemoryAllocateInfoNV));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkDedicatedAllocationMemoryAllocateInfoNV");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkDedicatedAllocationMemoryAllocateInfoNV_getpNext(PyVkDedicatedAllocationMemoryAllocateInfoNV *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkDedicatedAllocationMemoryAllocateInfoNV_getsetters[] = {

    { "pNext", (getter)PyVkDedicatedAllocationMemoryAllocateInfoNV_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkDedicatedAllocationMemoryAllocateInfoNV_init(PyVkDedicatedAllocationMemoryAllocateInfoNV *self, PyObject *args, PyObject *kwds) {
    PyObject* image = NULL;
    PyObject* buffer = NULL;
    static char *kwlist[] = {"image","buffer",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &image, &buffer)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV;

    (self->base)->pNext = NULL;

    if (image != NULL && image != Py_None) {

        (self->base)->image = PyCapsule_GetPointer(image, "VkImage");

    }

    if (buffer != NULL && buffer != Py_None) {

        (self->base)->buffer = PyCapsule_GetPointer(buffer, "VkBuffer");

    }

    return 0;
}
static PyTypeObject PyVkDedicatedAllocationMemoryAllocateInfoNVType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkDedicatedAllocationMemoryAllocateInfoNV", sizeof(PyVkDedicatedAllocationMemoryAllocateInfoNV), 0,
    (destructor)PyVkDedicatedAllocationMemoryAllocateInfoNV_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkDedicatedAllocationMemoryAllocateInfoNV object",0,0,0,0,0,0,0,0,
    PyVkDedicatedAllocationMemoryAllocateInfoNV_getsetters,0,0,0,0,0,(initproc)PyVkDedicatedAllocationMemoryAllocateInfoNV_init,0,PyVkDedicatedAllocationMemoryAllocateInfoNV_new,
};

static void PyVkExternalImageFormatPropertiesNV_del(PyVkExternalImageFormatPropertiesNV* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkExternalImageFormatPropertiesNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkExternalImageFormatPropertiesNV *self;
    self = (PyVkExternalImageFormatPropertiesNV *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkExternalImageFormatPropertiesNV));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkExternalImageFormatPropertiesNV");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkExternalImageFormatPropertiesNV_getsetters[] = {
    {NULL}
};

static int
PyVkExternalImageFormatPropertiesNV_init(PyVkExternalImageFormatPropertiesNV *self, PyObject *args, PyObject *kwds) {
    PyObject* imageFormatProperties = NULL;
    PyObject* externalMemoryFeatures = NULL;
    PyObject* exportFromImportedHandleTypes = NULL;
    PyObject* compatibleHandleTypes = NULL;
    static char *kwlist[] = {"imageFormatProperties","externalMemoryFeatures","exportFromImportedHandleTypes","compatibleHandleTypes",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &imageFormatProperties, &externalMemoryFeatures, &exportFromImportedHandleTypes, &compatibleHandleTypes)) return -1;

    if (imageFormatProperties != NULL && imageFormatProperties != Py_None) {

        (self->base)->imageFormatProperties = *(((PyVkImageFormatProperties*)imageFormatProperties)->base);

    }

    if (externalMemoryFeatures != NULL && externalMemoryFeatures != Py_None) {

        (self->base)->externalMemoryFeatures = PyLong_AsLong(externalMemoryFeatures);

    }

    if (exportFromImportedHandleTypes != NULL && exportFromImportedHandleTypes != Py_None) {

        (self->base)->exportFromImportedHandleTypes = PyLong_AsLong(exportFromImportedHandleTypes);

    }

    if (compatibleHandleTypes != NULL && compatibleHandleTypes != Py_None) {

        (self->base)->compatibleHandleTypes = PyLong_AsLong(compatibleHandleTypes);

    }

    return 0;
}
static PyTypeObject PyVkExternalImageFormatPropertiesNVType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkExternalImageFormatPropertiesNV", sizeof(PyVkExternalImageFormatPropertiesNV), 0,
    (destructor)PyVkExternalImageFormatPropertiesNV_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkExternalImageFormatPropertiesNV object",0,0,0,0,0,0,0,0,
    PyVkExternalImageFormatPropertiesNV_getsetters,0,0,0,0,0,(initproc)PyVkExternalImageFormatPropertiesNV_init,0,PyVkExternalImageFormatPropertiesNV_new,
};

static void PyVkExternalMemoryImageCreateInfoNV_del(PyVkExternalMemoryImageCreateInfoNV* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkExternalMemoryImageCreateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkExternalMemoryImageCreateInfoNV *self;
    self = (PyVkExternalMemoryImageCreateInfoNV *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkExternalMemoryImageCreateInfoNV));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkExternalMemoryImageCreateInfoNV");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkExternalMemoryImageCreateInfoNV_getpNext(PyVkExternalMemoryImageCreateInfoNV *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkExternalMemoryImageCreateInfoNV_getsetters[] = {

    { "pNext", (getter)PyVkExternalMemoryImageCreateInfoNV_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkExternalMemoryImageCreateInfoNV_init(PyVkExternalMemoryImageCreateInfoNV *self, PyObject *args, PyObject *kwds) {
    PyObject* handleTypes = NULL;
    static char *kwlist[] = {"handleTypes",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &handleTypes)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV;

    (self->base)->pNext = NULL;

    if (handleTypes != NULL && handleTypes != Py_None) {

        (self->base)->handleTypes = PyLong_AsLong(handleTypes);

    }

    return 0;
}
static PyTypeObject PyVkExternalMemoryImageCreateInfoNVType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkExternalMemoryImageCreateInfoNV", sizeof(PyVkExternalMemoryImageCreateInfoNV), 0,
    (destructor)PyVkExternalMemoryImageCreateInfoNV_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkExternalMemoryImageCreateInfoNV object",0,0,0,0,0,0,0,0,
    PyVkExternalMemoryImageCreateInfoNV_getsetters,0,0,0,0,0,(initproc)PyVkExternalMemoryImageCreateInfoNV_init,0,PyVkExternalMemoryImageCreateInfoNV_new,
};

static void PyVkExportMemoryAllocateInfoNV_del(PyVkExportMemoryAllocateInfoNV* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkExportMemoryAllocateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkExportMemoryAllocateInfoNV *self;
    self = (PyVkExportMemoryAllocateInfoNV *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkExportMemoryAllocateInfoNV));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkExportMemoryAllocateInfoNV");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkExportMemoryAllocateInfoNV_getpNext(PyVkExportMemoryAllocateInfoNV *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkExportMemoryAllocateInfoNV_getsetters[] = {

    { "pNext", (getter)PyVkExportMemoryAllocateInfoNV_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkExportMemoryAllocateInfoNV_init(PyVkExportMemoryAllocateInfoNV *self, PyObject *args, PyObject *kwds) {
    PyObject* handleTypes = NULL;
    static char *kwlist[] = {"handleTypes",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &handleTypes)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV;

    (self->base)->pNext = NULL;

    if (handleTypes != NULL && handleTypes != Py_None) {

        (self->base)->handleTypes = PyLong_AsLong(handleTypes);

    }

    return 0;
}
static PyTypeObject PyVkExportMemoryAllocateInfoNVType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkExportMemoryAllocateInfoNV", sizeof(PyVkExportMemoryAllocateInfoNV), 0,
    (destructor)PyVkExportMemoryAllocateInfoNV_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkExportMemoryAllocateInfoNV object",0,0,0,0,0,0,0,0,
    PyVkExportMemoryAllocateInfoNV_getsetters,0,0,0,0,0,(initproc)PyVkExportMemoryAllocateInfoNV_init,0,PyVkExportMemoryAllocateInfoNV_new,
};

#ifdef VK_USE_PLATFORM_WIN32_KHR

static void PyVkImportMemoryWin32HandleInfoNV_del(PyVkImportMemoryWin32HandleInfoNV* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkImportMemoryWin32HandleInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkImportMemoryWin32HandleInfoNV *self;
    self = (PyVkImportMemoryWin32HandleInfoNV *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkImportMemoryWin32HandleInfoNV));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkImportMemoryWin32HandleInfoNV");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkImportMemoryWin32HandleInfoNV_getpNext(PyVkImportMemoryWin32HandleInfoNV *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkImportMemoryWin32HandleInfoNV_getsetters[] = {

    { "pNext", (getter)PyVkImportMemoryWin32HandleInfoNV_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkImportMemoryWin32HandleInfoNV_init(PyVkImportMemoryWin32HandleInfoNV *self, PyObject *args, PyObject *kwds) {
    PyObject* handleType = NULL;
    PyObject* handle = NULL;
    static char *kwlist[] = {"handleType","handle",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &handleType, &handle)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV;

    (self->base)->pNext = NULL;

    if (handleType != NULL && handleType != Py_None) {

        (self->base)->handleType = PyLong_AsLong(handleType);

    }

    return 0;
}
static PyTypeObject PyVkImportMemoryWin32HandleInfoNVType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkImportMemoryWin32HandleInfoNV", sizeof(PyVkImportMemoryWin32HandleInfoNV), 0,
    (destructor)PyVkImportMemoryWin32HandleInfoNV_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkImportMemoryWin32HandleInfoNV object",0,0,0,0,0,0,0,0,
    PyVkImportMemoryWin32HandleInfoNV_getsetters,0,0,0,0,0,(initproc)PyVkImportMemoryWin32HandleInfoNV_init,0,PyVkImportMemoryWin32HandleInfoNV_new,
};

#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

static void PyVkExportMemoryWin32HandleInfoNV_del(PyVkExportMemoryWin32HandleInfoNV* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkExportMemoryWin32HandleInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkExportMemoryWin32HandleInfoNV *self;
    self = (PyVkExportMemoryWin32HandleInfoNV *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkExportMemoryWin32HandleInfoNV));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkExportMemoryWin32HandleInfoNV");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkExportMemoryWin32HandleInfoNV_getpNext(PyVkExportMemoryWin32HandleInfoNV *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkExportMemoryWin32HandleInfoNV_getsetters[] = {

    { "pNext", (getter)PyVkExportMemoryWin32HandleInfoNV_getpNext, NULL, "", NULL},
    {NULL}
};

static int
PyVkExportMemoryWin32HandleInfoNV_init(PyVkExportMemoryWin32HandleInfoNV *self, PyObject *args, PyObject *kwds) {
    PyObject* pAttributes = NULL;
    PyObject* dwAccess = NULL;
    static char *kwlist[] = {"pAttributes","dwAccess",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &pAttributes, &dwAccess)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV;

    (self->base)->pNext = NULL;

    return 0;
}
static PyTypeObject PyVkExportMemoryWin32HandleInfoNVType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkExportMemoryWin32HandleInfoNV", sizeof(PyVkExportMemoryWin32HandleInfoNV), 0,
    (destructor)PyVkExportMemoryWin32HandleInfoNV_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkExportMemoryWin32HandleInfoNV object",0,0,0,0,0,0,0,0,
    PyVkExportMemoryWin32HandleInfoNV_getsetters,0,0,0,0,0,(initproc)PyVkExportMemoryWin32HandleInfoNV_init,0,PyVkExportMemoryWin32HandleInfoNV_new,
};

#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

static void PyVkWin32KeyedMutexAcquireReleaseInfoNV_del(PyVkWin32KeyedMutexAcquireReleaseInfoNV* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkWin32KeyedMutexAcquireReleaseInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkWin32KeyedMutexAcquireReleaseInfoNV *self;
    self = (PyVkWin32KeyedMutexAcquireReleaseInfoNV *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkWin32KeyedMutexAcquireReleaseInfoNV));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkWin32KeyedMutexAcquireReleaseInfoNV");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpNext(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure) {
    Py_INCREF(Py_None);
    PyObject* value = Py_None;
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkWin32KeyedMutexAcquireReleaseInfoNV_getacquireCount(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->acquireCount);
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpAcquireTimeoutMilliseconds(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (*((self->base)->pAcquireTimeoutMilliseconds)));
    Py_INCREF(value);
    return value;
}

static PyObject * PyVkWin32KeyedMutexAcquireReleaseInfoNV_getreleaseCount(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure) {
    PyObject* value = PyLong_FromLong((long) (self->base)->releaseCount);
    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkWin32KeyedMutexAcquireReleaseInfoNV_getsetters[] = {

    { "pNext", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpNext, NULL, "", NULL},

    { "acquireCount", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getacquireCount, NULL, "", NULL},

    { "pAcquireTimeoutMilliseconds", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpAcquireTimeoutMilliseconds, NULL, "", NULL},

    { "releaseCount", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getreleaseCount, NULL, "", NULL},
    {NULL}
};

static int
PyVkWin32KeyedMutexAcquireReleaseInfoNV_init(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, PyObject *args, PyObject *kwds) {
    PyObject* acquireCount = NULL;
    PyObject* pAcquireSyncs = NULL;
    PyObject* pAcquireKeys = NULL;
    PyObject* pAcquireTimeoutMilliseconds = NULL;
    PyObject* releaseCount = NULL;
    PyObject* pReleaseSyncs = NULL;
    PyObject* pReleaseKeys = NULL;
    static char *kwlist[] = {"acquireCount","pAcquireSyncs","pAcquireKeys","pAcquireTimeoutMilliseconds","releaseCount","pReleaseSyncs","pReleaseKeys",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &acquireCount, &pAcquireSyncs, &pAcquireKeys, &pAcquireTimeoutMilliseconds, &releaseCount, &pReleaseSyncs, &pReleaseKeys)) return -1;

    (self->base)->sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV;

    (self->base)->pNext = NULL;

    if (acquireCount != NULL && acquireCount != Py_None) {
        (self->base)->acquireCount = (uint32_t) PyLong_AsLong(acquireCount);
    }

    if (pAcquireSyncs != NULL && pAcquireSyncs != Py_None) {

        (self->base)->pAcquireSyncs = PyCapsule_GetPointer(pAcquireSyncs, "VkDeviceMemory");

    }

    if (pAcquireTimeoutMilliseconds != NULL && pAcquireTimeoutMilliseconds != Py_None) {

        uint32_t tmp88532256 = (uint32_t) PyLong_AsLong(pAcquireTimeoutMilliseconds);
        uint32_t *tmp57148227 = malloc(sizeof(uint32_t));
        memcpy(tmp57148227, &tmp88532256, sizeof(uint32_t));
        (self->base)->pAcquireTimeoutMilliseconds = tmp57148227;

    }

    if (releaseCount != NULL && releaseCount != Py_None) {
        (self->base)->releaseCount = (uint32_t) PyLong_AsLong(releaseCount);
    }

    if (pReleaseSyncs != NULL && pReleaseSyncs != Py_None) {

        (self->base)->pReleaseSyncs = PyCapsule_GetPointer(pReleaseSyncs, "VkDeviceMemory");

    }

    return 0;
}
static PyTypeObject PyVkWin32KeyedMutexAcquireReleaseInfoNVType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkWin32KeyedMutexAcquireReleaseInfoNV", sizeof(PyVkWin32KeyedMutexAcquireReleaseInfoNV), 0,
    (destructor)PyVkWin32KeyedMutexAcquireReleaseInfoNV_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkWin32KeyedMutexAcquireReleaseInfoNV object",0,0,0,0,0,0,0,0,
    PyVkWin32KeyedMutexAcquireReleaseInfoNV_getsetters,0,0,0,0,0,(initproc)PyVkWin32KeyedMutexAcquireReleaseInfoNV_init,0,PyVkWin32KeyedMutexAcquireReleaseInfoNV_new,
};

#endif

static void PyVkClearColorValue_del(PyVkClearColorValue* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkClearColorValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkClearColorValue *self;
    self = (PyVkClearColorValue *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkClearColorValue));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkClearColorValue");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyObject * PyVkClearColorValue_getfloat32(PyVkClearColorValue *self, void *closure) {

    PyObject* value = PyList_New(0);
    int nb = sizeof((self->base)->float32) / sizeof((self->base)->float32[0]);
    int i = 0;
    for (i = 0; i < nb; i++) {
        PyObject* py_tmp = PyFloat_FromDouble((double) (self->base)->float32[i]);
        PyList_Append(value, py_tmp);
    }

    Py_INCREF(value);
    return value;
}

static PyGetSetDef PyVkClearColorValue_getsetters[] = {

    { "float32", (getter)PyVkClearColorValue_getfloat32, NULL, "", NULL},
    {NULL}
};

static int
PyVkClearColorValue_init(PyVkClearColorValue *self, PyObject *args, PyObject *kwds) {
    PyObject* float32 = NULL;
    PyObject* int32 = NULL;
    PyObject* uint32 = NULL;
    static char *kwlist[] = {"float32","int32","uint32",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &float32, &int32, &uint32)) return -1;

    int nb_union_arg = 0;

    if (float32 != NULL && float32 != Py_None) nb_union_arg++;

    if (int32 != NULL && int32 != Py_None) nb_union_arg++;

    if (uint32 != NULL && uint32 != Py_None) nb_union_arg++;

    if (nb_union_arg > 1) {
        PyErr_SetString(PyExc_TypeError, "Only one argument allowed");
        return -1;
    }

    if (float32 != NULL && float32 != Py_None) {

        int tmp68281907 = PyList_Size(float32);
        int tmp68878404;
        for (tmp68878404 = 0; tmp68878404 < tmp68281907; tmp68878404++) {
            float tmp = (float) PyFloat_AsDouble(
                            PyList_GetItem(float32, tmp68878404));
            ((self->base)->float32)[tmp68878404] = tmp;
        }

    }

    return 0;
}
static PyTypeObject PyVkClearColorValueType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkClearColorValue", sizeof(PyVkClearColorValue), 0,
    (destructor)PyVkClearColorValue_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkClearColorValue object",0,0,0,0,0,0,0,0,
    PyVkClearColorValue_getsetters,0,0,0,0,0,(initproc)PyVkClearColorValue_init,0,PyVkClearColorValue_new,
};

static void PyVkClearValue_del(PyVkClearValue* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyVkClearValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyVkClearValue *self;
    self = (PyVkClearValue *)type->tp_alloc(type, 0);
    if ( self != NULL) {
        self->base = malloc(sizeof(VkClearValue));
        if (self->base == NULL) {
            PyErr_SetString(PyExc_MemoryError,
                            "Cannot allocate memory for VkClearValue");
            return NULL;
        }
    }

    return (PyObject *)self;
}

static PyGetSetDef PyVkClearValue_getsetters[] = {
    {NULL}
};

static int
PyVkClearValue_init(PyVkClearValue *self, PyObject *args, PyObject *kwds) {
    PyObject* color = NULL;
    PyObject* depthStencil = NULL;
    static char *kwlist[] = {"color","depthStencil",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &color, &depthStencil)) return -1;

    int nb_union_arg = 0;

    if (color != NULL && color != Py_None) nb_union_arg++;

    if (depthStencil != NULL && depthStencil != Py_None) nb_union_arg++;

    if (nb_union_arg > 1) {
        PyErr_SetString(PyExc_TypeError, "Only one argument allowed");
        return -1;
    }

    return 0;
}
static PyTypeObject PyVkClearValueType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.VkClearValue", sizeof(PyVkClearValue), 0,
    (destructor)PyVkClearValue_del,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
    "VkClearValue object",0,0,0,0,0,0,0,0,
    PyVkClearValue_getsetters,0,0,0,0,0,(initproc)PyVkClearValue_init,0,PyVkClearValue_new,
};

#ifdef VK_USE_PLATFORM_ANDROID_KHR

typedef struct {
    PyObject_HEAD PFN_vkCreateAndroidSurfaceKHR pfn;
}
PyvkCreateAndroidSurfaceKHR;

#endif

typedef struct {
    PyObject_HEAD PFN_vkGetPhysicalDeviceDisplayPropertiesKHR pfn;
}
PyvkGetPhysicalDeviceDisplayPropertiesKHR;

typedef struct {
    PyObject_HEAD PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR pfn;
}
PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR;

typedef struct {
    PyObject_HEAD PFN_vkGetDisplayPlaneSupportedDisplaysKHR pfn;
}
PyvkGetDisplayPlaneSupportedDisplaysKHR;

typedef struct {
    PyObject_HEAD PFN_vkGetDisplayModePropertiesKHR pfn;
}
PyvkGetDisplayModePropertiesKHR;

typedef struct {
    PyObject_HEAD PFN_vkCreateDisplayModeKHR pfn;
}
PyvkCreateDisplayModeKHR;

typedef struct {
    PyObject_HEAD PFN_vkGetDisplayPlaneCapabilitiesKHR pfn;
}
PyvkGetDisplayPlaneCapabilitiesKHR;

typedef struct {
    PyObject_HEAD PFN_vkCreateDisplayPlaneSurfaceKHR pfn;
}
PyvkCreateDisplayPlaneSurfaceKHR;

typedef struct {
    PyObject_HEAD PFN_vkCreateSharedSwapchainsKHR pfn;
}
PyvkCreateSharedSwapchainsKHR;

#ifdef VK_USE_PLATFORM_MIR_KHR

typedef struct {
    PyObject_HEAD PFN_vkCreateMirSurfaceKHR pfn;
}
PyvkCreateMirSurfaceKHR;

#endif

#ifdef VK_USE_PLATFORM_MIR_KHR

typedef struct {
    PyObject_HEAD PFN_vkGetPhysicalDeviceMirPresentationSupportKHR pfn;
}
PyvkGetPhysicalDeviceMirPresentationSupportKHR;

#endif

typedef struct {
    PyObject_HEAD PFN_vkDestroySurfaceKHR pfn;
}
PyvkDestroySurfaceKHR;

typedef struct {
    PyObject_HEAD PFN_vkGetPhysicalDeviceSurfaceSupportKHR pfn;
}
PyvkGetPhysicalDeviceSurfaceSupportKHR;

typedef struct {
    PyObject_HEAD PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR pfn;
}
PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR;

typedef struct {
    PyObject_HEAD PFN_vkGetPhysicalDeviceSurfaceFormatsKHR pfn;
}
PyvkGetPhysicalDeviceSurfaceFormatsKHR;

typedef struct {
    PyObject_HEAD PFN_vkGetPhysicalDeviceSurfacePresentModesKHR pfn;
}
PyvkGetPhysicalDeviceSurfacePresentModesKHR;

typedef struct {
    PyObject_HEAD PFN_vkCreateSwapchainKHR pfn;
}
PyvkCreateSwapchainKHR;

typedef struct {
    PyObject_HEAD PFN_vkDestroySwapchainKHR pfn;
}
PyvkDestroySwapchainKHR;

typedef struct {
    PyObject_HEAD PFN_vkGetSwapchainImagesKHR pfn;
}
PyvkGetSwapchainImagesKHR;

typedef struct {
    PyObject_HEAD PFN_vkAcquireNextImageKHR pfn;
}
PyvkAcquireNextImageKHR;

typedef struct {
    PyObject_HEAD PFN_vkQueuePresentKHR pfn;
}
PyvkQueuePresentKHR;

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

typedef struct {
    PyObject_HEAD PFN_vkCreateWaylandSurfaceKHR pfn;
}
PyvkCreateWaylandSurfaceKHR;

#endif

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

typedef struct {
    PyObject_HEAD PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR pfn;
}
PyvkGetPhysicalDeviceWaylandPresentationSupportKHR;

#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

typedef struct {
    PyObject_HEAD PFN_vkCreateWin32SurfaceKHR pfn;
}
PyvkCreateWin32SurfaceKHR;

#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

typedef struct {
    PyObject_HEAD PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR pfn;
}
PyvkGetPhysicalDeviceWin32PresentationSupportKHR;

#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR

typedef struct {
    PyObject_HEAD PFN_vkCreateXlibSurfaceKHR pfn;
}
PyvkCreateXlibSurfaceKHR;

#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR

typedef struct {
    PyObject_HEAD PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR pfn;
}
PyvkGetPhysicalDeviceXlibPresentationSupportKHR;

#endif

#ifdef VK_USE_PLATFORM_XCB_KHR

typedef struct {
    PyObject_HEAD PFN_vkCreateXcbSurfaceKHR pfn;
}
PyvkCreateXcbSurfaceKHR;

#endif

#ifdef VK_USE_PLATFORM_XCB_KHR

typedef struct {
    PyObject_HEAD PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR pfn;
}
PyvkGetPhysicalDeviceXcbPresentationSupportKHR;

#endif

typedef struct {
    PyObject_HEAD PFN_vkCreateDebugReportCallbackEXT pfn;
}
PyvkCreateDebugReportCallbackEXT;

typedef struct {
    PyObject_HEAD PFN_vkDestroyDebugReportCallbackEXT pfn;
}
PyvkDestroyDebugReportCallbackEXT;

typedef struct {
    PyObject_HEAD PFN_vkDebugReportMessageEXT pfn;
}
PyvkDebugReportMessageEXT;

typedef struct {
    PyObject_HEAD PFN_vkDebugMarkerSetObjectNameEXT pfn;
}
PyvkDebugMarkerSetObjectNameEXT;

typedef struct {
    PyObject_HEAD PFN_vkDebugMarkerSetObjectTagEXT pfn;
}
PyvkDebugMarkerSetObjectTagEXT;

typedef struct {
    PyObject_HEAD PFN_vkCmdDebugMarkerBeginEXT pfn;
}
PyvkCmdDebugMarkerBeginEXT;

typedef struct {
    PyObject_HEAD PFN_vkCmdDebugMarkerEndEXT pfn;
}
PyvkCmdDebugMarkerEndEXT;

typedef struct {
    PyObject_HEAD PFN_vkCmdDebugMarkerInsertEXT pfn;
}
PyvkCmdDebugMarkerInsertEXT;

typedef struct {
    PyObject_HEAD PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV pfn;
}
PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV;

#ifdef VK_USE_PLATFORM_WIN32_KHR

typedef struct {
    PyObject_HEAD PFN_vkGetMemoryWin32HandleNV pfn;
}
PyvkGetMemoryWin32HandleNV;

#endif

typedef struct {
    PyObject_HEAD PFN_vkCmdDrawIndirectCountAMD pfn;
}
PyvkCmdDrawIndirectCountAMD;

typedef struct {
    PyObject_HEAD PFN_vkCmdDrawIndexedIndirectCountAMD pfn;
}
PyvkCmdDrawIndexedIndirectCountAMD;

#ifdef VK_USE_PLATFORM_ANDROID_KHR

static void PyvkCreateAndroidSurfaceKHR_del(PyvkCreateAndroidSurfaceKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkCreateAndroidSurfaceKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkCreateAndroidSurfaceKHR *self;
    self = (PyvkCreateAndroidSurfaceKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

#ifdef VK_USE_PLATFORM_ANDROID_KHR

static PyObject* PyvkCreateAndroidSurfaceKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* instance = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"instance","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &instance, &pCreateInfo)) return NULL;

    struct {

        VkInstance instance;

        VkAndroidSurfaceCreateInfoKHR* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.instance = PyCapsule_GetPointer(instance, "VkInstance");

    return_struct.pCreateInfo = (((PyVkAndroidSurfaceCreateInfoKHR*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkSurfaceKHR *value = malloc(sizeof(VkSurfaceKHR));
    if (raise(
                vkCreateAndroidSurfaceKHR(return_struct.instance,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkSurfaceKHR", NULL);

    return return_value;
}

#endif

static int
PyvkCreateAndroidSurfaceKHR_init(PyvkCreateAndroidSurfaceKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkCreateAndroidSurfaceKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkCreateAndroidSurfaceKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkCreateAndroidSurfaceKHR", sizeof(PyvkCreateAndroidSurfaceKHR), 0,
    (destructor)PyvkCreateAndroidSurfaceKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateAndroidSurfaceKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkCreateAndroidSurfaceKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkCreateAndroidSurfaceKHR_init,0,PyvkCreateAndroidSurfaceKHR_new,
};

#endif

static void PyvkGetPhysicalDeviceDisplayPropertiesKHR_del(PyvkGetPhysicalDeviceDisplayPropertiesKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkGetPhysicalDeviceDisplayPropertiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkGetPhysicalDeviceDisplayPropertiesKHR *self;
    self = (PyvkGetPhysicalDeviceDisplayPropertiesKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkGetPhysicalDeviceDisplayPropertiesKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    static char *kwlist[] = {"physicalDevice",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &physicalDevice)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    uint32_t count;
    if (raise(
                vkGetPhysicalDeviceDisplayPropertiesKHR(return_struct.physicalDevice,&count, NULL))) return NULL;
    VkDisplayPropertiesKHR *values = malloc(count*sizeof(VkDisplayPropertiesKHR));
    if (raise(
                vkGetPhysicalDeviceDisplayPropertiesKHR(return_struct.physicalDevice,&count, values))) return NULL;
    PyObject* return_value = PyList_New(0);
    uint32_t i;
    for (i=0; i<count; i++) {

        PyObject* pyreturn = PyObject_Call((PyObject *)&PyVkDisplayPropertiesKHRType,
                                           NULL, NULL);
        memcpy(((PyVkDisplayPropertiesKHR*)pyreturn)->base,
               values + i, sizeof(VkDisplayPropertiesKHR));

        PyList_Append(return_value, pyreturn);
    }

    return return_value;
}

static int
PyvkGetPhysicalDeviceDisplayPropertiesKHR_init(PyvkGetPhysicalDeviceDisplayPropertiesKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkGetPhysicalDeviceDisplayPropertiesKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkGetPhysicalDeviceDisplayPropertiesKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkGetPhysicalDeviceDisplayPropertiesKHR", sizeof(PyvkGetPhysicalDeviceDisplayPropertiesKHR), 0,
    (destructor)PyvkGetPhysicalDeviceDisplayPropertiesKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceDisplayPropertiesKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkGetPhysicalDeviceDisplayPropertiesKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceDisplayPropertiesKHR_init,0,PyvkGetPhysicalDeviceDisplayPropertiesKHR_new,
};

static void PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR_del(PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR *self;
    self = (PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    static char *kwlist[] = {"physicalDevice",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &physicalDevice)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    uint32_t count;
    if (raise(
                vkGetPhysicalDeviceDisplayPlanePropertiesKHR(return_struct.physicalDevice,&count, NULL))) return NULL;
    VkDisplayPlanePropertiesKHR *values = malloc(count*sizeof(VkDisplayPlanePropertiesKHR));
    if (raise(
                vkGetPhysicalDeviceDisplayPlanePropertiesKHR(return_struct.physicalDevice,&count, values))) return NULL;
    PyObject* return_value = PyList_New(0);
    uint32_t i;
    for (i=0; i<count; i++) {

        PyObject* pyreturn = PyObject_Call((PyObject *)&PyVkDisplayPlanePropertiesKHRType,
                                           NULL, NULL);
        memcpy(((PyVkDisplayPlanePropertiesKHR*)pyreturn)->base,
               values + i, sizeof(VkDisplayPlanePropertiesKHR));

        PyList_Append(return_value, pyreturn);
    }

    return return_value;
}

static int
PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR_init(PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkGetPhysicalDeviceDisplayPlanePropertiesKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkGetPhysicalDeviceDisplayPlanePropertiesKHR", sizeof(PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR), 0,
    (destructor)PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkGetPhysicalDeviceDisplayPlanePropertiesKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR_init,0,PyvkGetPhysicalDeviceDisplayPlanePropertiesKHR_new,
};

static void PyvkGetDisplayPlaneSupportedDisplaysKHR_del(PyvkGetDisplayPlaneSupportedDisplaysKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkGetDisplayPlaneSupportedDisplaysKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkGetDisplayPlaneSupportedDisplaysKHR *self;
    self = (PyvkGetDisplayPlaneSupportedDisplaysKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkGetDisplayPlaneSupportedDisplaysKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    PyObject* planeIndex = NULL;
    static char *kwlist[] = {"physicalDevice","planeIndex",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &physicalDevice, &planeIndex)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

        uint32_t planeIndex;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");
    return_struct.planeIndex = (uint32_t) PyLong_AsLong(planeIndex);
    uint32_t count;
    if (raise(
                vkGetDisplayPlaneSupportedDisplaysKHR(return_struct.physicalDevice,return_struct.planeIndex,&count, NULL))) return NULL;
    VkDisplayKHR *values = malloc(count*sizeof(VkDisplayKHR));
    if (raise(
                vkGetDisplayPlaneSupportedDisplaysKHR(return_struct.physicalDevice,return_struct.planeIndex,&count, values))) return NULL;
    PyObject* return_value = PyList_New(0);
    uint32_t i;
    for (i=0; i<count; i++) {

        PyObject* pyreturn = PyCapsule_New(values + i*sizeof(VkDisplayKHR)
                                           , "VkDisplayKHR", NULL);

        PyList_Append(return_value, pyreturn);
    }

    return return_value;
}

static int
PyvkGetDisplayPlaneSupportedDisplaysKHR_init(PyvkGetDisplayPlaneSupportedDisplaysKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkGetDisplayPlaneSupportedDisplaysKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkGetDisplayPlaneSupportedDisplaysKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkGetDisplayPlaneSupportedDisplaysKHR", sizeof(PyvkGetDisplayPlaneSupportedDisplaysKHR), 0,
    (destructor)PyvkGetDisplayPlaneSupportedDisplaysKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetDisplayPlaneSupportedDisplaysKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkGetDisplayPlaneSupportedDisplaysKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkGetDisplayPlaneSupportedDisplaysKHR_init,0,PyvkGetDisplayPlaneSupportedDisplaysKHR_new,
};

static void PyvkGetDisplayModePropertiesKHR_del(PyvkGetDisplayModePropertiesKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkGetDisplayModePropertiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkGetDisplayModePropertiesKHR *self;
    self = (PyvkGetDisplayModePropertiesKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkGetDisplayModePropertiesKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    PyObject* display = NULL;
    static char *kwlist[] = {"physicalDevice","display",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &physicalDevice, &display)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

        VkDisplayKHR display;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    return_struct.display = PyCapsule_GetPointer(display, "VkDisplayKHR");

    uint32_t count;
    if (raise(
                vkGetDisplayModePropertiesKHR(return_struct.physicalDevice,return_struct.display,&count, NULL))) return NULL;
    VkDisplayModePropertiesKHR *values = malloc(count*sizeof(VkDisplayModePropertiesKHR));
    if (raise(
                vkGetDisplayModePropertiesKHR(return_struct.physicalDevice,return_struct.display,&count, values))) return NULL;
    PyObject* return_value = PyList_New(0);
    uint32_t i;
    for (i=0; i<count; i++) {

        PyObject* pyreturn = PyObject_Call((PyObject *)&PyVkDisplayModePropertiesKHRType,
                                           NULL, NULL);
        memcpy(((PyVkDisplayModePropertiesKHR*)pyreturn)->base,
               values + i, sizeof(VkDisplayModePropertiesKHR));

        PyList_Append(return_value, pyreturn);
    }

    return return_value;
}

static int
PyvkGetDisplayModePropertiesKHR_init(PyvkGetDisplayModePropertiesKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkGetDisplayModePropertiesKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkGetDisplayModePropertiesKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkGetDisplayModePropertiesKHR", sizeof(PyvkGetDisplayModePropertiesKHR), 0,
    (destructor)PyvkGetDisplayModePropertiesKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetDisplayModePropertiesKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkGetDisplayModePropertiesKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkGetDisplayModePropertiesKHR_init,0,PyvkGetDisplayModePropertiesKHR_new,
};

static void PyvkCreateDisplayModeKHR_del(PyvkCreateDisplayModeKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkCreateDisplayModeKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkCreateDisplayModeKHR *self;
    self = (PyvkCreateDisplayModeKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkCreateDisplayModeKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    PyObject* display = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"physicalDevice","display","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &physicalDevice, &display, &pCreateInfo)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

        VkDisplayKHR display;

        VkDisplayModeCreateInfoKHR* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    return_struct.display = PyCapsule_GetPointer(display, "VkDisplayKHR");

    return_struct.pCreateInfo = (((PyVkDisplayModeCreateInfoKHR*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkDisplayModeKHR *value = malloc(sizeof(VkDisplayModeKHR));
    if (raise(
                vkCreateDisplayModeKHR(return_struct.physicalDevice,return_struct.display,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkDisplayModeKHR", NULL);

    return return_value;
}

static int
PyvkCreateDisplayModeKHR_init(PyvkCreateDisplayModeKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkCreateDisplayModeKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkCreateDisplayModeKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkCreateDisplayModeKHR", sizeof(PyvkCreateDisplayModeKHR), 0,
    (destructor)PyvkCreateDisplayModeKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateDisplayModeKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkCreateDisplayModeKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkCreateDisplayModeKHR_init,0,PyvkCreateDisplayModeKHR_new,
};

static void PyvkGetDisplayPlaneCapabilitiesKHR_del(PyvkGetDisplayPlaneCapabilitiesKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkGetDisplayPlaneCapabilitiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkGetDisplayPlaneCapabilitiesKHR *self;
    self = (PyvkGetDisplayPlaneCapabilitiesKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkGetDisplayPlaneCapabilitiesKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    PyObject* mode = NULL;
    PyObject* planeIndex = NULL;
    static char *kwlist[] = {"physicalDevice","mode","planeIndex",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &physicalDevice, &mode, &planeIndex)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

        VkDisplayModeKHR mode;

        uint32_t planeIndex;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    return_struct.mode = PyCapsule_GetPointer(mode, "VkDisplayModeKHR");
    return_struct.planeIndex = (uint32_t) PyLong_AsLong(planeIndex);
    VkDisplayPlaneCapabilitiesKHR *value = malloc(sizeof(VkDisplayPlaneCapabilitiesKHR));
    if (raise(
                vkGetDisplayPlaneCapabilitiesKHR(return_struct.physicalDevice,return_struct.mode,return_struct.planeIndex,value))) return NULL;
    PyObject* return_value =
        PyObject_Call((PyObject *)&PyVkDisplayPlaneCapabilitiesKHRType,NULL, NULL);
    memcpy(((PyVkDisplayPlaneCapabilitiesKHR*)return_value)->base,
           value, sizeof(VkDisplayPlaneCapabilitiesKHR));

    return return_value;
}

static int
PyvkGetDisplayPlaneCapabilitiesKHR_init(PyvkGetDisplayPlaneCapabilitiesKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkGetDisplayPlaneCapabilitiesKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkGetDisplayPlaneCapabilitiesKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkGetDisplayPlaneCapabilitiesKHR", sizeof(PyvkGetDisplayPlaneCapabilitiesKHR), 0,
    (destructor)PyvkGetDisplayPlaneCapabilitiesKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetDisplayPlaneCapabilitiesKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkGetDisplayPlaneCapabilitiesKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkGetDisplayPlaneCapabilitiesKHR_init,0,PyvkGetDisplayPlaneCapabilitiesKHR_new,
};

static void PyvkCreateDisplayPlaneSurfaceKHR_del(PyvkCreateDisplayPlaneSurfaceKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkCreateDisplayPlaneSurfaceKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkCreateDisplayPlaneSurfaceKHR *self;
    self = (PyvkCreateDisplayPlaneSurfaceKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkCreateDisplayPlaneSurfaceKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* instance = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"instance","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &instance, &pCreateInfo)) return NULL;

    struct {

        VkInstance instance;

        VkDisplaySurfaceCreateInfoKHR* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.instance = PyCapsule_GetPointer(instance, "VkInstance");

    return_struct.pCreateInfo = (((PyVkDisplaySurfaceCreateInfoKHR*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkSurfaceKHR *value = malloc(sizeof(VkSurfaceKHR));
    if (raise(
                vkCreateDisplayPlaneSurfaceKHR(return_struct.instance,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkSurfaceKHR", NULL);

    return return_value;
}

static int
PyvkCreateDisplayPlaneSurfaceKHR_init(PyvkCreateDisplayPlaneSurfaceKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkCreateDisplayPlaneSurfaceKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkCreateDisplayPlaneSurfaceKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkCreateDisplayPlaneSurfaceKHR", sizeof(PyvkCreateDisplayPlaneSurfaceKHR), 0,
    (destructor)PyvkCreateDisplayPlaneSurfaceKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateDisplayPlaneSurfaceKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkCreateDisplayPlaneSurfaceKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkCreateDisplayPlaneSurfaceKHR_init,0,PyvkCreateDisplayPlaneSurfaceKHR_new,
};

static void PyvkCreateSharedSwapchainsKHR_del(PyvkCreateSharedSwapchainsKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkCreateSharedSwapchainsKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkCreateSharedSwapchainsKHR *self;
    self = (PyvkCreateSharedSwapchainsKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkCreateSharedSwapchainsKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* swapchainCount = NULL;
    PyObject* pCreateInfos = NULL;
    static char *kwlist[] = {"device","swapchainCount","pCreateInfos",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &swapchainCount, &pCreateInfos)) return NULL;

    struct {

        VkDevice device;

        uint32_t swapchainCount;

        VkSwapchainCreateInfoKHR* pCreateInfos;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");
    return_struct.swapchainCount = (uint32_t) PyLong_AsLong(swapchainCount);
    return_struct.pCreateInfos = (((PyVkSwapchainCreateInfoKHR*)pCreateInfos)->base);

    return_struct.pAllocator = NULL;

    VkSwapchainKHR *value = malloc(sizeof(VkSwapchainKHR));
    if (raise(
                vkCreateSharedSwapchainsKHR(return_struct.device,return_struct.swapchainCount,return_struct.pCreateInfos,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkSwapchainKHR", NULL);

    return return_value;
}

static int
PyvkCreateSharedSwapchainsKHR_init(PyvkCreateSharedSwapchainsKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkCreateSharedSwapchainsKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkCreateSharedSwapchainsKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkCreateSharedSwapchainsKHR", sizeof(PyvkCreateSharedSwapchainsKHR), 0,
    (destructor)PyvkCreateSharedSwapchainsKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateSharedSwapchainsKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkCreateSharedSwapchainsKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkCreateSharedSwapchainsKHR_init,0,PyvkCreateSharedSwapchainsKHR_new,
};

#ifdef VK_USE_PLATFORM_MIR_KHR

static void PyvkCreateMirSurfaceKHR_del(PyvkCreateMirSurfaceKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkCreateMirSurfaceKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkCreateMirSurfaceKHR *self;
    self = (PyvkCreateMirSurfaceKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

#ifdef VK_USE_PLATFORM_MIR_KHR

static PyObject* PyvkCreateMirSurfaceKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* instance = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"instance","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &instance, &pCreateInfo)) return NULL;

    struct {

        VkInstance instance;

        VkMirSurfaceCreateInfoKHR* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.instance = PyCapsule_GetPointer(instance, "VkInstance");

    return_struct.pCreateInfo = (((PyVkMirSurfaceCreateInfoKHR*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkSurfaceKHR *value = malloc(sizeof(VkSurfaceKHR));
    if (raise(
                vkCreateMirSurfaceKHR(return_struct.instance,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkSurfaceKHR", NULL);

    return return_value;
}

#endif

static int
PyvkCreateMirSurfaceKHR_init(PyvkCreateMirSurfaceKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkCreateMirSurfaceKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkCreateMirSurfaceKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkCreateMirSurfaceKHR", sizeof(PyvkCreateMirSurfaceKHR), 0,
    (destructor)PyvkCreateMirSurfaceKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateMirSurfaceKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkCreateMirSurfaceKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkCreateMirSurfaceKHR_init,0,PyvkCreateMirSurfaceKHR_new,
};

#endif

#ifdef VK_USE_PLATFORM_MIR_KHR

static void PyvkGetPhysicalDeviceMirPresentationSupportKHR_del(PyvkGetPhysicalDeviceMirPresentationSupportKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkGetPhysicalDeviceMirPresentationSupportKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkGetPhysicalDeviceMirPresentationSupportKHR *self;
    self = (PyvkGetPhysicalDeviceMirPresentationSupportKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

#ifdef VK_USE_PLATFORM_MIR_KHR

static PyObject* PyvkGetPhysicalDeviceMirPresentationSupportKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    PyObject* queueFamilyIndex = NULL;
    static char *kwlist[] = {"physicalDevice","queueFamilyIndex",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &physicalDevice, &queueFamilyIndex)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

        uint32_t queueFamilyIndex;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");
    return_struct.queueFamilyIndex = (uint32_t) PyLong_AsLong(queueFamilyIndex);
    MirConnection *value = malloc(sizeof(MirConnection));

    vkGetPhysicalDeviceMirPresentationSupportKHR(return_struct.physicalDevice,return_struct.queueFamilyIndex,value);
    PyObject* return_value = PyLong_FromLong(*value);

    return return_value;
}

#endif

static int
PyvkGetPhysicalDeviceMirPresentationSupportKHR_init(PyvkGetPhysicalDeviceMirPresentationSupportKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkGetPhysicalDeviceMirPresentationSupportKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkGetPhysicalDeviceMirPresentationSupportKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkGetPhysicalDeviceMirPresentationSupportKHR", sizeof(PyvkGetPhysicalDeviceMirPresentationSupportKHR), 0,
    (destructor)PyvkGetPhysicalDeviceMirPresentationSupportKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceMirPresentationSupportKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkGetPhysicalDeviceMirPresentationSupportKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceMirPresentationSupportKHR_init,0,PyvkGetPhysicalDeviceMirPresentationSupportKHR_new,
};

#endif

static void PyvkDestroySurfaceKHR_del(PyvkDestroySurfaceKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkDestroySurfaceKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkDestroySurfaceKHR *self;
    self = (PyvkDestroySurfaceKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkDestroySurfaceKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* instance = NULL;
    PyObject* surface = NULL;
    static char *kwlist[] = {"instance","surface",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &instance, &surface)) return NULL;

    struct {

        VkInstance instance;

        VkSurfaceKHR surface;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.instance = PyCapsule_GetPointer(instance, "VkInstance");

    return_struct.surface = PyCapsule_GetPointer(surface, "VkSurfaceKHR");

    return_struct.pAllocator = NULL;

    vkDestroySurfaceKHR(return_struct.instance,return_struct.surface,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static int
PyvkDestroySurfaceKHR_init(PyvkDestroySurfaceKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkDestroySurfaceKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkDestroySurfaceKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkDestroySurfaceKHR", sizeof(PyvkDestroySurfaceKHR), 0,
    (destructor)PyvkDestroySurfaceKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkDestroySurfaceKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkDestroySurfaceKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkDestroySurfaceKHR_init,0,PyvkDestroySurfaceKHR_new,
};

static void PyvkGetPhysicalDeviceSurfaceSupportKHR_del(PyvkGetPhysicalDeviceSurfaceSupportKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkGetPhysicalDeviceSurfaceSupportKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkGetPhysicalDeviceSurfaceSupportKHR *self;
    self = (PyvkGetPhysicalDeviceSurfaceSupportKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkGetPhysicalDeviceSurfaceSupportKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    PyObject* queueFamilyIndex = NULL;
    PyObject* surface = NULL;
    static char *kwlist[] = {"physicalDevice","queueFamilyIndex","surface",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &physicalDevice, &queueFamilyIndex, &surface)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

        uint32_t queueFamilyIndex;

        VkSurfaceKHR surface;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");
    return_struct.queueFamilyIndex = (uint32_t) PyLong_AsLong(queueFamilyIndex);
    return_struct.surface = PyCapsule_GetPointer(surface, "VkSurfaceKHR");

    VkBool32 *value = malloc(sizeof(VkBool32));
    if (raise(
                vkGetPhysicalDeviceSurfaceSupportKHR(return_struct.physicalDevice,return_struct.queueFamilyIndex,return_struct.surface,value))) return NULL;
    PyObject* return_value = PyLong_FromLong(*value);

    return return_value;
}

static int
PyvkGetPhysicalDeviceSurfaceSupportKHR_init(PyvkGetPhysicalDeviceSurfaceSupportKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkGetPhysicalDeviceSurfaceSupportKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkGetPhysicalDeviceSurfaceSupportKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkGetPhysicalDeviceSurfaceSupportKHR", sizeof(PyvkGetPhysicalDeviceSurfaceSupportKHR), 0,
    (destructor)PyvkGetPhysicalDeviceSurfaceSupportKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceSurfaceSupportKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkGetPhysicalDeviceSurfaceSupportKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceSurfaceSupportKHR_init,0,PyvkGetPhysicalDeviceSurfaceSupportKHR_new,
};

static void PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR_del(PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR *self;
    self = (PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    PyObject* surface = NULL;
    static char *kwlist[] = {"physicalDevice","surface",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &physicalDevice, &surface)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

        VkSurfaceKHR surface;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    return_struct.surface = PyCapsule_GetPointer(surface, "VkSurfaceKHR");

    VkSurfaceCapabilitiesKHR *value = malloc(sizeof(VkSurfaceCapabilitiesKHR));
    if (raise(
                vkGetPhysicalDeviceSurfaceCapabilitiesKHR(return_struct.physicalDevice,return_struct.surface,value))) return NULL;
    PyObject* return_value =
        PyObject_Call((PyObject *)&PyVkSurfaceCapabilitiesKHRType,NULL, NULL);
    memcpy(((PyVkSurfaceCapabilitiesKHR*)return_value)->base,
           value, sizeof(VkSurfaceCapabilitiesKHR));

    return return_value;
}

static int
PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR_init(PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkGetPhysicalDeviceSurfaceCapabilitiesKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkGetPhysicalDeviceSurfaceCapabilitiesKHR", sizeof(PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR), 0,
    (destructor)PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkGetPhysicalDeviceSurfaceCapabilitiesKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR_init,0,PyvkGetPhysicalDeviceSurfaceCapabilitiesKHR_new,
};

static void PyvkGetPhysicalDeviceSurfaceFormatsKHR_del(PyvkGetPhysicalDeviceSurfaceFormatsKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkGetPhysicalDeviceSurfaceFormatsKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkGetPhysicalDeviceSurfaceFormatsKHR *self;
    self = (PyvkGetPhysicalDeviceSurfaceFormatsKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkGetPhysicalDeviceSurfaceFormatsKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    PyObject* surface = NULL;
    static char *kwlist[] = {"physicalDevice","surface",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &physicalDevice, &surface)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

        VkSurfaceKHR surface;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    return_struct.surface = PyCapsule_GetPointer(surface, "VkSurfaceKHR");

    uint32_t count;
    if (raise(
                vkGetPhysicalDeviceSurfaceFormatsKHR(return_struct.physicalDevice,return_struct.surface,&count, NULL))) return NULL;
    VkSurfaceFormatKHR *values = malloc(count*sizeof(VkSurfaceFormatKHR));
    if (raise(
                vkGetPhysicalDeviceSurfaceFormatsKHR(return_struct.physicalDevice,return_struct.surface,&count, values))) return NULL;
    PyObject* return_value = PyList_New(0);
    uint32_t i;
    for (i=0; i<count; i++) {

        PyObject* pyreturn = PyObject_Call((PyObject *)&PyVkSurfaceFormatKHRType,
                                           NULL, NULL);
        memcpy(((PyVkSurfaceFormatKHR*)pyreturn)->base,
               values + i, sizeof(VkSurfaceFormatKHR));

        PyList_Append(return_value, pyreturn);
    }

    return return_value;
}

static int
PyvkGetPhysicalDeviceSurfaceFormatsKHR_init(PyvkGetPhysicalDeviceSurfaceFormatsKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkGetPhysicalDeviceSurfaceFormatsKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkGetPhysicalDeviceSurfaceFormatsKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkGetPhysicalDeviceSurfaceFormatsKHR", sizeof(PyvkGetPhysicalDeviceSurfaceFormatsKHR), 0,
    (destructor)PyvkGetPhysicalDeviceSurfaceFormatsKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceSurfaceFormatsKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkGetPhysicalDeviceSurfaceFormatsKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceSurfaceFormatsKHR_init,0,PyvkGetPhysicalDeviceSurfaceFormatsKHR_new,
};

static void PyvkGetPhysicalDeviceSurfacePresentModesKHR_del(PyvkGetPhysicalDeviceSurfacePresentModesKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkGetPhysicalDeviceSurfacePresentModesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkGetPhysicalDeviceSurfacePresentModesKHR *self;
    self = (PyvkGetPhysicalDeviceSurfacePresentModesKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkGetPhysicalDeviceSurfacePresentModesKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    PyObject* surface = NULL;
    static char *kwlist[] = {"physicalDevice","surface",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &physicalDevice, &surface)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

        VkSurfaceKHR surface;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    return_struct.surface = PyCapsule_GetPointer(surface, "VkSurfaceKHR");

    uint32_t count;
    if (raise(
                vkGetPhysicalDeviceSurfacePresentModesKHR(return_struct.physicalDevice,return_struct.surface,&count, NULL))) return NULL;
    VkPresentModeKHR *values = malloc(count*sizeof(VkPresentModeKHR));
    if (raise(
                vkGetPhysicalDeviceSurfacePresentModesKHR(return_struct.physicalDevice,return_struct.surface,&count, values))) return NULL;
    PyObject* return_value = PyList_New(0);
    uint32_t i;
    for (i=0; i<count; i++) {

        PyObject* pyreturn =
            PyLong_FromLong((long) values + i*sizeof(VkPresentModeKHR));

        PyList_Append(return_value, pyreturn);
    }

    return return_value;
}

static int
PyvkGetPhysicalDeviceSurfacePresentModesKHR_init(PyvkGetPhysicalDeviceSurfacePresentModesKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkGetPhysicalDeviceSurfacePresentModesKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkGetPhysicalDeviceSurfacePresentModesKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkGetPhysicalDeviceSurfacePresentModesKHR", sizeof(PyvkGetPhysicalDeviceSurfacePresentModesKHR), 0,
    (destructor)PyvkGetPhysicalDeviceSurfacePresentModesKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceSurfacePresentModesKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkGetPhysicalDeviceSurfacePresentModesKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceSurfacePresentModesKHR_init,0,PyvkGetPhysicalDeviceSurfacePresentModesKHR_new,
};

static void PyvkCreateSwapchainKHR_del(PyvkCreateSwapchainKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkCreateSwapchainKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkCreateSwapchainKHR *self;
    self = (PyvkCreateSwapchainKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkCreateSwapchainKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"device","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pCreateInfo)) return NULL;

    struct {

        VkDevice device;

        VkSwapchainCreateInfoKHR* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pCreateInfo = (((PyVkSwapchainCreateInfoKHR*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkSwapchainKHR *value = malloc(sizeof(VkSwapchainKHR));
    if (raise(
                vkCreateSwapchainKHR(return_struct.device,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkSwapchainKHR", NULL);

    return return_value;
}

static int
PyvkCreateSwapchainKHR_init(PyvkCreateSwapchainKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkCreateSwapchainKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkCreateSwapchainKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkCreateSwapchainKHR", sizeof(PyvkCreateSwapchainKHR), 0,
    (destructor)PyvkCreateSwapchainKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateSwapchainKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkCreateSwapchainKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkCreateSwapchainKHR_init,0,PyvkCreateSwapchainKHR_new,
};

static void PyvkDestroySwapchainKHR_del(PyvkDestroySwapchainKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkDestroySwapchainKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkDestroySwapchainKHR *self;
    self = (PyvkDestroySwapchainKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkDestroySwapchainKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* swapchain = NULL;
    static char *kwlist[] = {"device","swapchain",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &swapchain)) return NULL;

    struct {

        VkDevice device;

        VkSwapchainKHR swapchain;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.swapchain = PyCapsule_GetPointer(swapchain, "VkSwapchainKHR");

    return_struct.pAllocator = NULL;

    vkDestroySwapchainKHR(return_struct.device,return_struct.swapchain,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static int
PyvkDestroySwapchainKHR_init(PyvkDestroySwapchainKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkDestroySwapchainKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkDestroySwapchainKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkDestroySwapchainKHR", sizeof(PyvkDestroySwapchainKHR), 0,
    (destructor)PyvkDestroySwapchainKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkDestroySwapchainKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkDestroySwapchainKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkDestroySwapchainKHR_init,0,PyvkDestroySwapchainKHR_new,
};

static void PyvkGetSwapchainImagesKHR_del(PyvkGetSwapchainImagesKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkGetSwapchainImagesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkGetSwapchainImagesKHR *self;
    self = (PyvkGetSwapchainImagesKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkGetSwapchainImagesKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* swapchain = NULL;
    static char *kwlist[] = {"device","swapchain",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &swapchain)) return NULL;

    struct {

        VkDevice device;

        VkSwapchainKHR swapchain;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.swapchain = PyCapsule_GetPointer(swapchain, "VkSwapchainKHR");

    uint32_t count;
    if (raise(
                vkGetSwapchainImagesKHR(return_struct.device,return_struct.swapchain,&count, NULL))) return NULL;
    VkImage *values = malloc(count*sizeof(VkImage));
    if (raise(
                vkGetSwapchainImagesKHR(return_struct.device,return_struct.swapchain,&count, values))) return NULL;
    PyObject* return_value = PyList_New(0);
    uint32_t i;
    for (i=0; i<count; i++) {

        PyObject* pyreturn = PyCapsule_New(values + i*sizeof(VkImage)
                                           , "VkImage", NULL);

        PyList_Append(return_value, pyreturn);
    }

    return return_value;
}

static int
PyvkGetSwapchainImagesKHR_init(PyvkGetSwapchainImagesKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkGetSwapchainImagesKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkGetSwapchainImagesKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkGetSwapchainImagesKHR", sizeof(PyvkGetSwapchainImagesKHR), 0,
    (destructor)PyvkGetSwapchainImagesKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetSwapchainImagesKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkGetSwapchainImagesKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkGetSwapchainImagesKHR_init,0,PyvkGetSwapchainImagesKHR_new,
};

static void PyvkAcquireNextImageKHR_del(PyvkAcquireNextImageKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkAcquireNextImageKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkAcquireNextImageKHR *self;
    self = (PyvkAcquireNextImageKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkAcquireNextImageKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* swapchain = NULL;
    PyObject* timeout = NULL;
    PyObject* semaphore = NULL;
    PyObject* fence = NULL;
    PyObject* pImageIndex = NULL;
    static char *kwlist[] = {"device","swapchain","timeout","semaphore","fence","pImageIndex",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &device, &swapchain, &timeout, &semaphore, &fence, &pImageIndex)) return NULL;

    struct {

        VkDevice device;

        VkSwapchainKHR swapchain;

        uint64_t timeout;

        VkSemaphore semaphore;

        VkFence fence;

        uint32_t* pImageIndex;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.swapchain = PyCapsule_GetPointer(swapchain, "VkSwapchainKHR");
    return_struct.timeout = (uint64_t) PyLong_AsLong(timeout);
    return_struct.semaphore = PyCapsule_GetPointer(semaphore, "VkSemaphore");

    return_struct.fence = PyCapsule_GetPointer(fence, "VkFence");

    vkAcquireNextImageKHR(return_struct.device,return_struct.swapchain,return_struct.timeout,return_struct.semaphore,return_struct.fence,return_struct.pImageIndex);
    PyObject* return_value = Py_None;

    return return_value;
}

static int
PyvkAcquireNextImageKHR_init(PyvkAcquireNextImageKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkAcquireNextImageKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkAcquireNextImageKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkAcquireNextImageKHR", sizeof(PyvkAcquireNextImageKHR), 0,
    (destructor)PyvkAcquireNextImageKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkAcquireNextImageKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkAcquireNextImageKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkAcquireNextImageKHR_init,0,PyvkAcquireNextImageKHR_new,
};

static void PyvkQueuePresentKHR_del(PyvkQueuePresentKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkQueuePresentKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkQueuePresentKHR *self;
    self = (PyvkQueuePresentKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkQueuePresentKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* queue = NULL;
    PyObject* pPresentInfo = NULL;
    static char *kwlist[] = {"queue","pPresentInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &queue, &pPresentInfo)) return NULL;

    struct {

        VkQueue queue;

        VkPresentInfoKHR* pPresentInfo;

    } return_struct = {};

    return_struct.queue = PyCapsule_GetPointer(queue, "VkQueue");

    return_struct.pPresentInfo = (((PyVkPresentInfoKHR*)pPresentInfo)->base);

    vkQueuePresentKHR(return_struct.queue,return_struct.pPresentInfo);
    PyObject* return_value = Py_None;

    return return_value;
}

static int
PyvkQueuePresentKHR_init(PyvkQueuePresentKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkQueuePresentKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkQueuePresentKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkQueuePresentKHR", sizeof(PyvkQueuePresentKHR), 0,
    (destructor)PyvkQueuePresentKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkQueuePresentKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkQueuePresentKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkQueuePresentKHR_init,0,PyvkQueuePresentKHR_new,
};

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

static void PyvkCreateWaylandSurfaceKHR_del(PyvkCreateWaylandSurfaceKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkCreateWaylandSurfaceKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkCreateWaylandSurfaceKHR *self;
    self = (PyvkCreateWaylandSurfaceKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

static PyObject* PyvkCreateWaylandSurfaceKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* instance = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"instance","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &instance, &pCreateInfo)) return NULL;

    struct {

        VkInstance instance;

        VkWaylandSurfaceCreateInfoKHR* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.instance = PyCapsule_GetPointer(instance, "VkInstance");

    return_struct.pCreateInfo = (((PyVkWaylandSurfaceCreateInfoKHR*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkSurfaceKHR *value = malloc(sizeof(VkSurfaceKHR));
    if (raise(
                vkCreateWaylandSurfaceKHR(return_struct.instance,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkSurfaceKHR", NULL);

    return return_value;
}

#endif

static int
PyvkCreateWaylandSurfaceKHR_init(PyvkCreateWaylandSurfaceKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkCreateWaylandSurfaceKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkCreateWaylandSurfaceKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkCreateWaylandSurfaceKHR", sizeof(PyvkCreateWaylandSurfaceKHR), 0,
    (destructor)PyvkCreateWaylandSurfaceKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateWaylandSurfaceKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkCreateWaylandSurfaceKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkCreateWaylandSurfaceKHR_init,0,PyvkCreateWaylandSurfaceKHR_new,
};

#endif

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

static void PyvkGetPhysicalDeviceWaylandPresentationSupportKHR_del(PyvkGetPhysicalDeviceWaylandPresentationSupportKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkGetPhysicalDeviceWaylandPresentationSupportKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkGetPhysicalDeviceWaylandPresentationSupportKHR *self;
    self = (PyvkGetPhysicalDeviceWaylandPresentationSupportKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

static PyObject* PyvkGetPhysicalDeviceWaylandPresentationSupportKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    PyObject* queueFamilyIndex = NULL;
    static char *kwlist[] = {"physicalDevice","queueFamilyIndex",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &physicalDevice, &queueFamilyIndex)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

        uint32_t queueFamilyIndex;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");
    return_struct.queueFamilyIndex = (uint32_t) PyLong_AsLong(queueFamilyIndex);
    wl_display *value = malloc(sizeof(wl_display));

    vkGetPhysicalDeviceWaylandPresentationSupportKHR(return_struct.physicalDevice,return_struct.queueFamilyIndex,value);
    PyObject* return_value = PyLong_FromLong(*value);

    return return_value;
}

#endif

static int
PyvkGetPhysicalDeviceWaylandPresentationSupportKHR_init(PyvkGetPhysicalDeviceWaylandPresentationSupportKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkGetPhysicalDeviceWaylandPresentationSupportKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkGetPhysicalDeviceWaylandPresentationSupportKHR", sizeof(PyvkGetPhysicalDeviceWaylandPresentationSupportKHR), 0,
    (destructor)PyvkGetPhysicalDeviceWaylandPresentationSupportKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceWaylandPresentationSupportKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkGetPhysicalDeviceWaylandPresentationSupportKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceWaylandPresentationSupportKHR_init,0,PyvkGetPhysicalDeviceWaylandPresentationSupportKHR_new,
};

#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

static void PyvkCreateWin32SurfaceKHR_del(PyvkCreateWin32SurfaceKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkCreateWin32SurfaceKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkCreateWin32SurfaceKHR *self;
    self = (PyvkCreateWin32SurfaceKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR

static PyObject* PyvkCreateWin32SurfaceKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* instance = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"instance","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &instance, &pCreateInfo)) return NULL;

    struct {

        VkInstance instance;

        VkWin32SurfaceCreateInfoKHR* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.instance = PyCapsule_GetPointer(instance, "VkInstance");

    return_struct.pCreateInfo = (((PyVkWin32SurfaceCreateInfoKHR*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkSurfaceKHR *value = malloc(sizeof(VkSurfaceKHR));
    if (raise(
                vkCreateWin32SurfaceKHR(return_struct.instance,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkSurfaceKHR", NULL);

    return return_value;
}

#endif

static int
PyvkCreateWin32SurfaceKHR_init(PyvkCreateWin32SurfaceKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkCreateWin32SurfaceKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkCreateWin32SurfaceKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkCreateWin32SurfaceKHR", sizeof(PyvkCreateWin32SurfaceKHR), 0,
    (destructor)PyvkCreateWin32SurfaceKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateWin32SurfaceKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkCreateWin32SurfaceKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkCreateWin32SurfaceKHR_init,0,PyvkCreateWin32SurfaceKHR_new,
};

#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

static void PyvkGetPhysicalDeviceWin32PresentationSupportKHR_del(PyvkGetPhysicalDeviceWin32PresentationSupportKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkGetPhysicalDeviceWin32PresentationSupportKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkGetPhysicalDeviceWin32PresentationSupportKHR *self;
    self = (PyvkGetPhysicalDeviceWin32PresentationSupportKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR

static PyObject* PyvkGetPhysicalDeviceWin32PresentationSupportKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    static char *kwlist[] = {"physicalDevice",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &physicalDevice)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    uint32_t *value = malloc(sizeof(uint32_t));

    vkGetPhysicalDeviceWin32PresentationSupportKHR(return_struct.physicalDevice,value);
    PyObject* return_value = PyLong_FromLong(*value);

    return return_value;
}

#endif

static int
PyvkGetPhysicalDeviceWin32PresentationSupportKHR_init(PyvkGetPhysicalDeviceWin32PresentationSupportKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkGetPhysicalDeviceWin32PresentationSupportKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkGetPhysicalDeviceWin32PresentationSupportKHR", sizeof(PyvkGetPhysicalDeviceWin32PresentationSupportKHR), 0,
    (destructor)PyvkGetPhysicalDeviceWin32PresentationSupportKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceWin32PresentationSupportKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkGetPhysicalDeviceWin32PresentationSupportKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceWin32PresentationSupportKHR_init,0,PyvkGetPhysicalDeviceWin32PresentationSupportKHR_new,
};

#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR

static void PyvkCreateXlibSurfaceKHR_del(PyvkCreateXlibSurfaceKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkCreateXlibSurfaceKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkCreateXlibSurfaceKHR *self;
    self = (PyvkCreateXlibSurfaceKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

#ifdef VK_USE_PLATFORM_XLIB_KHR

static PyObject* PyvkCreateXlibSurfaceKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* instance = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"instance","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &instance, &pCreateInfo)) return NULL;

    struct {

        VkInstance instance;

        VkXlibSurfaceCreateInfoKHR* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.instance = PyCapsule_GetPointer(instance, "VkInstance");

    return_struct.pCreateInfo = (((PyVkXlibSurfaceCreateInfoKHR*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkSurfaceKHR *value = malloc(sizeof(VkSurfaceKHR));
    if (raise(
                vkCreateXlibSurfaceKHR(return_struct.instance,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkSurfaceKHR", NULL);

    return return_value;
}

#endif

static int
PyvkCreateXlibSurfaceKHR_init(PyvkCreateXlibSurfaceKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkCreateXlibSurfaceKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkCreateXlibSurfaceKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkCreateXlibSurfaceKHR", sizeof(PyvkCreateXlibSurfaceKHR), 0,
    (destructor)PyvkCreateXlibSurfaceKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateXlibSurfaceKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkCreateXlibSurfaceKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkCreateXlibSurfaceKHR_init,0,PyvkCreateXlibSurfaceKHR_new,
};

#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR

static void PyvkGetPhysicalDeviceXlibPresentationSupportKHR_del(PyvkGetPhysicalDeviceXlibPresentationSupportKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkGetPhysicalDeviceXlibPresentationSupportKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkGetPhysicalDeviceXlibPresentationSupportKHR *self;
    self = (PyvkGetPhysicalDeviceXlibPresentationSupportKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

#ifdef VK_USE_PLATFORM_XLIB_KHR

static PyObject* PyvkGetPhysicalDeviceXlibPresentationSupportKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    PyObject* queueFamilyIndex = NULL;
    PyObject* dpy = NULL;
    PyObject* visualID = NULL;
    static char *kwlist[] = {"physicalDevice","queueFamilyIndex","dpy","visualID",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &physicalDevice, &queueFamilyIndex, &dpy, &visualID)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

        uint32_t queueFamilyIndex;

        Display* dpy;

        VisualID visualID;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");
    return_struct.queueFamilyIndex = (uint32_t) PyLong_AsLong(queueFamilyIndex);
    return_struct.dpy = (Display *) PyLong_AsLong(dpy);
    vkGetPhysicalDeviceXlibPresentationSupportKHR(return_struct.physicalDevice,return_struct.queueFamilyIndex,return_struct.dpy,return_struct.visualID);
    PyObject* return_value = Py_None;

    return return_value;
}

#endif

static int
PyvkGetPhysicalDeviceXlibPresentationSupportKHR_init(PyvkGetPhysicalDeviceXlibPresentationSupportKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkGetPhysicalDeviceXlibPresentationSupportKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkGetPhysicalDeviceXlibPresentationSupportKHR", sizeof(PyvkGetPhysicalDeviceXlibPresentationSupportKHR), 0,
    (destructor)PyvkGetPhysicalDeviceXlibPresentationSupportKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceXlibPresentationSupportKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkGetPhysicalDeviceXlibPresentationSupportKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceXlibPresentationSupportKHR_init,0,PyvkGetPhysicalDeviceXlibPresentationSupportKHR_new,
};

#endif

#ifdef VK_USE_PLATFORM_XCB_KHR

static void PyvkCreateXcbSurfaceKHR_del(PyvkCreateXcbSurfaceKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkCreateXcbSurfaceKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkCreateXcbSurfaceKHR *self;
    self = (PyvkCreateXcbSurfaceKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

#ifdef VK_USE_PLATFORM_XCB_KHR

static PyObject* PyvkCreateXcbSurfaceKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* instance = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"instance","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &instance, &pCreateInfo)) return NULL;

    struct {

        VkInstance instance;

        VkXcbSurfaceCreateInfoKHR* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.instance = PyCapsule_GetPointer(instance, "VkInstance");

    return_struct.pCreateInfo = (((PyVkXcbSurfaceCreateInfoKHR*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkSurfaceKHR *value = malloc(sizeof(VkSurfaceKHR));
    if (raise(
                vkCreateXcbSurfaceKHR(return_struct.instance,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkSurfaceKHR", NULL);

    return return_value;
}

#endif

static int
PyvkCreateXcbSurfaceKHR_init(PyvkCreateXcbSurfaceKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkCreateXcbSurfaceKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkCreateXcbSurfaceKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkCreateXcbSurfaceKHR", sizeof(PyvkCreateXcbSurfaceKHR), 0,
    (destructor)PyvkCreateXcbSurfaceKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateXcbSurfaceKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkCreateXcbSurfaceKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkCreateXcbSurfaceKHR_init,0,PyvkCreateXcbSurfaceKHR_new,
};

#endif

#ifdef VK_USE_PLATFORM_XCB_KHR

static void PyvkGetPhysicalDeviceXcbPresentationSupportKHR_del(PyvkGetPhysicalDeviceXcbPresentationSupportKHR* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkGetPhysicalDeviceXcbPresentationSupportKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkGetPhysicalDeviceXcbPresentationSupportKHR *self;
    self = (PyvkGetPhysicalDeviceXcbPresentationSupportKHR *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

#ifdef VK_USE_PLATFORM_XCB_KHR

static PyObject* PyvkGetPhysicalDeviceXcbPresentationSupportKHR_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    PyObject* queueFamilyIndex = NULL;
    PyObject* connection = NULL;
    static char *kwlist[] = {"physicalDevice","queueFamilyIndex","connection",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &physicalDevice, &queueFamilyIndex, &connection)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

        uint32_t queueFamilyIndex;

        xcb_connection_t* connection;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");
    return_struct.queueFamilyIndex = (uint32_t) PyLong_AsLong(queueFamilyIndex);
    xcb_visualid_t *value = malloc(sizeof(xcb_visualid_t));

    vkGetPhysicalDeviceXcbPresentationSupportKHR(return_struct.physicalDevice,return_struct.queueFamilyIndex,return_struct.connection,value);
    PyObject* return_value = PyLong_FromLong(*value);

    return return_value;
}

#endif

static int
PyvkGetPhysicalDeviceXcbPresentationSupportKHR_init(PyvkGetPhysicalDeviceXcbPresentationSupportKHR *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkGetPhysicalDeviceXcbPresentationSupportKHRType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkGetPhysicalDeviceXcbPresentationSupportKHR", sizeof(PyvkGetPhysicalDeviceXcbPresentationSupportKHR), 0,
    (destructor)PyvkGetPhysicalDeviceXcbPresentationSupportKHR_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceXcbPresentationSupportKHR_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkGetPhysicalDeviceXcbPresentationSupportKHR object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceXcbPresentationSupportKHR_init,0,PyvkGetPhysicalDeviceXcbPresentationSupportKHR_new,
};

#endif

static void PyvkCreateDebugReportCallbackEXT_del(PyvkCreateDebugReportCallbackEXT* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkCreateDebugReportCallbackEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkCreateDebugReportCallbackEXT *self;
    self = (PyvkCreateDebugReportCallbackEXT *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkCreateDebugReportCallbackEXT_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* instance = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"instance","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &instance, &pCreateInfo)) return NULL;

    struct {

        VkInstance instance;

        VkDebugReportCallbackCreateInfoEXT* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.instance = PyCapsule_GetPointer(instance, "VkInstance");

    return_struct.pCreateInfo = (((PyVkDebugReportCallbackCreateInfoEXT*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkDebugReportCallbackEXT *value = malloc(sizeof(VkDebugReportCallbackEXT));
    if (raise(
                vkCreateDebugReportCallbackEXT(return_struct.instance,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkDebugReportCallbackEXT", NULL);

    return return_value;
}

static int
PyvkCreateDebugReportCallbackEXT_init(PyvkCreateDebugReportCallbackEXT *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkCreateDebugReportCallbackEXT) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkCreateDebugReportCallbackEXTType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkCreateDebugReportCallbackEXT", sizeof(PyvkCreateDebugReportCallbackEXT), 0,
    (destructor)PyvkCreateDebugReportCallbackEXT_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCreateDebugReportCallbackEXT_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkCreateDebugReportCallbackEXT object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkCreateDebugReportCallbackEXT_init,0,PyvkCreateDebugReportCallbackEXT_new,
};

static void PyvkDestroyDebugReportCallbackEXT_del(PyvkDestroyDebugReportCallbackEXT* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkDestroyDebugReportCallbackEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkDestroyDebugReportCallbackEXT *self;
    self = (PyvkDestroyDebugReportCallbackEXT *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkDestroyDebugReportCallbackEXT_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* instance = NULL;
    PyObject* callback = NULL;
    static char *kwlist[] = {"instance","callback",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &instance, &callback)) return NULL;

    struct {

        VkInstance instance;

        VkDebugReportCallbackEXT callback;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.instance = PyCapsule_GetPointer(instance, "VkInstance");

    return_struct.callback = PyCapsule_GetPointer(callback, "VkDebugReportCallbackEXT");

    return_struct.pAllocator = NULL;

    vkDestroyDebugReportCallbackEXT(return_struct.instance,return_struct.callback,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static int
PyvkDestroyDebugReportCallbackEXT_init(PyvkDestroyDebugReportCallbackEXT *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkDestroyDebugReportCallbackEXT) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkDestroyDebugReportCallbackEXTType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkDestroyDebugReportCallbackEXT", sizeof(PyvkDestroyDebugReportCallbackEXT), 0,
    (destructor)PyvkDestroyDebugReportCallbackEXT_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkDestroyDebugReportCallbackEXT_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkDestroyDebugReportCallbackEXT object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkDestroyDebugReportCallbackEXT_init,0,PyvkDestroyDebugReportCallbackEXT_new,
};

static void PyvkDebugReportMessageEXT_del(PyvkDebugReportMessageEXT* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkDebugReportMessageEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkDebugReportMessageEXT *self;
    self = (PyvkDebugReportMessageEXT *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkDebugReportMessageEXT_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* instance = NULL;
    PyObject* flags = NULL;
    PyObject* objectType = NULL;
    PyObject* object = NULL;
    PyObject* location = NULL;
    PyObject* messageCode = NULL;
    PyObject* pLayerPrefix = NULL;
    PyObject* pMessage = NULL;
    static char *kwlist[] = {"instance","flags","objectType","object","location","messageCode","pLayerPrefix","pMessage",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOO", kwlist, &instance, &flags, &objectType, &object, &location, &messageCode, &pLayerPrefix, &pMessage)) return NULL;

    struct {

        VkInstance instance;

        VkDebugReportFlagsEXT flags;

        VkDebugReportObjectTypeEXT objectType;

        uint64_t object;

        size_t location;

        int32_t messageCode;

        char* pLayerPrefix;

        char* pMessage;

    } return_struct = {};

    return_struct.instance = PyCapsule_GetPointer(instance, "VkInstance");

    return_struct.flags = PyLong_AsLong(flags);

    return_struct.objectType = PyLong_AsLong(objectType);
    return_struct.object = (uint64_t) PyLong_AsLong(object);
    return_struct.location = (size_t) PyLong_AsLong(location);
    return_struct.messageCode = (int32_t) PyLong_AsLong(messageCode);
    if (pLayerPrefix == Py_None) {
        return_struct.pLayerPrefix = NULL;
    }
    else {
        PyObject * tmp79291514 = PyUnicode_AsASCIIString(pLayerPrefix);
        char* tmp65605375 = PyBytes_AsString(tmp79291514);
        char* tmp50506552 = strdup(tmp65605375);
        return_struct.pLayerPrefix = tmp50506552;
        Py_DECREF(tmp79291514);
    }

    if (pMessage == Py_None) {
        return_struct.pMessage = NULL;
    }
    else {
        PyObject * tmp52012845 = PyUnicode_AsASCIIString(pMessage);
        char* tmp75999200 = PyBytes_AsString(tmp52012845);
        char* tmp57966201 = strdup(tmp75999200);
        return_struct.pMessage = tmp57966201;
        Py_DECREF(tmp52012845);
    }

    vkDebugReportMessageEXT(return_struct.instance,return_struct.flags,return_struct.objectType,return_struct.object,return_struct.location,return_struct.messageCode,return_struct.pLayerPrefix,return_struct.pMessage);
    PyObject* return_value = Py_None;

    return return_value;
}

static int
PyvkDebugReportMessageEXT_init(PyvkDebugReportMessageEXT *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkDebugReportMessageEXT) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkDebugReportMessageEXTType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkDebugReportMessageEXT", sizeof(PyvkDebugReportMessageEXT), 0,
    (destructor)PyvkDebugReportMessageEXT_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkDebugReportMessageEXT_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkDebugReportMessageEXT object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkDebugReportMessageEXT_init,0,PyvkDebugReportMessageEXT_new,
};

static void PyvkDebugMarkerSetObjectNameEXT_del(PyvkDebugMarkerSetObjectNameEXT* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkDebugMarkerSetObjectNameEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkDebugMarkerSetObjectNameEXT *self;
    self = (PyvkDebugMarkerSetObjectNameEXT *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkDebugMarkerSetObjectNameEXT_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pNameInfo = NULL;
    static char *kwlist[] = {"device","pNameInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pNameInfo)) return NULL;

    struct {

        VkDevice device;

        VkDebugMarkerObjectNameInfoEXT* pNameInfo;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pNameInfo = (((PyVkDebugMarkerObjectNameInfoEXT*)pNameInfo)->base);

    vkDebugMarkerSetObjectNameEXT(return_struct.device,return_struct.pNameInfo);
    PyObject* return_value = Py_None;

    return return_value;
}

static int
PyvkDebugMarkerSetObjectNameEXT_init(PyvkDebugMarkerSetObjectNameEXT *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkDebugMarkerSetObjectNameEXT) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkDebugMarkerSetObjectNameEXTType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkDebugMarkerSetObjectNameEXT", sizeof(PyvkDebugMarkerSetObjectNameEXT), 0,
    (destructor)PyvkDebugMarkerSetObjectNameEXT_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkDebugMarkerSetObjectNameEXT_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkDebugMarkerSetObjectNameEXT object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkDebugMarkerSetObjectNameEXT_init,0,PyvkDebugMarkerSetObjectNameEXT_new,
};

static void PyvkDebugMarkerSetObjectTagEXT_del(PyvkDebugMarkerSetObjectTagEXT* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkDebugMarkerSetObjectTagEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkDebugMarkerSetObjectTagEXT *self;
    self = (PyvkDebugMarkerSetObjectTagEXT *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkDebugMarkerSetObjectTagEXT_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pTagInfo = NULL;
    static char *kwlist[] = {"device","pTagInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pTagInfo)) return NULL;

    struct {

        VkDevice device;

        VkDebugMarkerObjectTagInfoEXT* pTagInfo;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pTagInfo = (((PyVkDebugMarkerObjectTagInfoEXT*)pTagInfo)->base);

    vkDebugMarkerSetObjectTagEXT(return_struct.device,return_struct.pTagInfo);
    PyObject* return_value = Py_None;

    return return_value;
}

static int
PyvkDebugMarkerSetObjectTagEXT_init(PyvkDebugMarkerSetObjectTagEXT *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkDebugMarkerSetObjectTagEXT) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkDebugMarkerSetObjectTagEXTType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkDebugMarkerSetObjectTagEXT", sizeof(PyvkDebugMarkerSetObjectTagEXT), 0,
    (destructor)PyvkDebugMarkerSetObjectTagEXT_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkDebugMarkerSetObjectTagEXT_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkDebugMarkerSetObjectTagEXT object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkDebugMarkerSetObjectTagEXT_init,0,PyvkDebugMarkerSetObjectTagEXT_new,
};

static void PyvkCmdDebugMarkerBeginEXT_del(PyvkCmdDebugMarkerBeginEXT* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkCmdDebugMarkerBeginEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkCmdDebugMarkerBeginEXT *self;
    self = (PyvkCmdDebugMarkerBeginEXT *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkCmdDebugMarkerBeginEXT_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* pMarkerInfo = NULL;
    static char *kwlist[] = {"commandBuffer","pMarkerInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &commandBuffer, &pMarkerInfo)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkDebugMarkerMarkerInfoEXT* pMarkerInfo;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.pMarkerInfo = (((PyVkDebugMarkerMarkerInfoEXT*)pMarkerInfo)->base);

    vkCmdDebugMarkerBeginEXT(return_struct.commandBuffer,return_struct.pMarkerInfo);
    PyObject* return_value = Py_None;

    return return_value;
}

static int
PyvkCmdDebugMarkerBeginEXT_init(PyvkCmdDebugMarkerBeginEXT *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkCmdDebugMarkerBeginEXT) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkCmdDebugMarkerBeginEXTType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkCmdDebugMarkerBeginEXT", sizeof(PyvkCmdDebugMarkerBeginEXT), 0,
    (destructor)PyvkCmdDebugMarkerBeginEXT_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCmdDebugMarkerBeginEXT_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkCmdDebugMarkerBeginEXT object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkCmdDebugMarkerBeginEXT_init,0,PyvkCmdDebugMarkerBeginEXT_new,
};

static void PyvkCmdDebugMarkerEndEXT_del(PyvkCmdDebugMarkerEndEXT* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkCmdDebugMarkerEndEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkCmdDebugMarkerEndEXT *self;
    self = (PyvkCmdDebugMarkerEndEXT *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkCmdDebugMarkerEndEXT_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    static char *kwlist[] = {"commandBuffer",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &commandBuffer)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    vkCmdDebugMarkerEndEXT(return_struct.commandBuffer);
    PyObject* return_value = Py_None;

    return return_value;
}

static int
PyvkCmdDebugMarkerEndEXT_init(PyvkCmdDebugMarkerEndEXT *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkCmdDebugMarkerEndEXT) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkCmdDebugMarkerEndEXTType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkCmdDebugMarkerEndEXT", sizeof(PyvkCmdDebugMarkerEndEXT), 0,
    (destructor)PyvkCmdDebugMarkerEndEXT_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCmdDebugMarkerEndEXT_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkCmdDebugMarkerEndEXT object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkCmdDebugMarkerEndEXT_init,0,PyvkCmdDebugMarkerEndEXT_new,
};

static void PyvkCmdDebugMarkerInsertEXT_del(PyvkCmdDebugMarkerInsertEXT* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkCmdDebugMarkerInsertEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkCmdDebugMarkerInsertEXT *self;
    self = (PyvkCmdDebugMarkerInsertEXT *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkCmdDebugMarkerInsertEXT_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* pMarkerInfo = NULL;
    static char *kwlist[] = {"commandBuffer","pMarkerInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &commandBuffer, &pMarkerInfo)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkDebugMarkerMarkerInfoEXT* pMarkerInfo;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.pMarkerInfo = (((PyVkDebugMarkerMarkerInfoEXT*)pMarkerInfo)->base);

    vkCmdDebugMarkerInsertEXT(return_struct.commandBuffer,return_struct.pMarkerInfo);
    PyObject* return_value = Py_None;

    return return_value;
}

static int
PyvkCmdDebugMarkerInsertEXT_init(PyvkCmdDebugMarkerInsertEXT *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkCmdDebugMarkerInsertEXT) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkCmdDebugMarkerInsertEXTType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkCmdDebugMarkerInsertEXT", sizeof(PyvkCmdDebugMarkerInsertEXT), 0,
    (destructor)PyvkCmdDebugMarkerInsertEXT_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCmdDebugMarkerInsertEXT_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkCmdDebugMarkerInsertEXT object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkCmdDebugMarkerInsertEXT_init,0,PyvkCmdDebugMarkerInsertEXT_new,
};

static void PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV_del(PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV *self;
    self = (PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    PyObject* format = NULL;
    PyObject* type = NULL;
    PyObject* tiling = NULL;
    PyObject* usage = NULL;
    PyObject* flags = NULL;
    PyObject* externalHandleType = NULL;
    static char *kwlist[] = {"physicalDevice","format","type","tiling","usage","flags","externalHandleType",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &physicalDevice, &format, &type, &tiling, &usage, &flags, &externalHandleType)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

        VkFormat format;

        VkImageType type;

        VkImageTiling tiling;

        VkImageUsageFlags usage;

        VkImageCreateFlags flags;

        VkExternalMemoryHandleTypeFlagsNV externalHandleType;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    return_struct.format = PyLong_AsLong(format);

    return_struct.type = PyLong_AsLong(type);

    return_struct.tiling = PyLong_AsLong(tiling);

    return_struct.usage = PyLong_AsLong(usage);

    return_struct.flags = PyLong_AsLong(flags);

    return_struct.externalHandleType = PyLong_AsLong(externalHandleType);

    VkExternalImageFormatPropertiesNV *value = malloc(sizeof(VkExternalImageFormatPropertiesNV));
    if (raise(
                vkGetPhysicalDeviceExternalImageFormatPropertiesNV(return_struct.physicalDevice,return_struct.format,return_struct.type,return_struct.tiling,return_struct.usage,return_struct.flags,return_struct.externalHandleType,value))) return NULL;
    PyObject* return_value =
        PyObject_Call((PyObject *)&PyVkExternalImageFormatPropertiesNVType,NULL, NULL);
    memcpy(((PyVkExternalImageFormatPropertiesNV*)return_value)->base,
           value, sizeof(VkExternalImageFormatPropertiesNV));

    return return_value;
}

static int
PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV_init(PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkGetPhysicalDeviceExternalImageFormatPropertiesNVType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkGetPhysicalDeviceExternalImageFormatPropertiesNV", sizeof(PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV), 0,
    (destructor)PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkGetPhysicalDeviceExternalImageFormatPropertiesNV object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV_init,0,PyvkGetPhysicalDeviceExternalImageFormatPropertiesNV_new,
};

#ifdef VK_USE_PLATFORM_WIN32_KHR

static void PyvkGetMemoryWin32HandleNV_del(PyvkGetMemoryWin32HandleNV* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkGetMemoryWin32HandleNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkGetMemoryWin32HandleNV *self;
    self = (PyvkGetMemoryWin32HandleNV *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR

static PyObject* PyvkGetMemoryWin32HandleNV_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* memory = NULL;
    PyObject* handleType = NULL;
    static char *kwlist[] = {"device","memory","handleType",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &memory, &handleType)) return NULL;

    struct {

        VkDevice device;

        VkDeviceMemory memory;

        VkExternalMemoryHandleTypeFlagsNV handleType;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.memory = PyCapsule_GetPointer(memory, "VkDeviceMemory");

    return_struct.handleType = PyLong_AsLong(handleType);

    HANDLE *value = malloc(sizeof(HANDLE));
    if (raise(
                vkGetMemoryWin32HandleNV(return_struct.device,return_struct.memory,return_struct.handleType,value))) return NULL;
    PyObject* return_value = PyLong_FromLong(*value);

    return return_value;
}

#endif

static int
PyvkGetMemoryWin32HandleNV_init(PyvkGetMemoryWin32HandleNV *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkGetMemoryWin32HandleNV) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkGetMemoryWin32HandleNVType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkGetMemoryWin32HandleNV", sizeof(PyvkGetMemoryWin32HandleNV), 0,
    (destructor)PyvkGetMemoryWin32HandleNV_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkGetMemoryWin32HandleNV_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkGetMemoryWin32HandleNV object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkGetMemoryWin32HandleNV_init,0,PyvkGetMemoryWin32HandleNV_new,
};

#endif

static void PyvkCmdDrawIndirectCountAMD_del(PyvkCmdDrawIndirectCountAMD* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkCmdDrawIndirectCountAMD_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkCmdDrawIndirectCountAMD *self;
    self = (PyvkCmdDrawIndirectCountAMD *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkCmdDrawIndirectCountAMD_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* buffer = NULL;
    PyObject* offset = NULL;
    PyObject* countBuffer = NULL;
    PyObject* countBufferOffset = NULL;
    PyObject* maxDrawCount = NULL;
    PyObject* stride = NULL;
    static char *kwlist[] = {"commandBuffer","buffer","offset","countBuffer","countBufferOffset","maxDrawCount","stride",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &commandBuffer, &buffer, &offset, &countBuffer, &countBufferOffset, &maxDrawCount, &stride)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkBuffer buffer;

        VkDeviceSize offset;

        VkBuffer countBuffer;

        VkDeviceSize countBufferOffset;

        uint32_t maxDrawCount;

        uint32_t stride;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.buffer = PyCapsule_GetPointer(buffer, "VkBuffer");

    return_struct.offset = PyLong_AsLong(offset);

    return_struct.countBuffer = PyCapsule_GetPointer(countBuffer, "VkBuffer");

    return_struct.countBufferOffset = PyLong_AsLong(countBufferOffset);
    return_struct.maxDrawCount = (uint32_t) PyLong_AsLong(maxDrawCount);
    return_struct.stride = (uint32_t) PyLong_AsLong(stride);
    vkCmdDrawIndirectCountAMD(return_struct.commandBuffer,return_struct.buffer,return_struct.offset,return_struct.countBuffer,return_struct.countBufferOffset,return_struct.maxDrawCount,return_struct.stride);
    PyObject* return_value = Py_None;

    return return_value;
}

static int
PyvkCmdDrawIndirectCountAMD_init(PyvkCmdDrawIndirectCountAMD *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkCmdDrawIndirectCountAMD) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkCmdDrawIndirectCountAMDType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkCmdDrawIndirectCountAMD", sizeof(PyvkCmdDrawIndirectCountAMD), 0,
    (destructor)PyvkCmdDrawIndirectCountAMD_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCmdDrawIndirectCountAMD_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkCmdDrawIndirectCountAMD object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkCmdDrawIndirectCountAMD_init,0,PyvkCmdDrawIndirectCountAMD_new,
};

static void PyvkCmdDrawIndexedIndirectCountAMD_del(PyvkCmdDrawIndexedIndirectCountAMD* self) {
    Py_TYPE(self)->tp_free((PyObject*)self);
}

static PyObject *
PyvkCmdDrawIndexedIndirectCountAMD_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyvkCmdDrawIndexedIndirectCountAMD *self;
    self = (PyvkCmdDrawIndexedIndirectCountAMD *)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static PyObject* PyvkCmdDrawIndexedIndirectCountAMD_call(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* buffer = NULL;
    PyObject* offset = NULL;
    PyObject* countBuffer = NULL;
    PyObject* countBufferOffset = NULL;
    PyObject* maxDrawCount = NULL;
    PyObject* stride = NULL;
    static char *kwlist[] = {"commandBuffer","buffer","offset","countBuffer","countBufferOffset","maxDrawCount","stride",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &commandBuffer, &buffer, &offset, &countBuffer, &countBufferOffset, &maxDrawCount, &stride)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkBuffer buffer;

        VkDeviceSize offset;

        VkBuffer countBuffer;

        VkDeviceSize countBufferOffset;

        uint32_t maxDrawCount;

        uint32_t stride;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.buffer = PyCapsule_GetPointer(buffer, "VkBuffer");

    return_struct.offset = PyLong_AsLong(offset);

    return_struct.countBuffer = PyCapsule_GetPointer(countBuffer, "VkBuffer");

    return_struct.countBufferOffset = PyLong_AsLong(countBufferOffset);
    return_struct.maxDrawCount = (uint32_t) PyLong_AsLong(maxDrawCount);
    return_struct.stride = (uint32_t) PyLong_AsLong(stride);
    vkCmdDrawIndexedIndirectCountAMD(return_struct.commandBuffer,return_struct.buffer,return_struct.offset,return_struct.countBuffer,return_struct.countBufferOffset,return_struct.maxDrawCount,return_struct.stride);
    PyObject* return_value = Py_None;

    return return_value;
}

static int
PyvkCmdDrawIndexedIndirectCountAMD_init(PyvkCmdDrawIndexedIndirectCountAMD *self, PyObject *args, PyObject *kwds) {
    PyObject* capsule;
    if (!PyArg_ParseTuple(args, "O", &capsule))
        return -1;
    self->pfn = (PFN_vkCmdDrawIndexedIndirectCountAMD) PyCapsule_GetPointer(capsule, NULL);
    if (self->pfn == NULL) return -1;
    return 0;
}

static PyTypeObject PyvkCmdDrawIndexedIndirectCountAMDType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "vulkan.vkCmdDrawIndexedIndirectCountAMD", sizeof(PyvkCmdDrawIndexedIndirectCountAMD), 0,
    (destructor)PyvkCmdDrawIndexedIndirectCountAMD_del,
    0,0,0,0,0,0,0,0,0,(ternaryfunc)PyvkCmdDrawIndexedIndirectCountAMD_call,
    0,0,0,0,Py_TPFLAGS_DEFAULT,
    "vkCmdDrawIndexedIndirectCountAMD object",0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,(initproc)PyvkCmdDrawIndexedIndirectCountAMD_init,0,PyvkCmdDrawIndexedIndirectCountAMD_new,
};

static PyObject* PyvkGetInstanceProcAddr(
    PyObject *self, PyObject *args, PyObject *kwds) {

<<<<<<< HEAD
    PyObject* instance = NULL;
    PyObject* pName = NULL;
=======
    //TEST
    VkApplicationInfo appInfo = {};
    appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
    appInfo.pApplicationName = "Hello Triangle";
    appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
    appInfo.pEngineName = "No Engine";
    appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);
    appInfo.apiVersion = VK_API_VERSION_1_0;

    char *extensions[1] = {"VK_EXT_debug_report"};
    VkInstanceCreateInfo createInfo = {};
    createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    createInfo.pApplicationInfo = &appInfo;
    createInfo.enabledLayerCount = 0;
    createInfo.ppEnabledLayerNames = NULL;
    createInfo.enabledExtensionCount = 1;
    createInfo.ppEnabledExtensionNames = extensions;

    VkInstance instance;
    VkResult result = vkCreateInstance(&createInfo, NULL, &instance);
    if (result != VK_SUCCESS) {
         PyErr_SetString(PyExc_ValueError, "Instance can't be created");
         return NULL;
    }

    PFN_vkCreateDebugReportCallbackEXT fun = (PFN_vkCreateDebugReportCallbackEXT) vkGetInstanceProcAddr(instance, "vkCreateDebugReportCallbackEXT");
    if (fun == NULL) {
        PyErr_SetString(PyExc_ImportError, "Can't import function fun");
        return NULL;
    }
    else {
        PyErr_SetString(PyExc_ImportError, "It works");
        return NULL;
    }
    return Py_None;

    // NORMAL function
    /*PyObject* instance = NULL;
    char* pName = NULL;
>>>>>>> to test in pure C
    static char *kwlist[] = {"instance", "pName", NULL};

    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist,
                                    &instance, &pName))
        return NULL;

    VkInstance* arg0 = PyCapsule_GetPointer(instance, "VkInstance");
    if(arg0 == NULL) return NULL;

    PyObject* tmp = PyUnicode_AsASCIIString(pName);
    if(tmp == NULL) return NULL;

    char* arg1 = PyBytes_AsString(tmp);
    if(arg1 == NULL) return NULL;
    Py_DECREF(tmp);

    PFN_vkVoidFunction fun = vkGetInstanceProcAddr(*arg0, arg1);
    if (fun == NULL) {
        PyErr_SetString(PyExc_ImportError, "error");
        return NULL;
    }
    PyObject* pointer = PyCapsule_New(fun, NULL, NULL);
    if (pointer == NULL) return NULL;

    PyObject* call_args = Py_BuildValue("(O)", pointer);
    if (call_args == NULL) return NULL;

    PyObject* pyreturn = NULL;

    if (strcmp(arg1, "vkAcquireNextImageKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkAcquireNextImageKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceExternalImageFormatPropertiesNVType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkCmdDebugMarkerBeginEXT") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCmdDebugMarkerBeginEXTType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#ifdef VK_USE_PLATFORM_XLIB_KHR

    if (strcmp(arg1, "vkCreateXlibSurfaceKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateXlibSurfaceKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

    if (strcmp(arg1, "vkCreateSwapchainKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateSwapchainKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetPhysicalDeviceDisplayPropertiesKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceDisplayPropertiesKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR

    if (strcmp(arg1, "vkCreateWin32SurfaceKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateWin32SurfaceKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

    if (strcmp(arg1, "vkCreateDisplayPlaneSurfaceKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateDisplayPlaneSurfaceKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetPhysicalDeviceSurfacePresentModesKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceSurfacePresentModesKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkDestroyDebugReportCallbackEXT") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkDestroyDebugReportCallbackEXTType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetPhysicalDeviceSurfaceFormatsKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceSurfaceFormatsKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR

    if (strcmp(arg1, "vkGetPhysicalDeviceWin32PresentationSupportKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceWin32PresentationSupportKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

    if (strcmp(arg1, "vkCmdDebugMarkerEndEXT") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCmdDebugMarkerEndEXTType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceSurfaceCapabilitiesKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetDisplayPlaneSupportedDisplaysKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetDisplayPlaneSupportedDisplaysKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetPhysicalDeviceSurfaceSupportKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceSurfaceSupportKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

    if (strcmp(arg1, "vkCreateWaylandSurfaceKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateWaylandSurfaceKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

    if (strcmp(arg1, "vkDebugMarkerSetObjectTagEXT") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkDebugMarkerSetObjectTagEXTType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceDisplayPlanePropertiesKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkCmdDebugMarkerInsertEXT") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCmdDebugMarkerInsertEXTType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetDisplayModePropertiesKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetDisplayModePropertiesKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkCmdDrawIndirectCountAMD") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCmdDrawIndirectCountAMDType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#ifdef VK_USE_PLATFORM_ANDROID_KHR

    if (strcmp(arg1, "vkCreateAndroidSurfaceKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateAndroidSurfaceKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

    if (strcmp(arg1, "vkGetMemoryWin32HandleNV") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetMemoryWin32HandleNVType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

    if (strcmp(arg1, "vkGetDisplayPlaneCapabilitiesKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetDisplayPlaneCapabilitiesKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkCmdDrawIndexedIndirectCountAMD") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCmdDrawIndexedIndirectCountAMDType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetSwapchainImagesKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetSwapchainImagesKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkQueuePresentKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkQueuePresentKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#ifdef VK_USE_PLATFORM_MIR_KHR

    if (strcmp(arg1, "vkGetPhysicalDeviceMirPresentationSupportKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceMirPresentationSupportKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

    if (strcmp(arg1, "vkCreateDisplayModeKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateDisplayModeKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#ifdef VK_USE_PLATFORM_MIR_KHR

    if (strcmp(arg1, "vkCreateMirSurfaceKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateMirSurfaceKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR

    if (strcmp(arg1, "vkGetPhysicalDeviceXlibPresentationSupportKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceXlibPresentationSupportKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

#ifdef VK_USE_PLATFORM_XCB_KHR

    if (strcmp(arg1, "vkCreateXcbSurfaceKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateXcbSurfaceKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

#ifdef VK_USE_PLATFORM_XCB_KHR

    if (strcmp(arg1, "vkGetPhysicalDeviceXcbPresentationSupportKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceXcbPresentationSupportKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

    if (strcmp(arg1, "vkDestroySurfaceKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkDestroySurfaceKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkDebugReportMessageEXT") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkDebugReportMessageEXTType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

    if (strcmp(arg1, "vkGetPhysicalDeviceWaylandPresentationSupportKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceWaylandPresentationSupportKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

    if (strcmp(arg1, "vkCreateSharedSwapchainsKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateSharedSwapchainsKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkCreateDebugReportCallbackEXT") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateDebugReportCallbackEXTType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkDestroySwapchainKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkDestroySwapchainKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkDebugMarkerSetObjectNameEXT") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkDebugMarkerSetObjectNameEXTType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    Py_INCREF(pyreturn);
    return pyreturn;
    */
}

static PyObject* PyvkGetDeviceProcAddr(
    PyObject *self, PyObject *args, PyObject *kwds) {

    PyObject* instance = NULL;
    PyObject* pName = NULL;
    static char *kwlist[] = {"device", "pName", NULL};

    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist,
                                    &instance, &pName))
        return NULL;

    VkDevice* arg0 = PyCapsule_GetPointer(instance, "VkDevice");
    if(arg0 == NULL) return NULL;

    PyObject* tmp = PyUnicode_AsASCIIString(pName);
    if(tmp == NULL) return NULL;

    char* arg1 = PyBytes_AsString(tmp);
    if(arg1 == NULL) return NULL;
    Py_DECREF(tmp);

    PFN_vkVoidFunction fun = vkGetDeviceProcAddr(*arg0, arg1);
    if (fun == NULL) {
        PyErr_SetString(PyExc_ImportError, "error");
        return NULL;
    }
    PyObject* pointer = PyCapsule_New(fun, NULL, NULL);
    if (pointer == NULL) return NULL;

    PyObject* call_args = Py_BuildValue("(O)", pointer);
    if (call_args == NULL) return NULL;

    PyObject* pyreturn = NULL;

    if (strcmp(arg1, "vkAcquireNextImageKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkAcquireNextImageKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceExternalImageFormatPropertiesNVType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkCmdDebugMarkerBeginEXT") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCmdDebugMarkerBeginEXTType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#ifdef VK_USE_PLATFORM_XLIB_KHR

    if (strcmp(arg1, "vkCreateXlibSurfaceKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateXlibSurfaceKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

    if (strcmp(arg1, "vkCreateSwapchainKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateSwapchainKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetPhysicalDeviceDisplayPropertiesKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceDisplayPropertiesKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR

    if (strcmp(arg1, "vkCreateWin32SurfaceKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateWin32SurfaceKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

    if (strcmp(arg1, "vkCreateDisplayPlaneSurfaceKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateDisplayPlaneSurfaceKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetPhysicalDeviceSurfacePresentModesKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceSurfacePresentModesKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkDestroyDebugReportCallbackEXT") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkDestroyDebugReportCallbackEXTType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetPhysicalDeviceSurfaceFormatsKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceSurfaceFormatsKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR

    if (strcmp(arg1, "vkGetPhysicalDeviceWin32PresentationSupportKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceWin32PresentationSupportKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

    if (strcmp(arg1, "vkCmdDebugMarkerEndEXT") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCmdDebugMarkerEndEXTType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceSurfaceCapabilitiesKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetDisplayPlaneSupportedDisplaysKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetDisplayPlaneSupportedDisplaysKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetPhysicalDeviceSurfaceSupportKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceSurfaceSupportKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

    if (strcmp(arg1, "vkCreateWaylandSurfaceKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateWaylandSurfaceKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

    if (strcmp(arg1, "vkDebugMarkerSetObjectTagEXT") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkDebugMarkerSetObjectTagEXTType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceDisplayPlanePropertiesKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkCmdDebugMarkerInsertEXT") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCmdDebugMarkerInsertEXTType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetDisplayModePropertiesKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetDisplayModePropertiesKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkCmdDrawIndirectCountAMD") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCmdDrawIndirectCountAMDType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#ifdef VK_USE_PLATFORM_ANDROID_KHR

    if (strcmp(arg1, "vkCreateAndroidSurfaceKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateAndroidSurfaceKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

    if (strcmp(arg1, "vkGetMemoryWin32HandleNV") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetMemoryWin32HandleNVType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

    if (strcmp(arg1, "vkGetDisplayPlaneCapabilitiesKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetDisplayPlaneCapabilitiesKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkCmdDrawIndexedIndirectCountAMD") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCmdDrawIndexedIndirectCountAMDType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkGetSwapchainImagesKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetSwapchainImagesKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkQueuePresentKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkQueuePresentKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#ifdef VK_USE_PLATFORM_MIR_KHR

    if (strcmp(arg1, "vkGetPhysicalDeviceMirPresentationSupportKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceMirPresentationSupportKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

    if (strcmp(arg1, "vkCreateDisplayModeKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateDisplayModeKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#ifdef VK_USE_PLATFORM_MIR_KHR

    if (strcmp(arg1, "vkCreateMirSurfaceKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateMirSurfaceKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR

    if (strcmp(arg1, "vkGetPhysicalDeviceXlibPresentationSupportKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceXlibPresentationSupportKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

#ifdef VK_USE_PLATFORM_XCB_KHR

    if (strcmp(arg1, "vkCreateXcbSurfaceKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateXcbSurfaceKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

#ifdef VK_USE_PLATFORM_XCB_KHR

    if (strcmp(arg1, "vkGetPhysicalDeviceXcbPresentationSupportKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceXcbPresentationSupportKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

    if (strcmp(arg1, "vkDestroySurfaceKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkDestroySurfaceKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkDebugReportMessageEXT") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkDebugReportMessageEXTType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

    if (strcmp(arg1, "vkGetPhysicalDeviceWaylandPresentationSupportKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkGetPhysicalDeviceWaylandPresentationSupportKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

#endif

    if (strcmp(arg1, "vkCreateSharedSwapchainsKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateSharedSwapchainsKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkCreateDebugReportCallbackEXT") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkCreateDebugReportCallbackEXTType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkDestroySwapchainKHR") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkDestroySwapchainKHRType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    if (strcmp(arg1, "vkDebugMarkerSetObjectNameEXT") == 0) {
        pyreturn = PyObject_Call((PyObject *)&PyvkDebugMarkerSetObjectNameEXTType,
                                 call_args, NULL);
        if (pyreturn == NULL) return NULL;
    }

    Py_INCREF(pyreturn);
    return pyreturn;
}

static PyObject *
PyVK_MAKE_VERSION(PyObject *self, PyObject *args) {
    const int major, minor, patch;
    if (!PyArg_ParseTuple(args, "iii", &major, &minor, &patch))
        return NULL;
    return PyLong_FromLong(
               (((major) << 22) | ((minor) << 12) | (patch)));
}

static PyObject *
PyVK_VERSION_MAJOR(PyObject *self, PyObject *args) {
    const int version;
    if (!PyArg_ParseTuple(args, "i", &version))
        return NULL;
    return PyLong_FromLong(((uint32_t)(version) >> 22));
}

static PyObject *
PyVK_VERSION_MINOR(PyObject *self, PyObject *args) {
    const int version;
    if (!PyArg_ParseTuple(args, "i", &version))
        return NULL;
    return PyLong_FromLong((((uint32_t)(version) >> 12) & 0x3ff));
}

static PyObject *
PyVK_VERSION_PATCH(PyObject *self, PyObject *args) {
    const int version;
    if (!PyArg_ParseTuple(args, "i", &version))
        return NULL;
    return PyLong_FromLong(((uint32_t)(version) & 0xfff));
}

static PyObject* PyvkCreateInstance(PyObject *self, PyObject *args,
                                    PyObject *kwds) {
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &pCreateInfo)) return NULL;

    struct {

        VkInstanceCreateInfo* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.pCreateInfo = (((PyVkInstanceCreateInfo*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkInstance *value = malloc(sizeof(VkInstance));
    if (raise(
                vkCreateInstance(return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkInstance", NULL);

    return return_value;
}

static PyObject* PyvkDestroyInstance(PyObject *self, PyObject *args,
                                     PyObject *kwds) {
    PyObject* instance = NULL;
    static char *kwlist[] = {"instance",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &instance)) return NULL;

    struct {

        VkInstance instance;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.instance = PyCapsule_GetPointer(instance, "VkInstance");

    return_struct.pAllocator = NULL;

    vkDestroyInstance(return_struct.instance,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkEnumeratePhysicalDevices(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* instance = NULL;
    static char *kwlist[] = {"instance",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &instance)) return NULL;

    struct {

        VkInstance instance;

    } return_struct = {};

    return_struct.instance = PyCapsule_GetPointer(instance, "VkInstance");

    uint32_t count;
    if (raise(
                vkEnumeratePhysicalDevices(return_struct.instance,&count, NULL))) return NULL;
    VkPhysicalDevice *values = malloc(count*sizeof(VkPhysicalDevice));
    if (raise(
                vkEnumeratePhysicalDevices(return_struct.instance,&count, values))) return NULL;
    PyObject* return_value = PyList_New(0);
    uint32_t i;
    for (i=0; i<count; i++) {

        PyObject* pyreturn = PyCapsule_New(values + i*sizeof(VkPhysicalDevice)
                                           , "VkPhysicalDevice", NULL);

        PyList_Append(return_value, pyreturn);
    }

    return return_value;
}

static PyObject* PyvkGetPhysicalDeviceProperties(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    static char *kwlist[] = {"physicalDevice",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &physicalDevice)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    VkPhysicalDeviceProperties *value = malloc(sizeof(VkPhysicalDeviceProperties));

    vkGetPhysicalDeviceProperties(return_struct.physicalDevice,value);
    PyObject* return_value =
        PyObject_Call((PyObject *)&PyVkPhysicalDevicePropertiesType,NULL, NULL);
    memcpy(((PyVkPhysicalDeviceProperties*)return_value)->base,
           value, sizeof(VkPhysicalDeviceProperties));

    return return_value;
}

static PyObject* PyvkGetPhysicalDeviceQueueFamilyProperties(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    static char *kwlist[] = {"physicalDevice",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &physicalDevice)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    uint32_t count;
    vkGetPhysicalDeviceQueueFamilyProperties(return_struct.physicalDevice,&count, NULL);
    VkQueueFamilyProperties *values = malloc(count*sizeof(VkQueueFamilyProperties));

    vkGetPhysicalDeviceQueueFamilyProperties(return_struct.physicalDevice,&count, values);
    PyObject* return_value = PyList_New(0);
    uint32_t i;
    for (i=0; i<count; i++) {

        PyObject* pyreturn = PyObject_Call((PyObject *)&PyVkQueueFamilyPropertiesType,
                                           NULL, NULL);
        memcpy(((PyVkQueueFamilyProperties*)pyreturn)->base,
               values + i, sizeof(VkQueueFamilyProperties));

        PyList_Append(return_value, pyreturn);
    }

    return return_value;
}

static PyObject* PyvkGetPhysicalDeviceMemoryProperties(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    static char *kwlist[] = {"physicalDevice",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &physicalDevice)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    VkPhysicalDeviceMemoryProperties *value = malloc(sizeof(VkPhysicalDeviceMemoryProperties));

    vkGetPhysicalDeviceMemoryProperties(return_struct.physicalDevice,value);
    PyObject* return_value =
        PyObject_Call((PyObject *)&PyVkPhysicalDeviceMemoryPropertiesType,NULL, NULL);
    memcpy(((PyVkPhysicalDeviceMemoryProperties*)return_value)->base,
           value, sizeof(VkPhysicalDeviceMemoryProperties));

    return return_value;
}

static PyObject* PyvkGetPhysicalDeviceFeatures(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    static char *kwlist[] = {"physicalDevice",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &physicalDevice)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    VkPhysicalDeviceFeatures *value = malloc(sizeof(VkPhysicalDeviceFeatures));

    vkGetPhysicalDeviceFeatures(return_struct.physicalDevice,value);
    PyObject* return_value =
        PyObject_Call((PyObject *)&PyVkPhysicalDeviceFeaturesType,NULL, NULL);
    memcpy(((PyVkPhysicalDeviceFeatures*)return_value)->base,
           value, sizeof(VkPhysicalDeviceFeatures));

    return return_value;
}

static PyObject* PyvkGetPhysicalDeviceFormatProperties(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    PyObject* format = NULL;
    static char *kwlist[] = {"physicalDevice","format",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &physicalDevice, &format)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

        VkFormat format;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    return_struct.format = PyLong_AsLong(format);

    VkFormatProperties *value = malloc(sizeof(VkFormatProperties));

    vkGetPhysicalDeviceFormatProperties(return_struct.physicalDevice,return_struct.format,value);
    PyObject* return_value =
        PyObject_Call((PyObject *)&PyVkFormatPropertiesType,NULL, NULL);
    memcpy(((PyVkFormatProperties*)return_value)->base,
           value, sizeof(VkFormatProperties));

    return return_value;
}

static PyObject* PyvkGetPhysicalDeviceImageFormatProperties(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    PyObject* format = NULL;
    PyObject* type = NULL;
    PyObject* tiling = NULL;
    PyObject* usage = NULL;
    PyObject* flags = NULL;
    static char *kwlist[] = {"physicalDevice","format","type","tiling","usage","flags",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &physicalDevice, &format, &type, &tiling, &usage, &flags)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

        VkFormat format;

        VkImageType type;

        VkImageTiling tiling;

        VkImageUsageFlags usage;

        VkImageCreateFlags flags;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    return_struct.format = PyLong_AsLong(format);

    return_struct.type = PyLong_AsLong(type);

    return_struct.tiling = PyLong_AsLong(tiling);

    return_struct.usage = PyLong_AsLong(usage);

    return_struct.flags = PyLong_AsLong(flags);

    VkImageFormatProperties *value = malloc(sizeof(VkImageFormatProperties));
    if (raise(
                vkGetPhysicalDeviceImageFormatProperties(return_struct.physicalDevice,return_struct.format,return_struct.type,return_struct.tiling,return_struct.usage,return_struct.flags,value))) return NULL;
    PyObject* return_value =
        PyObject_Call((PyObject *)&PyVkImageFormatPropertiesType,NULL, NULL);
    memcpy(((PyVkImageFormatProperties*)return_value)->base,
           value, sizeof(VkImageFormatProperties));

    return return_value;
}

static PyObject* PyvkCreateDevice(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"physicalDevice","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &physicalDevice, &pCreateInfo)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

        VkDeviceCreateInfo* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    return_struct.pCreateInfo = (((PyVkDeviceCreateInfo*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkDevice *value = malloc(sizeof(VkDevice));
    if (raise(
                vkCreateDevice(return_struct.physicalDevice,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkDevice", NULL);

    return return_value;
}

static PyObject* PyvkDestroyDevice(PyObject *self, PyObject *args,
                                   PyObject *kwds) {
    PyObject* device = NULL;
    static char *kwlist[] = {"device",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &device)) return NULL;

    struct {

        VkDevice device;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pAllocator = NULL;

    vkDestroyDevice(return_struct.device,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkEnumerateInstanceLayerProperties(PyObject *self, PyObject *args,
        PyObject *kwds) {

    uint32_t count;
    if (raise(
                vkEnumerateInstanceLayerProperties(&count, NULL))) return NULL;
    VkLayerProperties *values = malloc(count*sizeof(VkLayerProperties));
    if (raise(
                vkEnumerateInstanceLayerProperties(&count, values))) return NULL;
    PyObject* return_value = PyList_New(0);
    uint32_t i;
    for (i=0; i<count; i++) {

        PyObject* pyreturn = PyObject_Call((PyObject *)&PyVkLayerPropertiesType,
                                           NULL, NULL);
        memcpy(((PyVkLayerProperties*)pyreturn)->base,
               values + i, sizeof(VkLayerProperties));

        PyList_Append(return_value, pyreturn);
    }

    return return_value;
}

static PyObject* PyvkEnumerateInstanceExtensionProperties(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* pLayerName = NULL;
    static char *kwlist[] = {"pLayerName",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &pLayerName)) return NULL;

    struct {

        char* pLayerName;

    } return_struct = {};

    if (pLayerName == Py_None) {
        return_struct.pLayerName = NULL;
    }
    else {
        PyObject * tmp39848314 = PyUnicode_AsASCIIString(pLayerName);
        char* tmp33500926 = PyBytes_AsString(tmp39848314);
        char* tmp24257592 = strdup(tmp33500926);
        return_struct.pLayerName = tmp24257592;
        Py_DECREF(tmp39848314);
    }

    uint32_t count;
    if (raise(
                vkEnumerateInstanceExtensionProperties(return_struct.pLayerName,&count, NULL))) return NULL;
    VkExtensionProperties *values = malloc(count*sizeof(VkExtensionProperties));
    if (raise(
                vkEnumerateInstanceExtensionProperties(return_struct.pLayerName,&count, values))) return NULL;
    PyObject* return_value = PyList_New(0);
    uint32_t i;
    for (i=0; i<count; i++) {

        PyObject* pyreturn = PyObject_Call((PyObject *)&PyVkExtensionPropertiesType,
                                           NULL, NULL);
        memcpy(((PyVkExtensionProperties*)pyreturn)->base,
               values + i, sizeof(VkExtensionProperties));

        PyList_Append(return_value, pyreturn);
    }

    return return_value;
}

static PyObject* PyvkEnumerateDeviceLayerProperties(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    static char *kwlist[] = {"physicalDevice",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &physicalDevice)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    uint32_t count;
    if (raise(
                vkEnumerateDeviceLayerProperties(return_struct.physicalDevice,&count, NULL))) return NULL;
    VkLayerProperties *values = malloc(count*sizeof(VkLayerProperties));
    if (raise(
                vkEnumerateDeviceLayerProperties(return_struct.physicalDevice,&count, values))) return NULL;
    PyObject* return_value = PyList_New(0);
    uint32_t i;
    for (i=0; i<count; i++) {

        PyObject* pyreturn = PyObject_Call((PyObject *)&PyVkLayerPropertiesType,
                                           NULL, NULL);
        memcpy(((PyVkLayerProperties*)pyreturn)->base,
               values + i, sizeof(VkLayerProperties));

        PyList_Append(return_value, pyreturn);
    }

    return return_value;
}

static PyObject* PyvkEnumerateDeviceExtensionProperties(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    PyObject* pLayerName = NULL;
    static char *kwlist[] = {"physicalDevice","pLayerName",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &physicalDevice, &pLayerName)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

        char* pLayerName;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    if (pLayerName == Py_None) {
        return_struct.pLayerName = NULL;
    }
    else {
        PyObject * tmp12398997 = PyUnicode_AsASCIIString(pLayerName);
        char* tmp21661033 = PyBytes_AsString(tmp12398997);
        char* tmp17643963 = strdup(tmp21661033);
        return_struct.pLayerName = tmp17643963;
        Py_DECREF(tmp12398997);
    }

    uint32_t count;
    if (raise(
                vkEnumerateDeviceExtensionProperties(return_struct.physicalDevice,return_struct.pLayerName,&count, NULL))) return NULL;
    VkExtensionProperties *values = malloc(count*sizeof(VkExtensionProperties));
    if (raise(
                vkEnumerateDeviceExtensionProperties(return_struct.physicalDevice,return_struct.pLayerName,&count, values))) return NULL;
    PyObject* return_value = PyList_New(0);
    uint32_t i;
    for (i=0; i<count; i++) {

        PyObject* pyreturn = PyObject_Call((PyObject *)&PyVkExtensionPropertiesType,
                                           NULL, NULL);
        memcpy(((PyVkExtensionProperties*)pyreturn)->base,
               values + i, sizeof(VkExtensionProperties));

        PyList_Append(return_value, pyreturn);
    }

    return return_value;
}

static PyObject* PyvkGetDeviceQueue(PyObject *self, PyObject *args,
                                    PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* queueFamilyIndex = NULL;
    PyObject* queueIndex = NULL;
    static char *kwlist[] = {"device","queueFamilyIndex","queueIndex",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &queueFamilyIndex, &queueIndex)) return NULL;

    struct {

        VkDevice device;

        uint32_t queueFamilyIndex;

        uint32_t queueIndex;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");
    return_struct.queueFamilyIndex = (uint32_t) PyLong_AsLong(queueFamilyIndex);
    return_struct.queueIndex = (uint32_t) PyLong_AsLong(queueIndex);
    VkQueue *value = malloc(sizeof(VkQueue));

    vkGetDeviceQueue(return_struct.device,return_struct.queueFamilyIndex,return_struct.queueIndex,value);
    PyObject* return_value = PyCapsule_New(value, "VkQueue", NULL);

    return return_value;
}

static PyObject* PyvkQueueSubmit(PyObject *self, PyObject *args,
                                 PyObject *kwds) {
    PyObject* queue = NULL;
    PyObject* submitCount = NULL;
    PyObject* pSubmits = NULL;
    PyObject* fence = NULL;
    static char *kwlist[] = {"queue","submitCount","pSubmits","fence",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &queue, &submitCount, &pSubmits, &fence)) return NULL;

    struct {

        VkQueue queue;

        uint32_t submitCount;

        VkSubmitInfo* pSubmits;

        VkFence fence;

    } return_struct = {};

    return_struct.queue = PyCapsule_GetPointer(queue, "VkQueue");
    return_struct.submitCount = (uint32_t) PyLong_AsLong(submitCount);
    return_struct.pSubmits = (((PyVkSubmitInfo*)pSubmits)->base);

    return_struct.fence = PyCapsule_GetPointer(fence, "VkFence");

    vkQueueSubmit(return_struct.queue,return_struct.submitCount,return_struct.pSubmits,return_struct.fence);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkQueueWaitIdle(PyObject *self, PyObject *args,
                                   PyObject *kwds) {
    PyObject* queue = NULL;
    static char *kwlist[] = {"queue",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &queue)) return NULL;

    struct {

        VkQueue queue;

    } return_struct = {};

    return_struct.queue = PyCapsule_GetPointer(queue, "VkQueue");

    vkQueueWaitIdle(return_struct.queue);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkDeviceWaitIdle(PyObject *self, PyObject *args,
                                    PyObject *kwds) {
    PyObject* device = NULL;
    static char *kwlist[] = {"device",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &device)) return NULL;

    struct {

        VkDevice device;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    vkDeviceWaitIdle(return_struct.device);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkAllocateMemory(PyObject *self, PyObject *args,
                                    PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pAllocateInfo = NULL;
    static char *kwlist[] = {"device","pAllocateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pAllocateInfo)) return NULL;

    struct {

        VkDevice device;

        VkMemoryAllocateInfo* pAllocateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pAllocateInfo = (((PyVkMemoryAllocateInfo*)pAllocateInfo)->base);

    return_struct.pAllocator = NULL;

    VkDeviceMemory *value = malloc(sizeof(VkDeviceMemory));
    if (raise(
                vkAllocateMemory(return_struct.device,return_struct.pAllocateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkDeviceMemory", NULL);

    return return_value;
}

static PyObject* PyvkFreeMemory(PyObject *self, PyObject *args,
                                PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* memory = NULL;
    static char *kwlist[] = {"device","memory",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &memory)) return NULL;

    struct {

        VkDevice device;

        VkDeviceMemory memory;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.memory = PyCapsule_GetPointer(memory, "VkDeviceMemory");

    return_struct.pAllocator = NULL;

    vkFreeMemory(return_struct.device,return_struct.memory,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkMapMemory(PyObject *self, PyObject *args,
                               PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* memory = NULL;
    PyObject* offset = NULL;
    PyObject* size = NULL;
    PyObject* flags = NULL;
    static char *kwlist[] = {"device","memory","offset","size","flags",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &device, &memory, &offset, &size, &flags)) return NULL;

    struct {

        VkDevice device;

        VkDeviceMemory memory;

        VkDeviceSize offset;

        VkDeviceSize size;

        VkMemoryMapFlags flags;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.memory = PyCapsule_GetPointer(memory, "VkDeviceMemory");

    return_struct.offset = PyLong_AsLong(offset);

    return_struct.size = PyLong_AsLong(size);

    return_struct.flags = PyLong_AsLong(flags);

    void* value;
    if (raise(
                vkMapMemory(return_struct.device, return_struct.memory,
                            return_struct.offset, return_struct.size,
                            return_struct.flags, &value)
            )) return NULL;
    PyObject* return_value = PyMemoryView_FromMemory(value,
                             return_struct.size, PyBUF_WRITE);

    return return_value;
}

static PyObject* PyvkUnmapMemory(PyObject *self, PyObject *args,
                                 PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* memory = NULL;
    static char *kwlist[] = {"device","memory",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &memory)) return NULL;

    struct {

        VkDevice device;

        VkDeviceMemory memory;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.memory = PyCapsule_GetPointer(memory, "VkDeviceMemory");

    vkUnmapMemory(return_struct.device,return_struct.memory);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkFlushMappedMemoryRanges(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* memoryRangeCount = NULL;
    PyObject* pMemoryRanges = NULL;
    static char *kwlist[] = {"device","memoryRangeCount","pMemoryRanges",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &memoryRangeCount, &pMemoryRanges)) return NULL;

    struct {

        VkDevice device;

        uint32_t memoryRangeCount;

        VkMappedMemoryRange* pMemoryRanges;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");
    return_struct.memoryRangeCount = (uint32_t) PyLong_AsLong(memoryRangeCount);
    return_struct.pMemoryRanges = (((PyVkMappedMemoryRange*)pMemoryRanges)->base);

    vkFlushMappedMemoryRanges(return_struct.device,return_struct.memoryRangeCount,return_struct.pMemoryRanges);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkInvalidateMappedMemoryRanges(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* memoryRangeCount = NULL;
    PyObject* pMemoryRanges = NULL;
    static char *kwlist[] = {"device","memoryRangeCount","pMemoryRanges",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &memoryRangeCount, &pMemoryRanges)) return NULL;

    struct {

        VkDevice device;

        uint32_t memoryRangeCount;

        VkMappedMemoryRange* pMemoryRanges;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");
    return_struct.memoryRangeCount = (uint32_t) PyLong_AsLong(memoryRangeCount);
    return_struct.pMemoryRanges = (((PyVkMappedMemoryRange*)pMemoryRanges)->base);

    vkInvalidateMappedMemoryRanges(return_struct.device,return_struct.memoryRangeCount,return_struct.pMemoryRanges);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkGetDeviceMemoryCommitment(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* memory = NULL;
    static char *kwlist[] = {"device","memory",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &memory)) return NULL;

    struct {

        VkDevice device;

        VkDeviceMemory memory;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.memory = PyCapsule_GetPointer(memory, "VkDeviceMemory");

    VkDeviceSize *value = malloc(sizeof(VkDeviceSize));

    vkGetDeviceMemoryCommitment(return_struct.device,return_struct.memory,value);
    PyObject* return_value = PyLong_FromLong(*value);

    return return_value;
}

static PyObject* PyvkGetBufferMemoryRequirements(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* buffer = NULL;
    static char *kwlist[] = {"device","buffer",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &buffer)) return NULL;

    struct {

        VkDevice device;

        VkBuffer buffer;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.buffer = PyCapsule_GetPointer(buffer, "VkBuffer");

    VkMemoryRequirements *value = malloc(sizeof(VkMemoryRequirements));

    vkGetBufferMemoryRequirements(return_struct.device,return_struct.buffer,value);
    PyObject* return_value =
        PyObject_Call((PyObject *)&PyVkMemoryRequirementsType,NULL, NULL);
    memcpy(((PyVkMemoryRequirements*)return_value)->base,
           value, sizeof(VkMemoryRequirements));

    return return_value;
}

static PyObject* PyvkBindBufferMemory(PyObject *self, PyObject *args,
                                      PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* buffer = NULL;
    PyObject* memory = NULL;
    PyObject* memoryOffset = NULL;
    static char *kwlist[] = {"device","buffer","memory","memoryOffset",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &buffer, &memory, &memoryOffset)) return NULL;

    struct {

        VkDevice device;

        VkBuffer buffer;

        VkDeviceMemory memory;

        VkDeviceSize memoryOffset;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.buffer = PyCapsule_GetPointer(buffer, "VkBuffer");

    return_struct.memory = PyCapsule_GetPointer(memory, "VkDeviceMemory");

    return_struct.memoryOffset = PyLong_AsLong(memoryOffset);

    vkBindBufferMemory(return_struct.device,return_struct.buffer,return_struct.memory,return_struct.memoryOffset);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkGetImageMemoryRequirements(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* image = NULL;
    static char *kwlist[] = {"device","image",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &image)) return NULL;

    struct {

        VkDevice device;

        VkImage image;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.image = PyCapsule_GetPointer(image, "VkImage");

    VkMemoryRequirements *value = malloc(sizeof(VkMemoryRequirements));

    vkGetImageMemoryRequirements(return_struct.device,return_struct.image,value);
    PyObject* return_value =
        PyObject_Call((PyObject *)&PyVkMemoryRequirementsType,NULL, NULL);
    memcpy(((PyVkMemoryRequirements*)return_value)->base,
           value, sizeof(VkMemoryRequirements));

    return return_value;
}

static PyObject* PyvkBindImageMemory(PyObject *self, PyObject *args,
                                     PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* image = NULL;
    PyObject* memory = NULL;
    PyObject* memoryOffset = NULL;
    static char *kwlist[] = {"device","image","memory","memoryOffset",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &image, &memory, &memoryOffset)) return NULL;

    struct {

        VkDevice device;

        VkImage image;

        VkDeviceMemory memory;

        VkDeviceSize memoryOffset;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.image = PyCapsule_GetPointer(image, "VkImage");

    return_struct.memory = PyCapsule_GetPointer(memory, "VkDeviceMemory");

    return_struct.memoryOffset = PyLong_AsLong(memoryOffset);

    vkBindImageMemory(return_struct.device,return_struct.image,return_struct.memory,return_struct.memoryOffset);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkGetImageSparseMemoryRequirements(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* image = NULL;
    static char *kwlist[] = {"device","image",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &image)) return NULL;

    struct {

        VkDevice device;

        VkImage image;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.image = PyCapsule_GetPointer(image, "VkImage");

    uint32_t count;
    vkGetImageSparseMemoryRequirements(return_struct.device,return_struct.image,&count, NULL);
    VkSparseImageMemoryRequirements *values = malloc(count*sizeof(VkSparseImageMemoryRequirements));

    vkGetImageSparseMemoryRequirements(return_struct.device,return_struct.image,&count, values);
    PyObject* return_value = PyList_New(0);
    uint32_t i;
    for (i=0; i<count; i++) {

        PyObject* pyreturn = PyObject_Call((PyObject *)&PyVkSparseImageMemoryRequirementsType,
                                           NULL, NULL);
        memcpy(((PyVkSparseImageMemoryRequirements*)pyreturn)->base,
               values + i, sizeof(VkSparseImageMemoryRequirements));

        PyList_Append(return_value, pyreturn);
    }

    return return_value;
}

static PyObject* PyvkGetPhysicalDeviceSparseImageFormatProperties(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* physicalDevice = NULL;
    PyObject* format = NULL;
    PyObject* type = NULL;
    PyObject* samples = NULL;
    PyObject* usage = NULL;
    PyObject* tiling = NULL;
    static char *kwlist[] = {"physicalDevice","format","type","samples","usage","tiling",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &physicalDevice, &format, &type, &samples, &usage, &tiling)) return NULL;

    struct {

        VkPhysicalDevice physicalDevice;

        VkFormat format;

        VkImageType type;

        VkSampleCountFlagBits samples;

        VkImageUsageFlags usage;

        VkImageTiling tiling;

    } return_struct = {};

    return_struct.physicalDevice = PyCapsule_GetPointer(physicalDevice, "VkPhysicalDevice");

    return_struct.format = PyLong_AsLong(format);

    return_struct.type = PyLong_AsLong(type);

    return_struct.samples = PyLong_AsLong(samples);

    return_struct.usage = PyLong_AsLong(usage);

    return_struct.tiling = PyLong_AsLong(tiling);

    uint32_t count;
    vkGetPhysicalDeviceSparseImageFormatProperties(return_struct.physicalDevice,return_struct.format,return_struct.type,return_struct.samples,return_struct.usage,return_struct.tiling,&count, NULL);
    VkSparseImageFormatProperties *values = malloc(count*sizeof(VkSparseImageFormatProperties));

    vkGetPhysicalDeviceSparseImageFormatProperties(return_struct.physicalDevice,return_struct.format,return_struct.type,return_struct.samples,return_struct.usage,return_struct.tiling,&count, values);
    PyObject* return_value = PyList_New(0);
    uint32_t i;
    for (i=0; i<count; i++) {

        PyObject* pyreturn = PyObject_Call((PyObject *)&PyVkSparseImageFormatPropertiesType,
                                           NULL, NULL);
        memcpy(((PyVkSparseImageFormatProperties*)pyreturn)->base,
               values + i, sizeof(VkSparseImageFormatProperties));

        PyList_Append(return_value, pyreturn);
    }

    return return_value;
}

static PyObject* PyvkQueueBindSparse(PyObject *self, PyObject *args,
                                     PyObject *kwds) {
    PyObject* queue = NULL;
    PyObject* bindInfoCount = NULL;
    PyObject* pBindInfo = NULL;
    PyObject* fence = NULL;
    static char *kwlist[] = {"queue","bindInfoCount","pBindInfo","fence",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &queue, &bindInfoCount, &pBindInfo, &fence)) return NULL;

    struct {

        VkQueue queue;

        uint32_t bindInfoCount;

        VkBindSparseInfo* pBindInfo;

        VkFence fence;

    } return_struct = {};

    return_struct.queue = PyCapsule_GetPointer(queue, "VkQueue");
    return_struct.bindInfoCount = (uint32_t) PyLong_AsLong(bindInfoCount);
    return_struct.pBindInfo = (((PyVkBindSparseInfo*)pBindInfo)->base);

    return_struct.fence = PyCapsule_GetPointer(fence, "VkFence");

    vkQueueBindSparse(return_struct.queue,return_struct.bindInfoCount,return_struct.pBindInfo,return_struct.fence);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCreateFence(PyObject *self, PyObject *args,
                                 PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"device","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pCreateInfo)) return NULL;

    struct {

        VkDevice device;

        VkFenceCreateInfo* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pCreateInfo = (((PyVkFenceCreateInfo*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkFence *value = malloc(sizeof(VkFence));
    if (raise(
                vkCreateFence(return_struct.device,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkFence", NULL);

    return return_value;
}

static PyObject* PyvkDestroyFence(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* fence = NULL;
    static char *kwlist[] = {"device","fence",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &fence)) return NULL;

    struct {

        VkDevice device;

        VkFence fence;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.fence = PyCapsule_GetPointer(fence, "VkFence");

    return_struct.pAllocator = NULL;

    vkDestroyFence(return_struct.device,return_struct.fence,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkResetFences(PyObject *self, PyObject *args,
                                 PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* fenceCount = NULL;
    PyObject* pFences = NULL;
    static char *kwlist[] = {"device","fenceCount","pFences",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &fenceCount, &pFences)) return NULL;

    struct {

        VkDevice device;

        uint32_t fenceCount;

        VkFence* pFences;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");
    return_struct.fenceCount = (uint32_t) PyLong_AsLong(fenceCount);
    return_struct.pFences = PyCapsule_GetPointer(pFences, "VkFence");

    vkResetFences(return_struct.device,return_struct.fenceCount,return_struct.pFences);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkGetFenceStatus(PyObject *self, PyObject *args,
                                    PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* fence = NULL;
    static char *kwlist[] = {"device","fence",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &fence)) return NULL;

    struct {

        VkDevice device;

        VkFence fence;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.fence = PyCapsule_GetPointer(fence, "VkFence");

    vkGetFenceStatus(return_struct.device,return_struct.fence);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkWaitForFences(PyObject *self, PyObject *args,
                                   PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* fenceCount = NULL;
    PyObject* pFences = NULL;
    PyObject* waitAll = NULL;
    PyObject* timeout = NULL;
    static char *kwlist[] = {"device","fenceCount","pFences","waitAll","timeout",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &device, &fenceCount, &pFences, &waitAll, &timeout)) return NULL;

    struct {

        VkDevice device;

        uint32_t fenceCount;

        VkFence* pFences;

        VkBool32 waitAll;

        uint64_t timeout;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");
    return_struct.fenceCount = (uint32_t) PyLong_AsLong(fenceCount);
    return_struct.pFences = PyCapsule_GetPointer(pFences, "VkFence");

    return_struct.waitAll = PyLong_AsLong(waitAll);
    return_struct.timeout = (uint64_t) PyLong_AsLong(timeout);
    vkWaitForFences(return_struct.device,return_struct.fenceCount,return_struct.pFences,return_struct.waitAll,return_struct.timeout);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCreateSemaphore(PyObject *self, PyObject *args,
                                     PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"device","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pCreateInfo)) return NULL;

    struct {

        VkDevice device;

        VkSemaphoreCreateInfo* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pCreateInfo = (((PyVkSemaphoreCreateInfo*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkSemaphore *value = malloc(sizeof(VkSemaphore));
    if (raise(
                vkCreateSemaphore(return_struct.device,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkSemaphore", NULL);

    return return_value;
}

static PyObject* PyvkDestroySemaphore(PyObject *self, PyObject *args,
                                      PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* semaphore = NULL;
    static char *kwlist[] = {"device","semaphore",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &semaphore)) return NULL;

    struct {

        VkDevice device;

        VkSemaphore semaphore;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.semaphore = PyCapsule_GetPointer(semaphore, "VkSemaphore");

    return_struct.pAllocator = NULL;

    vkDestroySemaphore(return_struct.device,return_struct.semaphore,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCreateEvent(PyObject *self, PyObject *args,
                                 PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"device","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pCreateInfo)) return NULL;

    struct {

        VkDevice device;

        VkEventCreateInfo* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pCreateInfo = (((PyVkEventCreateInfo*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkEvent *value = malloc(sizeof(VkEvent));
    if (raise(
                vkCreateEvent(return_struct.device,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkEvent", NULL);

    return return_value;
}

static PyObject* PyvkDestroyEvent(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* event = NULL;
    static char *kwlist[] = {"device","event",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &event)) return NULL;

    struct {

        VkDevice device;

        VkEvent event;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.event = PyCapsule_GetPointer(event, "VkEvent");

    return_struct.pAllocator = NULL;

    vkDestroyEvent(return_struct.device,return_struct.event,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkGetEventStatus(PyObject *self, PyObject *args,
                                    PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* event = NULL;
    static char *kwlist[] = {"device","event",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &event)) return NULL;

    struct {

        VkDevice device;

        VkEvent event;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.event = PyCapsule_GetPointer(event, "VkEvent");

    vkGetEventStatus(return_struct.device,return_struct.event);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkSetEvent(PyObject *self, PyObject *args,
                              PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* event = NULL;
    static char *kwlist[] = {"device","event",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &event)) return NULL;

    struct {

        VkDevice device;

        VkEvent event;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.event = PyCapsule_GetPointer(event, "VkEvent");

    vkSetEvent(return_struct.device,return_struct.event);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkResetEvent(PyObject *self, PyObject *args,
                                PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* event = NULL;
    static char *kwlist[] = {"device","event",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &event)) return NULL;

    struct {

        VkDevice device;

        VkEvent event;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.event = PyCapsule_GetPointer(event, "VkEvent");

    vkResetEvent(return_struct.device,return_struct.event);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCreateQueryPool(PyObject *self, PyObject *args,
                                     PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"device","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pCreateInfo)) return NULL;

    struct {

        VkDevice device;

        VkQueryPoolCreateInfo* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pCreateInfo = (((PyVkQueryPoolCreateInfo*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkQueryPool *value = malloc(sizeof(VkQueryPool));
    if (raise(
                vkCreateQueryPool(return_struct.device,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkQueryPool", NULL);

    return return_value;
}

static PyObject* PyvkDestroyQueryPool(PyObject *self, PyObject *args,
                                      PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* queryPool = NULL;
    static char *kwlist[] = {"device","queryPool",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &queryPool)) return NULL;

    struct {

        VkDevice device;

        VkQueryPool queryPool;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.queryPool = PyCapsule_GetPointer(queryPool, "VkQueryPool");

    return_struct.pAllocator = NULL;

    vkDestroyQueryPool(return_struct.device,return_struct.queryPool,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkGetQueryPoolResults(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* queryPool = NULL;
    PyObject* firstQuery = NULL;
    PyObject* queryCount = NULL;
    PyObject* dataSize = NULL;
    PyObject* pData = NULL;
    PyObject* stride = NULL;
    PyObject* flags = NULL;
    static char *kwlist[] = {"device","queryPool","firstQuery","queryCount","dataSize","pData","stride","flags",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOO", kwlist, &device, &queryPool, &firstQuery, &queryCount, &dataSize, &pData, &stride, &flags)) return NULL;

    struct {

        VkDevice device;

        VkQueryPool queryPool;

        uint32_t firstQuery;

        uint32_t queryCount;

        size_t dataSize;

        void* pData;

        VkDeviceSize stride;

        VkQueryResultFlags flags;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.queryPool = PyCapsule_GetPointer(queryPool, "VkQueryPool");
    return_struct.firstQuery = (uint32_t) PyLong_AsLong(firstQuery);
    return_struct.queryCount = (uint32_t) PyLong_AsLong(queryCount);
    return_struct.dataSize = (size_t) PyLong_AsLong(dataSize);
    return_struct.pData = NULL;
    return_struct.stride = PyLong_AsLong(stride);

    return_struct.flags = PyLong_AsLong(flags);

    vkGetQueryPoolResults(return_struct.device,return_struct.queryPool,return_struct.firstQuery,return_struct.queryCount,return_struct.dataSize,return_struct.pData,return_struct.stride,return_struct.flags);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCreateBuffer(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"device","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pCreateInfo)) return NULL;

    struct {

        VkDevice device;

        VkBufferCreateInfo* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pCreateInfo = (((PyVkBufferCreateInfo*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkBuffer *value = malloc(sizeof(VkBuffer));
    if (raise(
                vkCreateBuffer(return_struct.device,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkBuffer", NULL);

    return return_value;
}

static PyObject* PyvkDestroyBuffer(PyObject *self, PyObject *args,
                                   PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* buffer = NULL;
    static char *kwlist[] = {"device","buffer",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &buffer)) return NULL;

    struct {

        VkDevice device;

        VkBuffer buffer;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.buffer = PyCapsule_GetPointer(buffer, "VkBuffer");

    return_struct.pAllocator = NULL;

    vkDestroyBuffer(return_struct.device,return_struct.buffer,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCreateBufferView(PyObject *self, PyObject *args,
                                      PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"device","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pCreateInfo)) return NULL;

    struct {

        VkDevice device;

        VkBufferViewCreateInfo* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pCreateInfo = (((PyVkBufferViewCreateInfo*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkBufferView *value = malloc(sizeof(VkBufferView));
    if (raise(
                vkCreateBufferView(return_struct.device,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkBufferView", NULL);

    return return_value;
}

static PyObject* PyvkDestroyBufferView(PyObject *self, PyObject *args,
                                       PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* bufferView = NULL;
    static char *kwlist[] = {"device","bufferView",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &bufferView)) return NULL;

    struct {

        VkDevice device;

        VkBufferView bufferView;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.bufferView = PyCapsule_GetPointer(bufferView, "VkBufferView");

    return_struct.pAllocator = NULL;

    vkDestroyBufferView(return_struct.device,return_struct.bufferView,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCreateImage(PyObject *self, PyObject *args,
                                 PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"device","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pCreateInfo)) return NULL;

    struct {

        VkDevice device;

        VkImageCreateInfo* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pCreateInfo = (((PyVkImageCreateInfo*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkImage *value = malloc(sizeof(VkImage));
    if (raise(
                vkCreateImage(return_struct.device,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkImage", NULL);

    return return_value;
}

static PyObject* PyvkDestroyImage(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* image = NULL;
    static char *kwlist[] = {"device","image",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &image)) return NULL;

    struct {

        VkDevice device;

        VkImage image;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.image = PyCapsule_GetPointer(image, "VkImage");

    return_struct.pAllocator = NULL;

    vkDestroyImage(return_struct.device,return_struct.image,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkGetImageSubresourceLayout(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* image = NULL;
    PyObject* pSubresource = NULL;
    static char *kwlist[] = {"device","image","pSubresource",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &image, &pSubresource)) return NULL;

    struct {

        VkDevice device;

        VkImage image;

        VkImageSubresource* pSubresource;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.image = PyCapsule_GetPointer(image, "VkImage");

    return_struct.pSubresource = (((PyVkImageSubresource*)pSubresource)->base);

    VkSubresourceLayout *value = malloc(sizeof(VkSubresourceLayout));

    vkGetImageSubresourceLayout(return_struct.device,return_struct.image,return_struct.pSubresource,value);
    PyObject* return_value =
        PyObject_Call((PyObject *)&PyVkSubresourceLayoutType,NULL, NULL);
    memcpy(((PyVkSubresourceLayout*)return_value)->base,
           value, sizeof(VkSubresourceLayout));

    return return_value;
}

static PyObject* PyvkCreateImageView(PyObject *self, PyObject *args,
                                     PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"device","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pCreateInfo)) return NULL;

    struct {

        VkDevice device;

        VkImageViewCreateInfo* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pCreateInfo = (((PyVkImageViewCreateInfo*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkImageView *value = malloc(sizeof(VkImageView));
    if (raise(
                vkCreateImageView(return_struct.device,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkImageView", NULL);

    return return_value;
}

static PyObject* PyvkDestroyImageView(PyObject *self, PyObject *args,
                                      PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* imageView = NULL;
    static char *kwlist[] = {"device","imageView",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &imageView)) return NULL;

    struct {

        VkDevice device;

        VkImageView imageView;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.imageView = PyCapsule_GetPointer(imageView, "VkImageView");

    return_struct.pAllocator = NULL;

    vkDestroyImageView(return_struct.device,return_struct.imageView,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCreateShaderModule(PyObject *self, PyObject *args,
                                        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"device","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pCreateInfo)) return NULL;

    struct {

        VkDevice device;

        VkShaderModuleCreateInfo* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pCreateInfo = (((PyVkShaderModuleCreateInfo*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkShaderModule *value = malloc(sizeof(VkShaderModule));
    if (raise(
                vkCreateShaderModule(return_struct.device,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkShaderModule", NULL);

    return return_value;
}

static PyObject* PyvkDestroyShaderModule(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* shaderModule = NULL;
    static char *kwlist[] = {"device","shaderModule",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &shaderModule)) return NULL;

    struct {

        VkDevice device;

        VkShaderModule shaderModule;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.shaderModule = PyCapsule_GetPointer(shaderModule, "VkShaderModule");

    return_struct.pAllocator = NULL;

    vkDestroyShaderModule(return_struct.device,return_struct.shaderModule,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCreatePipelineCache(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"device","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pCreateInfo)) return NULL;

    struct {

        VkDevice device;

        VkPipelineCacheCreateInfo* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pCreateInfo = (((PyVkPipelineCacheCreateInfo*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkPipelineCache *value = malloc(sizeof(VkPipelineCache));
    if (raise(
                vkCreatePipelineCache(return_struct.device,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkPipelineCache", NULL);

    return return_value;
}

static PyObject* PyvkDestroyPipelineCache(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pipelineCache = NULL;
    static char *kwlist[] = {"device","pipelineCache",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pipelineCache)) return NULL;

    struct {

        VkDevice device;

        VkPipelineCache pipelineCache;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pipelineCache = PyCapsule_GetPointer(pipelineCache, "VkPipelineCache");

    return_struct.pAllocator = NULL;

    vkDestroyPipelineCache(return_struct.device,return_struct.pipelineCache,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkGetPipelineCacheData(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pipelineCache = NULL;
    PyObject* pDataSize = NULL;
    static char *kwlist[] = {"device","pipelineCache","pDataSize",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &pipelineCache, &pDataSize)) return NULL;

    struct {

        VkDevice device;

        VkPipelineCache pipelineCache;

        size_t* pDataSize;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pipelineCache = PyCapsule_GetPointer(pipelineCache, "VkPipelineCache");

    void* value = NULL;
    size_t* data_size = NULL;
    if (raise(
                vkGetPipelineCacheData(
                    return_struct.device, return_struct.pipelineCache,
                    data_size, value)
            )) return NULL;
    PyObject* return_value = PyMemoryView_FromMemory(value,
                             *data_size, PyBUF_WRITE);

    return return_value;
}

static PyObject* PyvkMergePipelineCaches(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* dstCache = NULL;
    PyObject* srcCacheCount = NULL;
    PyObject* pSrcCaches = NULL;
    static char *kwlist[] = {"device","dstCache","srcCacheCount","pSrcCaches",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &dstCache, &srcCacheCount, &pSrcCaches)) return NULL;

    struct {

        VkDevice device;

        VkPipelineCache dstCache;

        uint32_t srcCacheCount;

        VkPipelineCache* pSrcCaches;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.dstCache = PyCapsule_GetPointer(dstCache, "VkPipelineCache");
    return_struct.srcCacheCount = (uint32_t) PyLong_AsLong(srcCacheCount);
    return_struct.pSrcCaches = PyCapsule_GetPointer(pSrcCaches, "VkPipelineCache");

    vkMergePipelineCaches(return_struct.device,return_struct.dstCache,return_struct.srcCacheCount,return_struct.pSrcCaches);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCreateGraphicsPipelines(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pipelineCache = NULL;
    PyObject* createInfoCount = NULL;
    PyObject* pCreateInfos = NULL;
    static char *kwlist[] = {"device","pipelineCache","createInfoCount","pCreateInfos",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pipelineCache, &createInfoCount, &pCreateInfos)) return NULL;

    struct {

        VkDevice device;

        VkPipelineCache pipelineCache;

        uint32_t createInfoCount;

        VkGraphicsPipelineCreateInfo* pCreateInfos;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pipelineCache = PyCapsule_GetPointer(pipelineCache, "VkPipelineCache");
    return_struct.createInfoCount = (uint32_t) PyLong_AsLong(createInfoCount);
    return_struct.pCreateInfos = (((PyVkGraphicsPipelineCreateInfo*)pCreateInfos)->base);

    return_struct.pAllocator = NULL;

    VkPipeline *value = malloc(sizeof(VkPipeline));
    if (raise(
                vkCreateGraphicsPipelines(return_struct.device,return_struct.pipelineCache,return_struct.createInfoCount,return_struct.pCreateInfos,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkPipeline", NULL);

    return return_value;
}

static PyObject* PyvkCreateComputePipelines(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pipelineCache = NULL;
    PyObject* createInfoCount = NULL;
    PyObject* pCreateInfos = NULL;
    static char *kwlist[] = {"device","pipelineCache","createInfoCount","pCreateInfos",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &pipelineCache, &createInfoCount, &pCreateInfos)) return NULL;

    struct {

        VkDevice device;

        VkPipelineCache pipelineCache;

        uint32_t createInfoCount;

        VkComputePipelineCreateInfo* pCreateInfos;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pipelineCache = PyCapsule_GetPointer(pipelineCache, "VkPipelineCache");
    return_struct.createInfoCount = (uint32_t) PyLong_AsLong(createInfoCount);
    return_struct.pCreateInfos = (((PyVkComputePipelineCreateInfo*)pCreateInfos)->base);

    return_struct.pAllocator = NULL;

    VkPipeline *value = malloc(sizeof(VkPipeline));
    if (raise(
                vkCreateComputePipelines(return_struct.device,return_struct.pipelineCache,return_struct.createInfoCount,return_struct.pCreateInfos,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkPipeline", NULL);

    return return_value;
}

static PyObject* PyvkDestroyPipeline(PyObject *self, PyObject *args,
                                     PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pipeline = NULL;
    static char *kwlist[] = {"device","pipeline",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pipeline)) return NULL;

    struct {

        VkDevice device;

        VkPipeline pipeline;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pipeline = PyCapsule_GetPointer(pipeline, "VkPipeline");

    return_struct.pAllocator = NULL;

    vkDestroyPipeline(return_struct.device,return_struct.pipeline,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCreatePipelineLayout(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"device","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pCreateInfo)) return NULL;

    struct {

        VkDevice device;

        VkPipelineLayoutCreateInfo* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pCreateInfo = (((PyVkPipelineLayoutCreateInfo*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkPipelineLayout *value = malloc(sizeof(VkPipelineLayout));
    if (raise(
                vkCreatePipelineLayout(return_struct.device,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkPipelineLayout", NULL);

    return return_value;
}

static PyObject* PyvkDestroyPipelineLayout(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pipelineLayout = NULL;
    static char *kwlist[] = {"device","pipelineLayout",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pipelineLayout)) return NULL;

    struct {

        VkDevice device;

        VkPipelineLayout pipelineLayout;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pipelineLayout = PyCapsule_GetPointer(pipelineLayout, "VkPipelineLayout");

    return_struct.pAllocator = NULL;

    vkDestroyPipelineLayout(return_struct.device,return_struct.pipelineLayout,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCreateSampler(PyObject *self, PyObject *args,
                                   PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"device","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pCreateInfo)) return NULL;

    struct {

        VkDevice device;

        VkSamplerCreateInfo* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pCreateInfo = (((PyVkSamplerCreateInfo*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkSampler *value = malloc(sizeof(VkSampler));
    if (raise(
                vkCreateSampler(return_struct.device,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkSampler", NULL);

    return return_value;
}

static PyObject* PyvkDestroySampler(PyObject *self, PyObject *args,
                                    PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* sampler = NULL;
    static char *kwlist[] = {"device","sampler",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &sampler)) return NULL;

    struct {

        VkDevice device;

        VkSampler sampler;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.sampler = PyCapsule_GetPointer(sampler, "VkSampler");

    return_struct.pAllocator = NULL;

    vkDestroySampler(return_struct.device,return_struct.sampler,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCreateDescriptorSetLayout(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"device","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pCreateInfo)) return NULL;

    struct {

        VkDevice device;

        VkDescriptorSetLayoutCreateInfo* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pCreateInfo = (((PyVkDescriptorSetLayoutCreateInfo*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkDescriptorSetLayout *value = malloc(sizeof(VkDescriptorSetLayout));
    if (raise(
                vkCreateDescriptorSetLayout(return_struct.device,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkDescriptorSetLayout", NULL);

    return return_value;
}

static PyObject* PyvkDestroyDescriptorSetLayout(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* descriptorSetLayout = NULL;
    static char *kwlist[] = {"device","descriptorSetLayout",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &descriptorSetLayout)) return NULL;

    struct {

        VkDevice device;

        VkDescriptorSetLayout descriptorSetLayout;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.descriptorSetLayout = PyCapsule_GetPointer(descriptorSetLayout, "VkDescriptorSetLayout");

    return_struct.pAllocator = NULL;

    vkDestroyDescriptorSetLayout(return_struct.device,return_struct.descriptorSetLayout,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCreateDescriptorPool(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"device","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pCreateInfo)) return NULL;

    struct {

        VkDevice device;

        VkDescriptorPoolCreateInfo* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pCreateInfo = (((PyVkDescriptorPoolCreateInfo*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkDescriptorPool *value = malloc(sizeof(VkDescriptorPool));
    if (raise(
                vkCreateDescriptorPool(return_struct.device,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkDescriptorPool", NULL);

    return return_value;
}

static PyObject* PyvkDestroyDescriptorPool(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* descriptorPool = NULL;
    static char *kwlist[] = {"device","descriptorPool",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &descriptorPool)) return NULL;

    struct {

        VkDevice device;

        VkDescriptorPool descriptorPool;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.descriptorPool = PyCapsule_GetPointer(descriptorPool, "VkDescriptorPool");

    return_struct.pAllocator = NULL;

    vkDestroyDescriptorPool(return_struct.device,return_struct.descriptorPool,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkResetDescriptorPool(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* descriptorPool = NULL;
    PyObject* flags = NULL;
    static char *kwlist[] = {"device","descriptorPool","flags",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &descriptorPool, &flags)) return NULL;

    struct {

        VkDevice device;

        VkDescriptorPool descriptorPool;

        VkDescriptorPoolResetFlags flags;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.descriptorPool = PyCapsule_GetPointer(descriptorPool, "VkDescriptorPool");

    return_struct.flags = PyLong_AsLong(flags);

    vkResetDescriptorPool(return_struct.device,return_struct.descriptorPool,return_struct.flags);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkAllocateDescriptorSets(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pAllocateInfo = NULL;
    static char *kwlist[] = {"device","pAllocateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pAllocateInfo)) return NULL;

    struct {

        VkDevice device;

        VkDescriptorSetAllocateInfo* pAllocateInfo;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pAllocateInfo = (((PyVkDescriptorSetAllocateInfo*)pAllocateInfo)->base);

    VkDescriptorSet *value = malloc(sizeof(VkDescriptorSet));
    if (raise(
                vkAllocateDescriptorSets(return_struct.device,return_struct.pAllocateInfo,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkDescriptorSet", NULL);

    return return_value;
}

static PyObject* PyvkFreeDescriptorSets(PyObject *self, PyObject *args,
                                        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* descriptorPool = NULL;
    PyObject* descriptorSetCount = NULL;
    PyObject* pDescriptorSets = NULL;
    static char *kwlist[] = {"device","descriptorPool","descriptorSetCount","pDescriptorSets",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &descriptorPool, &descriptorSetCount, &pDescriptorSets)) return NULL;

    struct {

        VkDevice device;

        VkDescriptorPool descriptorPool;

        uint32_t descriptorSetCount;

        VkDescriptorSet* pDescriptorSets;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.descriptorPool = PyCapsule_GetPointer(descriptorPool, "VkDescriptorPool");
    return_struct.descriptorSetCount = (uint32_t) PyLong_AsLong(descriptorSetCount);
    return_struct.pDescriptorSets = PyCapsule_GetPointer(pDescriptorSets, "VkDescriptorSet");

    vkFreeDescriptorSets(return_struct.device,return_struct.descriptorPool,return_struct.descriptorSetCount,return_struct.pDescriptorSets);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkUpdateDescriptorSets(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* descriptorWriteCount = NULL;
    PyObject* pDescriptorWrites = NULL;
    PyObject* descriptorCopyCount = NULL;
    PyObject* pDescriptorCopies = NULL;
    static char *kwlist[] = {"device","descriptorWriteCount","pDescriptorWrites","descriptorCopyCount","pDescriptorCopies",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &device, &descriptorWriteCount, &pDescriptorWrites, &descriptorCopyCount, &pDescriptorCopies)) return NULL;

    struct {

        VkDevice device;

        uint32_t descriptorWriteCount;

        VkWriteDescriptorSet* pDescriptorWrites;

        uint32_t descriptorCopyCount;

        VkCopyDescriptorSet* pDescriptorCopies;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");
    return_struct.descriptorWriteCount = (uint32_t) PyLong_AsLong(descriptorWriteCount);
    return_struct.pDescriptorWrites = (((PyVkWriteDescriptorSet*)pDescriptorWrites)->base);
    return_struct.descriptorCopyCount = (uint32_t) PyLong_AsLong(descriptorCopyCount);
    return_struct.pDescriptorCopies = (((PyVkCopyDescriptorSet*)pDescriptorCopies)->base);

    vkUpdateDescriptorSets(return_struct.device,return_struct.descriptorWriteCount,return_struct.pDescriptorWrites,return_struct.descriptorCopyCount,return_struct.pDescriptorCopies);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCreateFramebuffer(PyObject *self, PyObject *args,
                                       PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"device","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pCreateInfo)) return NULL;

    struct {

        VkDevice device;

        VkFramebufferCreateInfo* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pCreateInfo = (((PyVkFramebufferCreateInfo*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkFramebuffer *value = malloc(sizeof(VkFramebuffer));
    if (raise(
                vkCreateFramebuffer(return_struct.device,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkFramebuffer", NULL);

    return return_value;
}

static PyObject* PyvkDestroyFramebuffer(PyObject *self, PyObject *args,
                                        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* framebuffer = NULL;
    static char *kwlist[] = {"device","framebuffer",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &framebuffer)) return NULL;

    struct {

        VkDevice device;

        VkFramebuffer framebuffer;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.framebuffer = PyCapsule_GetPointer(framebuffer, "VkFramebuffer");

    return_struct.pAllocator = NULL;

    vkDestroyFramebuffer(return_struct.device,return_struct.framebuffer,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCreateRenderPass(PyObject *self, PyObject *args,
                                      PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"device","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pCreateInfo)) return NULL;

    struct {

        VkDevice device;

        VkRenderPassCreateInfo* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pCreateInfo = (((PyVkRenderPassCreateInfo*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkRenderPass *value = malloc(sizeof(VkRenderPass));
    if (raise(
                vkCreateRenderPass(return_struct.device,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkRenderPass", NULL);

    return return_value;
}

static PyObject* PyvkDestroyRenderPass(PyObject *self, PyObject *args,
                                       PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* renderPass = NULL;
    static char *kwlist[] = {"device","renderPass",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &renderPass)) return NULL;

    struct {

        VkDevice device;

        VkRenderPass renderPass;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.renderPass = PyCapsule_GetPointer(renderPass, "VkRenderPass");

    return_struct.pAllocator = NULL;

    vkDestroyRenderPass(return_struct.device,return_struct.renderPass,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkGetRenderAreaGranularity(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* renderPass = NULL;
    static char *kwlist[] = {"device","renderPass",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &renderPass)) return NULL;

    struct {

        VkDevice device;

        VkRenderPass renderPass;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.renderPass = PyCapsule_GetPointer(renderPass, "VkRenderPass");

    VkExtent2D *value = malloc(sizeof(VkExtent2D));

    vkGetRenderAreaGranularity(return_struct.device,return_struct.renderPass,value);
    PyObject* return_value =
        PyObject_Call((PyObject *)&PyVkExtent2DType,NULL, NULL);
    memcpy(((PyVkExtent2D*)return_value)->base,
           value, sizeof(VkExtent2D));

    return return_value;
}

static PyObject* PyvkCreateCommandPool(PyObject *self, PyObject *args,
                                       PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pCreateInfo = NULL;
    static char *kwlist[] = {"device","pCreateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pCreateInfo)) return NULL;

    struct {

        VkDevice device;

        VkCommandPoolCreateInfo* pCreateInfo;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pCreateInfo = (((PyVkCommandPoolCreateInfo*)pCreateInfo)->base);

    return_struct.pAllocator = NULL;

    VkCommandPool *value = malloc(sizeof(VkCommandPool));
    if (raise(
                vkCreateCommandPool(return_struct.device,return_struct.pCreateInfo,return_struct.pAllocator,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkCommandPool", NULL);

    return return_value;
}

static PyObject* PyvkDestroyCommandPool(PyObject *self, PyObject *args,
                                        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* commandPool = NULL;
    static char *kwlist[] = {"device","commandPool",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &commandPool)) return NULL;

    struct {

        VkDevice device;

        VkCommandPool commandPool;

        VkAllocationCallbacks* pAllocator;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.commandPool = PyCapsule_GetPointer(commandPool, "VkCommandPool");

    return_struct.pAllocator = NULL;

    vkDestroyCommandPool(return_struct.device,return_struct.commandPool,return_struct.pAllocator);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkResetCommandPool(PyObject *self, PyObject *args,
                                      PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* commandPool = NULL;
    PyObject* flags = NULL;
    static char *kwlist[] = {"device","commandPool","flags",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &device, &commandPool, &flags)) return NULL;

    struct {

        VkDevice device;

        VkCommandPool commandPool;

        VkCommandPoolResetFlags flags;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.commandPool = PyCapsule_GetPointer(commandPool, "VkCommandPool");

    return_struct.flags = PyLong_AsLong(flags);

    vkResetCommandPool(return_struct.device,return_struct.commandPool,return_struct.flags);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkAllocateCommandBuffers(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* pAllocateInfo = NULL;
    static char *kwlist[] = {"device","pAllocateInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &device, &pAllocateInfo)) return NULL;

    struct {

        VkDevice device;

        VkCommandBufferAllocateInfo* pAllocateInfo;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.pAllocateInfo = (((PyVkCommandBufferAllocateInfo*)pAllocateInfo)->base);

    VkCommandBuffer *value = malloc(sizeof(VkCommandBuffer));
    if (raise(
                vkAllocateCommandBuffers(return_struct.device,return_struct.pAllocateInfo,value))) return NULL;
    PyObject* return_value = PyCapsule_New(value, "VkCommandBuffer", NULL);

    return return_value;
}

static PyObject* PyvkFreeCommandBuffers(PyObject *self, PyObject *args,
                                        PyObject *kwds) {
    PyObject* device = NULL;
    PyObject* commandPool = NULL;
    PyObject* commandBufferCount = NULL;
    PyObject* pCommandBuffers = NULL;
    static char *kwlist[] = {"device","commandPool","commandBufferCount","pCommandBuffers",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &device, &commandPool, &commandBufferCount, &pCommandBuffers)) return NULL;

    struct {

        VkDevice device;

        VkCommandPool commandPool;

        uint32_t commandBufferCount;

        VkCommandBuffer* pCommandBuffers;

    } return_struct = {};

    return_struct.device = PyCapsule_GetPointer(device, "VkDevice");

    return_struct.commandPool = PyCapsule_GetPointer(commandPool, "VkCommandPool");
    return_struct.commandBufferCount = (uint32_t) PyLong_AsLong(commandBufferCount);
    return_struct.pCommandBuffers = PyCapsule_GetPointer(pCommandBuffers, "VkCommandBuffer");

    vkFreeCommandBuffers(return_struct.device,return_struct.commandPool,return_struct.commandBufferCount,return_struct.pCommandBuffers);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkBeginCommandBuffer(PyObject *self, PyObject *args,
                                        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* pBeginInfo = NULL;
    static char *kwlist[] = {"commandBuffer","pBeginInfo",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &commandBuffer, &pBeginInfo)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkCommandBufferBeginInfo* pBeginInfo;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.pBeginInfo = (((PyVkCommandBufferBeginInfo*)pBeginInfo)->base);

    vkBeginCommandBuffer(return_struct.commandBuffer,return_struct.pBeginInfo);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkEndCommandBuffer(PyObject *self, PyObject *args,
                                      PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    static char *kwlist[] = {"commandBuffer",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &commandBuffer)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    vkEndCommandBuffer(return_struct.commandBuffer);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkResetCommandBuffer(PyObject *self, PyObject *args,
                                        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* flags = NULL;
    static char *kwlist[] = {"commandBuffer","flags",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &commandBuffer, &flags)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkCommandBufferResetFlags flags;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.flags = PyLong_AsLong(flags);

    vkResetCommandBuffer(return_struct.commandBuffer,return_struct.flags);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdBindPipeline(PyObject *self, PyObject *args,
                                     PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* pipelineBindPoint = NULL;
    PyObject* pipeline = NULL;
    static char *kwlist[] = {"commandBuffer","pipelineBindPoint","pipeline",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &pipelineBindPoint, &pipeline)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkPipelineBindPoint pipelineBindPoint;

        VkPipeline pipeline;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.pipelineBindPoint = PyLong_AsLong(pipelineBindPoint);

    return_struct.pipeline = PyCapsule_GetPointer(pipeline, "VkPipeline");

    vkCmdBindPipeline(return_struct.commandBuffer,return_struct.pipelineBindPoint,return_struct.pipeline);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdSetViewport(PyObject *self, PyObject *args,
                                    PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* firstViewport = NULL;
    PyObject* viewportCount = NULL;
    PyObject* pViewports = NULL;
    static char *kwlist[] = {"commandBuffer","firstViewport","viewportCount","pViewports",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &commandBuffer, &firstViewport, &viewportCount, &pViewports)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        uint32_t firstViewport;

        uint32_t viewportCount;

        VkViewport* pViewports;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");
    return_struct.firstViewport = (uint32_t) PyLong_AsLong(firstViewport);
    return_struct.viewportCount = (uint32_t) PyLong_AsLong(viewportCount);
    return_struct.pViewports = (((PyVkViewport*)pViewports)->base);

    vkCmdSetViewport(return_struct.commandBuffer,return_struct.firstViewport,return_struct.viewportCount,return_struct.pViewports);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdSetScissor(PyObject *self, PyObject *args,
                                   PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* firstScissor = NULL;
    PyObject* scissorCount = NULL;
    PyObject* pScissors = NULL;
    static char *kwlist[] = {"commandBuffer","firstScissor","scissorCount","pScissors",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &commandBuffer, &firstScissor, &scissorCount, &pScissors)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        uint32_t firstScissor;

        uint32_t scissorCount;

        VkRect2D* pScissors;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");
    return_struct.firstScissor = (uint32_t) PyLong_AsLong(firstScissor);
    return_struct.scissorCount = (uint32_t) PyLong_AsLong(scissorCount);
    return_struct.pScissors = (((PyVkRect2D*)pScissors)->base);

    vkCmdSetScissor(return_struct.commandBuffer,return_struct.firstScissor,return_struct.scissorCount,return_struct.pScissors);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdSetLineWidth(PyObject *self, PyObject *args,
                                     PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* lineWidth = NULL;
    static char *kwlist[] = {"commandBuffer","lineWidth",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &commandBuffer, &lineWidth)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        float lineWidth;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");
    return_struct.lineWidth = (float) PyFloat_AsDouble(lineWidth);
    vkCmdSetLineWidth(return_struct.commandBuffer,return_struct.lineWidth);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdSetDepthBias(PyObject *self, PyObject *args,
                                     PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* depthBiasConstantFactor = NULL;
    PyObject* depthBiasClamp = NULL;
    PyObject* depthBiasSlopeFactor = NULL;
    static char *kwlist[] = {"commandBuffer","depthBiasConstantFactor","depthBiasClamp","depthBiasSlopeFactor",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &commandBuffer, &depthBiasConstantFactor, &depthBiasClamp, &depthBiasSlopeFactor)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        float depthBiasConstantFactor;

        float depthBiasClamp;

        float depthBiasSlopeFactor;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");
    return_struct.depthBiasConstantFactor = (float) PyFloat_AsDouble(depthBiasConstantFactor);
    return_struct.depthBiasClamp = (float) PyFloat_AsDouble(depthBiasClamp);
    return_struct.depthBiasSlopeFactor = (float) PyFloat_AsDouble(depthBiasSlopeFactor);
    vkCmdSetDepthBias(return_struct.commandBuffer,return_struct.depthBiasConstantFactor,return_struct.depthBiasClamp,return_struct.depthBiasSlopeFactor);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdSetBlendConstants(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* blendConstants = NULL;
    static char *kwlist[] = {"commandBuffer","blendConstants",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &commandBuffer, &blendConstants)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        float* blendConstants;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    vkCmdSetBlendConstants(return_struct.commandBuffer,return_struct.blendConstants);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdSetDepthBounds(PyObject *self, PyObject *args,
                                       PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* minDepthBounds = NULL;
    PyObject* maxDepthBounds = NULL;
    static char *kwlist[] = {"commandBuffer","minDepthBounds","maxDepthBounds",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &minDepthBounds, &maxDepthBounds)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        float minDepthBounds;

        float maxDepthBounds;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");
    return_struct.minDepthBounds = (float) PyFloat_AsDouble(minDepthBounds);
    return_struct.maxDepthBounds = (float) PyFloat_AsDouble(maxDepthBounds);
    vkCmdSetDepthBounds(return_struct.commandBuffer,return_struct.minDepthBounds,return_struct.maxDepthBounds);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdSetStencilCompareMask(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* faceMask = NULL;
    PyObject* compareMask = NULL;
    static char *kwlist[] = {"commandBuffer","faceMask","compareMask",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &faceMask, &compareMask)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkStencilFaceFlags faceMask;

        uint32_t compareMask;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.faceMask = PyLong_AsLong(faceMask);
    return_struct.compareMask = (uint32_t) PyLong_AsLong(compareMask);
    vkCmdSetStencilCompareMask(return_struct.commandBuffer,return_struct.faceMask,return_struct.compareMask);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdSetStencilWriteMask(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* faceMask = NULL;
    PyObject* writeMask = NULL;
    static char *kwlist[] = {"commandBuffer","faceMask","writeMask",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &faceMask, &writeMask)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkStencilFaceFlags faceMask;

        uint32_t writeMask;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.faceMask = PyLong_AsLong(faceMask);
    return_struct.writeMask = (uint32_t) PyLong_AsLong(writeMask);
    vkCmdSetStencilWriteMask(return_struct.commandBuffer,return_struct.faceMask,return_struct.writeMask);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdSetStencilReference(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* faceMask = NULL;
    PyObject* reference = NULL;
    static char *kwlist[] = {"commandBuffer","faceMask","reference",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &faceMask, &reference)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkStencilFaceFlags faceMask;

        uint32_t reference;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.faceMask = PyLong_AsLong(faceMask);
    return_struct.reference = (uint32_t) PyLong_AsLong(reference);
    vkCmdSetStencilReference(return_struct.commandBuffer,return_struct.faceMask,return_struct.reference);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdBindDescriptorSets(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* pipelineBindPoint = NULL;
    PyObject* layout = NULL;
    PyObject* firstSet = NULL;
    PyObject* descriptorSetCount = NULL;
    PyObject* pDescriptorSets = NULL;
    PyObject* dynamicOffsetCount = NULL;
    PyObject* pDynamicOffsets = NULL;
    static char *kwlist[] = {"commandBuffer","pipelineBindPoint","layout","firstSet","descriptorSetCount","pDescriptorSets","dynamicOffsetCount","pDynamicOffsets",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOO", kwlist, &commandBuffer, &pipelineBindPoint, &layout, &firstSet, &descriptorSetCount, &pDescriptorSets, &dynamicOffsetCount, &pDynamicOffsets)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkPipelineBindPoint pipelineBindPoint;

        VkPipelineLayout layout;

        uint32_t firstSet;

        uint32_t descriptorSetCount;

        VkDescriptorSet* pDescriptorSets;

        uint32_t dynamicOffsetCount;

        uint32_t* pDynamicOffsets;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.pipelineBindPoint = PyLong_AsLong(pipelineBindPoint);

    return_struct.layout = PyCapsule_GetPointer(layout, "VkPipelineLayout");
    return_struct.firstSet = (uint32_t) PyLong_AsLong(firstSet);
    return_struct.descriptorSetCount = (uint32_t) PyLong_AsLong(descriptorSetCount);
    return_struct.pDescriptorSets = PyCapsule_GetPointer(pDescriptorSets, "VkDescriptorSet");
    return_struct.dynamicOffsetCount = (uint32_t) PyLong_AsLong(dynamicOffsetCount);
    uint32_t tmp67230381 = (uint32_t) PyLong_AsLong(pDynamicOffsets);
    uint32_t *tmp28974357 = malloc(sizeof(uint32_t));
    memcpy(tmp28974357, &tmp67230381, sizeof(uint32_t));
    return_struct.pDynamicOffsets = tmp28974357;

    vkCmdBindDescriptorSets(return_struct.commandBuffer,return_struct.pipelineBindPoint,return_struct.layout,return_struct.firstSet,return_struct.descriptorSetCount,return_struct.pDescriptorSets,return_struct.dynamicOffsetCount,return_struct.pDynamicOffsets);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdBindIndexBuffer(PyObject *self, PyObject *args,
                                        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* buffer = NULL;
    PyObject* offset = NULL;
    PyObject* indexType = NULL;
    static char *kwlist[] = {"commandBuffer","buffer","offset","indexType",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &commandBuffer, &buffer, &offset, &indexType)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkBuffer buffer;

        VkDeviceSize offset;

        VkIndexType indexType;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.buffer = PyCapsule_GetPointer(buffer, "VkBuffer");

    return_struct.offset = PyLong_AsLong(offset);

    return_struct.indexType = PyLong_AsLong(indexType);

    vkCmdBindIndexBuffer(return_struct.commandBuffer,return_struct.buffer,return_struct.offset,return_struct.indexType);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdBindVertexBuffers(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* firstBinding = NULL;
    PyObject* bindingCount = NULL;
    PyObject* pBuffers = NULL;
    PyObject* pOffsets = NULL;
    static char *kwlist[] = {"commandBuffer","firstBinding","bindingCount","pBuffers","pOffsets",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &commandBuffer, &firstBinding, &bindingCount, &pBuffers, &pOffsets)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        uint32_t firstBinding;

        uint32_t bindingCount;

        VkBuffer* pBuffers;

        VkDeviceSize* pOffsets;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");
    return_struct.firstBinding = (uint32_t) PyLong_AsLong(firstBinding);
    return_struct.bindingCount = (uint32_t) PyLong_AsLong(bindingCount);
    return_struct.pBuffers = PyCapsule_GetPointer(pBuffers, "VkBuffer");

    VkDeviceSize tmp = PyLong_AsLong(pOffsets);
    return_struct.pOffsets = &tmp;

    vkCmdBindVertexBuffers(return_struct.commandBuffer,return_struct.firstBinding,return_struct.bindingCount,return_struct.pBuffers,return_struct.pOffsets);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdDraw(PyObject *self, PyObject *args,
                             PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* vertexCount = NULL;
    PyObject* instanceCount = NULL;
    PyObject* firstVertex = NULL;
    PyObject* firstInstance = NULL;
    static char *kwlist[] = {"commandBuffer","vertexCount","instanceCount","firstVertex","firstInstance",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &commandBuffer, &vertexCount, &instanceCount, &firstVertex, &firstInstance)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        uint32_t vertexCount;

        uint32_t instanceCount;

        uint32_t firstVertex;

        uint32_t firstInstance;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");
    return_struct.vertexCount = (uint32_t) PyLong_AsLong(vertexCount);
    return_struct.instanceCount = (uint32_t) PyLong_AsLong(instanceCount);
    return_struct.firstVertex = (uint32_t) PyLong_AsLong(firstVertex);
    return_struct.firstInstance = (uint32_t) PyLong_AsLong(firstInstance);
    vkCmdDraw(return_struct.commandBuffer,return_struct.vertexCount,return_struct.instanceCount,return_struct.firstVertex,return_struct.firstInstance);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdDrawIndexed(PyObject *self, PyObject *args,
                                    PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* indexCount = NULL;
    PyObject* instanceCount = NULL;
    PyObject* firstIndex = NULL;
    PyObject* vertexOffset = NULL;
    PyObject* firstInstance = NULL;
    static char *kwlist[] = {"commandBuffer","indexCount","instanceCount","firstIndex","vertexOffset","firstInstance",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &commandBuffer, &indexCount, &instanceCount, &firstIndex, &vertexOffset, &firstInstance)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        uint32_t indexCount;

        uint32_t instanceCount;

        uint32_t firstIndex;

        int32_t vertexOffset;

        uint32_t firstInstance;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");
    return_struct.indexCount = (uint32_t) PyLong_AsLong(indexCount);
    return_struct.instanceCount = (uint32_t) PyLong_AsLong(instanceCount);
    return_struct.firstIndex = (uint32_t) PyLong_AsLong(firstIndex);
    return_struct.vertexOffset = (int32_t) PyLong_AsLong(vertexOffset);
    return_struct.firstInstance = (uint32_t) PyLong_AsLong(firstInstance);
    vkCmdDrawIndexed(return_struct.commandBuffer,return_struct.indexCount,return_struct.instanceCount,return_struct.firstIndex,return_struct.vertexOffset,return_struct.firstInstance);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdDrawIndirect(PyObject *self, PyObject *args,
                                     PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* buffer = NULL;
    PyObject* offset = NULL;
    PyObject* drawCount = NULL;
    PyObject* stride = NULL;
    static char *kwlist[] = {"commandBuffer","buffer","offset","drawCount","stride",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &commandBuffer, &buffer, &offset, &drawCount, &stride)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkBuffer buffer;

        VkDeviceSize offset;

        uint32_t drawCount;

        uint32_t stride;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.buffer = PyCapsule_GetPointer(buffer, "VkBuffer");

    return_struct.offset = PyLong_AsLong(offset);
    return_struct.drawCount = (uint32_t) PyLong_AsLong(drawCount);
    return_struct.stride = (uint32_t) PyLong_AsLong(stride);
    vkCmdDrawIndirect(return_struct.commandBuffer,return_struct.buffer,return_struct.offset,return_struct.drawCount,return_struct.stride);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdDrawIndexedIndirect(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* buffer = NULL;
    PyObject* offset = NULL;
    PyObject* drawCount = NULL;
    PyObject* stride = NULL;
    static char *kwlist[] = {"commandBuffer","buffer","offset","drawCount","stride",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &commandBuffer, &buffer, &offset, &drawCount, &stride)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkBuffer buffer;

        VkDeviceSize offset;

        uint32_t drawCount;

        uint32_t stride;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.buffer = PyCapsule_GetPointer(buffer, "VkBuffer");

    return_struct.offset = PyLong_AsLong(offset);
    return_struct.drawCount = (uint32_t) PyLong_AsLong(drawCount);
    return_struct.stride = (uint32_t) PyLong_AsLong(stride);
    vkCmdDrawIndexedIndirect(return_struct.commandBuffer,return_struct.buffer,return_struct.offset,return_struct.drawCount,return_struct.stride);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdDispatch(PyObject *self, PyObject *args,
                                 PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* x = NULL;
    PyObject* y = NULL;
    PyObject* z = NULL;
    static char *kwlist[] = {"commandBuffer","x","y","z",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &commandBuffer, &x, &y, &z)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        uint32_t x;

        uint32_t y;

        uint32_t z;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");
    return_struct.x = (uint32_t) PyLong_AsLong(x);
    return_struct.y = (uint32_t) PyLong_AsLong(y);
    return_struct.z = (uint32_t) PyLong_AsLong(z);
    vkCmdDispatch(return_struct.commandBuffer,return_struct.x,return_struct.y,return_struct.z);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdDispatchIndirect(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* buffer = NULL;
    PyObject* offset = NULL;
    static char *kwlist[] = {"commandBuffer","buffer","offset",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &buffer, &offset)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkBuffer buffer;

        VkDeviceSize offset;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.buffer = PyCapsule_GetPointer(buffer, "VkBuffer");

    return_struct.offset = PyLong_AsLong(offset);

    vkCmdDispatchIndirect(return_struct.commandBuffer,return_struct.buffer,return_struct.offset);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdCopyBuffer(PyObject *self, PyObject *args,
                                   PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* srcBuffer = NULL;
    PyObject* dstBuffer = NULL;
    PyObject* regionCount = NULL;
    PyObject* pRegions = NULL;
    static char *kwlist[] = {"commandBuffer","srcBuffer","dstBuffer","regionCount","pRegions",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &commandBuffer, &srcBuffer, &dstBuffer, &regionCount, &pRegions)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkBuffer srcBuffer;

        VkBuffer dstBuffer;

        uint32_t regionCount;

        VkBufferCopy* pRegions;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.srcBuffer = PyCapsule_GetPointer(srcBuffer, "VkBuffer");

    return_struct.dstBuffer = PyCapsule_GetPointer(dstBuffer, "VkBuffer");
    return_struct.regionCount = (uint32_t) PyLong_AsLong(regionCount);
    return_struct.pRegions = (((PyVkBufferCopy*)pRegions)->base);

    vkCmdCopyBuffer(return_struct.commandBuffer,return_struct.srcBuffer,return_struct.dstBuffer,return_struct.regionCount,return_struct.pRegions);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdCopyImage(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* srcImage = NULL;
    PyObject* srcImageLayout = NULL;
    PyObject* dstImage = NULL;
    PyObject* dstImageLayout = NULL;
    PyObject* regionCount = NULL;
    PyObject* pRegions = NULL;
    static char *kwlist[] = {"commandBuffer","srcImage","srcImageLayout","dstImage","dstImageLayout","regionCount","pRegions",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &commandBuffer, &srcImage, &srcImageLayout, &dstImage, &dstImageLayout, &regionCount, &pRegions)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkImage srcImage;

        VkImageLayout srcImageLayout;

        VkImage dstImage;

        VkImageLayout dstImageLayout;

        uint32_t regionCount;

        VkImageCopy* pRegions;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.srcImage = PyCapsule_GetPointer(srcImage, "VkImage");

    return_struct.srcImageLayout = PyLong_AsLong(srcImageLayout);

    return_struct.dstImage = PyCapsule_GetPointer(dstImage, "VkImage");

    return_struct.dstImageLayout = PyLong_AsLong(dstImageLayout);
    return_struct.regionCount = (uint32_t) PyLong_AsLong(regionCount);
    return_struct.pRegions = (((PyVkImageCopy*)pRegions)->base);

    vkCmdCopyImage(return_struct.commandBuffer,return_struct.srcImage,return_struct.srcImageLayout,return_struct.dstImage,return_struct.dstImageLayout,return_struct.regionCount,return_struct.pRegions);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdBlitImage(PyObject *self, PyObject *args,
                                  PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* srcImage = NULL;
    PyObject* srcImageLayout = NULL;
    PyObject* dstImage = NULL;
    PyObject* dstImageLayout = NULL;
    PyObject* regionCount = NULL;
    PyObject* pRegions = NULL;
    PyObject* filter = NULL;
    static char *kwlist[] = {"commandBuffer","srcImage","srcImageLayout","dstImage","dstImageLayout","regionCount","pRegions","filter",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOO", kwlist, &commandBuffer, &srcImage, &srcImageLayout, &dstImage, &dstImageLayout, &regionCount, &pRegions, &filter)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkImage srcImage;

        VkImageLayout srcImageLayout;

        VkImage dstImage;

        VkImageLayout dstImageLayout;

        uint32_t regionCount;

        VkImageBlit* pRegions;

        VkFilter filter;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.srcImage = PyCapsule_GetPointer(srcImage, "VkImage");

    return_struct.srcImageLayout = PyLong_AsLong(srcImageLayout);

    return_struct.dstImage = PyCapsule_GetPointer(dstImage, "VkImage");

    return_struct.dstImageLayout = PyLong_AsLong(dstImageLayout);
    return_struct.regionCount = (uint32_t) PyLong_AsLong(regionCount);
    return_struct.pRegions = (((PyVkImageBlit*)pRegions)->base);

    return_struct.filter = PyLong_AsLong(filter);

    vkCmdBlitImage(return_struct.commandBuffer,return_struct.srcImage,return_struct.srcImageLayout,return_struct.dstImage,return_struct.dstImageLayout,return_struct.regionCount,return_struct.pRegions,return_struct.filter);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdCopyBufferToImage(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* srcBuffer = NULL;
    PyObject* dstImage = NULL;
    PyObject* dstImageLayout = NULL;
    PyObject* regionCount = NULL;
    PyObject* pRegions = NULL;
    static char *kwlist[] = {"commandBuffer","srcBuffer","dstImage","dstImageLayout","regionCount","pRegions",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &commandBuffer, &srcBuffer, &dstImage, &dstImageLayout, &regionCount, &pRegions)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkBuffer srcBuffer;

        VkImage dstImage;

        VkImageLayout dstImageLayout;

        uint32_t regionCount;

        VkBufferImageCopy* pRegions;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.srcBuffer = PyCapsule_GetPointer(srcBuffer, "VkBuffer");

    return_struct.dstImage = PyCapsule_GetPointer(dstImage, "VkImage");

    return_struct.dstImageLayout = PyLong_AsLong(dstImageLayout);
    return_struct.regionCount = (uint32_t) PyLong_AsLong(regionCount);
    return_struct.pRegions = (((PyVkBufferImageCopy*)pRegions)->base);

    vkCmdCopyBufferToImage(return_struct.commandBuffer,return_struct.srcBuffer,return_struct.dstImage,return_struct.dstImageLayout,return_struct.regionCount,return_struct.pRegions);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdCopyImageToBuffer(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* srcImage = NULL;
    PyObject* srcImageLayout = NULL;
    PyObject* dstBuffer = NULL;
    PyObject* regionCount = NULL;
    PyObject* pRegions = NULL;
    static char *kwlist[] = {"commandBuffer","srcImage","srcImageLayout","dstBuffer","regionCount","pRegions",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &commandBuffer, &srcImage, &srcImageLayout, &dstBuffer, &regionCount, &pRegions)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkImage srcImage;

        VkImageLayout srcImageLayout;

        VkBuffer dstBuffer;

        uint32_t regionCount;

        VkBufferImageCopy* pRegions;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.srcImage = PyCapsule_GetPointer(srcImage, "VkImage");

    return_struct.srcImageLayout = PyLong_AsLong(srcImageLayout);

    return_struct.dstBuffer = PyCapsule_GetPointer(dstBuffer, "VkBuffer");
    return_struct.regionCount = (uint32_t) PyLong_AsLong(regionCount);
    return_struct.pRegions = (((PyVkBufferImageCopy*)pRegions)->base);

    vkCmdCopyImageToBuffer(return_struct.commandBuffer,return_struct.srcImage,return_struct.srcImageLayout,return_struct.dstBuffer,return_struct.regionCount,return_struct.pRegions);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdUpdateBuffer(PyObject *self, PyObject *args,
                                     PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* dstBuffer = NULL;
    PyObject* dstOffset = NULL;
    PyObject* dataSize = NULL;
    PyObject* pData = NULL;
    static char *kwlist[] = {"commandBuffer","dstBuffer","dstOffset","dataSize","pData",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &commandBuffer, &dstBuffer, &dstOffset, &dataSize, &pData)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkBuffer dstBuffer;

        VkDeviceSize dstOffset;

        VkDeviceSize dataSize;

        void* pData;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.dstBuffer = PyCapsule_GetPointer(dstBuffer, "VkBuffer");

    return_struct.dstOffset = PyLong_AsLong(dstOffset);

    return_struct.dataSize = PyLong_AsLong(dataSize);
    return_struct.pData = NULL;
    vkCmdUpdateBuffer(return_struct.commandBuffer,return_struct.dstBuffer,return_struct.dstOffset,return_struct.dataSize,return_struct.pData);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdFillBuffer(PyObject *self, PyObject *args,
                                   PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* dstBuffer = NULL;
    PyObject* dstOffset = NULL;
    PyObject* size = NULL;
    PyObject* data = NULL;
    static char *kwlist[] = {"commandBuffer","dstBuffer","dstOffset","size","data",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &commandBuffer, &dstBuffer, &dstOffset, &size, &data)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkBuffer dstBuffer;

        VkDeviceSize dstOffset;

        VkDeviceSize size;

        uint32_t data;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.dstBuffer = PyCapsule_GetPointer(dstBuffer, "VkBuffer");

    return_struct.dstOffset = PyLong_AsLong(dstOffset);

    return_struct.size = PyLong_AsLong(size);
    return_struct.data = (uint32_t) PyLong_AsLong(data);
    vkCmdFillBuffer(return_struct.commandBuffer,return_struct.dstBuffer,return_struct.dstOffset,return_struct.size,return_struct.data);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdClearColorImage(PyObject *self, PyObject *args,
                                        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* image = NULL;
    PyObject* imageLayout = NULL;
    PyObject* pColor = NULL;
    PyObject* rangeCount = NULL;
    PyObject* pRanges = NULL;
    static char *kwlist[] = {"commandBuffer","image","imageLayout","pColor","rangeCount","pRanges",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &commandBuffer, &image, &imageLayout, &pColor, &rangeCount, &pRanges)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkImage image;

        VkImageLayout imageLayout;

        VkClearColorValue* pColor;

        uint32_t rangeCount;

        VkImageSubresourceRange* pRanges;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.image = PyCapsule_GetPointer(image, "VkImage");

    return_struct.imageLayout = PyLong_AsLong(imageLayout);

    return_struct.pColor = (((PyVkClearColorValue*)pColor)->base);
    return_struct.rangeCount = (uint32_t) PyLong_AsLong(rangeCount);
    return_struct.pRanges = (((PyVkImageSubresourceRange*)pRanges)->base);

    vkCmdClearColorImage(return_struct.commandBuffer,return_struct.image,return_struct.imageLayout,return_struct.pColor,return_struct.rangeCount,return_struct.pRanges);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdClearDepthStencilImage(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* image = NULL;
    PyObject* imageLayout = NULL;
    PyObject* pDepthStencil = NULL;
    PyObject* rangeCount = NULL;
    PyObject* pRanges = NULL;
    static char *kwlist[] = {"commandBuffer","image","imageLayout","pDepthStencil","rangeCount","pRanges",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &commandBuffer, &image, &imageLayout, &pDepthStencil, &rangeCount, &pRanges)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkImage image;

        VkImageLayout imageLayout;

        VkClearDepthStencilValue* pDepthStencil;

        uint32_t rangeCount;

        VkImageSubresourceRange* pRanges;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.image = PyCapsule_GetPointer(image, "VkImage");

    return_struct.imageLayout = PyLong_AsLong(imageLayout);

    return_struct.pDepthStencil = (((PyVkClearDepthStencilValue*)pDepthStencil)->base);
    return_struct.rangeCount = (uint32_t) PyLong_AsLong(rangeCount);
    return_struct.pRanges = (((PyVkImageSubresourceRange*)pRanges)->base);

    vkCmdClearDepthStencilImage(return_struct.commandBuffer,return_struct.image,return_struct.imageLayout,return_struct.pDepthStencil,return_struct.rangeCount,return_struct.pRanges);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdClearAttachments(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* attachmentCount = NULL;
    PyObject* pAttachments = NULL;
    PyObject* rectCount = NULL;
    PyObject* pRects = NULL;
    static char *kwlist[] = {"commandBuffer","attachmentCount","pAttachments","rectCount","pRects",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO", kwlist, &commandBuffer, &attachmentCount, &pAttachments, &rectCount, &pRects)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        uint32_t attachmentCount;

        VkClearAttachment* pAttachments;

        uint32_t rectCount;

        VkClearRect* pRects;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");
    return_struct.attachmentCount = (uint32_t) PyLong_AsLong(attachmentCount);
    return_struct.pAttachments = (((PyVkClearAttachment*)pAttachments)->base);
    return_struct.rectCount = (uint32_t) PyLong_AsLong(rectCount);
    return_struct.pRects = (((PyVkClearRect*)pRects)->base);

    vkCmdClearAttachments(return_struct.commandBuffer,return_struct.attachmentCount,return_struct.pAttachments,return_struct.rectCount,return_struct.pRects);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdResolveImage(PyObject *self, PyObject *args,
                                     PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* srcImage = NULL;
    PyObject* srcImageLayout = NULL;
    PyObject* dstImage = NULL;
    PyObject* dstImageLayout = NULL;
    PyObject* regionCount = NULL;
    PyObject* pRegions = NULL;
    static char *kwlist[] = {"commandBuffer","srcImage","srcImageLayout","dstImage","dstImageLayout","regionCount","pRegions",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOO", kwlist, &commandBuffer, &srcImage, &srcImageLayout, &dstImage, &dstImageLayout, &regionCount, &pRegions)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkImage srcImage;

        VkImageLayout srcImageLayout;

        VkImage dstImage;

        VkImageLayout dstImageLayout;

        uint32_t regionCount;

        VkImageResolve* pRegions;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.srcImage = PyCapsule_GetPointer(srcImage, "VkImage");

    return_struct.srcImageLayout = PyLong_AsLong(srcImageLayout);

    return_struct.dstImage = PyCapsule_GetPointer(dstImage, "VkImage");

    return_struct.dstImageLayout = PyLong_AsLong(dstImageLayout);
    return_struct.regionCount = (uint32_t) PyLong_AsLong(regionCount);
    return_struct.pRegions = (((PyVkImageResolve*)pRegions)->base);

    vkCmdResolveImage(return_struct.commandBuffer,return_struct.srcImage,return_struct.srcImageLayout,return_struct.dstImage,return_struct.dstImageLayout,return_struct.regionCount,return_struct.pRegions);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdSetEvent(PyObject *self, PyObject *args,
                                 PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* event = NULL;
    PyObject* stageMask = NULL;
    static char *kwlist[] = {"commandBuffer","event","stageMask",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &event, &stageMask)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkEvent event;

        VkPipelineStageFlags stageMask;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.event = PyCapsule_GetPointer(event, "VkEvent");

    return_struct.stageMask = PyLong_AsLong(stageMask);

    vkCmdSetEvent(return_struct.commandBuffer,return_struct.event,return_struct.stageMask);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdResetEvent(PyObject *self, PyObject *args,
                                   PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* event = NULL;
    PyObject* stageMask = NULL;
    static char *kwlist[] = {"commandBuffer","event","stageMask",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &event, &stageMask)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkEvent event;

        VkPipelineStageFlags stageMask;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.event = PyCapsule_GetPointer(event, "VkEvent");

    return_struct.stageMask = PyLong_AsLong(stageMask);

    vkCmdResetEvent(return_struct.commandBuffer,return_struct.event,return_struct.stageMask);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdWaitEvents(PyObject *self, PyObject *args,
                                   PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* eventCount = NULL;
    PyObject* pEvents = NULL;
    PyObject* srcStageMask = NULL;
    PyObject* dstStageMask = NULL;
    PyObject* memoryBarrierCount = NULL;
    PyObject* pMemoryBarriers = NULL;
    PyObject* bufferMemoryBarrierCount = NULL;
    PyObject* pBufferMemoryBarriers = NULL;
    PyObject* imageMemoryBarrierCount = NULL;
    PyObject* pImageMemoryBarriers = NULL;
    static char *kwlist[] = {"commandBuffer","eventCount","pEvents","srcStageMask","dstStageMask","memoryBarrierCount","pMemoryBarriers","bufferMemoryBarrierCount","pBufferMemoryBarriers","imageMemoryBarrierCount","pImageMemoryBarriers",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOOOOO", kwlist, &commandBuffer, &eventCount, &pEvents, &srcStageMask, &dstStageMask, &memoryBarrierCount, &pMemoryBarriers, &bufferMemoryBarrierCount, &pBufferMemoryBarriers, &imageMemoryBarrierCount, &pImageMemoryBarriers)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        uint32_t eventCount;

        VkEvent* pEvents;

        VkPipelineStageFlags srcStageMask;

        VkPipelineStageFlags dstStageMask;

        uint32_t memoryBarrierCount;

        VkMemoryBarrier* pMemoryBarriers;

        uint32_t bufferMemoryBarrierCount;

        VkBufferMemoryBarrier* pBufferMemoryBarriers;

        uint32_t imageMemoryBarrierCount;

        VkImageMemoryBarrier* pImageMemoryBarriers;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");
    return_struct.eventCount = (uint32_t) PyLong_AsLong(eventCount);
    return_struct.pEvents = PyCapsule_GetPointer(pEvents, "VkEvent");

    return_struct.srcStageMask = PyLong_AsLong(srcStageMask);

    return_struct.dstStageMask = PyLong_AsLong(dstStageMask);
    return_struct.memoryBarrierCount = (uint32_t) PyLong_AsLong(memoryBarrierCount);
    return_struct.pMemoryBarriers = (((PyVkMemoryBarrier*)pMemoryBarriers)->base);
    return_struct.bufferMemoryBarrierCount = (uint32_t) PyLong_AsLong(bufferMemoryBarrierCount);
    return_struct.pBufferMemoryBarriers = (((PyVkBufferMemoryBarrier*)pBufferMemoryBarriers)->base);
    return_struct.imageMemoryBarrierCount = (uint32_t) PyLong_AsLong(imageMemoryBarrierCount);
    return_struct.pImageMemoryBarriers = (((PyVkImageMemoryBarrier*)pImageMemoryBarriers)->base);

    vkCmdWaitEvents(return_struct.commandBuffer,return_struct.eventCount,return_struct.pEvents,return_struct.srcStageMask,return_struct.dstStageMask,return_struct.memoryBarrierCount,return_struct.pMemoryBarriers,return_struct.bufferMemoryBarrierCount,return_struct.pBufferMemoryBarriers,return_struct.imageMemoryBarrierCount,return_struct.pImageMemoryBarriers);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdPipelineBarrier(PyObject *self, PyObject *args,
                                        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* srcStageMask = NULL;
    PyObject* dstStageMask = NULL;
    PyObject* dependencyFlags = NULL;
    PyObject* memoryBarrierCount = NULL;
    PyObject* pMemoryBarriers = NULL;
    PyObject* bufferMemoryBarrierCount = NULL;
    PyObject* pBufferMemoryBarriers = NULL;
    PyObject* imageMemoryBarrierCount = NULL;
    PyObject* pImageMemoryBarriers = NULL;
    static char *kwlist[] = {"commandBuffer","srcStageMask","dstStageMask","dependencyFlags","memoryBarrierCount","pMemoryBarriers","bufferMemoryBarrierCount","pBufferMemoryBarriers","imageMemoryBarrierCount","pImageMemoryBarriers",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOOOO", kwlist, &commandBuffer, &srcStageMask, &dstStageMask, &dependencyFlags, &memoryBarrierCount, &pMemoryBarriers, &bufferMemoryBarrierCount, &pBufferMemoryBarriers, &imageMemoryBarrierCount, &pImageMemoryBarriers)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkPipelineStageFlags srcStageMask;

        VkPipelineStageFlags dstStageMask;

        VkDependencyFlags dependencyFlags;

        uint32_t memoryBarrierCount;

        VkMemoryBarrier* pMemoryBarriers;

        uint32_t bufferMemoryBarrierCount;

        VkBufferMemoryBarrier* pBufferMemoryBarriers;

        uint32_t imageMemoryBarrierCount;

        VkImageMemoryBarrier* pImageMemoryBarriers;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.srcStageMask = PyLong_AsLong(srcStageMask);

    return_struct.dstStageMask = PyLong_AsLong(dstStageMask);

    return_struct.dependencyFlags = PyLong_AsLong(dependencyFlags);
    return_struct.memoryBarrierCount = (uint32_t) PyLong_AsLong(memoryBarrierCount);
    return_struct.pMemoryBarriers = (((PyVkMemoryBarrier*)pMemoryBarriers)->base);
    return_struct.bufferMemoryBarrierCount = (uint32_t) PyLong_AsLong(bufferMemoryBarrierCount);
    return_struct.pBufferMemoryBarriers = (((PyVkBufferMemoryBarrier*)pBufferMemoryBarriers)->base);
    return_struct.imageMemoryBarrierCount = (uint32_t) PyLong_AsLong(imageMemoryBarrierCount);
    return_struct.pImageMemoryBarriers = (((PyVkImageMemoryBarrier*)pImageMemoryBarriers)->base);

    vkCmdPipelineBarrier(return_struct.commandBuffer,return_struct.srcStageMask,return_struct.dstStageMask,return_struct.dependencyFlags,return_struct.memoryBarrierCount,return_struct.pMemoryBarriers,return_struct.bufferMemoryBarrierCount,return_struct.pBufferMemoryBarriers,return_struct.imageMemoryBarrierCount,return_struct.pImageMemoryBarriers);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdBeginQuery(PyObject *self, PyObject *args,
                                   PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* queryPool = NULL;
    PyObject* query = NULL;
    PyObject* flags = NULL;
    static char *kwlist[] = {"commandBuffer","queryPool","query","flags",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &commandBuffer, &queryPool, &query, &flags)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkQueryPool queryPool;

        uint32_t query;

        VkQueryControlFlags flags;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.queryPool = PyCapsule_GetPointer(queryPool, "VkQueryPool");
    return_struct.query = (uint32_t) PyLong_AsLong(query);
    return_struct.flags = PyLong_AsLong(flags);

    vkCmdBeginQuery(return_struct.commandBuffer,return_struct.queryPool,return_struct.query,return_struct.flags);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdEndQuery(PyObject *self, PyObject *args,
                                 PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* queryPool = NULL;
    PyObject* query = NULL;
    static char *kwlist[] = {"commandBuffer","queryPool","query",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &queryPool, &query)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkQueryPool queryPool;

        uint32_t query;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.queryPool = PyCapsule_GetPointer(queryPool, "VkQueryPool");
    return_struct.query = (uint32_t) PyLong_AsLong(query);
    vkCmdEndQuery(return_struct.commandBuffer,return_struct.queryPool,return_struct.query);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdResetQueryPool(PyObject *self, PyObject *args,
                                       PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* queryPool = NULL;
    PyObject* firstQuery = NULL;
    PyObject* queryCount = NULL;
    static char *kwlist[] = {"commandBuffer","queryPool","firstQuery","queryCount",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &commandBuffer, &queryPool, &firstQuery, &queryCount)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkQueryPool queryPool;

        uint32_t firstQuery;

        uint32_t queryCount;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.queryPool = PyCapsule_GetPointer(queryPool, "VkQueryPool");
    return_struct.firstQuery = (uint32_t) PyLong_AsLong(firstQuery);
    return_struct.queryCount = (uint32_t) PyLong_AsLong(queryCount);
    vkCmdResetQueryPool(return_struct.commandBuffer,return_struct.queryPool,return_struct.firstQuery,return_struct.queryCount);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdWriteTimestamp(PyObject *self, PyObject *args,
                                       PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* pipelineStage = NULL;
    PyObject* queryPool = NULL;
    PyObject* query = NULL;
    static char *kwlist[] = {"commandBuffer","pipelineStage","queryPool","query",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO", kwlist, &commandBuffer, &pipelineStage, &queryPool, &query)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkPipelineStageFlagBits pipelineStage;

        VkQueryPool queryPool;

        uint32_t query;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.pipelineStage = PyLong_AsLong(pipelineStage);

    return_struct.queryPool = PyCapsule_GetPointer(queryPool, "VkQueryPool");
    return_struct.query = (uint32_t) PyLong_AsLong(query);
    vkCmdWriteTimestamp(return_struct.commandBuffer,return_struct.pipelineStage,return_struct.queryPool,return_struct.query);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdCopyQueryPoolResults(PyObject *self, PyObject *args,
        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* queryPool = NULL;
    PyObject* firstQuery = NULL;
    PyObject* queryCount = NULL;
    PyObject* dstBuffer = NULL;
    PyObject* dstOffset = NULL;
    PyObject* stride = NULL;
    PyObject* flags = NULL;
    static char *kwlist[] = {"commandBuffer","queryPool","firstQuery","queryCount","dstBuffer","dstOffset","stride","flags",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOO", kwlist, &commandBuffer, &queryPool, &firstQuery, &queryCount, &dstBuffer, &dstOffset, &stride, &flags)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkQueryPool queryPool;

        uint32_t firstQuery;

        uint32_t queryCount;

        VkBuffer dstBuffer;

        VkDeviceSize dstOffset;

        VkDeviceSize stride;

        VkQueryResultFlags flags;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.queryPool = PyCapsule_GetPointer(queryPool, "VkQueryPool");
    return_struct.firstQuery = (uint32_t) PyLong_AsLong(firstQuery);
    return_struct.queryCount = (uint32_t) PyLong_AsLong(queryCount);
    return_struct.dstBuffer = PyCapsule_GetPointer(dstBuffer, "VkBuffer");

    return_struct.dstOffset = PyLong_AsLong(dstOffset);

    return_struct.stride = PyLong_AsLong(stride);

    return_struct.flags = PyLong_AsLong(flags);

    vkCmdCopyQueryPoolResults(return_struct.commandBuffer,return_struct.queryPool,return_struct.firstQuery,return_struct.queryCount,return_struct.dstBuffer,return_struct.dstOffset,return_struct.stride,return_struct.flags);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdPushConstants(PyObject *self, PyObject *args,
                                      PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* layout = NULL;
    PyObject* stageFlags = NULL;
    PyObject* offset = NULL;
    PyObject* size = NULL;
    PyObject* pValues = NULL;
    static char *kwlist[] = {"commandBuffer","layout","stageFlags","offset","size","pValues",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOO", kwlist, &commandBuffer, &layout, &stageFlags, &offset, &size, &pValues)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkPipelineLayout layout;

        VkShaderStageFlags stageFlags;

        uint32_t offset;

        uint32_t size;

        void* pValues;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.layout = PyCapsule_GetPointer(layout, "VkPipelineLayout");

    return_struct.stageFlags = PyLong_AsLong(stageFlags);
    return_struct.offset = (uint32_t) PyLong_AsLong(offset);
    return_struct.size = (uint32_t) PyLong_AsLong(size);
    return_struct.pValues = NULL;
    vkCmdPushConstants(return_struct.commandBuffer,return_struct.layout,return_struct.stageFlags,return_struct.offset,return_struct.size,return_struct.pValues);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdBeginRenderPass(PyObject *self, PyObject *args,
                                        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* pRenderPassBegin = NULL;
    PyObject* contents = NULL;
    static char *kwlist[] = {"commandBuffer","pRenderPassBegin","contents",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &pRenderPassBegin, &contents)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkRenderPassBeginInfo* pRenderPassBegin;

        VkSubpassContents contents;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.pRenderPassBegin = (((PyVkRenderPassBeginInfo*)pRenderPassBegin)->base);

    return_struct.contents = PyLong_AsLong(contents);

    vkCmdBeginRenderPass(return_struct.commandBuffer,return_struct.pRenderPassBegin,return_struct.contents);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdNextSubpass(PyObject *self, PyObject *args,
                                    PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* contents = NULL;
    static char *kwlist[] = {"commandBuffer","contents",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO", kwlist, &commandBuffer, &contents)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        VkSubpassContents contents;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    return_struct.contents = PyLong_AsLong(contents);

    vkCmdNextSubpass(return_struct.commandBuffer,return_struct.contents);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdEndRenderPass(PyObject *self, PyObject *args,
                                      PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    static char *kwlist[] = {"commandBuffer",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &commandBuffer)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");

    vkCmdEndRenderPass(return_struct.commandBuffer);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyObject* PyvkCmdExecuteCommands(PyObject *self, PyObject *args,
                                        PyObject *kwds) {
    PyObject* commandBuffer = NULL;
    PyObject* commandBufferCount = NULL;
    PyObject* pCommandBuffers = NULL;
    static char *kwlist[] = {"commandBuffer","commandBufferCount","pCommandBuffers",NULL};
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOO", kwlist, &commandBuffer, &commandBufferCount, &pCommandBuffers)) return NULL;

    struct {

        VkCommandBuffer commandBuffer;

        uint32_t commandBufferCount;

        VkCommandBuffer* pCommandBuffers;

    } return_struct = {};

    return_struct.commandBuffer = PyCapsule_GetPointer(commandBuffer, "VkCommandBuffer");
    return_struct.commandBufferCount = (uint32_t) PyLong_AsLong(commandBufferCount);
    return_struct.pCommandBuffers = PyCapsule_GetPointer(pCommandBuffers, "VkCommandBuffer");

    vkCmdExecuteCommands(return_struct.commandBuffer,return_struct.commandBufferCount,return_struct.pCommandBuffers);
    PyObject* return_value = Py_None;

    return return_value;
}

static PyMethodDef VulkanMethods[] = {
    {"vkLoadSdk", load_sdk, METH_NOARGS, "Load SDK"},
    {"vkGetInstanceProcAddr", (PyCFunction)PyvkGetInstanceProcAddr, METH_VARARGS, ""},
    {"vkGetDeviceProcAddr", (PyCFunction)PyvkGetDeviceProcAddr, METH_VARARGS, ""},
    {"VK_MAKE_VERSION", (PyCFunction)PyVK_MAKE_VERSION, METH_VARARGS, ""},
    {"VK_VERSION_MAJOR", (PyCFunction)PyVK_VERSION_MAJOR, METH_VARARGS, ""},
    {"VK_VERSION_MINOR", (PyCFunction)PyVK_VERSION_MINOR, METH_VARARGS, ""},
    {"VK_VERSION_PATCH", (PyCFunction)PyVK_VERSION_PATCH, METH_VARARGS, ""},
    {"VkPhysicalDevice", PyHandle_VkPhysicalDevice, METH_NOARGS, "Handle"},
    {"VkSurfaceKHR", PyHandle_VkSurfaceKHR, METH_NOARGS, "Handle"},
    {"VkQueryPool", PyHandle_VkQueryPool, METH_NOARGS, "Handle"},
    {"VkImage", PyHandle_VkImage, METH_NOARGS, "Handle"},
    {"VkPipelineLayout", PyHandle_VkPipelineLayout, METH_NOARGS, "Handle"},
    {"VkDebugReportCallbackEXT", PyHandle_VkDebugReportCallbackEXT, METH_NOARGS, "Handle"},
    {"VkDeviceMemory", PyHandle_VkDeviceMemory, METH_NOARGS, "Handle"},
    {"VkShaderModule", PyHandle_VkShaderModule, METH_NOARGS, "Handle"},
    {"VkFramebuffer", PyHandle_VkFramebuffer, METH_NOARGS, "Handle"},
    {"VkImageView", PyHandle_VkImageView, METH_NOARGS, "Handle"},
    {"VkCommandPool", PyHandle_VkCommandPool, METH_NOARGS, "Handle"},
    {"VkDevice", PyHandle_VkDevice, METH_NOARGS, "Handle"},
    {"VkSwapchainKHR", PyHandle_VkSwapchainKHR, METH_NOARGS, "Handle"},
    {"VkCommandBuffer", PyHandle_VkCommandBuffer, METH_NOARGS, "Handle"},
    {"VkFence", PyHandle_VkFence, METH_NOARGS, "Handle"},
    {"VkEvent", PyHandle_VkEvent, METH_NOARGS, "Handle"},
    {"VkDescriptorSet", PyHandle_VkDescriptorSet, METH_NOARGS, "Handle"},
    {"VkInstance", PyHandle_VkInstance, METH_NOARGS, "Handle"},
    {"VkSemaphore", PyHandle_VkSemaphore, METH_NOARGS, "Handle"},
    {"VkPipelineCache", PyHandle_VkPipelineCache, METH_NOARGS, "Handle"},
    {"VkDisplayModeKHR", PyHandle_VkDisplayModeKHR, METH_NOARGS, "Handle"},
    {"VkDescriptorSetLayout", PyHandle_VkDescriptorSetLayout, METH_NOARGS, "Handle"},
    {"VkBuffer", PyHandle_VkBuffer, METH_NOARGS, "Handle"},
    {"VkQueue", PyHandle_VkQueue, METH_NOARGS, "Handle"},
    {"VkRenderPass", PyHandle_VkRenderPass, METH_NOARGS, "Handle"},
    {"VkDescriptorPool", PyHandle_VkDescriptorPool, METH_NOARGS, "Handle"},
    {"VkDisplayKHR", PyHandle_VkDisplayKHR, METH_NOARGS, "Handle"},
    {"VkPipeline", PyHandle_VkPipeline, METH_NOARGS, "Handle"},
    {"VkSampler", PyHandle_VkSampler, METH_NOARGS, "Handle"},
    {"VkBufferView", PyHandle_VkBufferView, METH_NOARGS, "Handle"},
    {"vkCreateInstance", (PyCFunction) PyvkCreateInstance, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroyInstance", (PyCFunction) PyvkDestroyInstance, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkEnumeratePhysicalDevices", (PyCFunction) PyvkEnumeratePhysicalDevices, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkGetPhysicalDeviceProperties", (PyCFunction) PyvkGetPhysicalDeviceProperties, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkGetPhysicalDeviceQueueFamilyProperties", (PyCFunction) PyvkGetPhysicalDeviceQueueFamilyProperties, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkGetPhysicalDeviceMemoryProperties", (PyCFunction) PyvkGetPhysicalDeviceMemoryProperties, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkGetPhysicalDeviceFeatures", (PyCFunction) PyvkGetPhysicalDeviceFeatures, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkGetPhysicalDeviceFormatProperties", (PyCFunction) PyvkGetPhysicalDeviceFormatProperties, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkGetPhysicalDeviceImageFormatProperties", (PyCFunction) PyvkGetPhysicalDeviceImageFormatProperties, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreateDevice", (PyCFunction) PyvkCreateDevice, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroyDevice", (PyCFunction) PyvkDestroyDevice, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkEnumerateInstanceLayerProperties", (PyCFunction) PyvkEnumerateInstanceLayerProperties, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkEnumerateInstanceExtensionProperties", (PyCFunction) PyvkEnumerateInstanceExtensionProperties, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkEnumerateDeviceLayerProperties", (PyCFunction) PyvkEnumerateDeviceLayerProperties, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkEnumerateDeviceExtensionProperties", (PyCFunction) PyvkEnumerateDeviceExtensionProperties, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkGetDeviceQueue", (PyCFunction) PyvkGetDeviceQueue, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkQueueSubmit", (PyCFunction) PyvkQueueSubmit, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkQueueWaitIdle", (PyCFunction) PyvkQueueWaitIdle, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDeviceWaitIdle", (PyCFunction) PyvkDeviceWaitIdle, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkAllocateMemory", (PyCFunction) PyvkAllocateMemory, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkFreeMemory", (PyCFunction) PyvkFreeMemory, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkMapMemory", (PyCFunction) PyvkMapMemory, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkUnmapMemory", (PyCFunction) PyvkUnmapMemory, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkFlushMappedMemoryRanges", (PyCFunction) PyvkFlushMappedMemoryRanges, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkInvalidateMappedMemoryRanges", (PyCFunction) PyvkInvalidateMappedMemoryRanges, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkGetDeviceMemoryCommitment", (PyCFunction) PyvkGetDeviceMemoryCommitment, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkGetBufferMemoryRequirements", (PyCFunction) PyvkGetBufferMemoryRequirements, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkBindBufferMemory", (PyCFunction) PyvkBindBufferMemory, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkGetImageMemoryRequirements", (PyCFunction) PyvkGetImageMemoryRequirements, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkBindImageMemory", (PyCFunction) PyvkBindImageMemory, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkGetImageSparseMemoryRequirements", (PyCFunction) PyvkGetImageSparseMemoryRequirements, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkGetPhysicalDeviceSparseImageFormatProperties", (PyCFunction) PyvkGetPhysicalDeviceSparseImageFormatProperties, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkQueueBindSparse", (PyCFunction) PyvkQueueBindSparse, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreateFence", (PyCFunction) PyvkCreateFence, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroyFence", (PyCFunction) PyvkDestroyFence, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkResetFences", (PyCFunction) PyvkResetFences, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkGetFenceStatus", (PyCFunction) PyvkGetFenceStatus, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkWaitForFences", (PyCFunction) PyvkWaitForFences, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreateSemaphore", (PyCFunction) PyvkCreateSemaphore, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroySemaphore", (PyCFunction) PyvkDestroySemaphore, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreateEvent", (PyCFunction) PyvkCreateEvent, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroyEvent", (PyCFunction) PyvkDestroyEvent, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkGetEventStatus", (PyCFunction) PyvkGetEventStatus, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkSetEvent", (PyCFunction) PyvkSetEvent, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkResetEvent", (PyCFunction) PyvkResetEvent, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreateQueryPool", (PyCFunction) PyvkCreateQueryPool, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroyQueryPool", (PyCFunction) PyvkDestroyQueryPool, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkGetQueryPoolResults", (PyCFunction) PyvkGetQueryPoolResults, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreateBuffer", (PyCFunction) PyvkCreateBuffer, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroyBuffer", (PyCFunction) PyvkDestroyBuffer, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreateBufferView", (PyCFunction) PyvkCreateBufferView, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroyBufferView", (PyCFunction) PyvkDestroyBufferView, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreateImage", (PyCFunction) PyvkCreateImage, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroyImage", (PyCFunction) PyvkDestroyImage, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkGetImageSubresourceLayout", (PyCFunction) PyvkGetImageSubresourceLayout, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreateImageView", (PyCFunction) PyvkCreateImageView, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroyImageView", (PyCFunction) PyvkDestroyImageView, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreateShaderModule", (PyCFunction) PyvkCreateShaderModule, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroyShaderModule", (PyCFunction) PyvkDestroyShaderModule, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreatePipelineCache", (PyCFunction) PyvkCreatePipelineCache, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroyPipelineCache", (PyCFunction) PyvkDestroyPipelineCache, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkGetPipelineCacheData", (PyCFunction) PyvkGetPipelineCacheData, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkMergePipelineCaches", (PyCFunction) PyvkMergePipelineCaches, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreateGraphicsPipelines", (PyCFunction) PyvkCreateGraphicsPipelines, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreateComputePipelines", (PyCFunction) PyvkCreateComputePipelines, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroyPipeline", (PyCFunction) PyvkDestroyPipeline, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreatePipelineLayout", (PyCFunction) PyvkCreatePipelineLayout, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroyPipelineLayout", (PyCFunction) PyvkDestroyPipelineLayout, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreateSampler", (PyCFunction) PyvkCreateSampler, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroySampler", (PyCFunction) PyvkDestroySampler, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreateDescriptorSetLayout", (PyCFunction) PyvkCreateDescriptorSetLayout, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroyDescriptorSetLayout", (PyCFunction) PyvkDestroyDescriptorSetLayout, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreateDescriptorPool", (PyCFunction) PyvkCreateDescriptorPool, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroyDescriptorPool", (PyCFunction) PyvkDestroyDescriptorPool, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkResetDescriptorPool", (PyCFunction) PyvkResetDescriptorPool, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkAllocateDescriptorSets", (PyCFunction) PyvkAllocateDescriptorSets, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkFreeDescriptorSets", (PyCFunction) PyvkFreeDescriptorSets, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkUpdateDescriptorSets", (PyCFunction) PyvkUpdateDescriptorSets, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreateFramebuffer", (PyCFunction) PyvkCreateFramebuffer, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroyFramebuffer", (PyCFunction) PyvkDestroyFramebuffer, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreateRenderPass", (PyCFunction) PyvkCreateRenderPass, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroyRenderPass", (PyCFunction) PyvkDestroyRenderPass, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkGetRenderAreaGranularity", (PyCFunction) PyvkGetRenderAreaGranularity, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCreateCommandPool", (PyCFunction) PyvkCreateCommandPool, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkDestroyCommandPool", (PyCFunction) PyvkDestroyCommandPool, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkResetCommandPool", (PyCFunction) PyvkResetCommandPool, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkAllocateCommandBuffers", (PyCFunction) PyvkAllocateCommandBuffers, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkFreeCommandBuffers", (PyCFunction) PyvkFreeCommandBuffers, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkBeginCommandBuffer", (PyCFunction) PyvkBeginCommandBuffer, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkEndCommandBuffer", (PyCFunction) PyvkEndCommandBuffer, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkResetCommandBuffer", (PyCFunction) PyvkResetCommandBuffer, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdBindPipeline", (PyCFunction) PyvkCmdBindPipeline, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdSetViewport", (PyCFunction) PyvkCmdSetViewport, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdSetScissor", (PyCFunction) PyvkCmdSetScissor, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdSetLineWidth", (PyCFunction) PyvkCmdSetLineWidth, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdSetDepthBias", (PyCFunction) PyvkCmdSetDepthBias, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdSetBlendConstants", (PyCFunction) PyvkCmdSetBlendConstants, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdSetDepthBounds", (PyCFunction) PyvkCmdSetDepthBounds, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdSetStencilCompareMask", (PyCFunction) PyvkCmdSetStencilCompareMask, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdSetStencilWriteMask", (PyCFunction) PyvkCmdSetStencilWriteMask, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdSetStencilReference", (PyCFunction) PyvkCmdSetStencilReference, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdBindDescriptorSets", (PyCFunction) PyvkCmdBindDescriptorSets, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdBindIndexBuffer", (PyCFunction) PyvkCmdBindIndexBuffer, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdBindVertexBuffers", (PyCFunction) PyvkCmdBindVertexBuffers, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdDraw", (PyCFunction) PyvkCmdDraw, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdDrawIndexed", (PyCFunction) PyvkCmdDrawIndexed, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdDrawIndirect", (PyCFunction) PyvkCmdDrawIndirect, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdDrawIndexedIndirect", (PyCFunction) PyvkCmdDrawIndexedIndirect, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdDispatch", (PyCFunction) PyvkCmdDispatch, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdDispatchIndirect", (PyCFunction) PyvkCmdDispatchIndirect, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdCopyBuffer", (PyCFunction) PyvkCmdCopyBuffer, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdCopyImage", (PyCFunction) PyvkCmdCopyImage, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdBlitImage", (PyCFunction) PyvkCmdBlitImage, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdCopyBufferToImage", (PyCFunction) PyvkCmdCopyBufferToImage, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdCopyImageToBuffer", (PyCFunction) PyvkCmdCopyImageToBuffer, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdUpdateBuffer", (PyCFunction) PyvkCmdUpdateBuffer, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdFillBuffer", (PyCFunction) PyvkCmdFillBuffer, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdClearColorImage", (PyCFunction) PyvkCmdClearColorImage, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdClearDepthStencilImage", (PyCFunction) PyvkCmdClearDepthStencilImage, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdClearAttachments", (PyCFunction) PyvkCmdClearAttachments, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdResolveImage", (PyCFunction) PyvkCmdResolveImage, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdSetEvent", (PyCFunction) PyvkCmdSetEvent, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdResetEvent", (PyCFunction) PyvkCmdResetEvent, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdWaitEvents", (PyCFunction) PyvkCmdWaitEvents, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdPipelineBarrier", (PyCFunction) PyvkCmdPipelineBarrier, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdBeginQuery", (PyCFunction) PyvkCmdBeginQuery, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdEndQuery", (PyCFunction) PyvkCmdEndQuery, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdResetQueryPool", (PyCFunction) PyvkCmdResetQueryPool, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdWriteTimestamp", (PyCFunction) PyvkCmdWriteTimestamp, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdCopyQueryPoolResults", (PyCFunction) PyvkCmdCopyQueryPoolResults, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdPushConstants", (PyCFunction) PyvkCmdPushConstants, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdBeginRenderPass", (PyCFunction) PyvkCmdBeginRenderPass, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdNextSubpass", (PyCFunction) PyvkCmdNextSubpass, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdEndRenderPass", (PyCFunction) PyvkCmdEndRenderPass, METH_VARARGS | METH_KEYWORDS, ""},
    {"vkCmdExecuteCommands", (PyCFunction) PyvkCmdExecuteCommands, METH_VARARGS | METH_KEYWORDS, ""},

    {NULL, NULL, 0, NULL}
};

static struct PyModuleDef vulkanmodule = {
    PyModuleDef_HEAD_INIT, "vulkan", "Vulkan module", -1, VulkanMethods
};


PyMODINIT_FUNC PyInit_vulkan(void) {

    PyObject* module;
    module = PyModule_Create(&vulkanmodule);
    if (module == NULL) return NULL;


    PyModule_AddIntConstant(module, "VK_MAX_PHYSICAL_DEVICE_NAME_SIZE", 256);
    PyModule_AddIntConstant(module, "VK_UUID_SIZE", 16);
    PyModule_AddIntConstant(module, "VK_MAX_EXTENSION_NAME_SIZE", 256);
    PyModule_AddIntConstant(module, "VK_MAX_DESCRIPTION_SIZE", 256);
    PyModule_AddIntConstant(module, "VK_MAX_MEMORY_TYPES", 32);
    PyModule_AddIntConstant(module, "VK_MAX_MEMORY_HEAPS", 16);
    PyModule_AddIntConstant(module, "VK_LOD_CLAMP_NONE", 1000.0f);
    PyModule_AddIntConstant(module, "VK_REMAINING_MIP_LEVELS", (~0U));
    PyModule_AddIntConstant(module, "VK_REMAINING_ARRAY_LAYERS", (~0U));
    PyModule_AddIntConstant(module, "VK_WHOLE_SIZE", (~0ULL));
    PyModule_AddIntConstant(module, "VK_ATTACHMENT_UNUSED", (~0U));
    PyModule_AddIntConstant(module, "VK_TRUE", 1);
    PyModule_AddIntConstant(module, "VK_FALSE", 0);
    PyModule_AddIntConstant(module, "VK_QUEUE_FAMILY_IGNORED", (~0U));
    PyModule_AddIntConstant(module, "VK_SUBPASS_EXTERNAL", (~0U));
    PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_UNDEFINED", 0);
    PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_GENERAL", 1);
    PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL", 2);
    PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL", 3);
    PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL", 4);
    PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL", 5);
    PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL", 6);
    PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL", 7);
    PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_PREINITIALIZED", 8);
    PyModule_AddIntConstant(module, "VK_ATTACHMENT_LOAD_OP_LOAD", 0);
    PyModule_AddIntConstant(module, "VK_ATTACHMENT_LOAD_OP_CLEAR", 1);
    PyModule_AddIntConstant(module, "VK_ATTACHMENT_LOAD_OP_DONT_CARE", 2);
    PyModule_AddIntConstant(module, "VK_ATTACHMENT_STORE_OP_STORE", 0);
    PyModule_AddIntConstant(module, "VK_ATTACHMENT_STORE_OP_DONT_CARE", 1);
    PyModule_AddIntConstant(module, "VK_IMAGE_TYPE_1D", 0);
    PyModule_AddIntConstant(module, "VK_IMAGE_TYPE_2D", 1);
    PyModule_AddIntConstant(module, "VK_IMAGE_TYPE_3D", 2);
    PyModule_AddIntConstant(module, "VK_IMAGE_TILING_OPTIMAL", 0);
    PyModule_AddIntConstant(module, "VK_IMAGE_TILING_LINEAR", 1);
    PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_1D", 0);
    PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_2D", 1);
    PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_3D", 2);
    PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_CUBE", 3);
    PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_1D_ARRAY", 4);
    PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_2D_ARRAY", 5);
    PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", 6);
    PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_LEVEL_PRIMARY", 0);
    PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_LEVEL_SECONDARY", 1);
    PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_IDENTITY", 0);
    PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_ZERO", 1);
    PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_ONE", 2);
    PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_R", 3);
    PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_G", 4);
    PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_B", 5);
    PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_A", 6);
    PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_SAMPLER", 0);
    PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER", 1);
    PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE", 2);
    PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE", 3);
    PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER", 4);
    PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER", 5);
    PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER", 6);
    PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER", 7);
    PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC", 8);
    PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC", 9);
    PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT", 10);
    PyModule_AddIntConstant(module, "VK_QUERY_TYPE_OCCLUSION", 0);
    PyModule_AddIntConstant(module, "VK_QUERY_TYPE_PIPELINE_STATISTICS", 1);
    PyModule_AddIntConstant(module, "VK_QUERY_TYPE_TIMESTAMP", 2);
    PyModule_AddIntConstant(module, "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK", 0);
    PyModule_AddIntConstant(module, "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK", 1);
    PyModule_AddIntConstant(module, "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK", 2);
    PyModule_AddIntConstant(module, "VK_BORDER_COLOR_INT_OPAQUE_BLACK", 3);
    PyModule_AddIntConstant(module, "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE", 4);
    PyModule_AddIntConstant(module, "VK_BORDER_COLOR_INT_OPAQUE_WHITE", 5);
    PyModule_AddIntConstant(module, "VK_PIPELINE_BIND_POINT_GRAPHICS", 0);
    PyModule_AddIntConstant(module, "VK_PIPELINE_BIND_POINT_COMPUTE", 1);
    PyModule_AddIntConstant(module, "VK_PIPELINE_CACHE_HEADER_VERSION_ONE", 1);
    PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_POINT_LIST", 0);
    PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_LINE_LIST", 1);
    PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP", 2);
    PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST", 3);
    PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP", 4);
    PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN", 5);
    PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY", 6);
    PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY", 7);
    PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY", 8);
    PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY", 9);
    PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST", 10);
    PyModule_AddIntConstant(module, "VK_SHARING_MODE_EXCLUSIVE", 0);
    PyModule_AddIntConstant(module, "VK_SHARING_MODE_CONCURRENT", 1);
    PyModule_AddIntConstant(module, "VK_INDEX_TYPE_UINT16", 0);
    PyModule_AddIntConstant(module, "VK_INDEX_TYPE_UINT32", 1);
    PyModule_AddIntConstant(module, "VK_FILTER_NEAREST", 0);
    PyModule_AddIntConstant(module, "VK_FILTER_LINEAR", 1);
    PyModule_AddIntConstant(module, "VK_SAMPLER_MIPMAP_MODE_NEAREST", 0);
    PyModule_AddIntConstant(module, "VK_SAMPLER_MIPMAP_MODE_LINEAR", 1);
    PyModule_AddIntConstant(module, "VK_SAMPLER_ADDRESS_MODE_REPEAT", 0);
    PyModule_AddIntConstant(module, "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT", 1);
    PyModule_AddIntConstant(module, "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", 2);
    PyModule_AddIntConstant(module, "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER", 3);
    PyModule_AddIntConstant(module, "VK_COMPARE_OP_NEVER", 0);
    PyModule_AddIntConstant(module, "VK_COMPARE_OP_LESS", 1);
    PyModule_AddIntConstant(module, "VK_COMPARE_OP_EQUAL", 2);
    PyModule_AddIntConstant(module, "VK_COMPARE_OP_LESS_OR_EQUAL", 3);
    PyModule_AddIntConstant(module, "VK_COMPARE_OP_GREATER", 4);
    PyModule_AddIntConstant(module, "VK_COMPARE_OP_NOT_EQUAL", 5);
    PyModule_AddIntConstant(module, "VK_COMPARE_OP_GREATER_OR_EQUAL", 6);
    PyModule_AddIntConstant(module, "VK_COMPARE_OP_ALWAYS", 7);
    PyModule_AddIntConstant(module, "VK_POLYGON_MODE_FILL", 0);
    PyModule_AddIntConstant(module, "VK_POLYGON_MODE_LINE", 1);
    PyModule_AddIntConstant(module, "VK_POLYGON_MODE_POINT", 2);
    PyModule_AddIntConstant(module, "VK_CULL_MODE_NONE", 0);
    PyModule_AddIntConstant(module, "VK_CULL_MODE_FRONT_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_CULL_MODE_BACK_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_CULL_MODE_FRONT_AND_BACK", 0x00000003);
    PyModule_AddIntConstant(module, "VK_FRONT_FACE_COUNTER_CLOCKWISE", 0);
    PyModule_AddIntConstant(module, "VK_FRONT_FACE_CLOCKWISE", 1);
    PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ZERO", 0);
    PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE", 1);
    PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC_COLOR", 2);
    PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR", 3);
    PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_DST_COLOR", 4);
    PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR", 5);
    PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC_ALPHA", 6);
    PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA", 7);
    PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_DST_ALPHA", 8);
    PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA", 9);
    PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_CONSTANT_COLOR", 10);
    PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR", 11);
    PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_CONSTANT_ALPHA", 12);
    PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA", 13);
    PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE", 14);
    PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC1_COLOR", 15);
    PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR", 16);
    PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC1_ALPHA", 17);
    PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA", 18);
    PyModule_AddIntConstant(module, "VK_BLEND_OP_ADD", 0);
    PyModule_AddIntConstant(module, "VK_BLEND_OP_SUBTRACT", 1);
    PyModule_AddIntConstant(module, "VK_BLEND_OP_REVERSE_SUBTRACT", 2);
    PyModule_AddIntConstant(module, "VK_BLEND_OP_MIN", 3);
    PyModule_AddIntConstant(module, "VK_BLEND_OP_MAX", 4);
    PyModule_AddIntConstant(module, "VK_STENCIL_OP_KEEP", 0);
    PyModule_AddIntConstant(module, "VK_STENCIL_OP_ZERO", 1);
    PyModule_AddIntConstant(module, "VK_STENCIL_OP_REPLACE", 2);
    PyModule_AddIntConstant(module, "VK_STENCIL_OP_INCREMENT_AND_CLAMP", 3);
    PyModule_AddIntConstant(module, "VK_STENCIL_OP_DECREMENT_AND_CLAMP", 4);
    PyModule_AddIntConstant(module, "VK_STENCIL_OP_INVERT", 5);
    PyModule_AddIntConstant(module, "VK_STENCIL_OP_INCREMENT_AND_WRAP", 6);
    PyModule_AddIntConstant(module, "VK_STENCIL_OP_DECREMENT_AND_WRAP", 7);
    PyModule_AddIntConstant(module, "VK_LOGIC_OP_CLEAR", 0);
    PyModule_AddIntConstant(module, "VK_LOGIC_OP_AND", 1);
    PyModule_AddIntConstant(module, "VK_LOGIC_OP_AND_REVERSE", 2);
    PyModule_AddIntConstant(module, "VK_LOGIC_OP_COPY", 3);
    PyModule_AddIntConstant(module, "VK_LOGIC_OP_AND_INVERTED", 4);
    PyModule_AddIntConstant(module, "VK_LOGIC_OP_NO_OP", 5);
    PyModule_AddIntConstant(module, "VK_LOGIC_OP_XOR", 6);
    PyModule_AddIntConstant(module, "VK_LOGIC_OP_OR", 7);
    PyModule_AddIntConstant(module, "VK_LOGIC_OP_NOR", 8);
    PyModule_AddIntConstant(module, "VK_LOGIC_OP_EQUIVALENT", 9);
    PyModule_AddIntConstant(module, "VK_LOGIC_OP_INVERT", 10);
    PyModule_AddIntConstant(module, "VK_LOGIC_OP_OR_REVERSE", 11);
    PyModule_AddIntConstant(module, "VK_LOGIC_OP_COPY_INVERTED", 12);
    PyModule_AddIntConstant(module, "VK_LOGIC_OP_OR_INVERTED", 13);
    PyModule_AddIntConstant(module, "VK_LOGIC_OP_NAND", 14);
    PyModule_AddIntConstant(module, "VK_LOGIC_OP_SET", 15);
    PyModule_AddIntConstant(module, "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE", 0);
    PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND", 0);
    PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT", 1);
    PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_CACHE", 2);
    PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE", 3);
    PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE", 4);
    PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_OTHER", 0);
    PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU", 1);
    PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU", 2);
    PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU", 3);
    PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_CPU", 4);
    PyModule_AddIntConstant(module, "VK_VERTEX_INPUT_RATE_VERTEX", 0);
    PyModule_AddIntConstant(module, "VK_VERTEX_INPUT_RATE_INSTANCE", 1);
    PyModule_AddIntConstant(module, "VK_FORMAT_UNDEFINED", 0);
    PyModule_AddIntConstant(module, "VK_FORMAT_R4G4_UNORM_PACK8", 1);
    PyModule_AddIntConstant(module, "VK_FORMAT_R4G4B4A4_UNORM_PACK16", 2);
    PyModule_AddIntConstant(module, "VK_FORMAT_B4G4R4A4_UNORM_PACK16", 3);
    PyModule_AddIntConstant(module, "VK_FORMAT_R5G6B5_UNORM_PACK16", 4);
    PyModule_AddIntConstant(module, "VK_FORMAT_B5G6R5_UNORM_PACK16", 5);
    PyModule_AddIntConstant(module, "VK_FORMAT_R5G5B5A1_UNORM_PACK16", 6);
    PyModule_AddIntConstant(module, "VK_FORMAT_B5G5R5A1_UNORM_PACK16", 7);
    PyModule_AddIntConstant(module, "VK_FORMAT_A1R5G5B5_UNORM_PACK16", 8);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8_UNORM", 9);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8_SNORM", 10);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8_USCALED", 11);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8_SSCALED", 12);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8_UINT", 13);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8_SINT", 14);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8_SRGB", 15);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_UNORM", 16);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_SNORM", 17);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_USCALED", 18);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_SSCALED", 19);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_UINT", 20);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_SINT", 21);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_SRGB", 22);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_UNORM", 23);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_SNORM", 24);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_USCALED", 25);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_SSCALED", 26);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_UINT", 27);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_SINT", 28);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_SRGB", 29);
    PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_UNORM", 30);
    PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_SNORM", 31);
    PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_USCALED", 32);
    PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_SSCALED", 33);
    PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_UINT", 34);
    PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_SINT", 35);
    PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_SRGB", 36);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_UNORM", 37);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_SNORM", 38);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_USCALED", 39);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_SSCALED", 40);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_UINT", 41);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_SINT", 42);
    PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_SRGB", 43);
    PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_UNORM", 44);
    PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_SNORM", 45);
    PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_USCALED", 46);
    PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_SSCALED", 47);
    PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_UINT", 48);
    PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_SINT", 49);
    PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_SRGB", 50);
    PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_UNORM_PACK32", 51);
    PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_SNORM_PACK32", 52);
    PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_USCALED_PACK32", 53);
    PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_SSCALED_PACK32", 54);
    PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_UINT_PACK32", 55);
    PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_SINT_PACK32", 56);
    PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_SRGB_PACK32", 57);
    PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_UNORM_PACK32", 58);
    PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_SNORM_PACK32", 59);
    PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_USCALED_PACK32", 60);
    PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_SSCALED_PACK32", 61);
    PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_UINT_PACK32", 62);
    PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_SINT_PACK32", 63);
    PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_UNORM_PACK32", 64);
    PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_SNORM_PACK32", 65);
    PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_USCALED_PACK32", 66);
    PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_SSCALED_PACK32", 67);
    PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_UINT_PACK32", 68);
    PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_SINT_PACK32", 69);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16_UNORM", 70);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16_SNORM", 71);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16_USCALED", 72);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16_SSCALED", 73);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16_UINT", 74);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16_SINT", 75);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16_SFLOAT", 76);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_UNORM", 77);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_SNORM", 78);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_USCALED", 79);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_SSCALED", 80);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_UINT", 81);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_SINT", 82);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_SFLOAT", 83);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_UNORM", 84);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_SNORM", 85);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_USCALED", 86);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_SSCALED", 87);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_UINT", 88);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_SINT", 89);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_SFLOAT", 90);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_UNORM", 91);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_SNORM", 92);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_USCALED", 93);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_SSCALED", 94);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_UINT", 95);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_SINT", 96);
    PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_SFLOAT", 97);
    PyModule_AddIntConstant(module, "VK_FORMAT_R32_UINT", 98);
    PyModule_AddIntConstant(module, "VK_FORMAT_R32_SINT", 99);
    PyModule_AddIntConstant(module, "VK_FORMAT_R32_SFLOAT", 100);
    PyModule_AddIntConstant(module, "VK_FORMAT_R32G32_UINT", 101);
    PyModule_AddIntConstant(module, "VK_FORMAT_R32G32_SINT", 102);
    PyModule_AddIntConstant(module, "VK_FORMAT_R32G32_SFLOAT", 103);
    PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32_UINT", 104);
    PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32_SINT", 105);
    PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32_SFLOAT", 106);
    PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32A32_UINT", 107);
    PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32A32_SINT", 108);
    PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32A32_SFLOAT", 109);
    PyModule_AddIntConstant(module, "VK_FORMAT_R64_UINT", 110);
    PyModule_AddIntConstant(module, "VK_FORMAT_R64_SINT", 111);
    PyModule_AddIntConstant(module, "VK_FORMAT_R64_SFLOAT", 112);
    PyModule_AddIntConstant(module, "VK_FORMAT_R64G64_UINT", 113);
    PyModule_AddIntConstant(module, "VK_FORMAT_R64G64_SINT", 114);
    PyModule_AddIntConstant(module, "VK_FORMAT_R64G64_SFLOAT", 115);
    PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64_UINT", 116);
    PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64_SINT", 117);
    PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64_SFLOAT", 118);
    PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64A64_UINT", 119);
    PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64A64_SINT", 120);
    PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64A64_SFLOAT", 121);
    PyModule_AddIntConstant(module, "VK_FORMAT_B10G11R11_UFLOAT_PACK32", 122);
    PyModule_AddIntConstant(module, "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32", 123);
    PyModule_AddIntConstant(module, "VK_FORMAT_D16_UNORM", 124);
    PyModule_AddIntConstant(module, "VK_FORMAT_X8_D24_UNORM_PACK32", 125);
    PyModule_AddIntConstant(module, "VK_FORMAT_D32_SFLOAT", 126);
    PyModule_AddIntConstant(module, "VK_FORMAT_S8_UINT", 127);
    PyModule_AddIntConstant(module, "VK_FORMAT_D16_UNORM_S8_UINT", 128);
    PyModule_AddIntConstant(module, "VK_FORMAT_D24_UNORM_S8_UINT", 129);
    PyModule_AddIntConstant(module, "VK_FORMAT_D32_SFLOAT_S8_UINT", 130);
    PyModule_AddIntConstant(module, "VK_FORMAT_BC1_RGB_UNORM_BLOCK", 131);
    PyModule_AddIntConstant(module, "VK_FORMAT_BC1_RGB_SRGB_BLOCK", 132);
    PyModule_AddIntConstant(module, "VK_FORMAT_BC1_RGBA_UNORM_BLOCK", 133);
    PyModule_AddIntConstant(module, "VK_FORMAT_BC1_RGBA_SRGB_BLOCK", 134);
    PyModule_AddIntConstant(module, "VK_FORMAT_BC2_UNORM_BLOCK", 135);
    PyModule_AddIntConstant(module, "VK_FORMAT_BC2_SRGB_BLOCK", 136);
    PyModule_AddIntConstant(module, "VK_FORMAT_BC3_UNORM_BLOCK", 137);
    PyModule_AddIntConstant(module, "VK_FORMAT_BC3_SRGB_BLOCK", 138);
    PyModule_AddIntConstant(module, "VK_FORMAT_BC4_UNORM_BLOCK", 139);
    PyModule_AddIntConstant(module, "VK_FORMAT_BC4_SNORM_BLOCK", 140);
    PyModule_AddIntConstant(module, "VK_FORMAT_BC5_UNORM_BLOCK", 141);
    PyModule_AddIntConstant(module, "VK_FORMAT_BC5_SNORM_BLOCK", 142);
    PyModule_AddIntConstant(module, "VK_FORMAT_BC6H_UFLOAT_BLOCK", 143);
    PyModule_AddIntConstant(module, "VK_FORMAT_BC6H_SFLOAT_BLOCK", 144);
    PyModule_AddIntConstant(module, "VK_FORMAT_BC7_UNORM_BLOCK", 145);
    PyModule_AddIntConstant(module, "VK_FORMAT_BC7_SRGB_BLOCK", 146);
    PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK", 147);
    PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK", 148);
    PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK", 149);
    PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK", 150);
    PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK", 151);
    PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK", 152);
    PyModule_AddIntConstant(module, "VK_FORMAT_EAC_R11_UNORM_BLOCK", 153);
    PyModule_AddIntConstant(module, "VK_FORMAT_EAC_R11_SNORM_BLOCK", 154);
    PyModule_AddIntConstant(module, "VK_FORMAT_EAC_R11G11_UNORM_BLOCK", 155);
    PyModule_AddIntConstant(module, "VK_FORMAT_EAC_R11G11_SNORM_BLOCK", 156);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_4x4_UNORM_BLOCK", 157);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_4x4_SRGB_BLOCK", 158);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_5x4_UNORM_BLOCK", 159);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_5x4_SRGB_BLOCK", 160);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_5x5_UNORM_BLOCK", 161);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_5x5_SRGB_BLOCK", 162);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_6x5_UNORM_BLOCK", 163);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_6x5_SRGB_BLOCK", 164);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_6x6_UNORM_BLOCK", 165);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_6x6_SRGB_BLOCK", 166);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x5_UNORM_BLOCK", 167);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x5_SRGB_BLOCK", 168);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x6_UNORM_BLOCK", 169);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x6_SRGB_BLOCK", 170);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x8_UNORM_BLOCK", 171);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x8_SRGB_BLOCK", 172);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x5_UNORM_BLOCK", 173);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x5_SRGB_BLOCK", 174);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x6_UNORM_BLOCK", 175);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x6_SRGB_BLOCK", 176);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x8_UNORM_BLOCK", 177);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x8_SRGB_BLOCK", 178);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x10_UNORM_BLOCK", 179);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x10_SRGB_BLOCK", 180);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_12x10_UNORM_BLOCK", 181);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_12x10_SRGB_BLOCK", 182);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_12x12_UNORM_BLOCK", 183);
    PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_12x12_SRGB_BLOCK", 184);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_APPLICATION_INFO", 0);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO", 1);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO", 2);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO", 3);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_SUBMIT_INFO", 4);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO", 5);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE", 6);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO", 7);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO", 8);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO", 9);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO", 10);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO", 11);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO", 12);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO", 13);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO", 14);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO", 15);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO", 16);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO", 17);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO", 18);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO", 19);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO", 20);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO", 21);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO", 22);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO", 23);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO", 24);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO", 25);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO", 26);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO", 27);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO", 28);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO", 29);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO", 30);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO", 31);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO", 32);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO", 33);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO", 34);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET", 35);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET", 36);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO", 37);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO", 38);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO", 39);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO", 40);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO", 41);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO", 42);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO", 43);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER", 44);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER", 45);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_MEMORY_BARRIER", 46);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO", 47);
    PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO", 48);
    PyModule_AddIntConstant(module, "VK_SUBPASS_CONTENTS_INLINE", 0);
    PyModule_AddIntConstant(module, "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS", 1);
    PyModule_AddIntConstant(module, "VK_SUCCESS", 0);
    PyModule_AddIntConstant(module, "VK_NOT_READY", 1);
    PyModule_AddIntConstant(module, "VK_TIMEOUT", 2);
    PyModule_AddIntConstant(module, "VK_EVENT_SET", 3);
    PyModule_AddIntConstant(module, "VK_EVENT_RESET", 4);
    PyModule_AddIntConstant(module, "VK_INCOMPLETE", 5);
    PyModule_AddIntConstant(module, "VK_ERROR_OUT_OF_HOST_MEMORY", -1);
    PyModule_AddIntConstant(module, "VK_ERROR_OUT_OF_DEVICE_MEMORY", -2);
    PyModule_AddIntConstant(module, "VK_ERROR_INITIALIZATION_FAILED", -3);
    PyModule_AddIntConstant(module, "VK_ERROR_DEVICE_LOST", -4);
    PyModule_AddIntConstant(module, "VK_ERROR_MEMORY_MAP_FAILED", -5);
    PyModule_AddIntConstant(module, "VK_ERROR_LAYER_NOT_PRESENT", -6);
    PyModule_AddIntConstant(module, "VK_ERROR_EXTENSION_NOT_PRESENT", -7);
    PyModule_AddIntConstant(module, "VK_ERROR_FEATURE_NOT_PRESENT", -8);
    PyModule_AddIntConstant(module, "VK_ERROR_INCOMPATIBLE_DRIVER", -9);
    PyModule_AddIntConstant(module, "VK_ERROR_TOO_MANY_OBJECTS", -10);
    PyModule_AddIntConstant(module, "VK_ERROR_FORMAT_NOT_SUPPORTED", -11);
    PyModule_AddIntConstant(module, "VK_ERROR_FRAGMENTED_POOL", -12);
    PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_VIEWPORT", 0);
    PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_SCISSOR", 1);
    PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_LINE_WIDTH", 2);
    PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_DEPTH_BIAS", 3);
    PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_BLEND_CONSTANTS", 4);
    PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_DEPTH_BOUNDS", 5);
    PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK", 6);
    PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK", 7);
    PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_STENCIL_REFERENCE", 8);
    PyModule_AddIntConstant(module, "VK_QUEUE_GRAPHICS_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_QUEUE_COMPUTE_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_QUEUE_TRANSFER_BIT", 0x00000003);
    PyModule_AddIntConstant(module, "VK_QUEUE_SPARSE_BINDING_BIT", 0x00000004);
    PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT", 0x00000003);
    PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_HOST_CACHED_BIT", 0x00000004);
    PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT", 0x00000005);
    PyModule_AddIntConstant(module, "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_ACCESS_INDIRECT_COMMAND_READ_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_ACCESS_INDEX_READ_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT", 0x00000003);
    PyModule_AddIntConstant(module, "VK_ACCESS_UNIFORM_READ_BIT", 0x00000004);
    PyModule_AddIntConstant(module, "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT", 0x00000005);
    PyModule_AddIntConstant(module, "VK_ACCESS_SHADER_READ_BIT", 0x00000006);
    PyModule_AddIntConstant(module, "VK_ACCESS_SHADER_WRITE_BIT", 0x00000007);
    PyModule_AddIntConstant(module, "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT", 0x00000008);
    PyModule_AddIntConstant(module, "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT", 0x00000009);
    PyModule_AddIntConstant(module, "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT", 0x00000010);
    PyModule_AddIntConstant(module, "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT", 0x00000011);
    PyModule_AddIntConstant(module, "VK_ACCESS_TRANSFER_READ_BIT", 0x00000012);
    PyModule_AddIntConstant(module, "VK_ACCESS_TRANSFER_WRITE_BIT", 0x00000013);
    PyModule_AddIntConstant(module, "VK_ACCESS_HOST_READ_BIT", 0x00000014);
    PyModule_AddIntConstant(module, "VK_ACCESS_HOST_WRITE_BIT", 0x00000015);
    PyModule_AddIntConstant(module, "VK_ACCESS_MEMORY_READ_BIT", 0x00000016);
    PyModule_AddIntConstant(module, "VK_ACCESS_MEMORY_WRITE_BIT", 0x00000017);
    PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_TRANSFER_SRC_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_TRANSFER_DST_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT", 0x00000003);
    PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT", 0x00000004);
    PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT", 0x00000005);
    PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT", 0x00000006);
    PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_INDEX_BUFFER_BIT", 0x00000007);
    PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT", 0x00000008);
    PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT", 0x00000009);
    PyModule_AddIntConstant(module, "VK_BUFFER_CREATE_SPARSE_BINDING_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT", 0x00000003);
    PyModule_AddIntConstant(module, "VK_SHADER_STAGE_VERTEX_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT", 0x00000003);
    PyModule_AddIntConstant(module, "VK_SHADER_STAGE_GEOMETRY_BIT", 0x00000004);
    PyModule_AddIntConstant(module, "VK_SHADER_STAGE_FRAGMENT_BIT", 0x00000005);
    PyModule_AddIntConstant(module, "VK_SHADER_STAGE_COMPUTE_BIT", 0x00000006);
    PyModule_AddIntConstant(module, "VK_SHADER_STAGE_ALL_GRAPHICS", 0x0000001F);
    PyModule_AddIntConstant(module, "VK_SHADER_STAGE_ALL", 0x7FFFFFFF);
    PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_TRANSFER_SRC_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_TRANSFER_DST_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_SAMPLED_BIT", 0x00000003);
    PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_STORAGE_BIT", 0x00000004);
    PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT", 0x00000005);
    PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", 0x00000006);
    PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT", 0x00000007);
    PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT", 0x00000008);
    PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_SPARSE_BINDING_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT", 0x00000003);
    PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT", 0x00000004);
    PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT", 0x00000005);
    PyModule_AddIntConstant(module, "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_PIPELINE_CREATE_DERIVATIVE_BIT", 0x00000003);
    PyModule_AddIntConstant(module, "VK_COLOR_COMPONENT_R_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_COLOR_COMPONENT_G_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_COLOR_COMPONENT_B_BIT", 0x00000003);
    PyModule_AddIntConstant(module, "VK_COLOR_COMPONENT_A_BIT", 0x00000004);
    PyModule_AddIntConstant(module, "VK_FENCE_CREATE_SIGNALED_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", 0x00000003);
    PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT", 0x00000004);
    PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT", 0x00000005);
    PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT", 0x00000006);
    PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT", 0x00000007);
    PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT", 0x00000008);
    PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", 0x00000009);
    PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT", 0x00000010);
    PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_BLIT_SRC_BIT", 0x00000011);
    PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_BLIT_DST_BIT", 0x00000012);
    PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", 0x00000013);
    PyModule_AddIntConstant(module, "VK_QUERY_CONTROL_PRECISE_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_QUERY_RESULT_64_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_QUERY_RESULT_WAIT_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT", 0x00000003);
    PyModule_AddIntConstant(module, "VK_QUERY_RESULT_PARTIAL_BIT", 0x00000004);
    PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT", 0x00000003);
    PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT", 0x00000003);
    PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT", 0x00000004);
    PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT", 0x00000005);
    PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT", 0x00000006);
    PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT", 0x00000007);
    PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT", 0x00000008);
    PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT", 0x00000009);
    PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT", 0x00000010);
    PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT", 0x00000011);
    PyModule_AddIntConstant(module, "VK_IMAGE_ASPECT_COLOR_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_IMAGE_ASPECT_DEPTH_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_IMAGE_ASPECT_STENCIL_BIT", 0x00000003);
    PyModule_AddIntConstant(module, "VK_IMAGE_ASPECT_METADATA_BIT", 0x00000004);
    PyModule_AddIntConstant(module, "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT", 0x00000003);
    PyModule_AddIntConstant(module, "VK_SPARSE_MEMORY_BIND_METADATA_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT", 0x00000003);
    PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT", 0x00000004);
    PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT", 0x00000005);
    PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT", 0x00000006);
    PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", 0x00000007);
    PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT", 0x00000008);
    PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT", 0x00000009);
    PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT", 0x00000010);
    PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT", 0x00000011);
    PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT", 0x00000012);
    PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_TRANSFER_BIT", 0x00000013);
    PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT", 0x00000014);
    PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_HOST_BIT", 0x00000015);
    PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT", 0x00000016);
    PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT", 0x00000017);
    PyModule_AddIntConstant(module, "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_1_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_2_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_4_BIT", 0x00000003);
    PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_8_BIT", 0x00000004);
    PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_16_BIT", 0x00000005);
    PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_32_BIT", 0x00000006);
    PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_64_BIT", 0x00000007);
    PyModule_AddIntConstant(module, "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_STENCIL_FACE_FRONT_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_STENCIL_FACE_BACK_BIT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_STENCIL_FRONT_AND_BACK", 0x00000003);
    PyModule_AddIntConstant(module, "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_DEPENDENCY_BY_REGION_BIT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_PRESENT_MODE_IMMEDIATE_KHR", 0);
    PyModule_AddIntConstant(module, "VK_PRESENT_MODE_MAILBOX_KHR", 1);
    PyModule_AddIntConstant(module, "VK_PRESENT_MODE_FIFO_KHR", 2);
    PyModule_AddIntConstant(module, "VK_PRESENT_MODE_FIFO_RELAXED_KHR", 3);
    PyModule_AddIntConstant(module, "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR", 0);
    PyModule_AddIntConstant(module, "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR", 0x00000001);
    PyModule_AddIntConstant(module, "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR", 0x00000002);
    PyModule_AddIntConstant(module, "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR", 0x00000003);
    PyModule_AddIntConstant(module, "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR", 0x00000004);
    PyModule_AddIntConstant(module, "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR", 0x00000001);
    PyModule_AddIntConstant(module, "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR", 0x00000002);
    PyModule_AddIntConstant(module, "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR", 0x00000003);
    PyModule_AddIntConstant(module, "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR", 0x00000004);
    PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR", 0x00000001);
    PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR", 0x00000002);
    PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR", 0x00000003);
    PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR", 0x00000004);
    PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR", 0x00000005);
    PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR", 0x00000006);
    PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR", 0x00000007);
    PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR", 0x00000008);
    PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR", 0x00000009);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_INFORMATION_BIT_EXT", 0x00000001);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_WARNING_BIT_EXT", 0x00000002);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT", 0x00000003);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_ERROR_BIT_EXT", 0x00000004);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_DEBUG_BIT_EXT", 0x00000005);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT", 0);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT", 1);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT", 2);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT", 3);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT", 4);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT", 5);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT", 6);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT", 7);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT", 8);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT", 9);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT", 10);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT", 11);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT", 12);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT", 13);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT", 14);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT", 15);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT", 16);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT", 17);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT", 18);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT", 19);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT", 20);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT", 21);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT", 22);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT", 23);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT", 24);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT", 25);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT", 26);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT", 27);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT", 28);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_ERROR_NONE_EXT", 0);
    PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT", 1);
    PyModule_AddIntConstant(module, "VK_RASTERIZATION_ORDER_STRICT_AMD", 0);
    PyModule_AddIntConstant(module, "VK_RASTERIZATION_ORDER_RELAXED_AMD", 1);
    PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV", 0x00000001);
    PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV", 0x00000002);
    PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV", 0x00000003);
    PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV", 0x00000004);
    PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV", 0x00000001);
    PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV", 0x00000002);
    PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV", 0x00000003);
    PyModule_AddIntConstant(module, "VK_API_VERSION_1_0", VK_API_VERSION_1_0);

    if (PyType_Ready(&PyVkOffset2DType) < 0)
        return NULL;
    Py_INCREF(&PyVkOffset2DType);
    PyModule_AddObject(module, "VkOffset2D", (PyObject *)&PyVkOffset2DType);

    if (PyType_Ready(&PyVkOffset3DType) < 0)
        return NULL;
    Py_INCREF(&PyVkOffset3DType);
    PyModule_AddObject(module, "VkOffset3D", (PyObject *)&PyVkOffset3DType);

    if (PyType_Ready(&PyVkExtent2DType) < 0)
        return NULL;
    Py_INCREF(&PyVkExtent2DType);
    PyModule_AddObject(module, "VkExtent2D", (PyObject *)&PyVkExtent2DType);

    if (PyType_Ready(&PyVkExtent3DType) < 0)
        return NULL;
    Py_INCREF(&PyVkExtent3DType);
    PyModule_AddObject(module, "VkExtent3D", (PyObject *)&PyVkExtent3DType);

    if (PyType_Ready(&PyVkViewportType) < 0)
        return NULL;
    Py_INCREF(&PyVkViewportType);
    PyModule_AddObject(module, "VkViewport", (PyObject *)&PyVkViewportType);

    if (PyType_Ready(&PyVkRect2DType) < 0)
        return NULL;
    Py_INCREF(&PyVkRect2DType);
    PyModule_AddObject(module, "VkRect2D", (PyObject *)&PyVkRect2DType);

#ifdef hackdefine

    if (PyType_Ready(&PyVkRect3DType) < 0)
        return NULL;
    Py_INCREF(&PyVkRect3DType);
    PyModule_AddObject(module, "VkRect3D", (PyObject *)&PyVkRect3DType);

#endif

    if (PyType_Ready(&PyVkClearRectType) < 0)
        return NULL;
    Py_INCREF(&PyVkClearRectType);
    PyModule_AddObject(module, "VkClearRect", (PyObject *)&PyVkClearRectType);

    if (PyType_Ready(&PyVkComponentMappingType) < 0)
        return NULL;
    Py_INCREF(&PyVkComponentMappingType);
    PyModule_AddObject(module, "VkComponentMapping", (PyObject *)&PyVkComponentMappingType);

    if (PyType_Ready(&PyVkPhysicalDevicePropertiesType) < 0)
        return NULL;
    Py_INCREF(&PyVkPhysicalDevicePropertiesType);
    PyModule_AddObject(module, "VkPhysicalDeviceProperties", (PyObject *)&PyVkPhysicalDevicePropertiesType);

    if (PyType_Ready(&PyVkExtensionPropertiesType) < 0)
        return NULL;
    Py_INCREF(&PyVkExtensionPropertiesType);
    PyModule_AddObject(module, "VkExtensionProperties", (PyObject *)&PyVkExtensionPropertiesType);

    if (PyType_Ready(&PyVkLayerPropertiesType) < 0)
        return NULL;
    Py_INCREF(&PyVkLayerPropertiesType);
    PyModule_AddObject(module, "VkLayerProperties", (PyObject *)&PyVkLayerPropertiesType);

    if (PyType_Ready(&PyVkApplicationInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkApplicationInfoType);
    PyModule_AddObject(module, "VkApplicationInfo", (PyObject *)&PyVkApplicationInfoType);

    if (PyType_Ready(&PyVkAllocationCallbacksType) < 0)
        return NULL;
    Py_INCREF(&PyVkAllocationCallbacksType);
    PyModule_AddObject(module, "VkAllocationCallbacks", (PyObject *)&PyVkAllocationCallbacksType);

    if (PyType_Ready(&PyVkDeviceQueueCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkDeviceQueueCreateInfoType);
    PyModule_AddObject(module, "VkDeviceQueueCreateInfo", (PyObject *)&PyVkDeviceQueueCreateInfoType);

    if (PyType_Ready(&PyVkDeviceCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkDeviceCreateInfoType);
    PyModule_AddObject(module, "VkDeviceCreateInfo", (PyObject *)&PyVkDeviceCreateInfoType);

    if (PyType_Ready(&PyVkInstanceCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkInstanceCreateInfoType);
    PyModule_AddObject(module, "VkInstanceCreateInfo", (PyObject *)&PyVkInstanceCreateInfoType);

    if (PyType_Ready(&PyVkQueueFamilyPropertiesType) < 0)
        return NULL;
    Py_INCREF(&PyVkQueueFamilyPropertiesType);
    PyModule_AddObject(module, "VkQueueFamilyProperties", (PyObject *)&PyVkQueueFamilyPropertiesType);

    if (PyType_Ready(&PyVkPhysicalDeviceMemoryPropertiesType) < 0)
        return NULL;
    Py_INCREF(&PyVkPhysicalDeviceMemoryPropertiesType);
    PyModule_AddObject(module, "VkPhysicalDeviceMemoryProperties", (PyObject *)&PyVkPhysicalDeviceMemoryPropertiesType);

    if (PyType_Ready(&PyVkMemoryAllocateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkMemoryAllocateInfoType);
    PyModule_AddObject(module, "VkMemoryAllocateInfo", (PyObject *)&PyVkMemoryAllocateInfoType);

    if (PyType_Ready(&PyVkMemoryRequirementsType) < 0)
        return NULL;
    Py_INCREF(&PyVkMemoryRequirementsType);
    PyModule_AddObject(module, "VkMemoryRequirements", (PyObject *)&PyVkMemoryRequirementsType);

    if (PyType_Ready(&PyVkSparseImageFormatPropertiesType) < 0)
        return NULL;
    Py_INCREF(&PyVkSparseImageFormatPropertiesType);
    PyModule_AddObject(module, "VkSparseImageFormatProperties", (PyObject *)&PyVkSparseImageFormatPropertiesType);

    if (PyType_Ready(&PyVkSparseImageMemoryRequirementsType) < 0)
        return NULL;
    Py_INCREF(&PyVkSparseImageMemoryRequirementsType);
    PyModule_AddObject(module, "VkSparseImageMemoryRequirements", (PyObject *)&PyVkSparseImageMemoryRequirementsType);

    if (PyType_Ready(&PyVkMemoryTypeType) < 0)
        return NULL;
    Py_INCREF(&PyVkMemoryTypeType);
    PyModule_AddObject(module, "VkMemoryType", (PyObject *)&PyVkMemoryTypeType);

    if (PyType_Ready(&PyVkMemoryHeapType) < 0)
        return NULL;
    Py_INCREF(&PyVkMemoryHeapType);
    PyModule_AddObject(module, "VkMemoryHeap", (PyObject *)&PyVkMemoryHeapType);

    if (PyType_Ready(&PyVkMappedMemoryRangeType) < 0)
        return NULL;
    Py_INCREF(&PyVkMappedMemoryRangeType);
    PyModule_AddObject(module, "VkMappedMemoryRange", (PyObject *)&PyVkMappedMemoryRangeType);

    if (PyType_Ready(&PyVkFormatPropertiesType) < 0)
        return NULL;
    Py_INCREF(&PyVkFormatPropertiesType);
    PyModule_AddObject(module, "VkFormatProperties", (PyObject *)&PyVkFormatPropertiesType);

    if (PyType_Ready(&PyVkImageFormatPropertiesType) < 0)
        return NULL;
    Py_INCREF(&PyVkImageFormatPropertiesType);
    PyModule_AddObject(module, "VkImageFormatProperties", (PyObject *)&PyVkImageFormatPropertiesType);

    if (PyType_Ready(&PyVkDescriptorBufferInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkDescriptorBufferInfoType);
    PyModule_AddObject(module, "VkDescriptorBufferInfo", (PyObject *)&PyVkDescriptorBufferInfoType);

    if (PyType_Ready(&PyVkDescriptorImageInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkDescriptorImageInfoType);
    PyModule_AddObject(module, "VkDescriptorImageInfo", (PyObject *)&PyVkDescriptorImageInfoType);

    if (PyType_Ready(&PyVkWriteDescriptorSetType) < 0)
        return NULL;
    Py_INCREF(&PyVkWriteDescriptorSetType);
    PyModule_AddObject(module, "VkWriteDescriptorSet", (PyObject *)&PyVkWriteDescriptorSetType);

    if (PyType_Ready(&PyVkCopyDescriptorSetType) < 0)
        return NULL;
    Py_INCREF(&PyVkCopyDescriptorSetType);
    PyModule_AddObject(module, "VkCopyDescriptorSet", (PyObject *)&PyVkCopyDescriptorSetType);

    if (PyType_Ready(&PyVkBufferCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkBufferCreateInfoType);
    PyModule_AddObject(module, "VkBufferCreateInfo", (PyObject *)&PyVkBufferCreateInfoType);

    if (PyType_Ready(&PyVkBufferViewCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkBufferViewCreateInfoType);
    PyModule_AddObject(module, "VkBufferViewCreateInfo", (PyObject *)&PyVkBufferViewCreateInfoType);

    if (PyType_Ready(&PyVkImageSubresourceType) < 0)
        return NULL;
    Py_INCREF(&PyVkImageSubresourceType);
    PyModule_AddObject(module, "VkImageSubresource", (PyObject *)&PyVkImageSubresourceType);

    if (PyType_Ready(&PyVkImageSubresourceLayersType) < 0)
        return NULL;
    Py_INCREF(&PyVkImageSubresourceLayersType);
    PyModule_AddObject(module, "VkImageSubresourceLayers", (PyObject *)&PyVkImageSubresourceLayersType);

    if (PyType_Ready(&PyVkImageSubresourceRangeType) < 0)
        return NULL;
    Py_INCREF(&PyVkImageSubresourceRangeType);
    PyModule_AddObject(module, "VkImageSubresourceRange", (PyObject *)&PyVkImageSubresourceRangeType);

    if (PyType_Ready(&PyVkMemoryBarrierType) < 0)
        return NULL;
    Py_INCREF(&PyVkMemoryBarrierType);
    PyModule_AddObject(module, "VkMemoryBarrier", (PyObject *)&PyVkMemoryBarrierType);

    if (PyType_Ready(&PyVkBufferMemoryBarrierType) < 0)
        return NULL;
    Py_INCREF(&PyVkBufferMemoryBarrierType);
    PyModule_AddObject(module, "VkBufferMemoryBarrier", (PyObject *)&PyVkBufferMemoryBarrierType);

    if (PyType_Ready(&PyVkImageMemoryBarrierType) < 0)
        return NULL;
    Py_INCREF(&PyVkImageMemoryBarrierType);
    PyModule_AddObject(module, "VkImageMemoryBarrier", (PyObject *)&PyVkImageMemoryBarrierType);

    if (PyType_Ready(&PyVkImageCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkImageCreateInfoType);
    PyModule_AddObject(module, "VkImageCreateInfo", (PyObject *)&PyVkImageCreateInfoType);

    if (PyType_Ready(&PyVkSubresourceLayoutType) < 0)
        return NULL;
    Py_INCREF(&PyVkSubresourceLayoutType);
    PyModule_AddObject(module, "VkSubresourceLayout", (PyObject *)&PyVkSubresourceLayoutType);

    if (PyType_Ready(&PyVkImageViewCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkImageViewCreateInfoType);
    PyModule_AddObject(module, "VkImageViewCreateInfo", (PyObject *)&PyVkImageViewCreateInfoType);

    if (PyType_Ready(&PyVkBufferCopyType) < 0)
        return NULL;
    Py_INCREF(&PyVkBufferCopyType);
    PyModule_AddObject(module, "VkBufferCopy", (PyObject *)&PyVkBufferCopyType);

    if (PyType_Ready(&PyVkSparseMemoryBindType) < 0)
        return NULL;
    Py_INCREF(&PyVkSparseMemoryBindType);
    PyModule_AddObject(module, "VkSparseMemoryBind", (PyObject *)&PyVkSparseMemoryBindType);

    if (PyType_Ready(&PyVkSparseImageMemoryBindType) < 0)
        return NULL;
    Py_INCREF(&PyVkSparseImageMemoryBindType);
    PyModule_AddObject(module, "VkSparseImageMemoryBind", (PyObject *)&PyVkSparseImageMemoryBindType);

    if (PyType_Ready(&PyVkSparseBufferMemoryBindInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkSparseBufferMemoryBindInfoType);
    PyModule_AddObject(module, "VkSparseBufferMemoryBindInfo", (PyObject *)&PyVkSparseBufferMemoryBindInfoType);

    if (PyType_Ready(&PyVkSparseImageOpaqueMemoryBindInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkSparseImageOpaqueMemoryBindInfoType);
    PyModule_AddObject(module, "VkSparseImageOpaqueMemoryBindInfo", (PyObject *)&PyVkSparseImageOpaqueMemoryBindInfoType);

    if (PyType_Ready(&PyVkSparseImageMemoryBindInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkSparseImageMemoryBindInfoType);
    PyModule_AddObject(module, "VkSparseImageMemoryBindInfo", (PyObject *)&PyVkSparseImageMemoryBindInfoType);

    if (PyType_Ready(&PyVkBindSparseInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkBindSparseInfoType);
    PyModule_AddObject(module, "VkBindSparseInfo", (PyObject *)&PyVkBindSparseInfoType);

    if (PyType_Ready(&PyVkImageCopyType) < 0)
        return NULL;
    Py_INCREF(&PyVkImageCopyType);
    PyModule_AddObject(module, "VkImageCopy", (PyObject *)&PyVkImageCopyType);

    if (PyType_Ready(&PyVkImageBlitType) < 0)
        return NULL;
    Py_INCREF(&PyVkImageBlitType);
    PyModule_AddObject(module, "VkImageBlit", (PyObject *)&PyVkImageBlitType);

    if (PyType_Ready(&PyVkBufferImageCopyType) < 0)
        return NULL;
    Py_INCREF(&PyVkBufferImageCopyType);
    PyModule_AddObject(module, "VkBufferImageCopy", (PyObject *)&PyVkBufferImageCopyType);

    if (PyType_Ready(&PyVkImageResolveType) < 0)
        return NULL;
    Py_INCREF(&PyVkImageResolveType);
    PyModule_AddObject(module, "VkImageResolve", (PyObject *)&PyVkImageResolveType);

    if (PyType_Ready(&PyVkShaderModuleCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkShaderModuleCreateInfoType);
    PyModule_AddObject(module, "VkShaderModuleCreateInfo", (PyObject *)&PyVkShaderModuleCreateInfoType);

    if (PyType_Ready(&PyVkDescriptorSetLayoutBindingType) < 0)
        return NULL;
    Py_INCREF(&PyVkDescriptorSetLayoutBindingType);
    PyModule_AddObject(module, "VkDescriptorSetLayoutBinding", (PyObject *)&PyVkDescriptorSetLayoutBindingType);

    if (PyType_Ready(&PyVkDescriptorSetLayoutCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkDescriptorSetLayoutCreateInfoType);
    PyModule_AddObject(module, "VkDescriptorSetLayoutCreateInfo", (PyObject *)&PyVkDescriptorSetLayoutCreateInfoType);

    if (PyType_Ready(&PyVkDescriptorPoolSizeType) < 0)
        return NULL;
    Py_INCREF(&PyVkDescriptorPoolSizeType);
    PyModule_AddObject(module, "VkDescriptorPoolSize", (PyObject *)&PyVkDescriptorPoolSizeType);

    if (PyType_Ready(&PyVkDescriptorPoolCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkDescriptorPoolCreateInfoType);
    PyModule_AddObject(module, "VkDescriptorPoolCreateInfo", (PyObject *)&PyVkDescriptorPoolCreateInfoType);

    if (PyType_Ready(&PyVkDescriptorSetAllocateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkDescriptorSetAllocateInfoType);
    PyModule_AddObject(module, "VkDescriptorSetAllocateInfo", (PyObject *)&PyVkDescriptorSetAllocateInfoType);

    if (PyType_Ready(&PyVkSpecializationMapEntryType) < 0)
        return NULL;
    Py_INCREF(&PyVkSpecializationMapEntryType);
    PyModule_AddObject(module, "VkSpecializationMapEntry", (PyObject *)&PyVkSpecializationMapEntryType);

    if (PyType_Ready(&PyVkSpecializationInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkSpecializationInfoType);
    PyModule_AddObject(module, "VkSpecializationInfo", (PyObject *)&PyVkSpecializationInfoType);

    if (PyType_Ready(&PyVkPipelineShaderStageCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkPipelineShaderStageCreateInfoType);
    PyModule_AddObject(module, "VkPipelineShaderStageCreateInfo", (PyObject *)&PyVkPipelineShaderStageCreateInfoType);

    if (PyType_Ready(&PyVkComputePipelineCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkComputePipelineCreateInfoType);
    PyModule_AddObject(module, "VkComputePipelineCreateInfo", (PyObject *)&PyVkComputePipelineCreateInfoType);

    if (PyType_Ready(&PyVkVertexInputBindingDescriptionType) < 0)
        return NULL;
    Py_INCREF(&PyVkVertexInputBindingDescriptionType);
    PyModule_AddObject(module, "VkVertexInputBindingDescription", (PyObject *)&PyVkVertexInputBindingDescriptionType);

    if (PyType_Ready(&PyVkVertexInputAttributeDescriptionType) < 0)
        return NULL;
    Py_INCREF(&PyVkVertexInputAttributeDescriptionType);
    PyModule_AddObject(module, "VkVertexInputAttributeDescription", (PyObject *)&PyVkVertexInputAttributeDescriptionType);

    if (PyType_Ready(&PyVkPipelineVertexInputStateCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkPipelineVertexInputStateCreateInfoType);
    PyModule_AddObject(module, "VkPipelineVertexInputStateCreateInfo", (PyObject *)&PyVkPipelineVertexInputStateCreateInfoType);

    if (PyType_Ready(&PyVkPipelineInputAssemblyStateCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkPipelineInputAssemblyStateCreateInfoType);
    PyModule_AddObject(module, "VkPipelineInputAssemblyStateCreateInfo", (PyObject *)&PyVkPipelineInputAssemblyStateCreateInfoType);

    if (PyType_Ready(&PyVkPipelineTessellationStateCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkPipelineTessellationStateCreateInfoType);
    PyModule_AddObject(module, "VkPipelineTessellationStateCreateInfo", (PyObject *)&PyVkPipelineTessellationStateCreateInfoType);

    if (PyType_Ready(&PyVkPipelineViewportStateCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkPipelineViewportStateCreateInfoType);
    PyModule_AddObject(module, "VkPipelineViewportStateCreateInfo", (PyObject *)&PyVkPipelineViewportStateCreateInfoType);

    if (PyType_Ready(&PyVkPipelineRasterizationStateCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkPipelineRasterizationStateCreateInfoType);
    PyModule_AddObject(module, "VkPipelineRasterizationStateCreateInfo", (PyObject *)&PyVkPipelineRasterizationStateCreateInfoType);

    if (PyType_Ready(&PyVkPipelineMultisampleStateCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkPipelineMultisampleStateCreateInfoType);
    PyModule_AddObject(module, "VkPipelineMultisampleStateCreateInfo", (PyObject *)&PyVkPipelineMultisampleStateCreateInfoType);

    if (PyType_Ready(&PyVkPipelineColorBlendAttachmentStateType) < 0)
        return NULL;
    Py_INCREF(&PyVkPipelineColorBlendAttachmentStateType);
    PyModule_AddObject(module, "VkPipelineColorBlendAttachmentState", (PyObject *)&PyVkPipelineColorBlendAttachmentStateType);

    if (PyType_Ready(&PyVkPipelineColorBlendStateCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkPipelineColorBlendStateCreateInfoType);
    PyModule_AddObject(module, "VkPipelineColorBlendStateCreateInfo", (PyObject *)&PyVkPipelineColorBlendStateCreateInfoType);

    if (PyType_Ready(&PyVkPipelineDynamicStateCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkPipelineDynamicStateCreateInfoType);
    PyModule_AddObject(module, "VkPipelineDynamicStateCreateInfo", (PyObject *)&PyVkPipelineDynamicStateCreateInfoType);

    if (PyType_Ready(&PyVkStencilOpStateType) < 0)
        return NULL;
    Py_INCREF(&PyVkStencilOpStateType);
    PyModule_AddObject(module, "VkStencilOpState", (PyObject *)&PyVkStencilOpStateType);

    if (PyType_Ready(&PyVkPipelineDepthStencilStateCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkPipelineDepthStencilStateCreateInfoType);
    PyModule_AddObject(module, "VkPipelineDepthStencilStateCreateInfo", (PyObject *)&PyVkPipelineDepthStencilStateCreateInfoType);

    if (PyType_Ready(&PyVkGraphicsPipelineCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkGraphicsPipelineCreateInfoType);
    PyModule_AddObject(module, "VkGraphicsPipelineCreateInfo", (PyObject *)&PyVkGraphicsPipelineCreateInfoType);

    if (PyType_Ready(&PyVkPipelineCacheCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkPipelineCacheCreateInfoType);
    PyModule_AddObject(module, "VkPipelineCacheCreateInfo", (PyObject *)&PyVkPipelineCacheCreateInfoType);

    if (PyType_Ready(&PyVkPushConstantRangeType) < 0)
        return NULL;
    Py_INCREF(&PyVkPushConstantRangeType);
    PyModule_AddObject(module, "VkPushConstantRange", (PyObject *)&PyVkPushConstantRangeType);

    if (PyType_Ready(&PyVkPipelineLayoutCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkPipelineLayoutCreateInfoType);
    PyModule_AddObject(module, "VkPipelineLayoutCreateInfo", (PyObject *)&PyVkPipelineLayoutCreateInfoType);

    if (PyType_Ready(&PyVkSamplerCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkSamplerCreateInfoType);
    PyModule_AddObject(module, "VkSamplerCreateInfo", (PyObject *)&PyVkSamplerCreateInfoType);

    if (PyType_Ready(&PyVkCommandPoolCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkCommandPoolCreateInfoType);
    PyModule_AddObject(module, "VkCommandPoolCreateInfo", (PyObject *)&PyVkCommandPoolCreateInfoType);

    if (PyType_Ready(&PyVkCommandBufferAllocateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkCommandBufferAllocateInfoType);
    PyModule_AddObject(module, "VkCommandBufferAllocateInfo", (PyObject *)&PyVkCommandBufferAllocateInfoType);

    if (PyType_Ready(&PyVkCommandBufferInheritanceInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkCommandBufferInheritanceInfoType);
    PyModule_AddObject(module, "VkCommandBufferInheritanceInfo", (PyObject *)&PyVkCommandBufferInheritanceInfoType);

    if (PyType_Ready(&PyVkCommandBufferBeginInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkCommandBufferBeginInfoType);
    PyModule_AddObject(module, "VkCommandBufferBeginInfo", (PyObject *)&PyVkCommandBufferBeginInfoType);

    if (PyType_Ready(&PyVkRenderPassBeginInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkRenderPassBeginInfoType);
    PyModule_AddObject(module, "VkRenderPassBeginInfo", (PyObject *)&PyVkRenderPassBeginInfoType);

    if (PyType_Ready(&PyVkClearDepthStencilValueType) < 0)
        return NULL;
    Py_INCREF(&PyVkClearDepthStencilValueType);
    PyModule_AddObject(module, "VkClearDepthStencilValue", (PyObject *)&PyVkClearDepthStencilValueType);

    if (PyType_Ready(&PyVkClearAttachmentType) < 0)
        return NULL;
    Py_INCREF(&PyVkClearAttachmentType);
    PyModule_AddObject(module, "VkClearAttachment", (PyObject *)&PyVkClearAttachmentType);

    if (PyType_Ready(&PyVkAttachmentDescriptionType) < 0)
        return NULL;
    Py_INCREF(&PyVkAttachmentDescriptionType);
    PyModule_AddObject(module, "VkAttachmentDescription", (PyObject *)&PyVkAttachmentDescriptionType);

    if (PyType_Ready(&PyVkAttachmentReferenceType) < 0)
        return NULL;
    Py_INCREF(&PyVkAttachmentReferenceType);
    PyModule_AddObject(module, "VkAttachmentReference", (PyObject *)&PyVkAttachmentReferenceType);

    if (PyType_Ready(&PyVkSubpassDescriptionType) < 0)
        return NULL;
    Py_INCREF(&PyVkSubpassDescriptionType);
    PyModule_AddObject(module, "VkSubpassDescription", (PyObject *)&PyVkSubpassDescriptionType);

    if (PyType_Ready(&PyVkSubpassDependencyType) < 0)
        return NULL;
    Py_INCREF(&PyVkSubpassDependencyType);
    PyModule_AddObject(module, "VkSubpassDependency", (PyObject *)&PyVkSubpassDependencyType);

    if (PyType_Ready(&PyVkRenderPassCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkRenderPassCreateInfoType);
    PyModule_AddObject(module, "VkRenderPassCreateInfo", (PyObject *)&PyVkRenderPassCreateInfoType);

    if (PyType_Ready(&PyVkEventCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkEventCreateInfoType);
    PyModule_AddObject(module, "VkEventCreateInfo", (PyObject *)&PyVkEventCreateInfoType);

    if (PyType_Ready(&PyVkFenceCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkFenceCreateInfoType);
    PyModule_AddObject(module, "VkFenceCreateInfo", (PyObject *)&PyVkFenceCreateInfoType);

    if (PyType_Ready(&PyVkPhysicalDeviceFeaturesType) < 0)
        return NULL;
    Py_INCREF(&PyVkPhysicalDeviceFeaturesType);
    PyModule_AddObject(module, "VkPhysicalDeviceFeatures", (PyObject *)&PyVkPhysicalDeviceFeaturesType);

    if (PyType_Ready(&PyVkPhysicalDeviceSparsePropertiesType) < 0)
        return NULL;
    Py_INCREF(&PyVkPhysicalDeviceSparsePropertiesType);
    PyModule_AddObject(module, "VkPhysicalDeviceSparseProperties", (PyObject *)&PyVkPhysicalDeviceSparsePropertiesType);

    if (PyType_Ready(&PyVkPhysicalDeviceLimitsType) < 0)
        return NULL;
    Py_INCREF(&PyVkPhysicalDeviceLimitsType);
    PyModule_AddObject(module, "VkPhysicalDeviceLimits", (PyObject *)&PyVkPhysicalDeviceLimitsType);

    if (PyType_Ready(&PyVkSemaphoreCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkSemaphoreCreateInfoType);
    PyModule_AddObject(module, "VkSemaphoreCreateInfo", (PyObject *)&PyVkSemaphoreCreateInfoType);

    if (PyType_Ready(&PyVkQueryPoolCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkQueryPoolCreateInfoType);
    PyModule_AddObject(module, "VkQueryPoolCreateInfo", (PyObject *)&PyVkQueryPoolCreateInfoType);

    if (PyType_Ready(&PyVkFramebufferCreateInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkFramebufferCreateInfoType);
    PyModule_AddObject(module, "VkFramebufferCreateInfo", (PyObject *)&PyVkFramebufferCreateInfoType);

    if (PyType_Ready(&PyVkDrawIndirectCommandType) < 0)
        return NULL;
    Py_INCREF(&PyVkDrawIndirectCommandType);
    PyModule_AddObject(module, "VkDrawIndirectCommand", (PyObject *)&PyVkDrawIndirectCommandType);

    if (PyType_Ready(&PyVkDrawIndexedIndirectCommandType) < 0)
        return NULL;
    Py_INCREF(&PyVkDrawIndexedIndirectCommandType);
    PyModule_AddObject(module, "VkDrawIndexedIndirectCommand", (PyObject *)&PyVkDrawIndexedIndirectCommandType);

    if (PyType_Ready(&PyVkDispatchIndirectCommandType) < 0)
        return NULL;
    Py_INCREF(&PyVkDispatchIndirectCommandType);
    PyModule_AddObject(module, "VkDispatchIndirectCommand", (PyObject *)&PyVkDispatchIndirectCommandType);

    if (PyType_Ready(&PyVkSubmitInfoType) < 0)
        return NULL;
    Py_INCREF(&PyVkSubmitInfoType);
    PyModule_AddObject(module, "VkSubmitInfo", (PyObject *)&PyVkSubmitInfoType);

    if (PyType_Ready(&PyVkDisplayPropertiesKHRType) < 0)
        return NULL;
    Py_INCREF(&PyVkDisplayPropertiesKHRType);
    PyModule_AddObject(module, "VkDisplayPropertiesKHR", (PyObject *)&PyVkDisplayPropertiesKHRType);

    if (PyType_Ready(&PyVkDisplayPlanePropertiesKHRType) < 0)
        return NULL;
    Py_INCREF(&PyVkDisplayPlanePropertiesKHRType);
    PyModule_AddObject(module, "VkDisplayPlanePropertiesKHR", (PyObject *)&PyVkDisplayPlanePropertiesKHRType);

    if (PyType_Ready(&PyVkDisplayModeParametersKHRType) < 0)
        return NULL;
    Py_INCREF(&PyVkDisplayModeParametersKHRType);
    PyModule_AddObject(module, "VkDisplayModeParametersKHR", (PyObject *)&PyVkDisplayModeParametersKHRType);

    if (PyType_Ready(&PyVkDisplayModePropertiesKHRType) < 0)
        return NULL;
    Py_INCREF(&PyVkDisplayModePropertiesKHRType);
    PyModule_AddObject(module, "VkDisplayModePropertiesKHR", (PyObject *)&PyVkDisplayModePropertiesKHRType);

    if (PyType_Ready(&PyVkDisplayModeCreateInfoKHRType) < 0)
        return NULL;
    Py_INCREF(&PyVkDisplayModeCreateInfoKHRType);
    PyModule_AddObject(module, "VkDisplayModeCreateInfoKHR", (PyObject *)&PyVkDisplayModeCreateInfoKHRType);

    if (PyType_Ready(&PyVkDisplayPlaneCapabilitiesKHRType) < 0)
        return NULL;
    Py_INCREF(&PyVkDisplayPlaneCapabilitiesKHRType);
    PyModule_AddObject(module, "VkDisplayPlaneCapabilitiesKHR", (PyObject *)&PyVkDisplayPlaneCapabilitiesKHRType);

    if (PyType_Ready(&PyVkDisplaySurfaceCreateInfoKHRType) < 0)
        return NULL;
    Py_INCREF(&PyVkDisplaySurfaceCreateInfoKHRType);
    PyModule_AddObject(module, "VkDisplaySurfaceCreateInfoKHR", (PyObject *)&PyVkDisplaySurfaceCreateInfoKHRType);

    if (PyType_Ready(&PyVkDisplayPresentInfoKHRType) < 0)
        return NULL;
    Py_INCREF(&PyVkDisplayPresentInfoKHRType);
    PyModule_AddObject(module, "VkDisplayPresentInfoKHR", (PyObject *)&PyVkDisplayPresentInfoKHRType);

    if (PyType_Ready(&PyVkSurfaceCapabilitiesKHRType) < 0)
        return NULL;
    Py_INCREF(&PyVkSurfaceCapabilitiesKHRType);
    PyModule_AddObject(module, "VkSurfaceCapabilitiesKHR", (PyObject *)&PyVkSurfaceCapabilitiesKHRType);

#ifdef VK_USE_PLATFORM_ANDROID_KHR

    if (PyType_Ready(&PyVkAndroidSurfaceCreateInfoKHRType) < 0)
        return NULL;
    Py_INCREF(&PyVkAndroidSurfaceCreateInfoKHRType);
    PyModule_AddObject(module, "VkAndroidSurfaceCreateInfoKHR", (PyObject *)&PyVkAndroidSurfaceCreateInfoKHRType);

#endif

#ifdef VK_USE_PLATFORM_MIR_KHR

    if (PyType_Ready(&PyVkMirSurfaceCreateInfoKHRType) < 0)
        return NULL;
    Py_INCREF(&PyVkMirSurfaceCreateInfoKHRType);
    PyModule_AddObject(module, "VkMirSurfaceCreateInfoKHR", (PyObject *)&PyVkMirSurfaceCreateInfoKHRType);

#endif

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

    if (PyType_Ready(&PyVkWaylandSurfaceCreateInfoKHRType) < 0)
        return NULL;
    Py_INCREF(&PyVkWaylandSurfaceCreateInfoKHRType);
    PyModule_AddObject(module, "VkWaylandSurfaceCreateInfoKHR", (PyObject *)&PyVkWaylandSurfaceCreateInfoKHRType);

#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

    if (PyType_Ready(&PyVkWin32SurfaceCreateInfoKHRType) < 0)
        return NULL;
    Py_INCREF(&PyVkWin32SurfaceCreateInfoKHRType);
    PyModule_AddObject(module, "VkWin32SurfaceCreateInfoKHR", (PyObject *)&PyVkWin32SurfaceCreateInfoKHRType);

#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR

    if (PyType_Ready(&PyVkXlibSurfaceCreateInfoKHRType) < 0)
        return NULL;
    Py_INCREF(&PyVkXlibSurfaceCreateInfoKHRType);
    PyModule_AddObject(module, "VkXlibSurfaceCreateInfoKHR", (PyObject *)&PyVkXlibSurfaceCreateInfoKHRType);

#endif

#ifdef VK_USE_PLATFORM_XCB_KHR

    if (PyType_Ready(&PyVkXcbSurfaceCreateInfoKHRType) < 0)
        return NULL;
    Py_INCREF(&PyVkXcbSurfaceCreateInfoKHRType);
    PyModule_AddObject(module, "VkXcbSurfaceCreateInfoKHR", (PyObject *)&PyVkXcbSurfaceCreateInfoKHRType);

#endif

    if (PyType_Ready(&PyVkSurfaceFormatKHRType) < 0)
        return NULL;
    Py_INCREF(&PyVkSurfaceFormatKHRType);
    PyModule_AddObject(module, "VkSurfaceFormatKHR", (PyObject *)&PyVkSurfaceFormatKHRType);

    if (PyType_Ready(&PyVkSwapchainCreateInfoKHRType) < 0)
        return NULL;
    Py_INCREF(&PyVkSwapchainCreateInfoKHRType);
    PyModule_AddObject(module, "VkSwapchainCreateInfoKHR", (PyObject *)&PyVkSwapchainCreateInfoKHRType);

    if (PyType_Ready(&PyVkPresentInfoKHRType) < 0)
        return NULL;
    Py_INCREF(&PyVkPresentInfoKHRType);
    PyModule_AddObject(module, "VkPresentInfoKHR", (PyObject *)&PyVkPresentInfoKHRType);

    if (PyType_Ready(&PyVkDebugReportCallbackCreateInfoEXTType) < 0)
        return NULL;
    Py_INCREF(&PyVkDebugReportCallbackCreateInfoEXTType);
    PyModule_AddObject(module, "VkDebugReportCallbackCreateInfoEXT", (PyObject *)&PyVkDebugReportCallbackCreateInfoEXTType);

    if (PyType_Ready(&PyVkPipelineRasterizationStateRasterizationOrderAMDType) < 0)
        return NULL;
    Py_INCREF(&PyVkPipelineRasterizationStateRasterizationOrderAMDType);
    PyModule_AddObject(module, "VkPipelineRasterizationStateRasterizationOrderAMD", (PyObject *)&PyVkPipelineRasterizationStateRasterizationOrderAMDType);

    if (PyType_Ready(&PyVkDebugMarkerObjectNameInfoEXTType) < 0)
        return NULL;
    Py_INCREF(&PyVkDebugMarkerObjectNameInfoEXTType);
    PyModule_AddObject(module, "VkDebugMarkerObjectNameInfoEXT", (PyObject *)&PyVkDebugMarkerObjectNameInfoEXTType);

    if (PyType_Ready(&PyVkDebugMarkerObjectTagInfoEXTType) < 0)
        return NULL;
    Py_INCREF(&PyVkDebugMarkerObjectTagInfoEXTType);
    PyModule_AddObject(module, "VkDebugMarkerObjectTagInfoEXT", (PyObject *)&PyVkDebugMarkerObjectTagInfoEXTType);

    if (PyType_Ready(&PyVkDebugMarkerMarkerInfoEXTType) < 0)
        return NULL;
    Py_INCREF(&PyVkDebugMarkerMarkerInfoEXTType);
    PyModule_AddObject(module, "VkDebugMarkerMarkerInfoEXT", (PyObject *)&PyVkDebugMarkerMarkerInfoEXTType);

    if (PyType_Ready(&PyVkDedicatedAllocationImageCreateInfoNVType) < 0)
        return NULL;
    Py_INCREF(&PyVkDedicatedAllocationImageCreateInfoNVType);
    PyModule_AddObject(module, "VkDedicatedAllocationImageCreateInfoNV", (PyObject *)&PyVkDedicatedAllocationImageCreateInfoNVType);

    if (PyType_Ready(&PyVkDedicatedAllocationBufferCreateInfoNVType) < 0)
        return NULL;
    Py_INCREF(&PyVkDedicatedAllocationBufferCreateInfoNVType);
    PyModule_AddObject(module, "VkDedicatedAllocationBufferCreateInfoNV", (PyObject *)&PyVkDedicatedAllocationBufferCreateInfoNVType);

    if (PyType_Ready(&PyVkDedicatedAllocationMemoryAllocateInfoNVType) < 0)
        return NULL;
    Py_INCREF(&PyVkDedicatedAllocationMemoryAllocateInfoNVType);
    PyModule_AddObject(module, "VkDedicatedAllocationMemoryAllocateInfoNV", (PyObject *)&PyVkDedicatedAllocationMemoryAllocateInfoNVType);

    if (PyType_Ready(&PyVkExternalImageFormatPropertiesNVType) < 0)
        return NULL;
    Py_INCREF(&PyVkExternalImageFormatPropertiesNVType);
    PyModule_AddObject(module, "VkExternalImageFormatPropertiesNV", (PyObject *)&PyVkExternalImageFormatPropertiesNVType);

    if (PyType_Ready(&PyVkExternalMemoryImageCreateInfoNVType) < 0)
        return NULL;
    Py_INCREF(&PyVkExternalMemoryImageCreateInfoNVType);
    PyModule_AddObject(module, "VkExternalMemoryImageCreateInfoNV", (PyObject *)&PyVkExternalMemoryImageCreateInfoNVType);

    if (PyType_Ready(&PyVkExportMemoryAllocateInfoNVType) < 0)
        return NULL;
    Py_INCREF(&PyVkExportMemoryAllocateInfoNVType);
    PyModule_AddObject(module, "VkExportMemoryAllocateInfoNV", (PyObject *)&PyVkExportMemoryAllocateInfoNVType);

#ifdef VK_USE_PLATFORM_WIN32_KHR

    if (PyType_Ready(&PyVkImportMemoryWin32HandleInfoNVType) < 0)
        return NULL;
    Py_INCREF(&PyVkImportMemoryWin32HandleInfoNVType);
    PyModule_AddObject(module, "VkImportMemoryWin32HandleInfoNV", (PyObject *)&PyVkImportMemoryWin32HandleInfoNVType);

#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

    if (PyType_Ready(&PyVkExportMemoryWin32HandleInfoNVType) < 0)
        return NULL;
    Py_INCREF(&PyVkExportMemoryWin32HandleInfoNVType);
    PyModule_AddObject(module, "VkExportMemoryWin32HandleInfoNV", (PyObject *)&PyVkExportMemoryWin32HandleInfoNVType);

#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

    if (PyType_Ready(&PyVkWin32KeyedMutexAcquireReleaseInfoNVType) < 0)
        return NULL;
    Py_INCREF(&PyVkWin32KeyedMutexAcquireReleaseInfoNVType);
    PyModule_AddObject(module, "VkWin32KeyedMutexAcquireReleaseInfoNV", (PyObject *)&PyVkWin32KeyedMutexAcquireReleaseInfoNVType);

#endif

    if (PyType_Ready(&PyVkClearColorValueType) < 0)
        return NULL;
    Py_INCREF(&PyVkClearColorValueType);
    PyModule_AddObject(module, "VkClearColorValue", (PyObject *)&PyVkClearColorValueType);

    if (PyType_Ready(&PyVkClearValueType) < 0)
        return NULL;
    Py_INCREF(&PyVkClearValueType);
    PyModule_AddObject(module, "VkClearValue", (PyObject *)&PyVkClearValueType);

    if (PyType_Ready(&PyvkAcquireNextImageKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkAcquireNextImageKHRType);
    PyModule_AddObject(module, "vkAcquireNextImageKHR", (PyObject *)&PyvkAcquireNextImageKHRType);

    if (PyType_Ready(&PyvkGetPhysicalDeviceExternalImageFormatPropertiesNVType) < 0)
        return NULL;
    Py_INCREF(&PyvkGetPhysicalDeviceExternalImageFormatPropertiesNVType);
    PyModule_AddObject(module, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV", (PyObject *)&PyvkGetPhysicalDeviceExternalImageFormatPropertiesNVType);

    if (PyType_Ready(&PyvkCmdDebugMarkerBeginEXTType) < 0)
        return NULL;
    Py_INCREF(&PyvkCmdDebugMarkerBeginEXTType);
    PyModule_AddObject(module, "vkCmdDebugMarkerBeginEXT", (PyObject *)&PyvkCmdDebugMarkerBeginEXTType);

#ifdef VK_USE_PLATFORM_XLIB_KHR

    if (PyType_Ready(&PyvkCreateXlibSurfaceKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkCreateXlibSurfaceKHRType);
    PyModule_AddObject(module, "vkCreateXlibSurfaceKHR", (PyObject *)&PyvkCreateXlibSurfaceKHRType);

#endif

    if (PyType_Ready(&PyvkCreateSwapchainKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkCreateSwapchainKHRType);
    PyModule_AddObject(module, "vkCreateSwapchainKHR", (PyObject *)&PyvkCreateSwapchainKHRType);

    if (PyType_Ready(&PyvkGetPhysicalDeviceDisplayPropertiesKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkGetPhysicalDeviceDisplayPropertiesKHRType);
    PyModule_AddObject(module, "vkGetPhysicalDeviceDisplayPropertiesKHR", (PyObject *)&PyvkGetPhysicalDeviceDisplayPropertiesKHRType);

#ifdef VK_USE_PLATFORM_WIN32_KHR

    if (PyType_Ready(&PyvkCreateWin32SurfaceKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkCreateWin32SurfaceKHRType);
    PyModule_AddObject(module, "vkCreateWin32SurfaceKHR", (PyObject *)&PyvkCreateWin32SurfaceKHRType);

#endif

    if (PyType_Ready(&PyvkCreateDisplayPlaneSurfaceKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkCreateDisplayPlaneSurfaceKHRType);
    PyModule_AddObject(module, "vkCreateDisplayPlaneSurfaceKHR", (PyObject *)&PyvkCreateDisplayPlaneSurfaceKHRType);

    if (PyType_Ready(&PyvkGetPhysicalDeviceSurfacePresentModesKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkGetPhysicalDeviceSurfacePresentModesKHRType);
    PyModule_AddObject(module, "vkGetPhysicalDeviceSurfacePresentModesKHR", (PyObject *)&PyvkGetPhysicalDeviceSurfacePresentModesKHRType);

    if (PyType_Ready(&PyvkDestroyDebugReportCallbackEXTType) < 0)
        return NULL;
    Py_INCREF(&PyvkDestroyDebugReportCallbackEXTType);
    PyModule_AddObject(module, "vkDestroyDebugReportCallbackEXT", (PyObject *)&PyvkDestroyDebugReportCallbackEXTType);

    if (PyType_Ready(&PyvkGetPhysicalDeviceSurfaceFormatsKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkGetPhysicalDeviceSurfaceFormatsKHRType);
    PyModule_AddObject(module, "vkGetPhysicalDeviceSurfaceFormatsKHR", (PyObject *)&PyvkGetPhysicalDeviceSurfaceFormatsKHRType);

#ifdef VK_USE_PLATFORM_WIN32_KHR

    if (PyType_Ready(&PyvkGetPhysicalDeviceWin32PresentationSupportKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkGetPhysicalDeviceWin32PresentationSupportKHRType);
    PyModule_AddObject(module, "vkGetPhysicalDeviceWin32PresentationSupportKHR", (PyObject *)&PyvkGetPhysicalDeviceWin32PresentationSupportKHRType);

#endif

    if (PyType_Ready(&PyvkCmdDebugMarkerEndEXTType) < 0)
        return NULL;
    Py_INCREF(&PyvkCmdDebugMarkerEndEXTType);
    PyModule_AddObject(module, "vkCmdDebugMarkerEndEXT", (PyObject *)&PyvkCmdDebugMarkerEndEXTType);

    if (PyType_Ready(&PyvkGetPhysicalDeviceSurfaceCapabilitiesKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkGetPhysicalDeviceSurfaceCapabilitiesKHRType);
    PyModule_AddObject(module, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR", (PyObject *)&PyvkGetPhysicalDeviceSurfaceCapabilitiesKHRType);

    if (PyType_Ready(&PyvkGetDisplayPlaneSupportedDisplaysKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkGetDisplayPlaneSupportedDisplaysKHRType);
    PyModule_AddObject(module, "vkGetDisplayPlaneSupportedDisplaysKHR", (PyObject *)&PyvkGetDisplayPlaneSupportedDisplaysKHRType);

    if (PyType_Ready(&PyvkGetPhysicalDeviceSurfaceSupportKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkGetPhysicalDeviceSurfaceSupportKHRType);
    PyModule_AddObject(module, "vkGetPhysicalDeviceSurfaceSupportKHR", (PyObject *)&PyvkGetPhysicalDeviceSurfaceSupportKHRType);

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

    if (PyType_Ready(&PyvkCreateWaylandSurfaceKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkCreateWaylandSurfaceKHRType);
    PyModule_AddObject(module, "vkCreateWaylandSurfaceKHR", (PyObject *)&PyvkCreateWaylandSurfaceKHRType);

#endif

    if (PyType_Ready(&PyvkDebugMarkerSetObjectTagEXTType) < 0)
        return NULL;
    Py_INCREF(&PyvkDebugMarkerSetObjectTagEXTType);
    PyModule_AddObject(module, "vkDebugMarkerSetObjectTagEXT", (PyObject *)&PyvkDebugMarkerSetObjectTagEXTType);

    if (PyType_Ready(&PyvkGetPhysicalDeviceDisplayPlanePropertiesKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkGetPhysicalDeviceDisplayPlanePropertiesKHRType);
    PyModule_AddObject(module, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR", (PyObject *)&PyvkGetPhysicalDeviceDisplayPlanePropertiesKHRType);

    if (PyType_Ready(&PyvkCmdDebugMarkerInsertEXTType) < 0)
        return NULL;
    Py_INCREF(&PyvkCmdDebugMarkerInsertEXTType);
    PyModule_AddObject(module, "vkCmdDebugMarkerInsertEXT", (PyObject *)&PyvkCmdDebugMarkerInsertEXTType);

    if (PyType_Ready(&PyvkGetDisplayModePropertiesKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkGetDisplayModePropertiesKHRType);
    PyModule_AddObject(module, "vkGetDisplayModePropertiesKHR", (PyObject *)&PyvkGetDisplayModePropertiesKHRType);

    if (PyType_Ready(&PyvkCmdDrawIndirectCountAMDType) < 0)
        return NULL;
    Py_INCREF(&PyvkCmdDrawIndirectCountAMDType);
    PyModule_AddObject(module, "vkCmdDrawIndirectCountAMD", (PyObject *)&PyvkCmdDrawIndirectCountAMDType);

#ifdef VK_USE_PLATFORM_ANDROID_KHR

    if (PyType_Ready(&PyvkCreateAndroidSurfaceKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkCreateAndroidSurfaceKHRType);
    PyModule_AddObject(module, "vkCreateAndroidSurfaceKHR", (PyObject *)&PyvkCreateAndroidSurfaceKHRType);

#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

    if (PyType_Ready(&PyvkGetMemoryWin32HandleNVType) < 0)
        return NULL;
    Py_INCREF(&PyvkGetMemoryWin32HandleNVType);
    PyModule_AddObject(module, "vkGetMemoryWin32HandleNV", (PyObject *)&PyvkGetMemoryWin32HandleNVType);

#endif

    if (PyType_Ready(&PyvkGetDisplayPlaneCapabilitiesKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkGetDisplayPlaneCapabilitiesKHRType);
    PyModule_AddObject(module, "vkGetDisplayPlaneCapabilitiesKHR", (PyObject *)&PyvkGetDisplayPlaneCapabilitiesKHRType);

    if (PyType_Ready(&PyvkCmdDrawIndexedIndirectCountAMDType) < 0)
        return NULL;
    Py_INCREF(&PyvkCmdDrawIndexedIndirectCountAMDType);
    PyModule_AddObject(module, "vkCmdDrawIndexedIndirectCountAMD", (PyObject *)&PyvkCmdDrawIndexedIndirectCountAMDType);

    if (PyType_Ready(&PyvkGetSwapchainImagesKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkGetSwapchainImagesKHRType);
    PyModule_AddObject(module, "vkGetSwapchainImagesKHR", (PyObject *)&PyvkGetSwapchainImagesKHRType);

    if (PyType_Ready(&PyvkQueuePresentKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkQueuePresentKHRType);
    PyModule_AddObject(module, "vkQueuePresentKHR", (PyObject *)&PyvkQueuePresentKHRType);

#ifdef VK_USE_PLATFORM_MIR_KHR

    if (PyType_Ready(&PyvkGetPhysicalDeviceMirPresentationSupportKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkGetPhysicalDeviceMirPresentationSupportKHRType);
    PyModule_AddObject(module, "vkGetPhysicalDeviceMirPresentationSupportKHR", (PyObject *)&PyvkGetPhysicalDeviceMirPresentationSupportKHRType);

#endif

    if (PyType_Ready(&PyvkCreateDisplayModeKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkCreateDisplayModeKHRType);
    PyModule_AddObject(module, "vkCreateDisplayModeKHR", (PyObject *)&PyvkCreateDisplayModeKHRType);

#ifdef VK_USE_PLATFORM_MIR_KHR

    if (PyType_Ready(&PyvkCreateMirSurfaceKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkCreateMirSurfaceKHRType);
    PyModule_AddObject(module, "vkCreateMirSurfaceKHR", (PyObject *)&PyvkCreateMirSurfaceKHRType);

#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR

    if (PyType_Ready(&PyvkGetPhysicalDeviceXlibPresentationSupportKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkGetPhysicalDeviceXlibPresentationSupportKHRType);
    PyModule_AddObject(module, "vkGetPhysicalDeviceXlibPresentationSupportKHR", (PyObject *)&PyvkGetPhysicalDeviceXlibPresentationSupportKHRType);

#endif

#ifdef VK_USE_PLATFORM_XCB_KHR

    if (PyType_Ready(&PyvkCreateXcbSurfaceKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkCreateXcbSurfaceKHRType);
    PyModule_AddObject(module, "vkCreateXcbSurfaceKHR", (PyObject *)&PyvkCreateXcbSurfaceKHRType);

#endif

#ifdef VK_USE_PLATFORM_XCB_KHR

    if (PyType_Ready(&PyvkGetPhysicalDeviceXcbPresentationSupportKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkGetPhysicalDeviceXcbPresentationSupportKHRType);
    PyModule_AddObject(module, "vkGetPhysicalDeviceXcbPresentationSupportKHR", (PyObject *)&PyvkGetPhysicalDeviceXcbPresentationSupportKHRType);

#endif

    if (PyType_Ready(&PyvkDestroySurfaceKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkDestroySurfaceKHRType);
    PyModule_AddObject(module, "vkDestroySurfaceKHR", (PyObject *)&PyvkDestroySurfaceKHRType);

    if (PyType_Ready(&PyvkDebugReportMessageEXTType) < 0)
        return NULL;
    Py_INCREF(&PyvkDebugReportMessageEXTType);
    PyModule_AddObject(module, "vkDebugReportMessageEXT", (PyObject *)&PyvkDebugReportMessageEXTType);

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

    if (PyType_Ready(&PyvkGetPhysicalDeviceWaylandPresentationSupportKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkGetPhysicalDeviceWaylandPresentationSupportKHRType);
    PyModule_AddObject(module, "vkGetPhysicalDeviceWaylandPresentationSupportKHR", (PyObject *)&PyvkGetPhysicalDeviceWaylandPresentationSupportKHRType);

#endif

    if (PyType_Ready(&PyvkCreateSharedSwapchainsKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkCreateSharedSwapchainsKHRType);
    PyModule_AddObject(module, "vkCreateSharedSwapchainsKHR", (PyObject *)&PyvkCreateSharedSwapchainsKHRType);

    if (PyType_Ready(&PyvkCreateDebugReportCallbackEXTType) < 0)
        return NULL;
    Py_INCREF(&PyvkCreateDebugReportCallbackEXTType);
    PyModule_AddObject(module, "vkCreateDebugReportCallbackEXT", (PyObject *)&PyvkCreateDebugReportCallbackEXTType);

    if (PyType_Ready(&PyvkDestroySwapchainKHRType) < 0)
        return NULL;
    Py_INCREF(&PyvkDestroySwapchainKHRType);
    PyModule_AddObject(module, "vkDestroySwapchainKHR", (PyObject *)&PyvkDestroySwapchainKHRType);

    if (PyType_Ready(&PyvkDebugMarkerSetObjectNameEXTType) < 0)
        return NULL;
    Py_INCREF(&PyvkDebugMarkerSetObjectNameEXTType);
    PyModule_AddObject(module, "vkDebugMarkerSetObjectNameEXT", (PyObject *)&PyvkDebugMarkerSetObjectNameEXTType);

    VulkanError = PyErr_NewException("vulkan.VulkanError", NULL, NULL);
    Py_INCREF(VulkanError);
    PyModule_AddObject(module, "VulkanError", VulkanError);

    VkErrorTooManyObjects = PyErr_NewException("vulkan.VkErrorTooManyObjects", VulkanError, NULL);
    Py_INCREF(VkErrorTooManyObjects);
    PyModule_AddObject(module, "VkErrorTooManyObjects", VkErrorTooManyObjects);

    VkErrorOutOfHostMemory = PyErr_NewException("vulkan.VkErrorOutOfHostMemory", VulkanError, NULL);
    Py_INCREF(VkErrorOutOfHostMemory);
    PyModule_AddObject(module, "VkErrorOutOfHostMemory", VkErrorOutOfHostMemory);

    VkErrorIncompatibleDriver = PyErr_NewException("vulkan.VkErrorIncompatibleDriver", VulkanError, NULL);
    Py_INCREF(VkErrorIncompatibleDriver);
    PyModule_AddObject(module, "VkErrorIncompatibleDriver", VkErrorIncompatibleDriver);

    VkIncomplete = PyErr_NewException("vulkan.VkIncomplete", VulkanError, NULL);
    Py_INCREF(VkIncomplete);
    PyModule_AddObject(module, "VkIncomplete", VkIncomplete);

    VkEventSet = PyErr_NewException("vulkan.VkEventSet", VulkanError, NULL);
    Py_INCREF(VkEventSet);
    PyModule_AddObject(module, "VkEventSet", VkEventSet);

    VkTimeout = PyErr_NewException("vulkan.VkTimeout", VulkanError, NULL);
    Py_INCREF(VkTimeout);
    PyModule_AddObject(module, "VkTimeout", VkTimeout);

    VkEventReset = PyErr_NewException("vulkan.VkEventReset", VulkanError, NULL);
    Py_INCREF(VkEventReset);
    PyModule_AddObject(module, "VkEventReset", VkEventReset);

    VkErrorLayerNotPresent = PyErr_NewException("vulkan.VkErrorLayerNotPresent", VulkanError, NULL);
    Py_INCREF(VkErrorLayerNotPresent);
    PyModule_AddObject(module, "VkErrorLayerNotPresent", VkErrorLayerNotPresent);

    VkErrorExtensionNotPresent = PyErr_NewException("vulkan.VkErrorExtensionNotPresent", VulkanError, NULL);
    Py_INCREF(VkErrorExtensionNotPresent);
    PyModule_AddObject(module, "VkErrorExtensionNotPresent", VkErrorExtensionNotPresent);

    VkNotReady = PyErr_NewException("vulkan.VkNotReady", VulkanError, NULL);
    Py_INCREF(VkNotReady);
    PyModule_AddObject(module, "VkNotReady", VkNotReady);

    VkErrorFeatureNotPresent = PyErr_NewException("vulkan.VkErrorFeatureNotPresent", VulkanError, NULL);
    Py_INCREF(VkErrorFeatureNotPresent);
    PyModule_AddObject(module, "VkErrorFeatureNotPresent", VkErrorFeatureNotPresent);

    VkErrorInitializationFailed = PyErr_NewException("vulkan.VkErrorInitializationFailed", VulkanError, NULL);
    Py_INCREF(VkErrorInitializationFailed);
    PyModule_AddObject(module, "VkErrorInitializationFailed", VkErrorInitializationFailed);

    VkErrorOutOfDeviceMemory = PyErr_NewException("vulkan.VkErrorOutOfDeviceMemory", VulkanError, NULL);
    Py_INCREF(VkErrorOutOfDeviceMemory);
    PyModule_AddObject(module, "VkErrorOutOfDeviceMemory", VkErrorOutOfDeviceMemory);

    VkErrorFragmentedPool = PyErr_NewException("vulkan.VkErrorFragmentedPool", VulkanError, NULL);
    Py_INCREF(VkErrorFragmentedPool);
    PyModule_AddObject(module, "VkErrorFragmentedPool", VkErrorFragmentedPool);

    VkErrorMemoryMapFailed = PyErr_NewException("vulkan.VkErrorMemoryMapFailed", VulkanError, NULL);
    Py_INCREF(VkErrorMemoryMapFailed);
    PyModule_AddObject(module, "VkErrorMemoryMapFailed", VkErrorMemoryMapFailed);

    VkErrorFormatNotSupported = PyErr_NewException("vulkan.VkErrorFormatNotSupported", VulkanError, NULL);
    Py_INCREF(VkErrorFormatNotSupported);
    PyModule_AddObject(module, "VkErrorFormatNotSupported", VkErrorFormatNotSupported);

    VkErrorDeviceLost = PyErr_NewException("vulkan.VkErrorDeviceLost", VulkanError, NULL);
    Py_INCREF(VkErrorDeviceLost);
    PyModule_AddObject(module, "VkErrorDeviceLost", VkErrorDeviceLost);
    return module;
}
